//.............................................................................

declarator_list <CTypeSpecifier* $pTypeSpecifier>
	: full_declarator <$pTypeSpecifier> (',' full_declarator <$pTypeSpecifier>)*
	;
		
full_declarator <CTypeSpecifier* $pTypeSpecifier>
	: declarator <$pTypeSpecifier>
	  ('='
		{
			bool Result = Declare (&$1.m_Declarator, true);
			if (!Result)
				return false;

			if (!m_pLastDeclaredItem || 
				m_pLastDeclaredItem->GetItemKind () != EModuleItem_Variable)
			{
				err::SetFormatStringError (_T("can only apply initializers to variables"));
				return false;
			}
		}
	  initializer $i <.((CVariable*) m_pLastDeclaredItem)->GetType ().> 		
		{
			return m_pModule->m_OperatorMgr.BinaryOperator (EBinOp_Assign, (CVariable*) m_pLastDeclaredItem, $i.m_Value);
		}
	  )?
		{ 
			if (!IsValidLocator ($i))
				return Declare (&$1.m_Declarator);
		}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	CDeclarator m_Declarator;
}	
declarator <CTypeSpecifier* $pTypeSpecifier>
	enter
	{
		return $.m_Declarator.SetTypeSpecifier ($pTypeSpecifier);
	}
	: pointer <&$.m_Declarator>* 
	  declarator_name <&$.m_Declarator>
	  declarator_suffix <&$.m_Declarator>*
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	CValue m_Value;
	rtl::CBoxListT <CToken> m_TokenList;
}
initializer <CType* $pType>
	: resolver ({ return m_Stage == EStage_Pass1 }) 
	  expression_pass1 $e
		{
			$.m_TokenList.TakeOver (&$e.m_TokenList);
		}
	| expression
		{
			$.m_Value = $1.m_Value;
		}
	| '{' initializer_list <$pType> '}'
		{
		}
	;

nullable
initializer_list <CType* $pType>
	: initializer_list_entry <$pType> (',' initializer_list_entry <$pType>)*
	;

nullable
initializer_list_entry <CType* $pType>
	: initializer <$pType>
	| epsilon
	;

//.............................................................................

declarator_name <CDeclarator* $pDeclarator>
	: declarator_qualifier <$pDeclarator> 
		{
			$pDeclarator->m_Pos = $1.m_FirstToken.m_Pos;
		}
	  ('.' declarator_qualifier <$pDeclarator>)*
	;

declarator_qualifier <CDeclarator* $pDeclarator>
	: EToken_Identifier
		{
			return $pDeclarator->AddName ($1.m_Data.m_String);
		}
	| EToken_Get
		{
			return $pDeclarator->AddUnnamedMethod (EFunction_Getter);
		}
	| EToken_Set
		{
			return $pDeclarator->AddUnnamedMethod (EFunction_Setter);
		}
	| EToken_PreConstruct
		{
			return $pDeclarator->AddUnnamedMethod (EFunction_PreConstructor);
		}
	| EToken_This
		{
			return $pDeclarator->AddUnnamedMethod (EFunction_Constructor);
		}
	| resolver (static_this_rslv)
	  EToken_Static EToken_This
		{
			return $pDeclarator->AddUnnamedMethod (EFunction_StaticConstructor);
		}
	| '~' EToken_This
		{
			return $pDeclarator->AddUnnamedMethod (EFunction_Destructor);
		}
	| EToken_Operator
		{
			return $pDeclarator->AddUnnamedMethod (EFunction_CallOperator);
		}
	| EToken_Operator type_name
		{
			return $pDeclarator->AddCastOperator ($2.m_pType);
		}
	| EToken_Operator operator_name
		{
			return $pDeclarator->AddOperator ($2.m_UnOpKind, $2.m_BinOpKind);
		}
	| EToken_PropValue
		{
			return $pDeclarator->SetPropValue ();
		}
	;

// resolve storage_specifier + declarator_qualifier vs single declarator_qualifier
// in favor of single declarator_qualifier

static_this_rslv
	: EToken_Static EToken_This
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	EUnOp m_UnOpKind;
	EBinOp m_BinOpKind;
}
operator_name
	enter
	{
		$.m_UnOpKind = EUnOp_Undefined;
		$.m_BinOpKind = EBinOp_Undefined;
	}
	: '~'
		{
			$.m_UnOpKind = EUnOp_BwNot;
		}
	| '!'
		{
			$.m_UnOpKind = EUnOp_LogNot;
		}
	| EToken_Inc
		{
			$.m_UnOpKind = EUnOp_PreInc;
		}
	| EToken_Dec
		{
			$.m_UnOpKind = EUnOp_PreDec;
		}
	| EToken_Postfix EToken_Inc
		{
			$.m_UnOpKind = EUnOp_PostInc;
		}
	| EToken_Postfix EToken_Dec
		{
			$.m_UnOpKind = EUnOp_PostDec;
		}
	| EToken_Postfix? EToken_Ptr
		{
			$.m_UnOpKind = EUnOp_Ptr;
		}
	| '+'
		{
			$.m_UnOpKind = EUnOp_Plus;
			$.m_BinOpKind = EBinOp_Add;
		}
	| '-'
		{
			$.m_UnOpKind = EUnOp_Minus;
			$.m_BinOpKind = EBinOp_Sub;
		}
	| '*'
		{
			$.m_UnOpKind = EUnOp_Indir;
			$.m_BinOpKind = EBinOp_Mul;
		}
	| '/'
		{
			$.m_BinOpKind = EBinOp_Div;
		}
	| '%'
		{
			$.m_BinOpKind = EBinOp_Mod;
		}
	| EToken_Shl
		{
			$.m_BinOpKind = EBinOp_Shl;
		}
	| EToken_Shr
		{
			$.m_BinOpKind = EBinOp_Shr;
		}
	| '&'
		{
			$.m_UnOpKind = EUnOp_Addr;
			$.m_BinOpKind = EBinOp_BwAnd;
		}
	| '^'
		{
			$.m_BinOpKind = EBinOp_BwXor;
		}
	| '|'
		{
			$.m_BinOpKind = EBinOp_BwOr;
		}
	| EToken_Eq
		{
			$.m_BinOpKind = EBinOp_Eq;
		}
	| EToken_Ne
		{
			$.m_BinOpKind = EBinOp_Ne;
		}
	| '<'
		{
			$.m_BinOpKind = EBinOp_Lt;
		}
	| EToken_Le
		{
			$.m_BinOpKind = EBinOp_Le;
		}
	| '>'
		{
			$.m_BinOpKind = EBinOp_Gt;
		}
	| EToken_Ge
		{
			$.m_BinOpKind = EBinOp_Ge;
		}
	| '='
		{
			$.m_BinOpKind = EBinOp_Assign;
		}
	| EToken_AddAssign
		{
			$.m_BinOpKind = EBinOp_AddAssign;
		}
	| EToken_SubAssign
		{
			$.m_BinOpKind = EBinOp_SubAssign;
		}
	| EToken_MulAssign
		{
			$.m_BinOpKind = EBinOp_MulAssign;
		}
	| EToken_DivAssign
		{
			$.m_BinOpKind = EBinOp_DivAssign;
		}
	| EToken_ModAssign
		{
			$.m_BinOpKind = EBinOp_ModAssign;
		}
	| EToken_ShlAssign
		{
			$.m_BinOpKind = EBinOp_ShlAssign;
		}
	| EToken_ShrAssign
		{
			$.m_BinOpKind = EBinOp_ShrAssign;
		}
	| EToken_AndAssign
		{
			$.m_BinOpKind = EBinOp_AndAssign;
		}
	| EToken_XorAssign
		{
			$.m_BinOpKind = EBinOp_XorAssign;
		}
	| EToken_OrAssign
		{
			$.m_BinOpKind = EBinOp_OrAssign;
		}
	| EToken_AtAssign
		{
			$.m_BinOpKind = EBinOp_AtAssign;
		}
	| EToken_ClassAssign
		{
			$.m_BinOpKind = EBinOp_ClassAssign;
		}
	| EToken_LogAnd
		{
			$.m_BinOpKind = EBinOp_LogAnd;
		}
	| EToken_LogOr
		{
			$.m_BinOpKind = EBinOp_LogOr;
		}
	| '[' ']'
		{
			$.m_BinOpKind = EBinOp_Idx;
		}
	| '@'
		{
			$.m_BinOpKind = EBinOp_At;
		}
	;

//.............................................................................

// prefix

noast
pointer <CDeclarator* $pDeclarator>
	: '*' 
		{
			return $pDeclarator->AddPointer ();
		}
	  (type_modifier $m
		{
			return $pDeclarator->SetTypeModifier ($m.m_Modifier);
		}
	  )*
	;
	
//.............................................................................

// suffix 

noast
declarator_suffix <CDeclarator* $pDeclarator>
	: array_suffix <$pDeclarator>
	| function_suffix <$pDeclarator>
	| bitfield_suffix <$pDeclarator>
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

array_suffix <CDeclarator* $pDeclarator>
	: '[' EToken_Integer ']'
		{
			$pDeclarator->AddArraySuffix ($2.m_Data.m_Integer);
		}
	| '[' ']'
		{
			$pDeclarator->AddArraySuffix (0);
		}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

function_suffix <CDeclarator* $pDeclarator>
	local
	{
		CDeclFunctionSuffix* $pFunctionSuffix;
	}
	enter
	{
		$pFunctionSuffix = $pDeclarator->AddFunctionSuffix ();
	}
	: '(' function_formal_argument_list <$pFunctionSuffix> ')' function_modifier <$pFunctionSuffix>*
	| '(' ')' function_modifier <$pFunctionSuffix>*
	;	

function_formal_argument_list <CDeclFunctionSuffix* $pFunctionSuffix>
	: function_formal_argument <$pFunctionSuffix> 
	  (',' function_formal_argument <$pFunctionSuffix>)*
	;

function_formal_argument <CDeclFunctionSuffix* $pFunctionSuffix>
	: type_specifier_modifier_list $s
	  (declarator $d <&$s.m_TypeSpecifier> ('=' expression_pass1 $v)?)?
		{
			return CreateFormalArg (
				$pFunctionSuffix, 
				&$s.m_TypeSpecifier, 
				IsValidLocator ($d) ? &$d.m_Declarator : NULL, 
				CValue ()
				) != NULL;
		}
	| (EToken_Safe | EToken_Unsafe $u)? EToken_Ellipsis
		{
			$pFunctionSuffix->m_FunctionTypeFlags |= EFunctionTypeFlag_VarArg;
			if (IsValidLocator ($u))
				$pFunctionSuffix->m_FunctionTypeFlags |= EFunctionTypeFlag_UnsafeVarArg;
		}
	;

function_modifier <CDeclFunctionSuffix* $pFunctionSuffix>
	: EToken_Const
		{
			$pFunctionSuffix->m_FunctionFlags |= EFunctionFlag_Const;
		}
	;
	
//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

bitfield_suffix <CDeclarator* $pDeclarator>
	: ':' EToken_Integer
		{
			return $pDeclarator->AddBitFieldSuffix ($2.m_Data.m_Integer);
		}
	;

//.............................................................................
