//.............................................................................

common_declaration
	local
	{
		CModuleItem* $pLastDeclaredItem;
	}
	enter
	{
		$pLastDeclaredItem = NULL;
	}
	: attribute_block?
	  declaration_specifier_list $s
	  init_declarator_list <&$s.m_DeclSpecifiers, &$pLastDeclaredItem>?
	  declaration_terminator_2 <$pLastDeclaredItem>
	;

noast
init_declarator_list <CDeclSpecifiers* $pDeclSpecifiers, CModuleItem** $ppLastDeclaredItem>
	: init_declarator <$pDeclSpecifiers, $ppLastDeclaredItem> 
	  (
		',' 
		init_declarator <$pDeclSpecifiers, $ppLastDeclaredItem>
	  )*
	;

init_declarator <CDeclSpecifiers* $pDeclSpecifiers, CModuleItem** $ppLastDeclaredItem>
	: declarator('=' expression_pass1 $i)?
		{
			CModuleItem* pItem = Declare (
				$pDeclSpecifiers, 
				&$1.m_Declarator,
				IsValidLocator ($i) ? &$i.m_TokenList : NULL
				);

			if (!pItem)
				return false;

			*$ppLastDeclaredItem = pItem;
		}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

start
initializer
	: expression
	| '{' initializer_list '}'
	;

initializer_list
	: initializer_list_entry (',' initializer_list_entry)*
	;

initializer_list_entry
	: initializer
	| epsilon
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

noast
declaration_terminator_2 <CModuleItem* $pLastDeclaredItem>
	: ';'
	| function_body_pass1
		{
			return SetFunctionBody ($pLastDeclaredItem, &$1.m_TokenList);
		}
	;

noast
declaration_terminator
	: ';'
	| function_body_pass1
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	CDeclSpecifiers m_DeclSpecifiers;
}	
declaration_specifier_list
	enter 
	{
		PushTypeSpecifier (&$.m_DeclSpecifiers);
	}
	leave
	{
		PopTypeSpecifier (&$.m_DeclSpecifiers);
	}
	: declaration_specifier <&$.m_DeclSpecifiers>+
	;

class
{
	CTypeSpecifierModifiers m_TypeSpecifier;
}	
type_specifier_modifier_list
	enter 
	{
		PushTypeSpecifier (&$.m_TypeSpecifier);
	}
	leave
	{
		PopTypeSpecifier (&$.m_TypeSpecifier);
	}
	: type_specifier_modifier <&$.m_TypeSpecifier>+
	;

declaration_specifier <CDeclSpecifiers* $pDeclSpecifiers>
	: type_specifier_modifier <$pDeclSpecifiers>
	| access_specifier <$pDeclSpecifiers>
	| storage_class_specifier <$pDeclSpecifiers>
	;

noast
type_specifier_modifier <CTypeSpecifierModifiers* $pTypeSpecifier>
	: type_specifier <$pTypeSpecifier>
	| type_modifier <$pTypeSpecifier>
	;

access_specifier <CAccessSpecifier* $pAccessSpecifier>
	: EToken_Public
		{
			return $pAccessSpecifier->SetAccess (EAccess_Public);
		}
	| EToken_Private 
		{
			return $pAccessSpecifier->SetAccess (EAccess_Private);
		}
	;

storage_class_specifier <CDeclSpecifiers* $pDeclSpecifiers>
	: EToken_Static 
		{
			return $pDeclSpecifiers->SetStorageClass (EStorageClass_Static);
		}
	| EToken_Typedef
		{
			return $pDeclSpecifiers->SetStorageClass (EStorageClass_Typedef);
		}
	;

type_modifier <CTypeModifiers* $pTypeModifiers>
	: EToken_Const
		{
			return $pTypeModifiers->SetTypeModifier (ETypeModifier_Const);
		}
	| EToken_Property
		{
			return $pTypeModifiers->SetTypeModifier (ETypeModifier_Property);
		}
	| EToken_Signed
		{
			return $pTypeModifiers->SetTypeModifier (ETypeModifier_Signed);
		}
	| EToken_Unsigned
		{
			return $pTypeModifiers->SetTypeModifier (ETypeModifier_Unsigned);
		}
	| EToken_BigEndian
		{
			return $pTypeModifiers->SetTypeModifier (ETypeModifier_BigEndian);
		}
	| EToken_LittleEndian
		{
			return $pTypeModifiers->SetTypeModifier (ETypeModifier_LittleEndian);
		}
	;

type_specifier <CTypeSpecifier* $pTypeSpecifier>
	: EToken_Void
		{
			return $pTypeSpecifier->SetType (m_pModule->m_TypeMgr.GetBasicType (EType_Void));
		}
	| EToken_Bool
		{
			return $pTypeSpecifier->SetType (m_pModule->m_TypeMgr.GetBasicType (EType_Bool));
		}
	| EToken_Int
		{
			return $pTypeSpecifier->SetType (m_pModule->m_TypeMgr.GetBasicType (m_Endianness == EEndianness_BigEndian ? EType_Int32_be : EType_Int));
		}
	| EToken_Char
		{
			return $pTypeSpecifier->SetType (m_pModule->m_TypeMgr.GetBasicType (EType_Char));
		}
	| EToken_Short
		{
			return $pTypeSpecifier->SetType (m_pModule->m_TypeMgr.GetBasicType (m_Endianness == EEndianness_BigEndian ? EType_Int16_be : EType_Short));
		}
	| EToken_Long
		{
			return $pTypeSpecifier->SetType (m_pModule->m_TypeMgr.GetBasicType (m_Endianness == EEndianness_BigEndian ? EType_Int32_be : EType_Long));
		}
	| EToken_Float
		{
			return $pTypeSpecifier->SetType (m_pModule->m_TypeMgr.GetBasicType (EType_Float));
		}
	| EToken_Double
		{
			return $pTypeSpecifier->SetType (m_pModule->m_TypeMgr.GetBasicType (EType_Double));
		}
	| EToken_Int8
		{
			return $pTypeSpecifier->SetType (m_pModule->m_TypeMgr.GetBasicType (EType_Int8));
		}
	| EToken_Int16
		{
			return $pTypeSpecifier->SetType (m_pModule->m_TypeMgr.GetBasicType (m_Endianness == EEndianness_BigEndian ? EType_Int16_be : EType_Int16));
		}
	| EToken_Int32
		{
			return $pTypeSpecifier->SetType (m_pModule->m_TypeMgr.GetBasicType (m_Endianness == EEndianness_BigEndian ? EType_Int32_be : EType_Int32));
		}
	| EToken_Int64
		{
			return $pTypeSpecifier->SetType (m_pModule->m_TypeMgr.GetBasicType (m_Endianness == EEndianness_BigEndian ? EType_Int64_be : EType_Int64));
		}
	| EToken_WChar
		{
			return $pTypeSpecifier->SetType (m_pModule->m_TypeMgr.GetBasicType (EType_WChar));
		}
	| EToken_Variant
		{
			return $pTypeSpecifier->SetType (m_pModule->m_TypeMgr.GetBasicType (EType_Variant));
		}
	| EToken_Auto
		{
			err::SetStringError (_T("'auto' type specifier is not yet supported"));
			return false; 
		}
	| enum_specifier
		{
			return $pTypeSpecifier->SetType ($1.m_pType);
		}
	| struct_specifier
		{
			return $pTypeSpecifier->SetType ($1.m_pType);
		}
	| class_specifier
		{
			return $pTypeSpecifier->SetType ($1.m_pType);
		}
	| property_specifier
		{
			return $pTypeSpecifier->SetProperty ($1.m_pProperty);
		}
	| resolver (qualified_type_name_rslv)
	  qualified_type_name $t
	  generic_actual_argument_list?
		{
			return $pTypeSpecifier->SetType ($t.m_pType);
		}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

noast
qualified_type_name_rslv
	:	{
			if (IsTypeSpecified ())
				return false;
		}
	  qualified_name
		{
			return m_Stage == EStage_Pass1 || FindType ($1.m_Name) != NULL;
		}
	;

class
{
	CType* m_pType;
}
qualified_type_name
	: qualified_name
		{
			CType* pType = FindType ($1.m_Name);
			if (!pType)
			{
				err::SetFormatStringError (_T("'%s' is not a type"), $1.m_Name.GetFullName ());
				return false;
			}

			$.m_pType = pType;
		}
	;

generic_actual_argument_list
	: '<' type_name (',' type_name)* '>'
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	CDeclarator m_Declarator;
}	
declarator
	: pointer <&$.m_Declarator>* 
	  EToken_Identifier $n
		{
			$.m_Declarator.m_Pos = $n.m_Pos;
			$.m_Declarator.m_Name = $n.m_Data.m_String;
		}
	  ('.' property_accessor_kind $p
		{
			$.m_Declarator.m_PropertyAccessorKind = $p.m_PropertyAccessorKind;
		}
	  )?
	  declarator_suffix <&$.m_Declarator>*
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

noast
pointer <CDeclarator* $pDeclarator>
	local
	{	
		CDeclPointer* $pPointer;
	}
	: pointer_kind 
		{
			$pPointer = $pDeclarator->AddPointer ($1.m_TypeKind);
		}
	  type_modifier <$pPointer>*
	;

class
{
	EType m_TypeKind;
}
pointer_kind
	: '*'
		{
			$.m_TypeKind = EType_Pointer;
		}
	| '&'
		{
			$.m_TypeKind = EType_Reference;
		}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

noast
declarator_suffix <CDeclarator* $pDeclarator>
	: array_suffix <$pDeclarator>
	| function_suffix <$pDeclarator>
	;

array_suffix <CDeclarator* $pDeclarator>
	: '[' expression_pass1 ']'
		{
			$pDeclarator->AddArraySuffix (0);
		}
	| '[' ']'
		{
			$pDeclarator->AddArraySuffix (0);
		}
	;

function_suffix <CDeclarator* $pDeclarator>
	local
	{
		CDeclFunctionSuffix* $pFunctionSuffix;
	}
	enter
	{
		$pFunctionSuffix = $pDeclarator->AddFormalArgSuffix ();
	}
	: '(' function_formal_argument_list <$pFunctionSuffix> ')' 
	| '(' function_formal_argument_vararg <$pFunctionSuffix> ')' 
	| '(' ')' 
	;	

function_formal_argument_list <CDeclFunctionSuffix* $pFunctionSuffix>
	: function_formal_argument <$pFunctionSuffix> 
	  (',' function_formal_argument <$pFunctionSuffix>)* 
	  (',' function_formal_argument_vararg <$pFunctionSuffix>)?
	;

function_formal_argument <CDeclFunctionSuffix* $pFunctionSuffix>
	: type_specifier_modifier_list $s
	  declarator $d ('=' expression_pass1 $v)?
		{
			return DeclareFormalArg ($pFunctionSuffix, &$s.m_TypeSpecifier, &$d.m_Declarator, NULL) != NULL;
		}
	;

function_formal_argument_vararg <CDeclFunctionSuffix* $pFunctionSuffix>
	: EToken_Ellipsis
		{
			$pFunctionSuffix->m_FunctionTypeFlags |= EFunctionTypeFlag_IsVarArg;
		}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

pragma
pragma_endian
	: '#' EToken_Endian ':' pragma_endian_value
	;

pragma_endian_value
	: (EToken_LittleEndian | EToken_Default)
		{
			m_Endianness = EEndianness_LittleEndian;
		}
	| EToken_BigEndian
		{
			m_Endianness = EEndianness_BigEndian;
		}
	;

//.............................................................................
