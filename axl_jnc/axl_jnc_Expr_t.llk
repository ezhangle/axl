//.............................................................................

class
{
	CValue m_Value;	
}
start
expression_t
	: conditional_expr_t <&$.m_Value>
	;

class 
{
	CValue m_Value;
}
nullable
expression_or_empty_t
	: conditional_expr_t <&$.m_Value>
	| epsilon
	;

class
{
	rtl::CBoxListT <CValue> m_ValueList;
}
expression_list_t
	: expression_t 
		{
			$.m_ValueList.InsertTail ($1.m_Value);
		}
	  (	',' 
		expression_t $e2
			{
				$.m_ValueList.InsertTail ($e2.m_Value);
			}
	  )*
	;

// expression_or_empty_list might seem overcomplicated but
// this is done to avoid having a singe EValue_Void in case of empty list

class
{
	rtl::CBoxListT <CValue> m_ValueList;
}
nullable
expression_or_empty_list_t
	: expression_t
		{
			$.m_ValueList.InsertTail ($1.m_Value);
		}
	  (	',' 
		expression_or_empty_t $e2
			{
				$.m_ValueList.InsertTail ($e2.m_Value);
			}
	  )*
	|	{
			$.m_ValueList.InsertTail (CValue ());
		}	
	  (',' 
		expression_or_empty_t $e2
			{
				$.m_ValueList.InsertTail ($e2.m_Value);
			}
	  )+
	| epsilon 
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

conditional_expr_t <CValue* $pValue>
	local 
	{
		CValue $TrueValue;
		CValue $FalseValue;
	}
	: logical_or_expr_t <$pValue> 
	  (
		'?' conditional_expr_t <&$TrueValue> ':' conditional_expr_t <&$FalseValue>
			{
				return FinalizeConditionalExpr_t ($TrueValue, $FalseValue, $pValue);				
			}
	  )?
	;

logical_or_expr_t <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: logical_and_expr_t <$pValue> 
	  (
		EToken_LogOr logical_and_expr_t <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.GetBinaryOperatorResultType (EBinOp_LogAnd, $pValue, $OpValue2);
			}
	  )*
	;

logical_and_expr_t <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: inclusive_or_expr_t <$pValue> 
	  (
		EToken_LogAnd inclusive_or_expr_t <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.GetBinaryOperatorResultType (EBinOp_LogOr, $pValue, $OpValue2);
			}
	  )*
	;

inclusive_or_expr_t <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: exclusive_or_expr_t <$pValue> 
	  (
		'|' exclusive_or_expr_t <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.GetBinaryOperatorResultType (EBinOp_BwOr, $pValue, $OpValue2);
			}
	  )*
	;

exclusive_or_expr_t <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: and_expr_t <$pValue> 
	  (
		'^' and_expr_t <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.GetBinaryOperatorResultType (EBinOp_BwXor, $pValue, $OpValue2);
			}
	  )*
	;

and_expr_t <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: equality_expr_t <$pValue> 
	  (
		'&' equality_expr_t <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.GetBinaryOperatorResultType (EBinOp_BwAnd, $pValue, $OpValue2);
			}
	  )*
	;

equality_expr_t <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: relational_expr_t <$pValue> 
	  (
		equality_operator $o relational_expr_t <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.GetBinaryOperatorResultType ($o.m_OpKind, $pValue, $OpValue2);
			}
	  )*
	;

relational_expr_t <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: shift_expr_t <$pValue> 
	  (
		relational_operator $o shift_expr_t <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.GetBinaryOperatorResultType ($o.m_OpKind, $pValue, $OpValue2);
			}
	  )*
	;

shift_expr_t <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: additive_expr_t <$pValue> 
	  (
		shift_operator $o additive_expr_t <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.GetBinaryOperatorResultType ($o.m_OpKind, $pValue, $OpValue2);
			}
	  )*
	;

additive_expr_t <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: multiplicative_expr_t <$pValue> 
	  (
		additive_operator $o multiplicative_expr_t <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.GetBinaryOperatorResultType ($o.m_OpKind, $pValue, $OpValue2);
			}
	  )*
	;

multiplicative_expr_t <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: at_expr_t <$pValue> 
	  (
		multiplicative_operator $o at_expr_t <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.GetBinaryOperatorResultType ($o.m_OpKind, $pValue, $OpValue2);
			}
	  )*
	;

at_expr_t <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: assignment_expr_t <$pValue> 
	  (
		'@' assignment_expr_t <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.GetBinaryOperatorResultType (EBinOp_At, $pValue, $OpValue2);
			}
	  )*
	;

assignment_expr_t <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: unary_expr_t <$pValue> 
	  (
			{
				if (IsAutoEvStarter ())
					m_AutoEvBindSiteCount = 0; // reset on assignment
			}
		assignment_operator $o conditional_expr_t <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.GetBinaryOperatorResultType ($o.m_OpKind, $pValue, $OpValue2);
			}
	  )?
	;

unary_expr_t <CValue* $pValue>
	: postfix_expr_t <$pValue> 
	| unary_operator_expr_t <$pValue> 
	;

unary_operator_expr_t <CValue* $pValue>
	leave 
	{
		if (IsAutoEvStarter () && $pValue->GetType ()->IsBindablePropertyType ())
			m_AutoEvBindSiteCount++;
	}
	: '+' unary_expr_t <$pValue> 
		{
			return m_pModule->m_OperatorMgr.GetUnaryOperatorResultType (EUnOp_Plus, $pValue);
		}
	| '-' unary_expr_t <$pValue> 
		{
			return m_pModule->m_OperatorMgr.GetUnaryOperatorResultType (EUnOp_Minus, $pValue);
		}
	| '~' unary_expr_t <$pValue> 
		{
			return m_pModule->m_OperatorMgr.GetUnaryOperatorResultType (EUnOp_BwNot, $pValue);
		}
	| '&' unary_expr_t <$pValue> 
		{
			return m_pModule->m_OperatorMgr.GetUnaryOperatorResultType (EUnOp_Addr, $pValue);
		}
	| '*' unary_expr_t <$pValue> 
		{
			return m_pModule->m_OperatorMgr.GetUnaryOperatorResultType (EUnOp_Indir, $pValue);
		}
	| '!' unary_expr_t <$pValue> 
		{
			return m_pModule->m_OperatorMgr.GetUnaryOperatorResultType (EUnOp_LogNot, $pValue);
		}
	| EToken_Inc unary_expr_t <$pValue> 
		{
			return m_pModule->m_OperatorMgr.GetUnaryOperatorResultType (EUnOp_PreInc, $pValue);
		}
	| EToken_Dec unary_expr_t <$pValue> 
		{
			return m_pModule->m_OperatorMgr.GetUnaryOperatorResultType (EUnOp_PreDec, $pValue);
		}
	| EToken_SizeOf type_name_or_expr
		{
			$pValue->SetConstSizeT ($2.m_pType->GetSize ());
		}
	| EToken_TypeOf type_name_or_expr
		{
			$pValue->SetType ($2.m_pType);
		}
	| resolver (cast_operator_rslv) 
	  '(' storage_specifier? type_name $t ')' unary_expr_t <$pValue> 
		{
			$pValue->SetType ($t.m_pType);
		}
	| storage_specifier? EToken_New new_operator_type_t $t
		{
			$pValue->SetType (m_pModule->m_OperatorMgr.GetNewOperatorResultType ($t.m_pType));
		}
	| EToken_Delete unary_expr_t <$pValue> 
		{
			$pValue->SetVoid ();
		}
	;

class
{
	CType* m_pType;
}
new_operator_type_t
	: type_name
		{
			$.m_pType = $1.m_pType;
		}
	| resolver (type_name_w_constructor_rslv) priority (2) // set higher priority than type_specifier::qualified_name
	  qualified_type_name $t '(' expression_or_empty_list_t ')'
		{
			$.m_pType = $t.m_pType;
		}
	;

postfix_expr_t <CValue* $pValue>
	: primary_expr_t <$pValue>
	  postfix_operator_t <$pValue>*
	;

postfix_operator_t <CValue* $pValue>
	leave 
	{
		if (IsAutoEvStarter () && $pValue->GetType ()->IsBindablePropertyType ())
			m_AutoEvBindSiteCount++;
	}
	: '(' expression_or_empty_list_t ')'
		{
			return m_pModule->m_OperatorMgr.GetCallOperatorResultType ($pValue, &$2.m_ValueList);
		}		
	| '~' '(' expression_or_empty_list_t ')'
		{
			return m_pModule->m_OperatorMgr.GetClosureOperatorResultType ($pValue, &$3.m_ValueList);
		}		
	| '[' expression_t ']'
		{
			return m_pModule->m_OperatorMgr.GetBinaryOperatorResultType (EBinOp_Idx, $pValue, $2.m_Value);
		}	
	| EToken_Inc
		{
			return m_pModule->m_OperatorMgr.GetUnaryOperatorResultType (EUnOp_PostInc, $pValue);
		}
	| EToken_Dec
		{
			return m_pModule->m_OperatorMgr.GetUnaryOperatorResultType (EUnOp_PostDec, $pValue);
		}
	| '.' member_operator_t <$pValue>
	| EToken_Ptr 
		{
			return m_pModule->m_OperatorMgr.GetUnaryOperatorResultType (EUnOp_Ptr, $pValue);
		}
	  member_operator_t <$pValue>
	;

member_operator_t <CValue* $pValue>
	: EToken_Identifier $n
		{
			return m_pModule->m_OperatorMgr.GetMemberOperatorResultType ($pValue, $n.m_Data.m_String);
		}
	| EToken_OnChange
		{
			return m_pModule->m_OperatorMgr.GetAuPropertyFieldType ($pValue, EAuPropertyField_OnChange);
		}
	| EToken_PropValue
		{
			return m_pModule->m_OperatorMgr.GetAuPropertyFieldType ($pValue, EAuPropertyField_PropValue);
		}
	| EToken_Get
		{
			return m_pModule->m_OperatorMgr.GetPropertyGetterType ($pValue);
		}
	| EToken_Set
		{
			return m_pModule->m_OperatorMgr.GetPropertySetterType ($pValue);
		}
	;

primary_expr_t <CValue* $pValue>
	leave 
	{
		if (IsAutoEvStarter () && $pValue->GetType ()->IsBindablePropertyType ())
			m_AutoEvBindSiteCount++;
	}
	: EToken_Identifier
		{
			return LookupIdentifierType ($1.m_Data.m_String, $pValue);
		}
	| EToken_This
		{
			return GetThisValueType ($pValue);
		}
	| EToken_OnChange
		{
			return GetAuPropertyFieldType ($pValue, EAuPropertyField_OnChange);
		}
	| EToken_PropValue
		{
			return GetAuPropertyFieldType ($pValue, EAuPropertyField_PropValue);
		}
	| EToken_Integer
		{
			$pValue->SetType (GetUInt64TypeKind ($1.m_Data.m_UInt64, false));
		}
	| EToken_Fp
		{
			$pValue->SetType (EType_Double);
		}
	| literal 
		{
			$pValue->SetType (m_pModule->m_TypeMgr.GetLiteralType ($1.m_String.GetLength ()));
		}
	| EToken_True
		{
			$pValue->SetType (EType_Bool);
		}
	| EToken_False
		{
			$pValue->SetType (EType_Bool);
		}
	| EToken_Null
		{
			$pValue->SetNull ();
		}
	| '(' conditional_expr_t <$pValue> ')'
	;

//.............................................................................
 
