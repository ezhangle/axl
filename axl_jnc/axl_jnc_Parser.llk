import "axl_jnc_Decl.llk";
import "axl_jnc_Expr.llk";
import "axl_jnc_Stmt.llk";

import "axl_jnc_AttributeBlock.llk";
import "axl_jnc_NamespaceDeclaration.llk";
import "axl_jnc_CommonDeclaration.llk";
import "axl_jnc_EnumSpecifier.llk";
import "axl_jnc_StructSpecifier.llk";
import "axl_jnc_UnionSpecifier.llk";
import "axl_jnc_ClassSpecifier.llk";
import "axl_jnc_PropertySpecifier.llk";

//.............................................................................

LL (2);

start
compilation_unit
	: global_declaration*
	;

//.............................................................................

ParserClassName = CParser;

Includes
{
	#include "axl_jnc_Lexer.h"
	#include "axl_jnc_Module.h"
	#include "axl_jnc_Decl.h"
	#include "axl_llk_Parser.h"
}

Members
{
	enum EStage
	{
		EStage_Pass1, // global declarations (before linkage)
		EStage_Pass2, // statements and expressions (after linkage)
	};

	enum EEndianness
	{
		EEndianness_LittleEndian,
		EEndianness_BigEndian,
	};

	CModule* m_pModule;
	size_t m_StructPackFactor;
	size_t m_DefaultStructPackFactor;
	EEndianness m_Endianness;
	EStage m_Stage;
	CValue m_ThisValue;
	CClassType* m_pThisType;

	rtl::CArrayT <CTypeSpecifier*> m_TypeSpecifierStack;

	CParser ();

	CType*
	FindType (const CQualifiedName& Name);

	void
	PushTypeSpecifier (CTypeSpecifier* pTypeSpecifier)
	{
		m_TypeSpecifierStack.Append (pTypeSpecifier);
	}

	void
	PopTypeSpecifier (CTypeSpecifier* pTypeSpecifier)
	{
		m_TypeSpecifierStack.Pop ();
	}

	bool
	IsTypeSpecified ();

	CModuleItem*
	Declare (
		CDeclSpecifiers* pDeclSpecifiers,
		CDeclarator* pDeclarator,
		CClassType* pClassType = NULL,
		size_t BitCount = 0
		);

	CEnumType*
	DeclareEnumType (
		EType TypeKind,
		rtl::CString& Name
		);

	CStructType*
	DeclareStructType (
		rtl::CString& Name,
		rtl::CBoxListT <CType*>* pBaseTypeList,
		size_t PackFactor
		);

	CStructMember*
	DeclareStructMember (
		CStructType* pStructType,
		CTypeSpecifierModifiers* pTypeSpecifier,
		CDeclarator* pDeclarator,
		size_t BitCount
		);

	CUnionType*
	DeclareUnionType (rtl::CString& Name);

	CUnionMember*
	DeclareUnionMember (
		CUnionType* pStructType,
		CTypeSpecifierModifiers* pTypeSpecifier,
		CDeclarator* pDeclarator,
		size_t BitCount
		);

	CClassType*
	DeclareClassType (
		EType TypeKind,
		rtl::CString& Name,
		rtl::CBoxListT <CType*>* pBaseTypeList,
		size_t PackFactor
		);

	CFunctionFormalArg*
	DeclareFormalArg (
		CDeclFunctionSuffix* pArgSuffix,
		CTypeSpecifierModifiers* pTypeSpecifier,
		CDeclarator* pDeclarator,
		const CValue& DefaultValue
		);

	CFunction*
	DeclarePropertyAccessor (
		CPropertyType* pType,
		CTypeSpecifierModifiers* pTypeSpecifier,
		CDeclarator* pDeclarator
		);

	bool
	SetFunctionBody (
		CModuleItem* pItem,
		rtl::CBoxListT <CToken>* pBody
		);

	bool
	LookupIdentifier (
		const rtl::CString& Name,
		CValue* pValue
		);

	bool
	SetThis (CValue* pValue);
} 

OpenNamespace
{.
	namespace axl {
	namespace jnc {
.}

CloseNamespace
{.
	} // namespace axl {
	} // namespace jnc {
.}

//.............................................................................
