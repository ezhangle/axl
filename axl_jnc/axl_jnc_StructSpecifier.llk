//.............................................................................

class
{
	CStructType* m_pType;
}
struct_specifier
	: EToken_Struct
	  struct_pack_factor $p?
	  EToken_Identifier $n?
	  generic_formal_argument_list $g?
	  (':' type_name_list $i)?
		{
			$.m_pType = DeclareStructType (
				IsValidLocator ($n) ? $n.m_Data.m_String : rtl::CString (),
				IsValidLocator ($i) ? &$i.m_TypeList : NULL,
				IsValidLocator ($p) ? $p.m_PackFactor : m_StructPackFactor
				);

			if (!$.m_pType)
				return false;
		}
	  struct_block <$.m_pType>
	;

class
{
	size_t m_PackFactor;
}
struct_pack_factor
	: EToken_Pack '(' struct_pack_factor_value $v ')'	 
		{
			$.m_PackFactor = $v.m_Value;
		}
	;

class
{
	size_t m_Value;
}
struct_pack_factor_value
	: EToken_Integer
		{
			$.m_Value = $1.m_Data.m_Integer;
		}
	| EToken_Default
		{
			$.m_Value = m_DefaultStructPackFactor;
		}
	;

struct_block <CStructType* $pType>
	: '{' 
		{
			// m_pModule->m_NamespaceMgr.OpenNamespace ($pType);	
		}
	  struct_member_declaration <$pType>* 
	  '}'
		{
			// m_pModule->m_NamespaceMgr.CloseNamespace ();
		}
	;

struct_member_declaration <CStructType* $pType>
	: attribute_block?
	  type_specifier_modifier_list $s
	  struct_member_declarator_list <$pType, &$s.m_TypeSpecifier>?
	  ';'
	| ';'
	;

struct_member_declarator_list <CStructType* $pType, CTypeSpecifierModifiers* $pTypeSpecifier>
	: struct_member_declarator <$pType, $pTypeSpecifier> (',' struct_member_declarator <$pType, $pTypeSpecifier>)*
	;

struct_member_declarator <CStructType* $pType, CTypeSpecifierModifiers* $pTypeSpecifier>
	: declarator (':' constant_integer_expr $bf)?
		{
			return DeclareStructMember (
				$pType, 
				$pTypeSpecifier, 
				&$1.m_Declarator,
				IsValidLocator ($bf) ? $bf.m_Value : 0
				) != NULL;
		}
	;

//.............................................................................
