//.............................................................................

class
{
	CStructType* m_pType;
}
struct_specifier
	: struct_kind $k 
	  struct_pack_factor $p?
	  EToken_Identifier $n?
		{
			$.m_pType = DeclareStructType (
				$k.m_TypeKind,
				IsValidLocator ($n) ? $n.m_Data.m_String : rtl::CString (),
				IsValidLocator ($p) ? $p.m_PackFactor : m_StructPackFactor
				);

			if (!$.m_pType)
				return false;
		}
	  generic_formal_argument_list?
	  (':' type_name_list)?
	  struct_block <$.m_pType>
	;

class
{
	EType m_TypeKind;
}
struct_kind
	: EToken_Struct
		{
			$.m_TypeKind = EType_Struct;
		}
	| EToken_Union
		{
			$.m_TypeKind = EType_Union;
		}
	;

class
{
	size_t m_PackFactor;
}
struct_pack_factor
	: EToken_Pack '(' struct_pack_factor_value $v ')'	 
		{
			$.m_PackFactor = $v.m_Value;
		}
	;

class
{
	size_t m_Value;
}
struct_pack_factor_value
	: EToken_Integer
		{
			$.m_Value = $1.m_Data.m_Integer;
		}
	| EToken_Default
		{
			$.m_Value = m_DefaultStructPackFactor;
		}
	;

struct_block <CStructType* $pType>
	: '{' 
		{
			m_pModule->m_NamespaceMgr.OpenNamespace ($pType);	
		}
	  struct_member_declaration <$pType>* 
	  '}'
		{
			m_pModule->m_NamespaceMgr.CloseNamespace ();
		}
	;

struct_member_declaration <CStructType* $pType>
	: attribute_block?
	  type_specifier_modifier_list $s
	  struct_member_declarator_list <&$s.m_TypeSpecifier, $pType>
	  ';'
	| compound_stmt_pass1
	| ';'
	;

struct_member_declarator_list <CTypeSpecifierModifiers* $pTypeSpecifier, CStructType* $pType>
	: struct_member_declarator <$pTypeSpecifier, $pType> (',' struct_member_declarator <$pTypeSpecifier, $pType>)*
	;

struct_member_declarator <CTypeSpecifierModifiers* $pTypeSpecifier, CStructType* $pType>
local
{
	CStructMember* $pMember;
}
	: declarator (':' struct_member_bit_field)?
		{
			$pMember = DeclareStructMember ($pType, $pTypeSpecifier, &$1.m_Declarator);
			if (!$pMember)
				return false;
		}
	  ('=' initializer <.$pMember->GetType ().> 
		{
		}
	  )?
	;

struct_member_bit_field
	: constant_integer_expr
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

pragma
pragma_pack
	: '#' EToken_Pack ':' struct_pack_factor_value $v
		{
			m_StructPackFactor = $v.m_Value;
		}
	;

//.............................................................................
