//.............................................................................

class
{
	CStructType* m_pType;
}
struct_specifier
	: struct_kind EToken_Identifier generic_formal_argument_list?
		{
			rtl::CString Name = $2.m_Data.m_String;
			rtl::CString QualifiedName = m_pModule->m_NamespaceMgr.CreateQualifiedName (Name);
			$.m_pType = m_pModule->m_TypeMgr.GetStructType ($1.m_Type, Name, QualifiedName);
			
			bool Result = Declare ($.m_pType, $1.m_FirstToken.m_Pos);
			if (!Result)
				return false;
		}
		(inheritance_list? struct_block <$.m_pType>)?
	| struct_kind 
		{
			$.m_pType = m_pModule->m_TypeMgr.CreateUnnamedStructType ($1.m_Type);
			Declare ($.m_pType, $1.m_FirstToken.m_Pos);
		}	
	  inheritance_list? 
	  struct_block <$.m_pType>
	;

class
{
	EType m_Type;
}
struct_kind
	: EToken_Struct
		{
			$.m_Type = EType_Struct;
		}
	| EToken_Union
		{
			$.m_Type = EType_Union;
		}
	;

struct_block <CStructType* $pType>
	: '{' struct_member_declaration <$pType>* '}'
	;

struct_member_declaration <CStructType* $pType>
	: attribute_block?
	  type_specifier_modifier_list $s
	  struct_member_declarator_list <&$s.m_TypeSpecifier, $pType>
	  ';'
	| compound_statement_pass1
	| ';'
	;

struct_member_declarator_list <CTypeSpecifierModifiers* $pTypeSpecifier, CStructType* $pType>
	: struct_member_declarator <$pTypeSpecifier, $pType> (',' struct_member_declarator <$pTypeSpecifier, $pType>)*
	;

struct_member_declarator <CTypeSpecifierModifiers* $pTypeSpecifier, CStructType* $pType>
	: declarator (':' struct_member_bit_field)? ('=' initializer)?
		{
			bool Result = DeclareStructMember ($pType, $pTypeSpecifier, &$1.m_Declarator);
			if (!Result)
				return false;
		}
	;

struct_member_bit_field
	: constant_integer_expression
	;

//.............................................................................
