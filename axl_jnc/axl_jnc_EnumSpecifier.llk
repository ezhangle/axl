//.............................................................................

class
{
	CEnumType* m_pType;
}
enum_specifier
	leave
	{
		if ($.m_pType->GetTypeKind () == EType_EnumC ||
			$.m_pType->GetName ().IsEmpty ())
		{
			return m_pModule->m_NamespaceMgr.GetCurrentNamespace ()->ExposeEnumMembers ($.m_pType);
		}
	}
	: enum_kind $k 
	  EToken_Identifier $n?
		{
			$.m_pType = DeclareEnumType (
				$k.m_TypeKind,
				IsValidLocator ($n) ? $n.m_Data.m_String : rtl::CString ()
				);

			if (!$.m_pType)
				return false;
		}	
	  enum_block <$.m_pType>
	;

class
{
	EType m_TypeKind;
}
enum_kind
	: EToken_Enum
		{
			$.m_TypeKind = EType_Enum;
		}
	| EToken_EnumC
		{
			$.m_TypeKind = EType_EnumC;
		}
	;

enum_block <CEnumType* $pType>
	: '{' 
		{
			m_pModule->m_NamespaceMgr.OpenNamespace ($pType);	
		}
	  enum_member_list <$pType> 
	  '}'
		{
			m_pModule->m_NamespaceMgr.CloseNamespace ();	
		}
	;

enum_member_list <CEnumType* $pType>
	: enum_member <$pType> (',' enum_member <$pType>)*
	;

enum_member <CEnumType* $pType>
	: EToken_Identifier ('=' expression_pass1 $e)?
		{
			CEnumMember* pMember = $pType->CreateMember ($1.m_Data.m_String);
			if (!pMember)
				return false;

			pMember->m_Pos = $1.m_Pos;
			
			if (IsValidLocator ($e)) 
				pMember->SetExpression (&$e.m_TokenList);
		}
	| epsilon
	;

//.............................................................................
