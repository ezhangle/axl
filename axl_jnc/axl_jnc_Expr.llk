//.............................................................................

class
{
	rtl::CBoxListT <CToken> m_TokenList;
}
expression_pass1
	: primary_expr_pass1 <&$.m_TokenList>+
	;

noast
primary_expr_pass1 <rtl::CBoxListT <CToken>* $pTokenList>
	: '{' primary_expr_pass1 <$pTokenList>+ '}'
	| '[' primary_expr_pass1 <$pTokenList>+ ']'
	| '(' primary_expr_pass1 <$pTokenList>* ')'
	| any
		{
			$pTokenList->InsertTail ($1);
		}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	CValue m_Value;	
}
start
expression
	: conditional_expr <&$.m_Value>
	;

class 
{
	CValue m_Value;
}
nullable
expression_or_empty
	: conditional_expr <&$.m_Value>
	| epsilon
	;

class
{
	rtl::CBoxListT <CValue> m_ValueList;
}
expression_list
	: expression 
		{
			$.m_ValueList.InsertTail ($1.m_Value);
		}
	  (	',' 
		expression $e2
			{
				$.m_ValueList.InsertTail ($e2.m_Value);
			}
	  )*
	;

class
{
	rtl::CBoxListT <CValue> m_ValueList;
}
nullable
expression_or_empty_list
	: expression_or_empty
		{
			$.m_ValueList.InsertTail ($1.m_Value);
		}
	  (	',' 
		expression_or_empty $e2
			{
				$.m_ValueList.InsertTail ($e2.m_Value);
			}
	  )*
	;

class
{
	CValue m_Value;	
}
start
constant_expr
	: conditional_expr <&$.m_Value>
		{
			if ($.m_Value.GetValueKind () != EValue_Const)
			{
				err::SetFormatStringError (_T("not a constant expression"));
				return false;
			}
		}
	;

class
{
	intptr_t m_Value;
}
start
constant_integer_expr
	: expression
		{						
			if ($1.m_Value.GetValueKind () != EValue_Const || !$1.m_Value.GetType ()->IsIntegerType ())
			{
				err::SetFormatStringError (_T("not a constant integer expression"));
				return false;
			}

			bool Result = m_pModule->m_OperatorMgr.CastOperator (&$1.m_Value, EType_Int32);
			if (!Result)
				return false;

			$.m_Value = $1.m_Value.GetInt32 ();
		}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class CConditionalExpr
{
	CValue m_TrueValue;
	CValue m_FalseValue;
	CBasicBlock* m_pThenBlock;
	CBasicBlock* m_pElseBlock;
	CBasicBlock* m_pPhiBlock;
}
conditional_expr <CValue* $pValue>
	: logical_or_expr <$pValue> 
	  (
		{
			$.m_pThenBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("cond_then"));
			$.m_pElseBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("cond_else"));
			$.m_pPhiBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("cond_phi"));			
			m_pModule->m_ControlFlowMgr.ConditionalJump (*$pValue, $.m_pThenBlock, $.m_pElseBlock);
		}
		'?' 
		conditional_expr <&$.m_TrueValue> 
			{
				$.m_pThenBlock = m_pModule->m_ControlFlowMgr.SetCurrentBlock ($.m_pElseBlock); // might have changed				
			}
		':' 
		conditional_expr <&$.m_FalseValue>
			{
				FinalizeConditionalExpr (&$, $pValue);
			}
	  )?
	;

logical_or_expr <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: logical_and_expr <$pValue> 
	  (
		EToken_LogicalOr logical_and_expr <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.BinaryOperator (EBinOp_LogicalAnd, $pValue, $OpValue2);
			}
	  )*
	;

logical_and_expr <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: inclusive_or_expr <$pValue> 
	  (
		EToken_LogicalAnd inclusive_or_expr <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.BinaryOperator (EBinOp_LogicalOr, $pValue, $OpValue2);
			}
	  )*
	;

inclusive_or_expr <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: exclusive_or_expr <$pValue> 
	  (
		'|' exclusive_or_expr <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.BinaryOperator (EBinOp_BitwiseOr, $pValue, $OpValue2);
			}
	  )*
	;

exclusive_or_expr <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: and_expr <$pValue> 
	  (
		'^' and_expr <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.BinaryOperator (EBinOp_BitwiseXor, $pValue, $OpValue2);
			}
	  )*
	;

and_expr <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: equality_expr <$pValue> 
	  (
		'&' equality_expr <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.BinaryOperator (EBinOp_BitwiseAnd, $pValue, $OpValue2);
			}
	  )*
	;

equality_expr <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: relational_expr <$pValue> 
	  (
		equality_operator $o relational_expr <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.BinaryOperator ($o.m_OpKind, $pValue, $OpValue2);
			}
	  )*
	;

class
{
	EBinOp m_OpKind;
}
equality_operator
	: EToken_Eq
		{
			$.m_OpKind = EBinOp_Eq;
		}
	| EToken_Ne
		{
			$.m_OpKind = EBinOp_Ne;
		}
	;

relational_expr <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: shift_expr <$pValue> 
	  (
		relational_operator $o shift_expr <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.BinaryOperator ($o.m_OpKind, $pValue, $OpValue2);
			}
	  )*
	;

class
{
	EBinOp m_OpKind;
}
relational_operator
	: '<'
		{
			$.m_OpKind = EBinOp_Lt;
		}
	| '>'
		{
			$.m_OpKind = EBinOp_Gt;
		}
	| EToken_Le
		{
			$.m_OpKind = EBinOp_Le;
		}
	| EToken_Ge
		{
			$.m_OpKind = EBinOp_Ge;
		}
	;

shift_expr <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: additive_expr <$pValue> 
	  (
		shift_operator $o additive_expr <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.BinaryOperator ($o.m_OpKind, $pValue, $OpValue2);
			}
	  )*
	;

class
{
	EBinOp m_OpKind;
}
shift_operator
	: EToken_Shl
		{
			$.m_OpKind = EBinOp_Shl;
		}
	| EToken_Shr
		{
			$.m_OpKind = EBinOp_Shr;
		}
	;

additive_expr <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: multiplicative_expr <$pValue> 
	  (
		additive_operator $o multiplicative_expr <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.BinaryOperator ($o.m_OpKind, $pValue, $OpValue2);
			}
	  )*
	;

class
{
	EBinOp m_OpKind;
}
additive_operator
	: '+'
		{
			$.m_OpKind = EBinOp_Add;
		}
	| '-'
		{
			$.m_OpKind = EBinOp_Sub;
		}
	;

multiplicative_expr <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: at_expr <$pValue> 
	  (
		multiplicative_operator $o at_expr <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.BinaryOperator ($o.m_OpKind, $pValue, $OpValue2);
			}
	  )*
	;

class
{
	EBinOp m_OpKind;
}
multiplicative_operator
	: '*'
		{
			$.m_OpKind = EBinOp_Mul;
		}
	| '/'
		{
			$.m_OpKind = EBinOp_Div;
		}
	| '%'
		{
			$.m_OpKind = EBinOp_Mod;
		}
	;

at_expr <CValue* $pValue>
	local
	{
		CValue $OpValue2;
	}
	: assignment_expr <$pValue> 
	  (
		'@' $o assignment_expr <&$OpValue2>
			{
				return m_pModule->m_OperatorMgr.BinaryOperator (EBinOp_At, $pValue, $OpValue2);
			}
	  )*
	;

assignment_expr <CValue* $pValue>
	local
	{
		CValue $RValue;
	}
	: unary_expr <$pValue> 
	  (
		assignment_operator $o conditional_expr <&$RValue>
			{
				switch ($o.m_AssignKind)
				{
				case EAssign_Normal:
					return m_pModule->m_OperatorMgr.MoveOperator ($RValue, *$pValue);

				case EAssign_BinOp:
					return m_pModule->m_OperatorMgr.BinOpMoveOperator ($RValue, *$pValue, $o.m_OpKind);

				case EAssign_Ref:
					return m_pModule->m_OperatorMgr.RefMoveOperator ($RValue, *$pValue);
				}
			}
	  )?
	;

class
{
	EAssign m_AssignKind;
	EBinOp m_OpKind;
}
assignment_operator
	: '='
		{
			$.m_AssignKind = EAssign_Normal;
		}
	| binop_assignment_operator
		{
			$.m_AssignKind = EAssign_BinOp;
			$.m_OpKind = $1.m_OpKind;
		}
	| EToken_RefAssign
		{
			$.m_AssignKind = EAssign_Ref;
		}
	;

class
{
	EBinOp m_OpKind;
}
binop_assignment_operator
	: EToken_AddAssign
		{
			$.m_OpKind = EBinOp_Add;
		}
	| EToken_SubAssign
		{
			$.m_OpKind = EBinOp_Sub;
		}
	| EToken_MulAssign
		{
			$.m_OpKind = EBinOp_Mul;
		}
	| EToken_DivAssign
		{
			$.m_OpKind = EBinOp_Div;
		}
	| EToken_ModAssign
		{
			$.m_OpKind = EBinOp_Mod;
		}
	| EToken_ShlAssign
		{
			$.m_OpKind = EBinOp_Shl;
		}
	| EToken_ShrAssign
		{
			$.m_OpKind = EBinOp_Shr;
		}
	| EToken_AndAssign
		{
			$.m_OpKind = EBinOp_BitwiseAnd;
		}
	| EToken_XorAssign
		{
			$.m_OpKind = EBinOp_BitwiseXor;
		}
	| EToken_OrAssign
		{
			$.m_OpKind = EBinOp_BitwiseOr;
		}
	;

unary_expr <CValue* $pValue>
	: postfix_expr <$pValue> 
	| unary_operator_expr <$pValue> 
	;

unary_operator_expr <CValue* $pValue>
	leave 
	{
		if (m_pAutoEvType && $pValue->GetType ()->IsBindablePropertyType ())
			m_BindablePropertyList.InsertTail (*$pValue);
	}
	: '&' unary_expr <$pValue> 
		{
			return m_pModule->m_OperatorMgr.UnaryOperator (EUnOp_Addr, $pValue);
		}
	| '*' unary_expr <$pValue> 
		{
			return m_pModule->m_OperatorMgr.UnaryOperator (EUnOp_Indir, $pValue);
		}
	| '+' unary_expr <$pValue> 
		{
			return m_pModule->m_OperatorMgr.UnaryOperator (EUnOp_Plus, $pValue);
		}
	| '-' unary_expr <$pValue> 
		{
			return m_pModule->m_OperatorMgr.UnaryOperator (EUnOp_Minus, $pValue);
		}
	| '~' unary_expr <$pValue> 
		{
			return m_pModule->m_OperatorMgr.UnaryOperator (EUnOp_BitwiseNot, $pValue);
		}
	| '!' unary_expr <$pValue> 
		{
			return m_pModule->m_OperatorMgr.UnaryOperator (EUnOp_LogicalNot, $pValue);
		}
	| EToken_Inc unary_expr <$pValue> 
		{
			return m_pModule->m_OperatorMgr.UnaryOperator (EUnOp_PreInc, $pValue);
		}
	| EToken_Dec unary_expr <$pValue> 
		{
			return m_pModule->m_OperatorMgr.UnaryOperator (EUnOp_PreDec, $pValue);
		}
	| EToken_OnChange unary_expr <$pValue> 
		{
			return m_pModule->m_OperatorMgr.OnChangeOperator ($pValue);
		}
	| EToken_SizeOf type_name_or_expr
		{
			$pValue->SetConstSizeT ($2.m_pType->GetSize ());
		}
	| EToken_TypeOf type_name_or_expr
		{
			$pValue->SetType ($2.m_pType);
		}
	| resolver (cast_operator_rslv) 
	  '(' allocation_specifier $a? type_name $t ')' unary_expr <$pValue> 
		{
			EAlloc AllocKind = IsValidLocator ($a) ? $a.m_AllocKind : EAlloc_Undefined;
			return m_pModule->m_OperatorMgr.CastOperator (AllocKind, $pValue, $t.m_pType);
		}
	| allocation_specifier $a? EToken_New type_name $t
		{
			EAlloc AllocKind = IsValidLocator ($a) ? $a.m_AllocKind : EAlloc_Undefined;
			return m_pModule->m_OperatorMgr.NewOperator (AllocKind, $t.m_pType, $pValue);
		}
	;

class
{
	EAlloc m_AllocKind;
}
allocation_specifier
	: EToken_Stack
		{
			$.m_AllocKind = EAlloc_Stack;
		}
	| EToken_Heap
		{
			$.m_AllocKind = EAlloc_Heap;
		}
	;

// since '(' at 'unary_expr' is a conflict against epsilon production we need a resolver
// otherwise epsilon production always loses

cast_operator_rslv
	local
	{
		CTypeSpecifierModifiers $TypeSpecifier;
	}
	: '(' allocation_specifier? type_specifier_modifier <&$TypeSpecifier>
	;

class
{
	CType* m_pType;
}
type_name_or_expr
	local
	{
		CValue $Value;
	}	
	: type_name 
		{
			$.m_pType = $1.m_pType;
		}
	| '(' type_name ')'
		{
			$.m_pType = $2.m_pType;
		}
	| unary_expr <&$Value>
		{
			CType* pType = $Value.GetType ();
			$.m_pType = pType->IsReferenceType () ? ((CPointerType*) pType)->GetBaseType () : pType;
		}
	;

postfix_expr <CValue* $pValue>
	: primary_expr <$pValue>
	  postfix_operator <$pValue>*
	;

postfix_operator <CValue* $pValue>
	leave 
	{
		if (m_pAutoEvType && $pValue->GetType ()->IsBindablePropertyType ())
			m_BindablePropertyList.InsertTail (*$pValue);
	}
	: '.' EToken_Identifier
		{
			return m_pModule->m_OperatorMgr.MemberOperator ($pValue, $2.m_Data.m_String);
		}
	| EToken_Ptr EToken_Identifier
		{
			return m_pModule->m_OperatorMgr.PointerToMemberOperator ($pValue, $2.m_Data.m_String);
		}
	| '(' expression_or_empty_list ')'
		{
			return m_pModule->m_OperatorMgr.CallOperator ($pValue, &$2.m_ValueList);
		}		
	| '~' '(' expression_or_empty_list ')'
		{
			return m_pModule->m_OperatorMgr.ClosureOperator ($pValue, &$3.m_ValueList);
		}		
	| '[' expression ']'
		{
			return m_pModule->m_OperatorMgr.BinaryOperator (EBinOp_Idx, $pValue, $2.m_Value);
		}	
	| EToken_Inc
		{
			return m_pModule->m_OperatorMgr.UnaryOperator (EUnOp_PostInc, $pValue);
		}
	| EToken_Dec
		{
			return m_pModule->m_OperatorMgr.UnaryOperator (EUnOp_PostDec, $pValue);
		}
	;

primary_expr <CValue* $pValue>
	leave 
	{
		if (m_pAutoEvType && $pValue->GetType ()->IsBindablePropertyType ())
			m_BindablePropertyList.InsertTail (*$pValue);
	}
	: EToken_Identifier
		{
			return LookupIdentifier ($1.m_Data.m_String, $pValue);
		}
	| EToken_This
		{
			return SetThis ($pValue);
		}
	| EToken_Integer
		{
			$pValue->SetConstUInt64 ($1.m_Data.m_UInt64);
		}
	| EToken_Fp
		{
			$pValue->SetConstDouble ($1.m_Data.m_Double);
		}
	| literal 
		{
			$pValue->SetLiteral ($1.m_String);
		}
	| EToken_True
		{
			$pValue->SetConstBool (true);
		}
	| EToken_False
		{
			$pValue->SetConstBool (false);
		}
	| EToken_Null
		{
			$pValue->SetNull ();
		}
	| '(' conditional_expr <$pValue> ')'
	;

class
{
	rtl::CString m_String;
}
literal
	: EToken_Literal 
		{
			$.m_String = $1.m_Data.m_String;
		}
	  (EToken_Literal 
		{
			$.m_String.Append ($2.m_Data.m_String);
		}
	  )*
	;

//.............................................................................
 