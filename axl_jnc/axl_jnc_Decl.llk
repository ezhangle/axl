//.............................................................................

global_declaration
	: namespace_declaration
	| using_declaration 
	| common_declaration
	| compound_statement_pass1
	| ';'
	;

local_declaration
	: using_declaration 
	| common_declaration
	| statement
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

pragma
pragma_pack
	: '#' EToken_Pack pack_pack_argument
	;

pack_pack_argument
	: pack_value
	| '(' pack_value ')'
	;

pack_value
	: EToken_Integer
		{
			m_StructPackFactor = $1.m_Data.m_Integer;
		}
	| EToken_Default
		{
			m_StructPackFactor = m_DefaultStructPackFactor;
		}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	CQualifiedName m_Name;
}
qualified_name
	: EToken_Identifier       
		{  
			$.m_Name.m_First = $1.m_Data.m_String; 
		}
	  ('.' EToken_Identifier $n2
		{ 
			$.m_Name.m_List.InsertTail ($n2.m_Data.m_String);
		}
	  )*
	; 

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	CType* m_pType;
} 
type_name
	local
	{	
		CDeclarator $Declarator;
	}
	: type_specifier_modifier_list
	  pointer <&$Declarator>* 
	  declarator_suffix <&$Declarator>*
		{
			$.m_pType = $Declarator.GetType (&$1.m_TypeSpecifier, &m_pModule->m_TypeMgr);
		}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

generic_formal_argument_list <CStructClassType* $pType>
	: '<' generic_formal_argument <$pType> (',' generic_formal_argument <$pType>)* '>'
	;

generic_formal_argument <CStructClassType* $pType>
	: EToken_Identifier
		{						
			CImportType* pArgumentType = m_pModule->m_TypeMgr.GetImportType ($1.m_Data.m_String, $pType);
			bool Result = $pType->AddGenericArgument (pArgumentType);
			if (!Result)
				return false;
		}
	;

generic_actual_argument_list
	: '<' type_name (',' type_name)* '>'
	;

//.............................................................................

