//.............................................................................

global_declaration
	: namespace_declaration
	| using_declaration 
	| common_declaration
	| function_body_pass1
	| ';'
	;

local_declaration
	: using_declaration 
	| common_declaration
	| statement
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	CQualifiedName m_Name;
}
qualified_name
	: EToken_Identifier       
		{  
			$.m_Name.m_First = $1.m_Data.m_String; 
		}
	  ('.' EToken_Identifier $n2
		{ 
			$.m_Name.m_List.InsertTail ($n2.m_Data.m_String);
		}
	  )*
	; 

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	CType* m_pType;
} 
type_name
	local
	{	
		CDeclarator $Declarator;
	}
	: type_specifier_modifier_list
	  pointer <&$Declarator>* 
	  declarator_suffix <&$Declarator>*
		{
			$.m_pType = $Declarator.GetType (&$1.m_TypeSpecifier);
		}
	;

class
{
	rtl::CBoxListT <CType*> m_TypeList;
}
type_name_list
	: type_name
		{
			$.m_TypeList.InsertTail ($1.m_pType);
		}
	  (',' type_name $t2
		{
			$.m_TypeList.InsertTail ($t2.m_pType);
		}
	  )*

	;


//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

generic_formal_argument_list
	: '<' EToken_Identifier (',' generic_formal_argument)* '>'
	;

generic_formal_argument
	: EToken_Identifier
/*		{						
			CImportType* pArgumentType = m_pModule->m_TypeMgr.GetImportType ($1.m_Data.m_String, $pType);
			return $pType->AddGenericArgument (pArgumentType);
		} */
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

pragma
pragma_pack
	: '#' EToken_Pack ':' struct_pack_factor_value $v
		{
			m_StructPackFactor = $v.m_Value;
		}
	;

//.............................................................................
