//.............................................................................

// pragmas

pragma
pragma_pack
	: '#' EToken_Pack '(' struct_pack_factor_value $v ')'
		{
			m_StructPackFactor = $v.m_Value;
		}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

pragma
pragma_endian
	: '#' EToken_Endian '(' pragma_endian_value ')'
	;

pragma_endian_value
	: (EToken_LittleEndian | EToken_Default)
		{
			m_Endianness = EEndianness_LittleEndian;
		}
	| EToken_BigEndian
		{
			m_Endianness = EEndianness_BigEndian;
		}
	;

//.............................................................................

// root declaration productions

global_declaration
	: namespace_declaration
	| using_declaration 
	| item_declaration
	;

local_declaration
	: using_declaration 
	| item_declaration_w_specifier
	| statement
	;

//.............................................................................

// namespace & using declarations

namespace_declaration
	: EToken_Namespace qualified_name
		{ 
			CNamespace* pNamespace = m_pModule->m_NamespaceMgr.OpenNamespace ($1.m_Pos, $2.m_Name);
			if (!pNamespace)
				return false;
		}
	  '{' global_declaration* '}' 
		{ 
			m_pModule->m_NamespaceMgr.CloseNamespace ($2.m_Name.m_List.GetCount () + 1);
		}
	;

using_declaration
	: EToken_Using qualified_name ';'
	;

//.............................................................................

class
{
	CQualifiedName m_Name
}
qualified_name
	: qualified_name_impl <&$.m_Name>
	; 

qualified_name_impl <CQualifiedName* $pName>
	: EToken_Identifier       
		{  
			$pName->m_First = $1.m_Data.m_String; 
		}
	  ('.' EToken_Identifier $n2
		{ 
			$pName->m_List.InsertTail ($n2.m_Data.m_String);
		}
	  )*
	; 

//.............................................................................

// item declarations

item_declaration
	: item_declaration_w_specifier
	| item_declaration_no_specifier
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

item_declaration_w_specifier
	enter
	{
		m_StorageKind = EStorage_Undefined;
		m_AccessKind = EAccess_Undefined;
	}	
	: declaration_specifier_list $s
	  declarator_list <&$s.m_TypeSpecifier>?
	  declaration_terminator <&$s.m_TypeSpecifier>
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	CDeclarator m_Declarator;
}
item_declaration_no_specifier
	enter
	{
		m_StorageKind = EStorage_Undefined;
		m_AccessKind = m_DefaultAccessKind;		
		$.m_Declarator.SetTypeSpecifier (NULL);
	}	
	: declarator_name <&$.m_Declarator>
	  declarator_suffix <&$.m_Declarator>*
		{
			CTypeSpecifier TypeSpecifier;
			TypeSpecifier.SetType (m_pModule->m_TypeMgr.GetPrimitiveType (EType_Void));
			return Declare (&$.m_Declarator);
		}
	  declaration_terminator <NULL>
	;

// this resolver is needed to deal with the conflict in item_declaration between
// item_declaration_w_specifier::qualified_type_name and item_declaration_no_specifier::declarator_name

item_declaration_no_specifier_rslv
	local
	{
		CDeclarator $Declarator;
	}
	: declarator_name <&$Declarator> '(' // must be a function
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

declaration_terminator <CTypeSpecifier* $pTypeSpecifier>
	leave 
	{
		if (m_pAttributeBlock)
		{
			err::SetFormatStringError (_T("unused attribute block in declaration"));
			return false;
		}

		m_pLastDeclaredItem = NULL;
	}
	: ';'
		{
			return IsEmptyDeclarationTerminatorAllowed ($pTypeSpecifier);
		}
	| function_body_pass1
		{
			return SetFunctionBody (&$1.m_TokenList);
		}
	;

//.............................................................................

// type names

class
{
	CType* m_pType;
} 
type_name
	local
	{	
		CDeclarator $Declarator;
	}
	: type_specifier_modifier_list
		{
			$Declarator.SetTypeSpecifier (&$1.m_TypeSpecifier);
		}
	  pointer <&$Declarator>* 
	  declarator_suffix <&$Declarator>*
		{
			$.m_pType = $Declarator.GetType ();
		}
	;

class
{
	rtl::CBoxListT <CType*> m_TypeList;
}
type_name_list
	: type_name
		{
			$.m_TypeList.InsertTail ($1.m_pType);
		}
	  (',' type_name $t2
		{
			$.m_TypeList.InsertTail ($t2.m_pType);
		}
	  )*

	;

//.............................................................................

// generics

generic_formal_argument_list
	: '<' EToken_Identifier (',' generic_formal_argument)* '>'
	;

generic_formal_argument
	: EToken_Identifier
/*		{						
			CImportType* pArgumentType = m_pModule->m_TypeMgr.GetImportType ($1.m_Data.m_String, $pType);
			return $pType->AddGenericArgument (pArgumentType);
		} */
	;

generic_actual_argument_list
	: '<' type_name (',' type_name)* '>'
	;

//.............................................................................

// attributes

attribute_block
	: '[' 
		{
			m_pAttributeBlock = m_pModule->m_AttributeMgr.CreateAttributeBlock ();
		}
	  attribute_declarator_list
	  ']'
	;

nullable
attribute_declarator_list
	: attribute_declarator (',' attribute_declarator)*
	;

nullable
attribute_declarator
	: EToken_Identifier ('=' expression_pass1)?
		{
			CAttribute* pAttribute = m_pAttributeBlock->CreateAttribute ($1.m_Data.m_String, NULL);
			if (!pAttribute)
				return false;

			pAttribute->m_Pos = $1.m_Pos;
		}
	| epsilon
	;

//.............................................................................
