//.............................................................................

global_declaration
	: namespace_declaration
	| using_declaration 
	| common_declaration
	| function_body_pass1
	| ';'
	;

local_declaration
	: using_declaration 
	| common_declaration
	| statement
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	CQualifiedName m_Name;
}
qualified_name
	: EToken_Identifier       
		{  
			$.m_Name.m_First = $1.m_Data.m_String; 
		}
	  ('.' EToken_Identifier $n2
		{ 
			$.m_Name.m_List.InsertTail ($n2.m_Data.m_String);
		}
	  )*
	; 

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	CType* m_pType;
} 
type_name
	local
	{	
		CDeclarator $Declarator;
	}
	: type_specifier_modifier_list
	  pointer <&$Declarator>* 
	  declarator_suffix <&$Declarator>*
		{
			$.m_pType = $Declarator.GetType (&$1.m_TypeSpecifier);
		}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

generic_formal_argument_list <CStructClassType* $pType>
	: '<' generic_formal_argument <$pType> (',' generic_formal_argument <$pType>)* '>'
	;

generic_formal_argument <CStructClassType* $pType>
	: EToken_Identifier
		{						
			CImportType* pArgumentType = m_pModule->m_TypeMgr.GetImportType ($1.m_Data.m_String, $pType);
			return $pType->AddGenericArgument (pArgumentType);
		}
	;

//.............................................................................
