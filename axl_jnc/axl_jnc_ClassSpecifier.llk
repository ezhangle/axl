//.............................................................................

class
{
	CClassType* m_pType;
}
class_specifier
	: class_kind $k 
	  EToken_Identifier $n?
		{
			$.m_pType = DeclareClassType (
				$k.m_TypeKind,
				IsValidLocator ($n) ? $n.m_Data.m_String : rtl::CString ()
				);

			if (!$.m_pType)
				return false;
		}
	  generic_formal_argument_list?
	  (':' type_name_list)?
	  class_block <$.m_pType>
	;

class
{
	EType m_TypeKind;
}
class_kind
	: EToken_Interface
		{
			$.m_TypeKind = EType_Interface;
		}
	| EToken_Class
		{
			$.m_TypeKind = EType_Class;
		}
	;

class_block <CClassType* $pType>
	: '{' 
		{
			m_pModule->m_NamespaceMgr.OpenNamespace ($pType);	
		}
	  class_member_declaration <$pType>* 
	  '}'
		{
			m_pModule->m_NamespaceMgr.CloseNamespace ();
		}
	;

class_member_declaration <CClassType* $pType>
	: attribute_block?
	  declaration_specifier_list $s
	  class_member_declarator_list <&$s.m_DeclSpecifiers, $pType>? 
	  declaration_terminator
	| function_body_pass1
	| ';'
	;

class_member_declarator_list <CDeclSpecifiers* $pDeclSpecifiers, CClassType* $pType>
	: class_member_declarator <$pDeclSpecifiers, $pType> (',' class_member_declarator <$pDeclSpecifiers, $pType>)*
	;

class_member_declarator <CDeclSpecifiers* $pDeclSpecifiers, CClassType* $pType>
local
{
	CModuleItem* $pMember;
}
	: declarator (':' struct_member_bit_field)? 
		{
			$pMember = DeclareClassMember ($pType, $pDeclSpecifiers, &$1.m_Declarator);
			if (!$pMember)
				return false;
		}
	  ('=' 
		{
			if ($pMember->GetItemKind () != EModuleItem_ClassMember)
			{
				err::SetFormatStringError (_T("cannot apply initializer to '%s'"), $pMember->GetItemKindString ());
				return false;
			}			
		}
	  initializer <.((CClassFieldMember*) $pMember)->GetType ().>
		{
		}
	  )?
	;

//.............................................................................
