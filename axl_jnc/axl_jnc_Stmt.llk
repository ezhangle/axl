//.............................................................................

class
{
	rtl::CBoxListT <CToken> m_TokenList;
}
function_body_pass1
	: compound_stmt_pass1 <&$.m_TokenList>
	;

noast
compound_stmt_pass1 <rtl::CBoxListT <CToken>* $pTokenList>
	: '{'
		{
			$pTokenList->InsertTail ($1);
		}
	  statement_pass1 <$pTokenList>* 
	  '}'
		{
			$pTokenList->InsertTail ($3);
		}
	;

noast
statement_pass1 <rtl::CBoxListT <CToken>* $pTokenList>
	: compound_stmt_pass1 <$pTokenList>
	| any
		{
			$pTokenList->InsertTail ($1);
		}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

start
compound_stmt
	: '{' $l
		{
			OpenScope ($l.m_Pos);
		}
	  local_declaration* 
	  '}' $r
		{
			CloseScope ($r.m_Pos);
		}
	;

start
constructor_compound_stmt
	: '{' $l
		{
			OpenScope ($l.m_Pos);
		}
	  base_type_constructor*
		{
			return m_pModule->m_OperatorMgr.PostBaseTypeConstructorList ();
		}
	  local_declaration* 
	  '}' $r
		{
			CloseScope ($r.m_Pos);
		}
	;

base_type_constructor
	: resolver (base_type_constructor_rslv)
	  qualified_type_name $t '(' expression_or_empty_list $a ')'
		{
			return m_pModule->m_OperatorMgr.CallBaseTypeConstructor ($t.m_pType, &$a.m_ValueList);
		}
	| ';'
	;

base_type_constructor_rslv
	: qualified_type_name '('
	;

statement
	: compound_stmt
	| expression_stmt
	| if_stmt
	| switch_stmt
	| while_stmt
	| do_stmt
	| for_stmt
	| break_stmt
	| continue_stmt
	| return_stmt
	| ';'
	;

expression_stmt
	: expression ';'
	;

if_stmt
	local
	{
		CBasicBlock* $pThenBlock;
		CBasicBlock* $pElseBlock;
		CBasicBlock* $pFollowBlock;
	}
	enter
	{
		$pThenBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("if_then"));
		$pElseBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("if_else"));
		$pFollowBlock = $pElseBlock;
	}
	: EToken_If '(' expression $e ')' 
		{
			return m_pModule->m_ControlFlowMgr.ConditionalJump ($e.m_Value, $pThenBlock, $pElseBlock);
		}
	  statement $t 
	  (
		EToken_Else 
			{
				$pFollowBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("if_follow"));
				m_pModule->m_ControlFlowMgr.Jump ($pFollowBlock, $pElseBlock);
			}
		statement $f
	  )?
		{	
			m_pModule->m_ControlFlowMgr.Follow ($pFollowBlock);
		}
	;

class CSwitchStmt
{
	CValue m_Value;
	CBasicBlock* m_pSwitchBlock;
	CBasicBlock* m_pFollowBlock;
	CBasicBlock* m_pDefaultBlock;
	rtl::CHashTableMapT <intptr_t, CBasicBlock*, axl::rtl::CHashIdT <intptr_t> > m_CaseMap;
}
switch_stmt
	: EToken_Switch '(' expression $e ')' 
		{
			bool Result = m_pModule->m_OperatorMgr.CastOperator ($e.m_Value, EType_Int, &$.m_Value);
			if (!Result)
				return false;

			$.m_pSwitchBlock = m_pModule->m_ControlFlowMgr.GetCurrentBlock ();
			$.m_pFollowBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("switch_follow"));
			$.m_pDefaultBlock = NULL;
			
			CBasicBlock* pBodyBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("switch_body"));
			m_pModule->m_ControlFlowMgr.SetCurrentBlock (pBodyBlock);
			m_pModule->m_ControlFlowMgr.MarkUnreachable (pBodyBlock);
		}
	  '{' $a
		{
			CScope* pScope = OpenScope ($a.m_Pos);
			pScope->m_pBreakBlock = $.m_pFollowBlock;
		}	   
	  switch_block_stmt <&$>* 
	  '}' $a2
		{
			CloseScope ($a2.m_Pos);
			m_pModule->m_ControlFlowMgr.Follow ($.m_pFollowBlock);

			return FinalizeSwitchStmt (&$);
		}
	;

switch_block_stmt <CSwitchStmt* $pSwitchStmt>
	: EToken_Case constant_integer_expr $e ':' $a
		{
			return SwitchCaseLabel ($pSwitchStmt, $e.m_Value, $1.m_Pos, $a.m_Pos);
		}
	| EToken_Default ':' $a
		{
			return SwitchDefaultLabel ($pSwitchStmt, $1.m_Pos, $a.m_Pos);
		}
	| statement
	;

while_stmt
	local
	{
		CBasicBlock* $pConditionBlock;
		CBasicBlock* $pBodyBlock;
		CBasicBlock* $pFollowBlock;
	}
	enter
	{
		$pConditionBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("while_condition"));
		$pBodyBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("while_body"));
		$pFollowBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("while_follow"));
		m_pModule->m_ControlFlowMgr.Follow ($pConditionBlock);
	}
	: EToken_While '(' expression $e ')' $a
		{
			CScope* pScope = OpenScope ($a.m_Pos);
			pScope->m_pBreakBlock = $pFollowBlock;
			pScope->m_pContinueBlock = $pConditionBlock;
			return m_pModule->m_ControlFlowMgr.ConditionalJump ($e.m_Value, $pBodyBlock, $pFollowBlock);
		}		
	  statement $s
		{
			CloseScope ($s.m_LastToken.m_Pos);
			m_pModule->m_ControlFlowMgr.Jump ($pConditionBlock, $pFollowBlock);
		}		
	;

do_stmt
	local
	{
		CBasicBlock* $pConditionBlock;
		CBasicBlock* $pBodyBlock;
		CBasicBlock* $pFollowBlock;
	}
	enter
	{
		$pConditionBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("do_condition"));
		$pBodyBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("do_body"));
		$pFollowBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("do_follow"));
		m_pModule->m_ControlFlowMgr.Follow ($pBodyBlock);
	}
	: EToken_Do
		{
			CScope* pScope = OpenScope ($1.m_Pos);
			pScope->m_pBreakBlock = $pFollowBlock;
			pScope->m_pContinueBlock = $pConditionBlock;
		}
	  statement $s
		{
			m_pModule->m_ControlFlowMgr.Follow ($pConditionBlock);
		}
	  EToken_While '(' expression $e ')' 
		{
			return m_pModule->m_ControlFlowMgr.ConditionalJump ($e.m_Value, $pBodyBlock, $pFollowBlock);
			m_pModule->m_ControlFlowMgr.SetCurrentBlock ($pFollowBlock);
		}			  
	  ';'
	;

for_stmt
	local
	{
		CScope* $pScope;
		CBasicBlock* $pConditionBlock;
		CBasicBlock* $pBodyBlock;
		CBasicBlock* $pLoopBlock;
		CBasicBlock* $pFollowBlock;
	}
	enter
	{
		$pBodyBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("for_body"));
		$pFollowBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("for_follow"));
		$pConditionBlock = $pBodyBlock;
		$pLoopBlock = $pBodyBlock;
	}
	: EToken_For '(' 
		{
			$pScope = OpenScope ($1.m_Pos);
		}	  
	  (item_declaration_w_specifier | expression_or_empty_list ';') 
	  (
			{
				$pConditionBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("for_condition"));
				$pLoopBlock = $pConditionBlock;
				m_pModule->m_ControlFlowMgr.Follow ($pConditionBlock);
			}
		expression $e
			{
				return m_pModule->m_ControlFlowMgr.ConditionalJump ($e.m_Value, $pBodyBlock, $pFollowBlock);
			}
	  )? ';' 
	  (
			{
				$pLoopBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("for_loop"));
				m_pModule->m_ControlFlowMgr.SetCurrentBlock ($pLoopBlock);
			}
		expression_list
			{
				m_pModule->m_ControlFlowMgr.Jump ($pConditionBlock, $pBodyBlock);
			}
	  )? ')'
		{
			$pScope->m_pBreakBlock = $pFollowBlock;
			$pScope->m_pContinueBlock = $pConditionBlock;
		}
	  statement $s
		{
			CloseScope ($s.m_LastToken.m_Pos);
			m_pModule->m_ControlFlowMgr.Jump ($pLoopBlock, $pFollowBlock);

			if (!($pFollowBlock->GetFlags () & EBasicBlockFlag_Jumped))
				m_pModule->m_ControlFlowMgr.MarkUnreachable ($pFollowBlock);
		}
	;

break_stmt
	: EToken_Break constant_integer_expr $e? ';'
		{
			return m_pModule->m_ControlFlowMgr.Break (IsValidLocator ($e) ? $e.m_Value : 1);
		}
	;

continue_stmt 
	: EToken_Continue constant_integer_expr $e? ';'
		{
			return m_pModule->m_ControlFlowMgr.Continue (IsValidLocator ($e) ? $e.m_Value : 1);
		}
	;

return_stmt
	: EToken_Return expression $e? ';'
		{
			return m_pModule->m_ControlFlowMgr.Return (IsValidLocator ($e) ? $e.m_Value : CValue ());
		}
	;

//.............................................................................

start
autoev_body
	: '{' autoev_stmt+ '}'
		{
			return FinalizeAutoEv ();
		}
	;
	
autoev_stmt
	: resolver ({ return true; }) // within autoev_body prefer autoev_onchange_stmt 
	  autoev_onchange_stmt 
	| autoev_expression_stmt
	| ';'
	;

autoev_onchange_stmt
	: EToken_OnChange '(' expression_list ')'
		{
			return FinalizeAutoEvOnChangeClause ();
		}
	  statement 
		{
			FinalizeAutoEvOnChangeStmt ();
		}
	;

autoev_expression_stmt
	: expression_pass1 ';'
		{
			return AutoEvExpressionStmt (&$1.m_TokenList);
		}
	;

//.............................................................................
