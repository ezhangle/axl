//.............................................................................

class
{
	rtl::CBoxListT <CToken> m_TokenList;
}
function_body_pass1
	: compound_stmt_pass1 <&$.m_TokenList>
	;

noast
compound_stmt_pass1 <rtl::CBoxListT <CToken>* $pTokenList>
	: '{' $l
		{
			$pTokenList->InsertTail ($l);
		}
	  statement_pass1 <$pTokenList>* 
	  '}' $r
		{
			$pTokenList->InsertTail ($r);
		}
	;

noast
statement_pass1 <rtl::CBoxListT <CToken>* $pTokenList>
	: compound_stmt_pass1 <$pTokenList>
	| any
		{
			$pTokenList->InsertTail ($1);
		}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class CCompoundStmt
{
	CScope* m_pScope;
}
start
compound_stmt
	: '{' $l
		{
			$.m_pScope = m_pModule->m_NamespaceMgr.OpenScope ($l.m_Pos);
		}
	  local_declaration* 
	  '}' $r
		{
			m_pModule->m_NamespaceMgr.CloseScope ($r.m_Pos);
		}
	;

statement
	: compound_stmt
	| expression_stmt
	| if_stmt
	| switch_stmt
	| while_stmt
	| do_stmt
	| for_stmt
	| break_stmt
	| continue_stmt
	| return_stmt
	| ';'
	;

expression_stmt
	: expression ';'
	;

if_stmt
local
{
	CBasicBlock* $pThenBlock;
	CBasicBlock* $pElseBlock;
	CBasicBlock* $pFollowBlock;
}
enter
{
	$pThenBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("if_then"));
	$pElseBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("if_else"));
	$pFollowBlock = $pElseBlock;
}
	: EToken_If '(' expression $e ')' 
		{
			return m_pModule->m_ControlFlowMgr.ConditionalJump ($e.m_Value, $pThenBlock, $pElseBlock);
		}
	  statement $t 
	  (
		EToken_Else 
			{
				$pFollowBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("if_follow"));
				m_pModule->m_ControlFlowMgr.Jump ($pFollowBlock, $pElseBlock);
			}
		statement $f
	  )?
		{	
			m_pModule->m_ControlFlowMgr.Follow ($pFollowBlock);
		}
	;

switch_stmt
	: EToken_Switch '(' expression ')' '{' switch_block_stmt* '}'
	;

switch_block_stmt
	: EToken_Case constant_integer_expr ':'
	| EToken_Default ':'
	| statement
	;

while_stmt
local
{
	CBasicBlock* $pConditionBlock;
	CBasicBlock* $pBodyBlock;
	CBasicBlock* $pFollowBlock;
}
enter
{
	$pConditionBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("while_condition"));
	$pBodyBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("while_body"));
	$pFollowBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("while_follow"));
	m_pModule->m_ControlFlowMgr.Follow ($pConditionBlock);
}
	: EToken_While '(' expression $e ')' $a
		{
			return m_pModule->m_ControlFlowMgr.ConditionalJump ($e.m_Value, $pBodyBlock, $pFollowBlock);
		}		
	  loop_stmt <&$a.m_Pos, $pFollowBlock, $pConditionBlock>
		{
			m_pModule->m_ControlFlowMgr.Jump ($pConditionBlock, $pFollowBlock);
		}		
	;

do_stmt
local
{
	CBasicBlock* $pConditionBlock;
	CBasicBlock* $pBodyBlock;
	CBasicBlock* $pFollowBlock;
}
enter
{
	$pConditionBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("do_condition"));
	$pBodyBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("do_body"));
	$pFollowBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("do_follow"));
	m_pModule->m_ControlFlowMgr.Follow ($pBodyBlock);
}
	: EToken_Do $a loop_stmt <&$a.m_Pos, $pFollowBlock, $pConditionBlock>
		{
			m_pModule->m_ControlFlowMgr.Follow ($pConditionBlock);
		}
	  EToken_While '(' expression $e ')' 
		{
			return m_pModule->m_ControlFlowMgr.ConditionalJump ($e.m_Value, $pBodyBlock, $pFollowBlock);
		}			  
	  ';'
		{	
			m_pModule->m_ControlFlowMgr.SetCurrentBlock ($pFollowBlock);
		}
	;

for_stmt
local
{
	CScope* $pScope;
	CBasicBlock* $pConditionBlock;
	CBasicBlock* $pBodyBlock;
	CBasicBlock* $pLoopBlock;
	CBasicBlock* $pFollowBlock;
}
enter
{
	$pBodyBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("for_body"));
	$pFollowBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("for_follow"));
	$pConditionBlock = $pBodyBlock;
	$pLoopBlock = $pBodyBlock;
}
	: EToken_For '(' 
		{
			$pScope = m_pModule->m_NamespaceMgr.OpenScope ($1.m_Pos);
		}	  
	  (declaration_list | expression_list)? ';'
	  (
			{
				$pConditionBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("for_condition"));
				$pLoopBlock = $pConditionBlock;
				m_pModule->m_ControlFlowMgr.Follow ($pConditionBlock);
			}
		expression $e
			{
				return m_pModule->m_ControlFlowMgr.ConditionalJump ($e.m_Value, $pBodyBlock, $pFollowBlock);
			}
	  )? ';' 
	  (
			{
				$pLoopBlock = m_pModule->m_ControlFlowMgr.CreateBlock (_T("for_loop"));
				m_pModule->m_ControlFlowMgr.SetCurrentBlock ($pLoopBlock);
			}
		expression_list
			{
				m_pModule->m_ControlFlowMgr.Jump ($pConditionBlock, $pBodyBlock);
			}
	  )?
	  ')'
		{
			$pScope->m_pBreakBlock = $pFollowBlock;
			$pScope->m_pContinueBlock = $pConditionBlock;
		}
	  statement $s
		{
			m_pModule->m_NamespaceMgr.CloseScope ($s.m_LastToken.m_Pos);
			m_pModule->m_ControlFlowMgr.Jump ($pLoopBlock, $pFollowBlock);
		}		 
	;

loop_stmt <const CToken::CPos* $pPos, CBasicBlock* $pBreakBlock, CBasicBlock* $pContinueBlock>
	: 
		{			
		}
	 
		{
		}
	;

break_stmt
	: EToken_Break constant_integer_expr $e? ';'
		{
			return m_pModule->m_ControlFlowMgr.Break (IsValidLocator ($e) ? $e.m_Value : 1);
		}
	;

continue_stmt 
	: EToken_Continue constant_integer_expr $e? ';'
		{
			return m_pModule->m_ControlFlowMgr.Continue (IsValidLocator ($e) ? $e.m_Value : 1);
		}
	;

return_stmt
	: EToken_Return expression $e? ';'
		{
			return m_pModule->m_ControlFlowMgr.Return (IsValidLocator ($e) ? $e.m_Value : CValue ());
		}
	;

//.............................................................................
