//.............................................................................

// enum

class
{
	CEnumType* m_pType;
}
enum_specifier
	leave
	{
		if ($.m_pType->GetName ().IsEmpty () || ($.m_pType->GetFlags () & EEnumTypeFlag_Exposed))
			return m_pModule->m_NamespaceMgr.GetCurrentNamespace ()->ExposeEnumConsts ($.m_pType);
	}
	: (EToken_Enum | EToken_EnumC $c)
	  EToken_Identifier $n?
		{
			$.m_pType = CreateEnumType (
				IsValidLocator ($n) ? $n.m_Data.m_String : rtl::CString (),
				IsValidLocator ($c) ? EEnumTypeFlag_Exposed : 0
				);

			if (!$.m_pType)
				return false;
		}	
	  enum_block <$.m_pType>
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

enum_block <CEnumType* $pType>
	: '{' 
		{
			OpenNamespace ($pType);	
		}
	  enum_member_list <$pType> 
	  '}'
		{
			CloseNamespace ();	
		}
	;

nullable
enum_member_list <CEnumType* $pType>
	: enum_member <$pType> (',' enum_member <$pType>)*
	;

nullable
enum_member <CEnumType* $pType>
	: EToken_Identifier ('=' expression_pass1 $e)?
		{
			CEnumConst* pMember = $pType->CreateConstMember ($1.m_Data.m_String);
			if (!pMember)
				return false;

			pMember->m_Pos = $1.m_Pos;
			
			if (IsValidLocator ($e)) 
				pMember->SetExpression (&$e.m_TokenList);
		}
	| epsilon
	;

//.............................................................................
	
// struct

class
{
	CStructType* m_pType;
}
struct_specifier
	: EToken_Struct
	  struct_pack_factor $p?
	  (EToken_Identifier $n generic_formal_argument_list $g?)?
	  (':' type_name_list $b)?
		{
			$.m_pType = CreateStructType (
				IsValidLocator ($n) ? $n.m_Data.m_String : rtl::CString (),
				IsValidLocator ($b) ? &$b.m_TypeList : NULL,
				IsValidLocator ($p) ? $p.m_PackFactor : m_StructPackFactor
				);

			if (!$.m_pType)
				return false;
		}
	  named_type_block <$.m_pType>
	;
	 
//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	size_t m_PackFactor;
}
struct_pack_factor
	: EToken_Pack '(' struct_pack_factor_value $v ')'	 
		{
			$.m_PackFactor = $v.m_Value;
		}
	;

class
{
	size_t m_Value;
}
struct_pack_factor_value
	: EToken_Integer
		{
			$.m_Value = $1.m_Data.m_Integer;
		}
	| EToken_Default
		{
			$.m_Value = m_DefaultStructPackFactor;
		}
	;

//.............................................................................

// union

class
{
	CUnionType* m_pType;
}
union_specifier
	: EToken_Union
	  (EToken_Identifier $n generic_formal_argument_list $g?)?
		{
			$.m_pType = CreateUnionType (IsValidLocator ($n) ? $n.m_Data.m_String : rtl::CString ());
			if (!$.m_pType)
				return false;
		}	  
	  named_type_block <$.m_pType>
	;

//.............................................................................

// class 

class
{
	CClassType* m_pType;
}
class_specifier
	: EToken_Class
	  struct_pack_factor $p?
	  (EToken_Identifier $n generic_formal_argument_list $g?)?
	  (':' type_name_list $b)?
		{
			$.m_pType = CreateClassType (
				IsValidLocator ($n) ? $n.m_Data.m_String : rtl::CString (),
				IsValidLocator ($b) ? &$b.m_TypeList : NULL,
				IsValidLocator ($p) ? $p.m_PackFactor : m_StructPackFactor
				);

			if (!$.m_pType)
				return false;
		}
	  named_type_block <$.m_pType>
	;

//.............................................................................

// property

class
{
	CPropertyType* m_pType;
}
property_template_specifier
	local
	{
		CPropertyTemplate* $pTemplate;
	}
	: EToken_Property 
		{
			$pTemplate = CreatePropertyTemplate ();
		}
	  named_type_block <$pTemplate>		
		{
			$.m_pType = $pTemplate->CalcType ();
			return $.m_pType != NULL;
		}
	;

class
{
	CProperty* m_pProperty;
}
property_specifier
	: EToken_Property 
	  struct_pack_factor $p?
	  EToken_Identifier $n
		{
			$.m_pProperty = CreateProperty (
				$n.m_Data.m_String,
				IsValidLocator ($p) ? $p.m_PackFactor : m_StructPackFactor
				);

			if (!$.m_pProperty)
				return false;
		}	  
	  named_type_block <$.m_pProperty>
		{
			m_pLastDeclaredItem = $.m_pProperty;
			return $.m_pProperty->CalcType () != NULL; 
		}
	;

// since EToken_Property EToken_Identifier is a conflict against epsilon production we need a resolver
// otherwise epsilon production (i.e. property modifier) always loses

property_specifier_rslv 
	: EToken_Property struct_pack_factor? EToken_Identifier '{'
	;

//.............................................................................

// autoev

class
{
	CClassType* m_pType;
	CDeclarator m_Declarator;
}
autoev_specifier
	: EToken_AutoEv
	  (EToken_Identifier $n
		{
			$.m_Declarator.AddName ($n.m_Data.m_String);
		}
	  )?
	  function_suffix $a <&$.m_Declarator>?
		{
			$.m_pType = CreateAutoEvType (&$.m_Declarator);
			if (!$.m_pType)
				return false;
		}
	  (
		resolver ({ return m_Stage == EStage_Pass1 }) 
		function_body_pass1 $b
			{
				$.m_pType->SetAutoEvBody (&$b.m_TokenList);
			}
	  |	autoev_body <$.m_pType> 
	  )	  
	;

start
autoev_body <CClassType* $pType>
	: 
		{
			return PreAutoEvBlock ($pType);
		}
	  '{' autoev_stmt* '}'
		{
			return PostAutoEvBlock ();
		}
	;
	
autoev_stmt
	: 
		{
			return PreAutoEvExpression ();
		}
	  expression ';'
		{
			return PostAutoEvExpression ($1.m_Value);
		}
	| ';'
	;

//.............................................................................

// struct, union, class, interface, property

named_type_block <CNamespace* $pNamespace>
	: '{' 
		{
			OpenNamespace ($pNamespace);
		}
	  named_type_block_declaration*
	  '}'
		{
			CloseNamespace ();
		}
	;

//.............................................................................
