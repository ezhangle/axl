// closure function pointer can be 'weak', meaning they do not retain selected objects in closure
// of course it's up to developer to specify which closure members will be retained
// and which ones will not

//.............................................................................

// class with a method to be called through function pointer

class C1
{
	int m_x = -1;

	construct ()
	{
		printf ("C1.construct ()\n");
	}		

	destruct ()
	{
		printf ("C1.destruct ()\n");
	}		

	foo (
		int a,
		int b,
		int c		
		)
	{
		printf ("C1.foo (%d, %d, %d) { m_x = %d }\n", a, b, c, m_x);
	}
}

//.............................................................................

// entry point

int main ()
{
	C1* p;
	weak C1* wp;
	weak function* wpf (int, int);

	{ 
		// like normal classes, closure objects are protected by adding a gc-root
		// so, to make sure no implicit roots are holding our objects, enclose everything in a scope

		p = new C1;
		wp = p;

		// 'weak' in regard to function pointers is all about captured arguments:
		// code pointer cannot be strong or weak in itself.
		// so, to make function pointer weak, we must specify which of the captured arguments
		// will be weakly referenced. to make 'this' argument weak, either use 
		// weak-member operator '.weak' or apply member operator to weak class pointer		

		wpf = p.weak foo ~(,, 3); // 'p.weak foo' is equivalent to 'wp.foo'		
	} 

	// ok, only pointers keep object alive from now on

	// p = null; // <-- uncomment to lose strong pointer, then object will get destructed next gc run

	printf ("gc run...\n");
	jnc.runGc ();

	function* pf (int, int) = wpf;
	if (pf)
	{
		printf ("object survived gc run\n");
		pf (1, 2);
	}
	else
		printf ("object was collected during gc run\n");

	return 0;
}

//.............................................................................
