// exceptions in Jancy is merely a syntactic sugar over old C-style error code model
// as a result, it is compatible with anything, including legacy C exported to jancy namespace
// catch and finally can be declared at any scope
// when calling the same function, developer can use either error code check, 
// or exception semantics – depending on what’s more appropriate or convenient in particular case

//.............................................................................

// function marked by 'pitcher' modifier will have its return value interpreted as an error code
// intuitive defaults are assumed ('false' for bools, '-1' for integers, 'null' for pointers)

bool pitcher foo (int a)
{
	printf ("foo (%d)\n", a);
	return a < 0;
}

// if something more complex or non-standard is required, custom pitch conditions are supported

int pitcher (retval < 0) baz (int a)
{
	printf ("baz (%d)\n", a);
	return a;
}

// if pitcher conditions match, error code can be automatically propagated

int pitcher (retval < 0) bar ()
{
	printf ("bar ()\n");

	foo (1);
	baz (10);

	int result = try baz (-5); // 'try' operator shields expression from 'throwing'
	printf ("baz returned %d\n", result);

	baz (-10); // error code will transfer control to 'catch' label
	baz (30);

	return 0;

catch:
	printf ("bar.catch\n");	
	return -5;

finally:
	printf ("bar.finally\n");	
}

//.............................................................................

// entry point

int main ()
{
	printf ("hello world!\n");

	int result = try bar (); // try is a must here
	printf ("bar returned %d\n", result);		

	// result = bar (); // <-- error: cannot call a 'pitcher' from non-pitcher without 'try' or 'catch'

	return 0;
}

//.............................................................................
