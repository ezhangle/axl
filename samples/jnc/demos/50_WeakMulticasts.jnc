// weak multicasts and events is one the main application of the whole concept of weak pointers.
// probably the most well known scenario in which weak pointers are extremely useful is
// event-subscriber interaction model: usually developer does not want the pointer held by 
// event to retain subscriber from being collected (which leads to subtle and hard to track leaks/bugs)
// jancy fully addresses this issue by internally supporting 'weak' multicasts

//.............................................................................

// class with a method to be called through function pointer stored in multicast

class C1
{
	int m_x = -1;

	construct ()
	{
		printf ("C1.construct ()\n");
	}		

	destruct ()
	{
		printf ("C1.destruct ()\n");
	}		

	Foo ()
	{
		printf ("C1.Foo () { m_x = %d }\n", m_x);
	}
}

//.............................................................................

// entry point

int
main ()
{
	weak multicast Multicast ();

	C1* p;
	weak C1* wp;

	{ 
		// scope is to limit life of 'new operator'-induced gc-root
		p = new C1; 
		wp = p;

		Multicast += p.weak Foo;
	} 

	// ok, only pointers keep object alive from now on

	// p = null; // <-- uncomment to loose strong pointer, then object will get destructed next gc run

	printf ("GC run...\n");
	jnc.RunGcWaitForDestructors ();

	p = wp;
	if (p)
		printf ("Object survived GC run\n");
	else
		printf ("Object was collected during GC run\n");

	// if object was collected during gc-run, entry in multicast will be automatically removed
	// during getting a snapshot (which is implicitly done inside Multicast.Call ())

	Multicast (); 	

	return 0;
}

//.............................................................................

// system functions

int
printf (
	unsafe const thin char* pFormat,
	unsafe ...
	);

//.............................................................................
