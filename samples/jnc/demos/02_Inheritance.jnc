// in jancy, simple multiple inheritance model is adopted
// simple means no C++ virtual inheritance; multiple instances of shared bases (if any)

//.............................................................................

class I1
{
	abstract 
	Foo ();
}

class C1: I1
{
	construct (int a)
	{
		printf ("C1.construct (%d)\n", a);
	}

	override
	Foo ()
	{
		printf ("C1.Foo ()\n");		
	}
}

//.............................................................................

class I2
{
	abstract 
	Bar ();

	abstract 
	Baz (
		int x,
		int y
		); 
}

class C2: I2
{
	construct (int a)
	{
		printf ("C2.construct (%d)\n", a);
	}

	override
	Bar ()
	{
		printf ("C2.Bar ()\n");		
	}

	override
	Baz (
		int x,
		int y
		)
	{
		printf ("C2.Baz (%d, %d)\n", x, y);		
	}
}

//.............................................................................

struct TPoint
{
	int m_x;
	int m_y;
}

// mulitple inheritance allows easy implementation sharing

class C3:
	C1,
	C2,
	TPoint // also ok to inherit from structs or unions
{
	construct (int a)
	{
		// if base classes require construction, it must be done in the beginning of constructor		

		C1.construct (a * 10); 
		C2.construct (a * 100);

		printf ("C3.construct (%d)\n", a);
	}

	override
	Baz (	
		int x,
		int y
		);
}

override // it's ok to use storage specifier (must match the original one, of course)
C3.Baz (
	int x,
	int y
	)
{
	printf ("C3.Baz (%d, %d)\n", x, y);
	m_x = x;
	m_y = y;
}	

//.............................................................................

// entry point

int 
main ()
{
	printf ("main ()\n");

	C3 c construct (7);

	c.Foo ();
	c.Bar ();
	c.Baz (20, 30);

	printf ("c = { %d, %d }\n", c.m_x, c.m_y);

	return 0;
}

//.............................................................................

// system functions

int
printf (
	unsafe const thin char* pFormat,
	unsafe ...
	);

//.............................................................................
