// property pointers, just like function pointers, could be 'weak' meaning they do not
// retain objects in the closure from being collected by gc run

//.............................................................................

// class with a property to be called through p pointer

class C1
{
	construct ()
	{
		printf ("C1.construct ()\n");
	}		

	destruct ()
	{
		printf ("C1.destruct ()\n");
	}		

	int autoget property m_Foo;
}

C1.m_Foo.set (int x)
{
	printf ("C1.s_Foo.set (%d)\n", x);
	propvalue = x;
}

//.............................................................................

// entry point

int
main ()
{
	C1* p;
	weak int property* wpProp;

	{  
		// scope is to limit the life of 'new operator'-induced gc-root

		p = new C1;

		// like with function pointers, 'weak' in regard to property pointers applies to captured arguments:
		// so, we must specify which of the captured arguments will be weakly referenced	

		wpProp = &p.weak m_Foo;
	} 

	// ok, only pointers keep object alive from now on

	// p = null; // <-- uncomment to loose strong pointer, then object will get destructed next gc run

	printf ("gc run...\n");
	jnc.RunGcWaitForDestructors ();

	int property * pProp = wpProp;
	if (pProp)
	{
		printf ("object survived GC run\n");
		*pProp = 100;
	}
	else
		printf ("object was collected during GC run\n");

	return 0;
}

//.............................................................................

// system functions

int
printf (
	unsafe const thin char* pFormat,
	unsafe ...
	);

//.............................................................................
