// jancy also brings a couple of enhancements for enumeration types.
// enums in jancy conseal member identifiers within enum namespace to prevent namespace pollution.
// to simplify porting of existing C/C++ code jancy offers 'cenum' variation,
// which behaves like a traditional C/C++ enum (exposing member identifiers).
// yet another flavour of enums which i always wanted to have is flag enum, i.e. enum
// dedicated to describe set of flags. 'fenum' differs from normal 'enum' in 2 key aspects:
// - automatic value assignment goes 1, 2, 4, 8 etc (increments previous bit position)
// - bitwise or operator '|' on 2 operands of matching 'fenum' type yields the same 'fenum' type
// - it's ok to assign '0' to 'fenum'
// note that like normal 'enum', 'fenum' does not pollute parent namespace.

//.............................................................................

enum Color
{
	Red,      // = 0 
	Orange,
	Yellow,
	Green = 15, 
	Blue,
	Purple,
}

fenum OpenFlags
{
	ReadOnly,      // = 0x01
	Exclusive = 0x20,
	DeleteOnClose, // = 0x40
}

cenum State
{
	State_Idle, // = 0
	State_Connecting,
	State_Connected,
	State_Disconnecting,
}

//.............................................................................

// entry point

int main ()
{
	printf ("main ()\n");

	Color color = Color.Blue;
	// color = 0; // <-- error cast int->enum must be explicit
	printf ("color = %d\n", color);

	State state = State_Connecting; // State.State_Connecting works also
	// state = 100; // <-- error cast int->enum must be explicit
	printf ("state = %d\n", state);

	OpenFlags flags = 0; // 0 is ok to assign to 'fenum'
	 
	flags = OpenFlags.ReadOnly | OpenFlags.Exclusive | OpenFlags.DeleteOnClose;
	// flags = 200; // <-- error cast int->enum must be explicit
	printf ("flags = %x\n", flags);

	return 0;
}

//.............................................................................
