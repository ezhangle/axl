// another unique feature of jancy is property pointers. properties are present in many modern languages. 
// dealing with property pointers though, requires developed syntax and semantics of pointer 
// declarations and operators, which is usually lacking.
// property pointers resemble and are closely related to function pointers.
// unlike function pointers however, dealing with property pointers requires careful application
// of address '&' an indirection '*' operators. this is due to implicit invokation of
// property accessors and ambiguity induced by this invokation, which cannot be automatically
// resolved like in case of function pointers

//.............................................................................

int autoget property s_Foo;

s_Foo.set (int x)
{
	printf ("s_Foo.set (%d)\n", x);
	propvalue = x;
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class C1
{
	int autoget property m_Bar;

	m_Bar.set (int x)
	{
		printf ("C1.m_Bar.set (%d)\n", x);
		propvalue = x;
	}
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

int s_BazTable [2] [2];

int indexed property s_Baz (
	unsigned int i,
	unsigned int j
	);

int 
s_Baz.get (
	unsigned int i,
	unsigned int j
	)
{
	printf ("s_Baz.get (%d, %d)\n", i, j);
	return s_BazTable [i] [j];
}

s_Baz.set (
	unsigned int i,
	unsigned int j,
	int x
	)
{
	printf ("s_Baz.set (%d, %d, %d)\n", i, j, x);
 	s_BazTable [i] [j] = x;
}

//.............................................................................

// entry point

int
main ()
{
	// 'thin' property pointer is simply a pointer to property accessor table

	int thin property* p1 = &s_Foo;
	*p1 = 10;

	// like with function pointers, argument conversion is automated (compiler generates thunks if needed)

	typedef double property XFpProp;
	XFpProp thin* p2 = (XFpProp thin*) &s_Foo;
	*p2 = 15.8;

	// like with function pointers, property pointers can can capture values of arguments in a closure

	C1 c;

	int property* p3 = &c.m_Bar; // in this case, pointer to 'c' was captured
	*p3 = 200;
	
	// it is also possible to capture index arguments in the closure, thus reducing dimensions
	// of indexed property or completely de-indexing property 

	int property* p4 = &(s_Baz [0] [1]);
	*p4 = 300;

	// like with function pointers, it's ok to skip indexes when capturing

	int indexed property* p5 (unsigned int) = &(s_Baz [] [0]);
	(*p5) [1] = 400;

	return 0;
}

//.............................................................................

// system functions

int
printf (
	unsafe const thin char* pFormat,
	unsafe ...
	);

//.............................................................................
