// another unique feature of jancy is property pointers. properties are present in many modern languages. 
// dealing with property pointers though, requires developed syntax and semantics of pointer 
// declarations and operators, which is usually lacking.
// property pointers resemble and are closely related to function pointers.
// unlike function pointers however, dealing with property pointers requires careful application
// of address '&' an indirection '*' operators. this is due to implicit invokation of
// property accessors and ambiguity induced by this invokation, which cannot be automatically
// resolved like in case of function pointers

//.............................................................................

int autoget property g_foo;

g_foo.set (int x)
{
	printf ("g_foo.set (%d)\n", x);
	m_value = x;
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class C1
{
	int autoget property m_bar;

	m_bar.set (int x)
	{
		printf ("C1.m_bar.set (%d)\n", x);
		m_value = x;
	}
}

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

int g_bazTable [2] [2];

int indexed property g_baz (
	unsigned int i,
	unsigned int j
	);

int g_baz.get (
	unsigned int i,
	unsigned int j
	)
{
	printf ("g_baz.get (%d, %d)\n", i, j);
	return g_bazTable [i] [j];
}

g_baz.set (
	unsigned int i,
	unsigned int j,
	int x
	)
{
	printf ("g_baz.set (%d, %d, %d)\n", i, j, x);
	g_bazTable [i] [j] = x;
}

//.............................................................................

// entry point

int main ()
{
	// 'thin' property pointer is simply a pointer to property accessor table

	int thin property* p1 = &g_foo;
	*p1 = 10;

	// like with function pointers, argument conversion is automated (compiler generates thunks if needed)

	typedef double property FpProp;
	FpProp thin* p2 = (FpProp thin*) &g_foo;
	*p2 = 15.8;

	// like with function pointers, property pointers can can capture values of arguments in a closure

	C1 c;

	int property* p3 = &c.m_bar; // in this case, pointer to 'c' was captured
	*p3 = 200;
	
	// it is also possible to capture index arguments in the closure, thus reducing dimensions
	// of indexed property or completely de-indexing property 

	int property* p4 = &(g_baz [0] [1]);
	*p4 = 300;

	// like with function pointers, it's ok to skip indexes when capturing

	int indexed property* p5 (unsigned int) = &(g_baz [] [0]);
	(*p5) [1] = 400;

	return 0;
}

//.............................................................................
