// jancy brings back const-correctness: a great tool unjustly left behind in 
// most of the modern managed languages

//.............................................................................

struct Point
{
	int m_x;
	int m_y;
}

transpose (
	Point* dst,
	const Point* src
	)
{
	printf ("transpose (%d, %d)\n", src.m_x, src.m_y);

	int x = src.m_x; // to ensure it works even when dst and src point to the same location
	dst.m_x = src.m_y;
	dst.m_y = x;

	// src.m_x = 0; // <-- error: cannot store into const location
}

//.............................................................................

class C1
{
	int m_field;
	mutable int m_mutableField;

	foo () const // jancy uses C++ syntax for declaring const methods
	{
		printf ("C1.foo () { m_field = %d }\n", m_field);
	}

	bar (int x)
	{
		printf ("C1.bar (%d)\n", x);
		m_field = x;
	}	
}

baz (const C1* p)
{
	printf ("p.m_x = %d\n", p.m_field);

	p.foo (); // ok, const method
	p.m_mutableField = 100; // ok, mutable field

	// p.m_field = 200; // <-- error: cannot store to const location
	// p.bar (200); // <-- error: cannot convert 'const C1*' to 'C1*'
}

//.............................................................................

// entry point

int main ()
{
	printf ("main ()\n");

	Point srcPoint = { 10, 20 };

	Point dstPoint;
	transpose (&dstPoint, &srcPoint); // we can be sure 'srcPoint' is not going to change

	C1 c;
	c.bar (10); // no problem, we access C1 by non-const pointer
	baz (&c); // we can be sure 'c' is not going to change

	return 0;
}

//.............................................................................
