// jancy gives developer full control over which storage to use during particular operation
// it includes allocation of member fields, global & local variables, allocations induced by casts,
// and of course allocations performed by 'new' operator

//.............................................................................

class C1
{
	int m_memberField;
	static int m_staticField = 2;
	thread int m_threadField;
	// thread int m_threadField2 = 3; // <-- error: thread fields cannot be initialized

	construct (int x)
	{
		printf ("C1.construct (%d)\n", x);
		m_memberField = x;
	}

	destruct ()
	{
		printf ("C1.destruct (%d)\n", m_memberField);
	}
}

class C2
{
	C1 m_classField; // unlike most of managed languages, jancy allows allocating multiple objects at once

	construct (int x)
	{
		m_classField.construct (x); // field requires construction

		printf ("C2.construct (%d)\n", x);
	}

	destruct ()
	{
		printf ("C2.destruct (%d)\n", m_classField.m_memberField);
	}
}

int g_staticGlobal; // for global variables, default storage is 'static'
thread int g_threadGlobal;
// thread int g_threadGlobal2 = 10; // <-- error: global thread variables cannot be initialized
// thread C1 g_threadGlobal3; // <-- error: thread variables cannot be aggregate

//.............................................................................

// entry point

int main ()
{
	printf ("main ()\n");

	int x; // for local variables, default storage is 'stack'
	static int s = 100; // 'static' can be surely used for local variables
	thread int t = 200; // for local 'thread' variables, initialization is permitted
	heap char a [256]; // 'heap' storage can be used to allocate local variables on gc-heap
	// uheap char b [256];  // <-- error: 'uheap' storage cannot be used for variables

	heap C2 c1 construct (1000); // for local 'class' variables, default storage is 'heap'
	static C2 c2 construct (2000); // 'static' and 'stack' can also be used for 'class' variables
	// thread C2 c construct (3000); // <-- error: thread variables cannot be aggregate

	C2* p1 = new C2 (4000); // for 'new' operator, default storage is 'heap'

	C2* p3 = static new C2 (6000); // 'static' also can be used

	{
	C2* p4 = stack new C2 (7000); // objects allocated on 'stack' storage will be destructed upon exiting the scope
	} // 'destruct' will be called

	// thread new C2 (8000); // <-- error: thread variables cannot be aggregate

	return 0;
}

//.............................................................................
