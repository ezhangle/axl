// property pointers, just like function pointers, could be 'weak' meaning they do not
// retain objects in the closure from being collected by gc run

//.............................................................................

// class with a property to be called through p pointer

class C1
{
	construct ()
	{
		printf ("C1.construct ()\n");
	}		

	destruct ()
	{
		printf ("C1.destruct ()\n");
	}		

	int autoget property m_foo;
}

C1.m_foo.set (int x)
{
	printf ("C1.m_foo.set (%d)\n", x);
	m_value = x;
}

//.............................................................................

// entry point

int main ()
{
	C1* p;
	weak int property* wpp;

	{  
		// scope is to limit the life of 'new operator'-induced gc-root

		p = new C1;

		// like with function pointers, 'weak' in regard to property pointers applies to captured arguments:
		// so, we must specify which of the captured arguments will be weakly referenced	

		wpp = &p.weak m_foo;
	} 

	// ok, only pointers keep object alive from now on

	// p = null; // <-- uncomment to lose strong pointer, then object will get destructed next gc run

	printf ("gc run...\n");
	jnc.runGc ();

	int property* pp = wpp;
	if (pp)
	{
		printf ("object survived gc run\n");
		*pp = 100;
	}
	else
		printf ("object was collected during gc run\n");

	return 0;
}

//.............................................................................
