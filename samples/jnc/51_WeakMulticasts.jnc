// weak multicasts and events is one the main application of the whole concept of weak pointers.
// probably the most well known scenario in which weak pointers are extremely useful is
// event-subscriber interaction model: usually developer does not want the pointer held by 
// event to retain subscriber from being collected (which leads to subtle and hard to track leaks/bugs)
// jancy fully addresses this issue by out-of-the-box support of 'weak' multicasts

//.............................................................................

// class with a method to be called through function pointer stored in multicast

class C1
{
	int m_x = -1;

	construct ()
	{
		printf ("C1.construct ()\n");
	}		

	destruct ()
	{
		printf ("C1.destruct ()\n");
	}		

	foo ()
	{
		printf ("C1.foo () { m_x = %d }\n", m_x);
	}
}

//.............................................................................

// entry point

int main ()
{
	weak multicast wmc ();

	C1* p;
	weak C1* wp;

	{ 
		// scope is to limit life of 'new operator'-induced gc-root
		p = new C1; 
		wp = p;

		wmc += p.weak foo;
	} 

	// ok, only pointers keep object alive from now on

	// p = null; // <-- uncomment to loose strong pointer, then object will get destructed next gc run

	printf ("gc run...\n");
	jnc.runGc ();

	p = wp;
	if (p)
		printf ("object survived gc run\n");
	else
		printf ("object was collected during gc run\n");

	// if object was collected during gc-run, entry in multicast will be automatically removed
	// during getting a snapshot (which is implicitly done inside wmc.Call ())

	wmc (); 	

	return 0;
}

//.............................................................................
