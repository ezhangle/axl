----------------------
27/02/2019 18:01:38 - C:\Projects\repos\ioninja\axl\include\axl_cf\axl_cf_Dictionary.h
----------------------
[-] class DictionaryRefBase: public TypeRefBase <T>
[+] class DictionaryRefBase: public TypeRefBase<T>
[-] 	DictionaryRefBase ()
[+] 	DictionaryRefBase()
[-] 	DictionaryRefBase (const DictionaryRefBase& src)
[+] 	DictionaryRefBase(const DictionaryRefBase& src)
[-] 		this->copy (src);
[+] 		this->copy(src);
[-] 	DictionaryRefBase (
[+] 	DictionaryRefBase(
[-] 		isAttach ? this->copy (p) : this->attach (p);
[+] 		isAttach ? this->copy(p) : this->attach(p);
[-] 		this->copy (src);
[+] 		this->copy(src);
[-] 		this->copy (p);
[+] 		this->copy(p);
[-] 	create (CFDictionaryRef src)
[+] 	create(CFDictionaryRef src)
[-] 		CFDictionaryRef newDictionary = ::CFDictionaryCreateCopy (kCFAllocatorDefault, src);
[+] 		CFDictionaryRef newDictionary = ::CFDictionaryCreateCopy(kCFAllocatorDefault, src);
[-] 			return err::fail (err::SystemErrorCode_InsufficientResources);
[+] 			return err::fail(err::SystemErrorCode_InsufficientResources);
[-] 		this->attach (newDictionary);
[+] 		this->attach(newDictionary);
[-] 	getCount () const
[+] 	getCount() const
[-] 		return ::CFDictionaryGetCount (this->m_p);
[+] 		return ::CFDictionaryGetCount(this->m_p);
[-] 	getCountOfKey (const void* key) const
[+] 	getCountOfKey(const void* key) const
[-] 		return ::CFDictionaryGetCountOfKey (this->m_p, key);
[+] 		return ::CFDictionaryGetCountOfKey(this->m_p, key);
[-] 	getCountOfValue (const void* value) const
[+] 	getCountOfValue(const void* value) const
[-] 		return ::CFDictionaryGetCountOfKey (this->m_p, value);
[+] 		return ::CFDictionaryGetCountOfKey(this->m_p, value);
[-] 	getValue (const void* key) const
[+] 	getValue(const void* key) const
[-] 		return ::CFDictionaryGetValue (this->m_p, key);
[+] 		return ::CFDictionaryGetValue(this->m_p, key);
[-] 	getValueIfPresent (
[+] 	getValueIfPresent(
[-] 		return ::CFDictionaryGetValueIfPresent (this->m_p, key, value);
[+] 		return ::CFDictionaryGetValueIfPresent(this->m_p, key, value);
[-] 	getKeysAndValues (
[+] 	getKeysAndValues(
[-] 		return ::CFDictionaryGetKeysAndValues (this->m_p, keyArray, valueArray);
[+] 		return ::CFDictionaryGetKeysAndValues(this->m_p, keyArray, valueArray);
[-] 	getKeysAndValues (
[+] 	getKeysAndValues(
[-] 		sl::Array <const void*>* keyArray,
[+] 		sl::Array<const void*>* keyArray,
[-] 		sl::Array <const void*>* valueArray
[+] 		sl::Array<const void*>* valueArray
[-] 		size_t count = getCount ();
[+] 		size_t count = getCount();
[-] 			result = keyArray->setCount (count);
[+] 			result = keyArray->setCount(count);
[-] 			result = valueArray->setCount (count);
[+] 			result = valueArray->setCount(count);
[-] 		::CFDictionaryGetKeysAndValues (this->m_p, keyBuffer, valueBuffer);
[+] 		::CFDictionaryGetKeysAndValues(this->m_p, keyBuffer, valueBuffer);
[-] typedef DictionaryRefBase <CFDictionaryRef> DictionaryRef;
[+] typedef DictionaryRefBase<CFDictionaryRef> DictionaryRef;
[-] class MutableDictionaryRef: public DictionaryRefBase <CFMutableDictionaryRef>
[+] class MutableDictionaryRef: public DictionaryRefBase<CFMutableDictionaryRef>
[-] 	MutableDictionaryRef ()
[+] 	MutableDictionaryRef()
[-] 	MutableDictionaryRef (const MutableDictionaryRef& src)
[+] 	MutableDictionaryRef(const MutableDictionaryRef& src)
[-] 		copy (src);
[+] 		copy(src);
[-] 	MutableDictionaryRef (
[+] 	MutableDictionaryRef(
[-] 		isAttach ? copy (p) : attach (p);
[+] 		isAttach ? copy(p) : attach(p);
[-] 		copy (src);
[+] 		copy(src);
[-] 		copy (p);
[+] 		copy(p);
[-] 	create (CFDictionaryRef src);
[+] 	create(CFDictionaryRef src);
[-] 	addValue (
[+] 	addValue(
[-] 		::CFDictionaryAddValue (m_p, key, value);
[+] 		::CFDictionaryAddValue(m_p, key, value);
[-] 	removeValue (const void* key)
[+] 	removeValue(const void* key)
[-] 		::CFDictionaryRemoveValue (m_p, key);
[+] 		::CFDictionaryRemoveValue(m_p, key);
[-] 	removeAllValues ()
[+] 	removeAllValues()
[-] 		::CFDictionaryRemoveAllValues (m_p);
[+] 		::CFDictionaryRemoveAllValues(m_p);
[-] 	setValue (
[+] 	setValue(
[-] 		::CFDictionarySetValue (m_p, key, value);
[+] 		::CFDictionarySetValue(m_p, key, value);
[-] 	replaceValue (
[+] 	replaceValue(
[-] 		::CFDictionaryReplaceValue (m_p, key, value);
[+] 		::CFDictionaryReplaceValue(m_p, key, value);
----------------------
27/02/2019 18:01:38 - C:\Projects\repos\ioninja\axl\include\axl_cf\axl_cf_Number.h
----------------------
[-] class NumberRef: public TypeRefBase <CFNumberRef>
[+] class NumberRef: public TypeRefBase<CFNumberRef>
[-] 	NumberRef ()
[+] 	NumberRef()
[-] 	NumberRef (const NumberRef& src)
[+] 	NumberRef(const NumberRef& src)
[-] 		copy (src);
[+] 		copy(src);
[-] 	NumberRef (
[+] 	NumberRef(
[-] 		isAttach ? copy (p) : attach (p);
[+] 		isAttach ? copy(p) : attach(p);
[-] 	NumberRef (char x)
[+] 	NumberRef(char x)
[-] 		create (kCFNumberCharType, &x);
[+] 		create(kCFNumberCharType, &x);
[-] 	NumberRef (short x)
[+] 	NumberRef(short x)
[-] 		create (kCFNumberShortType, &x);
[+] 		create(kCFNumberShortType, &x);
[-] 	NumberRef (int x)
[+] 	NumberRef(int x)
[-] 		create (kCFNumberIntType, &x);
[+] 		create(kCFNumberIntType, &x);
[-] 	NumberRef (long x)
[+] 	NumberRef(long x)
[-] 		create (kCFNumberLongType, &x);
[+] 		create(kCFNumberLongType, &x);
[-] 	NumberRef (long long x)
[+] 	NumberRef(long long x)
[-] 		create (kCFNumberLongLongType, &x);
[+] 		create(kCFNumberLongLongType, &x);
[-] 	NumberRef (float x)
[+] 	NumberRef(float x)
[-] 		create (kCFNumberFloatType, &x);
[+] 		create(kCFNumberFloatType, &x);
[-] 	NumberRef (double x)
[+] 	NumberRef(double x)
[-] 		create (kCFNumberDoubleType, &x);
[+] 		create(kCFNumberDoubleType, &x);
[-] 		copy (src);
[+] 		copy(src);
[-] 		copy (p);
[+] 		copy(p);
[-] 		create (kCFNumberCharType, &x);
[+] 		create(kCFNumberCharType, &x);
[-] 		create (kCFNumberShortType, &x);
[+] 		create(kCFNumberShortType, &x);
[-] 		create (kCFNumberIntType, &x);
[+] 		create(kCFNumberIntType, &x);
[-] 		create (kCFNumberLongType, &x);
[+] 		create(kCFNumberLongType, &x);
[-] 		create (kCFNumberLongLongType, &x);
[+] 		create(kCFNumberLongLongType, &x);
[-] 		create (kCFNumberFloatType, &x);
[+] 		create(kCFNumberFloatType, &x);
[-] 		create (kCFNumberDoubleType, &x);
[+] 		create(kCFNumberDoubleType, &x);
[-] 	create (
[+] 	create(
[-] 	create (char x)
[+] 	create(char x)
[-] 		return create (kCFNumberCharType, &x);
[+] 		return create(kCFNumberCharType, &x);
[-] 	create (short x)
[+] 	create(short x)
[-] 		return create (kCFNumberShortType, &x);
[+] 		return create(kCFNumberShortType, &x);
[-] 	create (int x)
[+] 	create(int x)
[-] 		return create (kCFNumberIntType, &x);
[+] 		return create(kCFNumberIntType, &x);
[-] 	create (long x)
[+] 	create(long x)
[-] 		return create (kCFNumberLongType, &x);
[+] 		return create(kCFNumberLongType, &x);
[-] 	create (long long x)
[+] 	create(long long x)
[-] 		return create (kCFNumberLongLongType, &x);
[+] 		return create(kCFNumberLongLongType, &x);
[-] 	create (float x)
[+] 	create(float x)
[-] 		return create (kCFNumberFloatType, &x);
[+] 		return create(kCFNumberFloatType, &x);
[-] 	create (double x)
[+] 	create(double x)
[-] 		return create (kCFNumberDoubleType, &x);
[+] 		return create(kCFNumberDoubleType, &x);
[-] 	isFloat () const
[+] 	isFloat() const
[-] 		return ::CFNumberIsFloatType (m_p);
[+] 		return ::CFNumberIsFloatType(m_p);
[-] 	compare (CFNumberRef p2) const
[+] 	compare(CFNumberRef p2) const
[-] 		return ::CFNumberCompare (m_p, p2, NULL);
[+] 		return ::CFNumberCompare(m_p, p2, NULL);
----------------------
27/02/2019 18:01:38 - C:\Projects\repos\ioninja\axl\include\axl_cf\axl_cf_String.h
----------------------
[-] class StringRef: public TypeRefBase <CFStringRef>
[+] class StringRef: public TypeRefBase<CFStringRef>
[-] 	StringRef ()
[+] 	StringRef()
[-] 	StringRef (const StringRef& src)
[+] 	StringRef(const StringRef& src)
[-] 		copy (src);
[+] 		copy(src);
[-] 	StringRef (
[+] 	StringRef(
[-] 		isAttach ? copy (p) : attach (p);
[+] 		isAttach ? copy(p) : attach(p);
[-] 	StringRef (
[+] 	StringRef(
[-] 		create (p, length);
[+] 		create(p, length);
[-] 		copy (src);
[+] 		copy(src);
[-] 		copy (p);
[+] 		copy(p);
[-] 		create (p);
[+] 		create(p);
[-] 	create (CFStringRef src);
[+] 	create(CFStringRef src);
[-] 	create (
[+] 	create(
[-] 	getLength () const
[+] 	getLength() const
[-] 		return ::CFStringGetLength (m_p);
[+] 		return ::CFStringGetLength(m_p);
[-] 	compare (
[+] 	compare(
[-] 		return ::CFStringCompare (m_p, p2, flags);
[+] 		return ::CFStringCompare(m_p, p2, flags);
[-] 	getString () const
[+] 	getString() const
[-] 		return getStringFromCfString (m_p);
[+] 		return getStringFromCfString(m_p);
----------------------
27/02/2019 18:01:38 - C:\Projects\repos\ioninja\axl\include\axl_cf\axl_cf_Type.h
----------------------
[-] getStringFromCfString (CFStringRef cfString);
[+] getStringFromCfString(CFStringRef cfString);
[-] cfTypeToString (
[+] cfTypeToString(
[-] getTypeIdDescription (CFTypeID typeId);
[+] getTypeIdDescription(CFTypeID typeId);
[-] getStringTypeId ()
[+] getStringTypeId()
[-] 	return ::CFStringGetTypeID ();
[+] 	return ::CFStringGetTypeID();
[-] getBooleanTypeId ()
[+] getBooleanTypeId()
[-] 	return ::CFBooleanGetTypeID ();
[+] 	return ::CFBooleanGetTypeID();
[-] getNumberTypeId ()
[+] getNumberTypeId()
[-] 	return ::CFNumberGetTypeID ();
[+] 	return ::CFNumberGetTypeID();
[-] 	TypeRefBase ()
[+] 	TypeRefBase()
[-] 	TypeRefBase (const TypeRefBase& src)
[+] 	TypeRefBase(const TypeRefBase& src)
[-] 			::CFRetain (src.m_p);
[+] 			::CFRetain(src.m_p);
[-] 	TypeRefBase (
[+] 	TypeRefBase(
[-] 			::CFRetain (p);
[+] 			::CFRetain(p);
[-] 	~TypeRefBase ()
[+] 	~TypeRefBase()
[-] 		clear ();
[+] 		clear();
[-] 	operator T () const
[+] 	operator T() const
[-] 		copy (src.m_p);
[+] 		copy(src.m_p);
[-] 		copy (p);
[+] 		copy(p);
[-] 	p () const
[+] 	p() const
[-] 	attach (T p)
[+] 	attach(T p)
[-] 		clear ();
[+] 		clear();
[-] 	detach ()
[+] 	detach()
[-] 	clear ()
[+] 	clear()
[-] 			::CFRelease (m_p);
[+] 			::CFRelease(m_p);
[-] 	copy (T p)
[+] 	copy(T p)
[-] 			::CFRetain (p);
[+] 			::CFRetain(p);
[-] 			::CFRelease (m_p);
[+] 			::CFRelease(m_p);
[-] 	getRetainCount () const
[+] 	getRetainCount() const
[-] 		return ::CFGetRetainCount (m_p);
[+] 		return ::CFGetRetainCount(m_p);
[-] 	retain ()
[+] 	retain()
[-] 		::CFRetain (m_p);
[+] 		::CFRetain(m_p);
[-] 	release ()
[+] 	release()
[-] 		::CFRelease (m_p);
[+] 		::CFRelease(m_p);
[-] 	isEqual (T type) const
[+] 	isEqual(T type) const
[-] 		return ::CFEqual (m_p, type);
[+] 		return ::CFEqual(m_p, type);
[-] 	getHash () const
[+] 	getHash() const
[-] 		return ::CFHash (m_p);
[+] 		return ::CFHash(m_p);
[-] 	getTypeId () const
[+] 	getTypeId() const
[-] 		return ::CFGetTypeID (m_p);
[+] 		return ::CFGetTypeID(m_p);
[-] 	getDescription () const
[+] 	getDescription() const
[-] 		CFStringRef cfString = ::CFCopyDescription (m_p);
[+] 		CFStringRef cfString = ::CFCopyDescription(m_p);
[-] 		sl::String string = getStringFromCfString (cfString);
[+] 		sl::String string = getStringFromCfString(cfString);
[-] 		::CFRelease (cfString);
[+] 		::CFRelease(cfString);
[-] 	getTypeIdDescription () const
[+] 	getTypeIdDescription() const
[-] 		return getTypeIdDescription (getTypeId ());
[+] 		return getTypeIdDescription(getTypeId());
[-] 	show () const
[+] 	show() const
[-] 		::CFShow (m_p);
[+] 		::CFShow(m_p);
[-] 	toString ()
[+] 	toString()
[-] 		return cfTypeToString (m_p);
[+] 		return cfTypeToString(m_p);
[-] typedef TypeRefBase <CFTypeRef> TypeRef;
[+] typedef TypeRefBase<CFTypeRef> TypeRef;
----------------------
27/02/2019 18:01:38 - C:\Projects\repos\ioninja\axl\include\axl_cry\axl_cry_Aes.h
----------------------
[-] 	AesKey ()
[+] 	AesKey()
[-] 		memset (this, 0, sizeof (AesKey));
[+] 		memset(this, 0, sizeof(AesKey));
[-] 	setEncryptKey (
[+] 	setEncryptKey(
[-] 		int result = AES_set_encrypt_key ((const uchar_t*) p, (int) bitCount, this);
[+] 		int result = AES_set_encrypt_key((const uchar_t*) p, (int)bitCount, this);
[-] 		return err::completeWithSystemError (result == 0, err::SystemErrorCode_InvalidParameter);
[+] 		return err::completeWithSystemError(result == 0, err::SystemErrorCode_InvalidParameter);
[-] 	setDecryptKey (
[+] 	setDecryptKey(
[-] 		int result = AES_set_decrypt_key ((const uchar_t*) p, (int) bitCount, this);
[+] 		int result = AES_set_decrypt_key((const uchar_t*) p, (int)bitCount, this);
[-] 		return err::completeWithSystemError (result == 0, err::SystemErrorCode_InvalidParameter);
[+] 		return err::completeWithSystemError(result == 0, err::SystemErrorCode_InvalidParameter);
[-] 	void cbcEncrypt (
[+] 	void cbcEncrypt(
[-] 		AES_cbc_encrypt (
[+] 		AES_cbc_encrypt(
[-] 			(uchar_t*) dst,
[+] 			(uchar_t*)dst,
[-] 			(uchar_t*) iv,
[+] 			(uchar_t*)iv,
[-] 	void cbcDecrypt (
[+] 	void cbcDecrypt(
[-] 		AES_cbc_encrypt (
[+] 		AES_cbc_encrypt(
[-] 			(uchar_t*) dst,
[+] 			(uchar_t*)dst,
[-] 			(uchar_t*) iv,
[+] 			(uchar_t*)iv,
----------------------
27/02/2019 18:01:38 - C:\Projects\repos\ioninja\axl\include\axl_cry\axl_cry_BigNum.h
----------------------
[-] 		BN_CTX_free (h);
[+] 		BN_CTX_free(h);
[-] class BnCtx: public sl::Handle <BN_CTX*, FreeBnCtx>
[+] class BnCtx: public sl::Handle<BN_CTX*, FreeBnCtx>
[-] 	BnCtx ()
[+] 	BnCtx()
[-] 	BnCtx (BN_CTX* h):
[+] 	BnCtx(BN_CTX* h):
[-] 		sl::Handle <BN_CTX*, FreeBnCtx> (h)
[+] 		sl::Handle<BN_CTX*, FreeBnCtx> (h)
[-] 	start ()
[+] 	start()
[-] 		BN_CTX_start (m_h);
[+] 		BN_CTX_start(m_h);
[-] 	end ()
[+] 	end()
[-] 		BN_CTX_end (m_h);
[+] 		BN_CTX_end(m_h);
[-] 	getBigNum ();
[+] 	getBigNum();
[-] 		BN_free (h);
[+] 		BN_free(h);
[-] class BigNum: public sl::Handle <BIGNUM*, FreeBigNum>
[+] class BigNum: public sl::Handle<BIGNUM*, FreeBigNum>
[-] 	BigNum ()
[+] 	BigNum()
[-] 		create ();
[+] 		create();
[-] 	BigNum (BIGNUM* h):
[+] 	BigNum(BIGNUM* h):
[-] 		sl::Handle <BIGNUM*, FreeBigNum> (h)
[+] 		sl::Handle<BIGNUM*, FreeBigNum> (h)
[-] 	create ();
[+] 	create();
[-] 	createCopy (BIGNUM* src);
[+] 	createCopy(BIGNUM* src);
[-] 	copy (BIGNUM* src)
[+] 	copy(BIGNUM* src)
[-] 		BIGNUM* result = BN_copy (m_h, src);
[+] 		BIGNUM* result = BN_copy(m_h, src);
[-] 		return completeWithLastCryptoError (result != NULL);
[+] 		return completeWithLastCryptoError(result != NULL);
[-] 	getBitCount ()
[+] 	getBitCount()
[-] 		return BN_num_bits (m_h);
[+] 		return BN_num_bits(m_h);
[-] 	getSize ()
[+] 	getSize()
[-] 		return BN_num_bytes (m_h);
[+] 		return BN_num_bytes(m_h);
[-] 	getData (
[+] 	getData(
[-] 	getData (sl::Array <char>* data)
[+] 	getData(sl::Array<char>* data)
[-] 		size_t size = getSize ();
[+] 		size_t size = getSize();
[-] 		return data->setCount (size) && getData (*data, size);
[+] 		return data->setCount(size) && getData(*data, size);
[-] 	sl::Array <char>
[+] 	sl::Array<char>
[-] 	getData ()
[+] 	getData()
[-] 		sl::Array <char> data;
[+] 		sl::Array<char> data;
[-] 		getData (&data);
[+] 		getData(&data);
[-] 	setData (
[+] 	setData(
[-] 		BIGNUM* result = BN_bin2bn ((const uchar_t*) p, (int) size, m_h);
[+] 		BIGNUM* result = BN_bin2bn((const uchar_t*) p, (int)size, m_h);
[-] 		return completeWithLastCryptoError (result != NULL);
[+] 		return completeWithLastCryptoError(result != NULL);
[-] 	getDecString (sl::String* string);
[+] 	getDecString(sl::String* string);
[-] 	getDecString ()
[+] 	getDecString()
[-] 		getDecString (&string);
[+] 		getDecString(&string);
[-] 	setDecString (const sl::StringRef& string)
[+] 	setDecString(const sl::StringRef& string)
[-] 		int result = BN_dec2bn (&m_h, string.sz ());
[+] 		int result = BN_dec2bn(&m_h, string.sz());
[-] 		return completeWithLastCryptoError (result);
[+] 		return completeWithLastCryptoError(result);
[-] 	getHexString (sl::String* string);
[+] 	getHexString(sl::String* string);
[-] 	getHexString ()
[+] 	getHexString()
[-] 		getHexString (&string);
[+] 		getHexString(&string);
[-] 	setHexString (const sl::StringRef& string)
[+] 	setHexString(const sl::StringRef& string)
[-] 		int result = BN_hex2bn (&m_h, string.sz ());
[+] 		int result = BN_hex2bn(&m_h, string.sz());
[-] 		return completeWithLastCryptoError (result);
[+] 		return completeWithLastCryptoError(result);
[-] 	rand (int bitCount)
[+] 	rand(int bitCount)
[-] 		int result = BN_rand (m_h, bitCount, -1, 0);
[+] 		int result = BN_rand(m_h, bitCount, -1, 0);
[-] 		return completeWithLastCryptoError (result);
[+] 		return completeWithLastCryptoError(result);
[-] 	pseudoRand (int bitCount)
[+] 	pseudoRand(int bitCount)
[-] 		int result = BN_pseudo_rand (m_h, bitCount, -1, 0);
[+] 		int result = BN_pseudo_rand(m_h, bitCount, -1, 0);
[-] 		return completeWithLastCryptoError (result);
[+] 		return completeWithLastCryptoError(result);
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_cry\axl_cry_Bio.h
----------------------
[-] 		BIO_free (h);
[+] 		BIO_free(h);
[-] class Bio: public sl::Handle <BIO*, FreeBio>
[+] class Bio: public sl::Handle<BIO*, FreeBio>
[-] 	Bio ()
[+] 	Bio()
[-] 	Bio (
[+] 	Bio(
[-] 		create (p, size);
[+] 		create(p, size);
[-] 	create (
[+] 	create(
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_cry\axl_cry_CryptoError.h
----------------------
[-] AXL_SL_DEFINE_GUID (
[+] AXL_SL_DEFINE_GUID(
[-] 	getErrorDescription (const err::ErrorRef& error);
[+] 	getErrorDescription(const err::ErrorRef& error);
[-] registerCryptoErrorProvider ()
[+] registerCryptoErrorProvider()
[-] 	err::getErrorMgr ()->registerProvider (
[+] 	err::getErrorMgr()->registerProvider(
[-] 		sl::getSimpleSingleton <CryptoErrorProvider> ()
[+] 		sl::getSimpleSingleton<CryptoErrorProvider> ()
[-] 	CryptoError ()
[+] 	CryptoError()
[-] 	CryptoError (int code)
[+] 	CryptoError(int code)
[-] 		create (code);
[+] 		create(code);
[-] 	create (int code)
[+] 	create(int code)
[-] 		return createSimpleError (g_cryptoErrorGuid, code);
[+] 		return createSimpleError(g_cryptoErrorGuid, code);
[-] setCryptoError (int code)
[+] setCryptoError(int code)
[-] 	return setError (CryptoError (code));
[+] 	return setError(CryptoError(code));
[-] setLastCryptoError ()
[+] setLastCryptoError()
[-] 	size_t result = setError (CryptoError (ERR_peek_last_error ()));
[+] 	size_t result = setError(CryptoError(ERR_peek_last_error()));
[-] 	ERR_clear_error ();
[+] 	ERR_clear_error();
[-] completeWithCryptoError (
[+] completeWithCryptoError(
[-] 		setCryptoError (errorCode);
[+] 		setCryptoError(errorCode);
[-] completeWithCryptoError (
[+] completeWithCryptoError(
[-] 	return completeWithCryptoError <bool> (result != 0, false, errorCode);
[+] 	return completeWithCryptoError<bool> (result != 0, false, errorCode);
[-] completeWithLastCryptoError (
[+] completeWithLastCryptoError(
[-] 		setLastCryptoError ();
[+] 		setLastCryptoError();
[-] completeWithLastCryptoError (int result)
[+] completeWithLastCryptoError(int result)
[-] 	return completeWithLastCryptoError <bool> (result != 0, false);
[+] 	return completeWithLastCryptoError<bool> (result != 0, false);
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_cry\axl_cry_EcKey.h
----------------------
[-] 		EC_KEY_free (h);
[+] 		EC_KEY_free(h);
[-] class EcKey: public sl::Handle <EC_KEY*, FreeEcKey>
[+] class EcKey: public sl::Handle<EC_KEY*, FreeEcKey>
[-] 	EcKey ()
[+] 	EcKey()
[-] 		create ();
[+] 		create();
[-] 	EcKey (uint_t curveId)
[+] 	EcKey(uint_t curveId)
[-] 		create (curveId);
[+] 		create(curveId);
[-] 	EcKey (EC_KEY* h):
[+] 	EcKey(EC_KEY* h):
[-] 		sl::Handle <EC_KEY*, FreeEcKey> (h)
[+] 		sl::Handle<EC_KEY*, FreeEcKey> (h)
[-] 	create ();
[+] 	create();
[-] 	create (uint_t curveId);
[+] 	create(uint_t curveId);
[-] 	createCopy (EC_KEY* src);
[+] 	createCopy(EC_KEY* src);
[-] 	copy (EC_KEY* src)
[+] 	copy(EC_KEY* src)
[-] 		EC_KEY* result = EC_KEY_copy (m_h, src);
[+] 		EC_KEY* result = EC_KEY_copy(m_h, src);
[-] 		return completeWithLastCryptoError (result != NULL);
[+] 		return completeWithLastCryptoError(result != NULL);
[-] 	getFlags ()
[+] 	getFlags()
[-] 		return EC_KEY_get_flags (m_h);
[+] 		return EC_KEY_get_flags(m_h);
[-] 	addFlags (uint_t flags)
[+] 	addFlags(uint_t flags)
[-] 		EC_KEY_set_flags (m_h, flags);
[+] 		EC_KEY_set_flags(m_h, flags);
[-] 	removeFlags (uint_t flags)
[+] 	removeFlags(uint_t flags)
[-] 		EC_KEY_clear_flags (m_h, flags);
[+] 		EC_KEY_clear_flags(m_h, flags);
[-] 	setFlags (uint_t flags);
[+] 	setFlags(uint_t flags);
[-] 	getEncFlags ()
[+] 	getEncFlags()
[-] 		return EC_KEY_get_enc_flags (m_h);
[+] 		return EC_KEY_get_enc_flags(m_h);
[-] 	setEncFlags (uint_t flags)
[+] 	setEncFlags(uint_t flags)
[-] 		EC_KEY_set_enc_flags (m_h, flags);
[+] 		EC_KEY_set_enc_flags(m_h, flags);
[-] 	getGroup ()
[+] 	getGroup()
[-] 		return (EC_GROUP*) EC_KEY_get0_group (m_h);
[+] 		return (EC_GROUP*)EC_KEY_get0_group(m_h);
[-] 	setGroup (EC_GROUP* group)
[+] 	setGroup(EC_GROUP* group)
[-] 		int result = EC_KEY_set_group (m_h, group);
[+] 		int result = EC_KEY_set_group(m_h, group);
[-] 		return completeWithLastCryptoError (result);
[+] 		return completeWithLastCryptoError(result);
[-] 	getPrivateKey ()
[+] 	getPrivateKey()
[-] 		return (BIGNUM*) EC_KEY_get0_private_key (m_h);
[+] 		return (BIGNUM*)EC_KEY_get0_private_key(m_h);
[-] 	setPrivateKey (BIGNUM* key)
[+] 	setPrivateKey(BIGNUM* key)
[-] 		int result = EC_KEY_set_private_key (m_h, key);
[+] 		int result = EC_KEY_set_private_key(m_h, key);
[-] 		return completeWithLastCryptoError (result);
[+] 		return completeWithLastCryptoError(result);
[-] 	setPrivateKeyData (
[+] 	setPrivateKeyData(
[-] 		return key.setData (p, size) && setPrivateKey (key);
[+] 		return key.setData(p, size) && setPrivateKey(key);
[-] 	setPrivateKeyDecString (const sl::StringRef& string)
[+] 	setPrivateKeyDecString(const sl::StringRef& string)
[-] 		return key.setDecString (string) && setPrivateKey (key);
[+] 		return key.setDecString(string) && setPrivateKey(key);
[-] 	setPrivateKeyHexString (const sl::StringRef& string)
[+] 	setPrivateKeyHexString(const sl::StringRef& string)
[-] 		return key.setHexString (string) && setPrivateKey (key);
[+] 		return key.setHexString(string) && setPrivateKey(key);
[-] 	getPublicKey ()
[+] 	getPublicKey()
[-] 		return (EC_POINT*) EC_KEY_get0_public_key (m_h);
[+] 		return (EC_POINT*)EC_KEY_get0_public_key(m_h);
[-] 	setPublicKey (EC_POINT* key)
[+] 	setPublicKey(EC_POINT* key)
[-] 		int result = EC_KEY_set_public_key (m_h, key);
[+] 		int result = EC_KEY_set_public_key(m_h, key);
[-] 		return completeWithLastCryptoError (result);
[+] 		return completeWithLastCryptoError(result);
[-] 	setPublicKeyData (
[+] 	setPublicKeyData(
[-] 	setPublicKeyDecString (
[+] 	setPublicKeyDecString(
[-] 	setPublicKeyHexString (
[+] 	setPublicKeyHexString(
[-] 	generateKey ()
[+] 	generateKey()
[-] 		int result = EC_KEY_generate_key (m_h);
[+] 		int result = EC_KEY_generate_key(m_h);
[-] 		return completeWithLastCryptoError (result);
[+] 		return completeWithLastCryptoError(result);
[-] 	getMaxSignatureSize ()
[+] 	getMaxSignatureSize()
[-] 		return ECDSA_size (m_h);
[+] 		return ECDSA_size(m_h);
[-] 	signHash (
[+] 	signHash(
[-] 	signHash (
[+] 	signHash(
[-] 		sl::Array <char>* signature,
[+] 		sl::Array<char>* signature,
[-] 	sl::Array <char>
[+] 	sl::Array<char>
[-] 	signHash (
[+] 	signHash(
[-] 		sl::Array <char> signature;
[+] 		sl::Array<char> signature;
[-] 		signHash (&signature, hash, hashSize);
[+] 		signHash(&signature, hash, hashSize);
[-] 	sign (
[+] 	sign(
[-] 		sl::Array <char>* signature,
[+] 		sl::Array<char>* signature,
[-] 		char hash [MD5_DIGEST_LENGTH];
[+] 		char hash[MD5_DIGEST_LENGTH];
[-] 		MD5 ((const uchar_t*) p, size, (uchar_t*) hash);
[+] 		MD5((const uchar_t*) p, size, (uchar_t*)hash);
[-] 		return signHash (signature, hash, sizeof (hash));
[+] 		return signHash(signature, hash, sizeof(hash));
[-] 	sl::Array <char>
[+] 	sl::Array<char>
[-] 	sign (
[+] 	sign(
[-] 		sl::Array <char> signature;
[+] 		sl::Array<char> signature;
[-] 		sign (&signature, p, size);
[+] 		sign(&signature, p, size);
[-] 	verifyHash (
[+] 	verifyHash(
[-] 		return ECDSA_verify (
[+] 		return ECDSA_verify(
[-] 			(int) hashSize,
[+] 			(int)hashSize,
[-] 			(int) signatureSize,
[+] 			(int)signatureSize,
[-] 	verify (
[+] 	verify(
[-] 		char hash [MD5_DIGEST_LENGTH];
[+] 		char hash[MD5_DIGEST_LENGTH];
[-] 		MD5 ((const uchar_t*) p, size, (uchar_t*) hash);
[+] 		MD5((const uchar_t*) p, size, (uchar_t*)hash);
[-] 		return verifyHash (hash, sizeof (hash), signature, signatureSize);
[+] 		return verifyHash(hash, sizeof(hash), signature, signatureSize);
[-] generateEcProductKey (
[+] generateEcProductKey(
[-] generateEcProductKey (
[+] generateEcProductKey(
[-] 	generateEcProductKey (ecKey, &productKey, userName, hyphenDistance);
[+] 	generateEcProductKey(ecKey, &productKey, userName, hyphenDistance);
[-] verifyEcProductKey (
[+] verifyEcProductKey(
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_cry\axl_cry_EcPoint.h
----------------------
[-] 		EC_POINT_free (h);
[+] 		EC_POINT_free(h);
[-] class EcPoint: public sl::Handle <EC_POINT*, FreeEcPoint>
[+] class EcPoint: public sl::Handle<EC_POINT*, FreeEcPoint>
[-] 	EcPoint (EC_GROUP* group)
[+] 	EcPoint(EC_GROUP* group)
[-] 		create (group);
[+] 		create(group);
[-] 	EcPoint (EC_POINT* h):
[+] 	EcPoint(EC_POINT* h):
[-] 		sl::Handle <EC_POINT*, FreeEcPoint> (h)
[+] 		sl::Handle<EC_POINT*, FreeEcPoint> (h)
[-] 	create (EC_GROUP* group);
[+] 	create(EC_GROUP* group);
[-] 	createCopy (
[+] 	createCopy(
[-] 	copy (EC_POINT* src)
[+] 	copy(EC_POINT* src)
[-] 		int result = EC_POINT_copy (m_h, src);
[+] 		int result = EC_POINT_copy(m_h, src);
[-] 		return completeWithLastCryptoError (result);
[+] 		return completeWithLastCryptoError(result);
[-] 	getData (
[+] 	getData(
[-] 		sl::Array <char>* data,
[+] 		sl::Array<char>* data,
[-] 	sl::Array <char>
[+] 	sl::Array<char>
[-] 	getData (
[+] 	getData(
[-] 		sl::Array <char> data;
[+] 		sl::Array<char> data;
[-] 		getData (&data, group, form, ctx);
[+] 		getData(&data, group, form, ctx);
[-] 	setData (
[+] 	setData(
[-] 		int result = EC_POINT_oct2point (group, m_h, (const uchar_t*) p, size, ctx);
[+] 		int result = EC_POINT_oct2point(group, m_h, (const uchar_t*) p, size, ctx);
[-] 		return completeWithLastCryptoError (result);
[+] 		return completeWithLastCryptoError(result);
[-] 	getBigNum (
[+] 	getBigNum(
[-] 		BIGNUM* result = EC_POINT_point2bn (group, m_h, form, bigNum, ctx);
[+] 		BIGNUM* result = EC_POINT_point2bn(group, m_h, form, bigNum, ctx);
[-] 		return completeWithLastCryptoError (result != NULL);
[+] 		return completeWithLastCryptoError(result != NULL);
[-] 	setBigNum (
[+] 	setBigNum(
[-] 		EC_POINT* result = EC_POINT_bn2point (group, bigNum, m_h, ctx);
[+] 		EC_POINT* result = EC_POINT_bn2point(group, bigNum, m_h, ctx);
[-] 		return completeWithLastCryptoError (result != NULL);
[+] 		return completeWithLastCryptoError(result != NULL);
[-] 	getDecString (
[+] 	getDecString(
[-] 		return getBigNum (group, bigNum, form, ctx) && bigNum.getDecString (string);
[+] 		return getBigNum(group, bigNum, form, ctx) && bigNum.getDecString(string);
[-] 	getDecString (
[+] 	getDecString(
[-] 		getDecString (&string, group, form, ctx);
[+] 		getDecString(&string, group, form, ctx);
[-] 	setDecString (
[+] 	setDecString(
[-] 		return bigNum.setDecString (string) && setBigNum (group, bigNum, ctx);
[+] 		return bigNum.setDecString(string) && setBigNum(group, bigNum, ctx);
[-] 	getHexString (
[+] 	getHexString(
[-] 	getHexString (
[+] 	getHexString(
[-] 		getHexString (&string, group, form, ctx);
[+] 		getHexString(&string, group, form, ctx);
[-] 	setHexString (
[+] 	setHexString(
[-] 		EC_POINT* result = EC_POINT_hex2point (group, string.sz (), m_h, ctx);
[+] 		EC_POINT* result = EC_POINT_hex2point(group, string.sz(), m_h, ctx);
[-] 		return completeWithLastCryptoError (result != NULL);
[+] 		return completeWithLastCryptoError(result != NULL);
[-] 	isAtInfinity (EC_GROUP* group)
[+] 	isAtInfinity(EC_GROUP* group)
[-] 		return EC_POINT_is_at_infinity (group, m_h) == 1;
[+] 		return EC_POINT_is_at_infinity(group, m_h) == 1;
[-] 	isOnCurve (
[+] 	isOnCurve(
[-] 		return EC_POINT_is_on_curve (group, m_h, ctx) == 1;
[+] 		return EC_POINT_is_on_curve(group, m_h, ctx) == 1;
[-] 	isEqual (
[+] 	isEqual(
[-] 		return EC_POINT_cmp (group, m_h, op, ctx) == 1;
[+] 		return EC_POINT_cmp(group, m_h, op, ctx) == 1;
[-] 	add (
[+] 	add(
[-] 		int result = EC_POINT_add (group, m_h, op1, op2, ctx);
[+] 		int result = EC_POINT_add(group, m_h, op1, op2, ctx);
[-] 		return completeWithLastCryptoError (result);
[+] 		return completeWithLastCryptoError(result);
[-] 	mul (
[+] 	mul(
[-] 		int result = EC_POINT_mul (group, m_h, op1, op2, op3, ctx);
[+] 		int result = EC_POINT_mul(group, m_h, op1, op2, op3, ctx);
[-] 		return completeWithLastCryptoError (result);
[+] 		return completeWithLastCryptoError(result);
[-] 	mul (
[+] 	mul(
[-] 		int result = EC_POINT_mul (group, m_h, op, NULL, NULL, ctx);
[+] 		int result = EC_POINT_mul(group, m_h, op, NULL, NULL, ctx);
[-] 		return completeWithLastCryptoError (result);
[+] 		return completeWithLastCryptoError(result);
[-] 	dbl (
[+] 	dbl(
[-] 		int result = EC_POINT_dbl (group, m_h, op, ctx);
[+] 		int result = EC_POINT_dbl(group, m_h, op, ctx);
[-] 		return completeWithLastCryptoError (result);
[+] 		return completeWithLastCryptoError(result);
[-] 	invert (
[+] 	invert(
[-] 		int result = EC_POINT_invert (group, m_h, ctx);
[+] 		int result = EC_POINT_invert(group, m_h, ctx);
[-] 		return completeWithLastCryptoError (result);
[+] 		return completeWithLastCryptoError(result);
[-] 	makeAffine (
[+] 	makeAffine(
[-] 		int result = EC_POINT_make_affine (group, m_h, ctx);
[+] 		int result = EC_POINT_make_affine(group, m_h, ctx);
[-] 		return completeWithLastCryptoError (result);
[+] 		return completeWithLastCryptoError(result);
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_cry\axl_cry_Rsa.h
----------------------
[-] 		RSA_free (h);
[+] 		RSA_free(h);
[-] class Rsa: public sl::Handle <RSA*, FreeRsa>
[+] class Rsa: public sl::Handle<RSA*, FreeRsa>
[-] 	Rsa ()
[+] 	Rsa()
[-] 	getSize ()
[+] 	getSize()
[-] 		return RSA_size (m_h);
[+] 		return RSA_size(m_h);
[-] 	readPublicKey (BIO* bio);
[+] 	readPublicKey(BIO* bio);
[-] 	readPublicKey (
[+] 	readPublicKey(
[-] 		return bio.create (pem, size) && readPublicKey (bio);
[+] 		return bio.create(pem, size) && readPublicKey(bio);
[-] 	readPrivateKey (BIO* bio);
[+] 	readPrivateKey(BIO* bio);
[-] 	readPrivateKey (
[+] 	readPrivateKey(
[-] 		return bio.create (pem, size) && readPrivateKey (bio);
[+] 		return bio.create(pem, size) && readPrivateKey(bio);
[-] 	publicEncrypt (
[+] 	publicEncrypt(
[-] 		int result = RSA_public_encrypt (size, (const uchar_t*) src, (uchar_t*) dst, m_h, padding);
[+] 		int result = RSA_public_encrypt(size, (const uchar_t*) src, (uchar_t*)dst, m_h, padding);
[-] 		return completeWithLastCryptoError <size_t> (result, -1);
[+] 		return completeWithLastCryptoError<size_t> (result, -1);
[-] 	privateEncrypt (
[+] 	privateEncrypt(
[-] 		int result = RSA_private_encrypt (size, (const uchar_t*) src, (uchar_t*) dst, m_h, padding);
[+] 		int result = RSA_private_encrypt(size, (const uchar_t*) src, (uchar_t*)dst, m_h, padding);
[-] 		return completeWithLastCryptoError <size_t> (result, -1);
[+] 		return completeWithLastCryptoError<size_t> (result, -1);
[-] 	publicDecrypt (
[+] 	publicDecrypt(
[-] 		int result = RSA_public_decrypt (size, (const uchar_t*) src, (uchar_t*) dst, m_h, padding);
[+] 		int result = RSA_public_decrypt(size, (const uchar_t*) src, (uchar_t*)dst, m_h, padding);
[-] 		return completeWithLastCryptoError <size_t> (result, -1);
[+] 		return completeWithLastCryptoError<size_t> (result, -1);
[-] 	privateDecrypt (
[+] 	privateDecrypt(
[-] 		int result = RSA_private_decrypt (size, (const uchar_t*) src, (uchar_t*) dst, m_h, padding);
[+] 		int result = RSA_private_decrypt(size, (const uchar_t*) src, (uchar_t*)dst, m_h, padding);
[-] 		return completeWithLastCryptoError <size_t> (result, -1);
[+] 		return completeWithLastCryptoError<size_t> (result, -1);
[-] 	signHash (
[+] 	signHash(
[-] 	signHash (
[+] 	signHash(
[-] 		sl::Array <char>* signature,
[+] 		sl::Array<char>* signature,
[-] 	sl::Array <char>
[+] 	sl::Array<char>
[-] 	signHash (
[+] 	signHash(
[-] 		sl::Array <char> signature;
[+] 		sl::Array<char> signature;
[-] 		signHash (type, &signature, hash, hashSize);
[+] 		signHash(type, &signature, hash, hashSize);
[-] 	sign (
[+] 	sign(
[-] 		sl::Array <char>* signature,
[+] 		sl::Array<char>* signature,
[-] 		char hash [MD5_DIGEST_LENGTH];
[+] 		char hash[MD5_DIGEST_LENGTH];
[-] 		MD5 ((const uchar_t*) p, size, (uchar_t*) hash);
[+] 		MD5((const uchar_t*) p, size, (uchar_t*)hash);
[-] 		return signHash (NID_md5, signature, hash, sizeof (hash));
[+] 		return signHash(NID_md5, signature, hash, sizeof(hash));
[-] 	sl::Array <char>
[+] 	sl::Array<char>
[-] 	sign (
[+] 	sign(
[-] 		sl::Array <char> signature;
[+] 		sl::Array<char> signature;
[-] 		sign (&signature, p, size);
[+] 		sign(&signature, p, size);
[-] 	verifyHash (
[+] 	verifyHash(
[-] 		return RSA_verify (
[+] 		return RSA_verify(
[-] 			(int) hashSize,
[+] 			(int)hashSize,
[-] 			(int) signatureSize,
[+] 			(int)signatureSize,
[-] 	verify (
[+] 	verify(
[-] 		char hash [MD5_DIGEST_LENGTH];
[+] 		char hash[MD5_DIGEST_LENGTH];
[-] 		MD5 ((const uchar_t*) p, size, (uchar_t*) hash);
[+] 		MD5((const uchar_t*) p, size, (uchar_t*)hash);
[-] 		return verifyHash (NID_md5, hash, sizeof (hash), signature, signatureSize);
[+] 		return verifyHash(NID_md5, hash, sizeof(hash), signature, signatureSize);
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_enc\axl_enc_Base32Encoding.h
----------------------
[-] 	encode (
[+] 	encode(
[-] 	encode (
[+] 	encode(
[-] 		encode (&string, p, size, hyphenDistance);
[+] 		encode(&string, p, size, hyphenDistance);
[-] 	decode (
[+] 	decode(
[-] 		sl::Array <char>* buffer,
[+] 		sl::Array<char>* buffer,
[-] 	sl::Array <char>
[+] 	sl::Array<char>
[-] 	decode (const sl::StringRef& string)
[+] 	decode(const sl::StringRef& string)
[-] 		sl::Array <char> buffer;
[+] 		sl::Array<char> buffer;
[-] 		decode (&buffer, string);
[+] 		decode(&buffer, string);
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_enc\axl_enc_CharCodec.h
----------------------
[-] 	CharCodec ()
[+] 	CharCodec()
[-] 	getUnitSize ()
[+] 	getUnitSize()
[-] 	calcRequiredBufferSizeToEncodeFromUtf8 (
[+] 	calcRequiredBufferSizeToEncodeFromUtf8(
[-] 	calcRequiredBufferSizeToEncodeFromUtf16 (
[+] 	calcRequiredBufferSizeToEncodeFromUtf16(
[-] 	calcRequiredBufferSizeToEncodeFromUtf32 (
[+] 	calcRequiredBufferSizeToEncodeFromUtf32(
[-] 	encodeFromUtf8 (
[+] 	encodeFromUtf8(
[-] 		sl::Array <char>* buffer,
[+] 		sl::Array<char>* buffer,
[-] 	encodeFromUtf16 (
[+] 	encodeFromUtf16(
[-] 		sl::Array <char>* buffer,
[+] 		sl::Array<char>* buffer,
[-] 	encodeFromUtf32 (
[+] 	encodeFromUtf32(
[-] 		sl::Array <char>* buffer,
[+] 		sl::Array<char>* buffer,
[-] 	sl::Array <char>
[+] 	sl::Array<char>
[-] 	encodeFromUtf8 (
[+] 	encodeFromUtf8(
[-] 	sl::Array <char>
[+] 	sl::Array<char>
[-] 	encodeFromUtf16 (
[+] 	encodeFromUtf16(
[-] 	sl::Array <char>
[+] 	sl::Array<char>
[-] 	encodeFromUtf32 (
[+] 	encodeFromUtf32(
[-] 	encodeFromUtf8 (
[+] 	encodeFromUtf8(
[-] 	encodeFromUtf16 (
[+] 	encodeFromUtf16(
[-] 	encodeFromUtf32 (
[+] 	encodeFromUtf32(
[-] 	calcRequiredBufferLengthToDecodeToUtf8 (
[+] 	calcRequiredBufferLengthToDecodeToUtf8(
[-] 	calcRequiredBufferLengthToDecodeToUtf16 (
[+] 	calcRequiredBufferLengthToDecodeToUtf16(
[-] 	calcRequiredBufferLengthToDecodeToUtf32 (
[+] 	calcRequiredBufferLengthToDecodeToUtf32(
[-] 	decodeToUtf8 (
[+] 	decodeToUtf8(
[-] 		sl::Array <utf8_t>* buffer,
[+] 		sl::Array<utf8_t>* buffer,
[-] 	decodeToUtf16 (
[+] 	decodeToUtf16(
[-] 		sl::Array <utf16_t>* buffer,
[+] 		sl::Array<utf16_t>* buffer,
[-] 	decodeToUtf32 (
[+] 	decodeToUtf32(
[-] 		sl::Array <utf32_t>* buffer,
[+] 		sl::Array<utf32_t>* buffer,
[-] 	sl::Array <utf8_t>
[+] 	sl::Array<utf8_t>
[-] 	decodeToUtf8 (
[+] 	decodeToUtf8(
[-] 	sl::Array <utf16_t>
[+] 	sl::Array<utf16_t>
[-] 	decodeToUtf16 (
[+] 	decodeToUtf16(
[-] 	sl::Array <utf32_t>
[+] 	sl::Array<utf32_t>
[-] 	decodeToUtf32 (
[+] 	decodeToUtf32(
[-] 	decodeToUtf8 (
[+] 	decodeToUtf8(
[-] 	decodeToUtf16 (
[+] 	decodeToUtf16(
[-] 	decodeToUtf32 (
[+] 	decodeToUtf32(
[-] 	decodeToUtf32 (
[+] 	decodeToUtf32(
[-] getCharCodec (CharCodecKind codecKind);
[+] getCharCodec(CharCodecKind codecKind);
[-] 	AsciiCodec ()
[+] 	AsciiCodec()
[-] 	calcRequiredBufferSizeToEncodeFromUtf8 (
[+] 	calcRequiredBufferSizeToEncodeFromUtf8(
[-] 		return UtfToAsciiConvert <Utf8>::calcRequiredLength (p, length);
[+] 		return UtfToAsciiConvert<Utf8>::calcRequiredLength(p, length);
[-] 	calcRequiredBufferSizeToEncodeFromUtf16 (
[+] 	calcRequiredBufferSizeToEncodeFromUtf16(
[-] 		return UtfToAsciiConvert <Utf16>::calcRequiredLength (p, length);
[+] 		return UtfToAsciiConvert<Utf16>::calcRequiredLength(p, length);
[-] 	calcRequiredBufferSizeToEncodeFromUtf32 (
[+] 	calcRequiredBufferSizeToEncodeFromUtf32(
[-] 		return UtfToAsciiConvert <Utf32>::calcRequiredLength (p, length);
[+] 		return UtfToAsciiConvert<Utf32>::calcRequiredLength(p, length);
[-] 	encodeFromUtf8 (
[+] 	encodeFromUtf8(
[-] 		return UtfToAsciiConvert <Utf8>::convert (
[+] 		return UtfToAsciiConvert<Utf8>::convert(
[-] 			(char*) buffer,
[+] 			(char*)buffer,
[-] 	encodeFromUtf16 (
[+] 	encodeFromUtf16(
[-] 		return UtfToAsciiConvert <Utf16>::convert (
[+] 		return UtfToAsciiConvert<Utf16>::convert(
[-] 			(char*) buffer,
[+] 			(char*)buffer,
[-] 	encodeFromUtf32 (
[+] 	encodeFromUtf32(
[-] 		return UtfToAsciiConvert <Utf32>::convert (
[+] 		return UtfToAsciiConvert<Utf32>::convert(
[-] 			(char*) buffer,
[+] 			(char*)buffer,
[-] 	calcRequiredBufferLengthToDecodeToUtf8 (
[+] 	calcRequiredBufferLengthToDecodeToUtf8(
[-] 		return AsciiToUtfConvert <Utf8>::calcRequiredLength ((const char*) p, size);
[+] 		return AsciiToUtfConvert<Utf8>::calcRequiredLength((const char*) p, size);
[-] 	calcRequiredBufferLengthToDecodeToUtf16 (
[+] 	calcRequiredBufferLengthToDecodeToUtf16(
[-] 		return AsciiToUtfConvert <Utf16>::calcRequiredLength ((const char*) p, size);
[+] 		return AsciiToUtfConvert<Utf16>::calcRequiredLength((const char*) p, size);
[-] 	calcRequiredBufferLengthToDecodeToUtf32 (
[+] 	calcRequiredBufferLengthToDecodeToUtf32(
[-] 		return AsciiToUtfConvert <Utf32>::calcRequiredLength ((const char*) p, size);
[+] 		return AsciiToUtfConvert<Utf32>::calcRequiredLength((const char*) p, size);
[-] 	decodeToUtf8 (
[+] 	decodeToUtf8(
[-] 		return AsciiToUtfConvert <Utf8>::convert (
[+] 		return AsciiToUtfConvert<Utf8>::convert(
[-] 	decodeToUtf16 (
[+] 	decodeToUtf16(
[-] 		return AsciiToUtfConvert <Utf16>::convert (
[+] 		return AsciiToUtfConvert<Utf16>::convert(
[-] 	decodeToUtf32 (
[+] 	decodeToUtf32(
[-] 		return AsciiToUtfConvert <Utf32>::convert (
[+] 		return AsciiToUtfConvert<Utf32>::convert(
[-] 	decodeToUtf32 (
[+] 	decodeToUtf32(
[-] 		return AsciiToUtfConvert <Utf32>::convert (
[+] 		return AsciiToUtfConvert<Utf32>::convert(
[-] 	UtfCodec ()
[+] 	UtfCodec()
[-] 		m_unitSize = sizeof (C);
[+] 		m_unitSize = sizeof(C);
[-] 	calcRequiredBufferSizeToEncodeFromUtf8 (
[+] 	calcRequiredBufferSizeToEncodeFromUtf8(
[-] 		return UtfConvert <T, Utf8>::calcRequiredLength (p, length) * sizeof (C);
[+] 		return UtfConvert<T, Utf8>::calcRequiredLength(p, length) * sizeof(C);
[-] 	calcRequiredBufferSizeToEncodeFromUtf16 (
[+] 	calcRequiredBufferSizeToEncodeFromUtf16(
[-] 		return UtfConvert <T, Utf16>::calcRequiredLength (p, length) * sizeof (C);
[+] 		return UtfConvert<T, Utf16>::calcRequiredLength(p, length) * sizeof(C);
[-] 	calcRequiredBufferSizeToEncodeFromUtf32 (
[+] 	calcRequiredBufferSizeToEncodeFromUtf32(
[-] 		return UtfConvert <T, Utf32>::calcRequiredLength (p, length) * sizeof (C);
[+] 		return UtfConvert<T, Utf32>::calcRequiredLength(p, length) * sizeof(C);
[-] 	encodeFromUtf8 (
[+] 	encodeFromUtf8(
[-] 		return UtfConvert <T, Utf8>::convert (
[+] 		return UtfConvert<T, Utf8>::convert(
[-] 			(C*) buffer,
[+] 			(C*)buffer,
[-] 			bufferSize / sizeof (C),
[+] 			bufferSize / sizeof(C),
[-] 			) * sizeof (C);
[+] 			) * sizeof(C);
[-] 	encodeFromUtf16 (
[+] 	encodeFromUtf16(
[-] 		return UtfConvert <T, Utf16>::convert (
[+] 		return UtfConvert<T, Utf16>::convert(
[-] 			(C*) buffer,
[+] 			(C*)buffer,
[-] 			bufferSize / sizeof (C),
[+] 			bufferSize / sizeof(C),
[-] 			) * sizeof (C);
[+] 			) * sizeof(C);
[-] 	encodeFromUtf32 (
[+] 	encodeFromUtf32(
[-] 		return UtfConvert <T, Utf32>::convert (
[+] 		return UtfConvert<T, Utf32>::convert(
[-] 			(C*) buffer,
[+] 			(C*)buffer,
[-] 			bufferSize / sizeof (C),
[+] 			bufferSize / sizeof(C),
[-] 			) * sizeof (C);
[+] 			) * sizeof(C);
[-] 	calcRequiredBufferLengthToDecodeToUtf8 (
[+] 	calcRequiredBufferLengthToDecodeToUtf8(
[-] 		return UtfConvert <Utf8, T>::calcRequiredLength (
[+] 		return UtfConvert<Utf8, T>::calcRequiredLength(
[-] 			size / sizeof (C)
[+] 			size / sizeof(C)
[-] 	calcRequiredBufferLengthToDecodeToUtf16 (
[+] 	calcRequiredBufferLengthToDecodeToUtf16(
[-] 		return UtfConvert <Utf16, T>::calcRequiredLength (
[+] 		return UtfConvert<Utf16, T>::calcRequiredLength(
[-] 			size / sizeof (C)
[+] 			size / sizeof(C)
[-] 	calcRequiredBufferLengthToDecodeToUtf32 (
[+] 	calcRequiredBufferLengthToDecodeToUtf32(
[-] 		return UtfConvert <Utf32, T>::calcRequiredLength (
[+] 		return UtfConvert<Utf32, T>::calcRequiredLength(
[-] 			size / sizeof (C)
[+] 			size / sizeof(C)
[-] 	decodeToUtf8 (
[+] 	decodeToUtf8(
[-] 		size_t takenBufferLength = UtfConvert <Utf8, T>::convert (
[+] 		size_t takenBufferLength = UtfConvert<Utf8, T>::convert(
[-] 			size / sizeof (C),
[+] 			size / sizeof(C),
[-] 			*takenSize = takenLength * sizeof (C);
[+] 			*takenSize = takenLength * sizeof(C);
[-] 	decodeToUtf16 (
[+] 	decodeToUtf16(
[-] 		size_t takenBufferLength = UtfConvert <Utf16, T>::convert (
[+] 		size_t takenBufferLength = UtfConvert<Utf16, T>::convert(
[-] 			size / sizeof (C),
[+] 			size / sizeof(C),
[-] 			*takenSize = takenLength * sizeof (C);
[+] 			*takenSize = takenLength * sizeof(C);
[-] 	decodeToUtf32 (
[+] 	decodeToUtf32(
[-] 		size_t takenBufferLength = UtfConvert <Utf32, T>::convert (
[+] 		size_t takenBufferLength = UtfConvert<Utf32, T>::convert(
[-] 			size / sizeof (C),
[+] 			size / sizeof(C),
[-] 			*takenSize = takenLength * sizeof (C);
[+] 			*takenSize = takenLength * sizeof(C);
[-] 	decodeToUtf32 (
[+] 	decodeToUtf32(
[-] 		size_t takenBufferLength = UtfConvert <Utf32, T>::convert (
[+] 		size_t takenBufferLength = UtfConvert<Utf32, T>::convert(
[-] 			size / sizeof (C),
[+] 			size / sizeof(C),
[-] 			*takenSize = takenLength * sizeof (C);
[+] 			*takenSize = takenLength * sizeof(C);
[-] 		char m_accumulator [4];
[+] 		char m_accumulator[4];
[-] 	CodePointDecoder (
[+] 	CodePointDecoder(
[-] 		setup (codecKind, state);
[+] 		setup(codecKind, state);
[-] 	getCharCodec ()
[+] 	getCharCodec()
[-] 	getAccumulatorCount ()
[+] 	getAccumulatorCount()
[-] 	getAccumulator ()
[+] 	getAccumulator()
[-] 	getAccumulator_i32 ()
[+] 	getAccumulator_i32()
[-] 	setup (
[+] 	setup(
[-] 		setup (enc::getCharCodec (codecKind), state);
[+] 		setup(enc::getCharCodec(codecKind), state);
[-] 	setup (
[+] 	setup(
[-] 		loadState (state);
[+] 		loadState(state);
[-] 	clear ()
[+] 	clear()
[-] 		resetAccumulator ();
[+] 		resetAccumulator();
[-] 	resetAccumulator ()
[+] 	resetAccumulator()
[-] 	loadState (uint32_t state);
[+] 	loadState(uint32_t state);
[-] 	saveState ();
[+] 	saveState();
[-] 	decode (
[+] 	decode(
[-] 	decode (
[+] 	decode(
[-] 	decodeImpl (
[+] 	decodeImpl(
[-] 	decodeImpl (
[+] 	decodeImpl(
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_enc\axl_enc_EscapeEncoding.h
----------------------
[-] 	findEscapeChar (char x);
[+] 	findEscapeChar(char x);
[-] 	findEscapeReplaceChar (char x);
[+] 	findEscapeReplaceChar(char x);
[-] 	encode (
[+] 	encode(
[-] 	encode (const sl::StringRef& source)
[+] 	encode(const sl::StringRef& source)
[-] 		encode (&string, source);
[+] 		encode(&string, source);
[-] 	decode (
[+] 	decode(
[-] 	decode (const sl::StringRef& source)
[+] 	decode(const sl::StringRef& source)
[-] 		decode (&string, source);
[+] 		decode(&string, source);
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_enc\axl_enc_HexEncoding.h
----------------------
[-] 	getHexChar_l (uchar_t x)
[+] 	getHexChar_l(uchar_t x)
[-] 		static char charTable [] = "0123456789abcdef";
[+] 		static char charTable[] = "0123456789abcdef";
[-] 		return charTable [x & 0xf];
[+] 		return charTable[x & 0xf];
[-] 	getHexChar_u (uchar_t x)
[+] 	getHexChar_u(uchar_t x)
[-] 		static char charTable [] = "0123456789ABCDEF";
[+] 		static char charTable[] = "0123456789ABCDEF";
[-] 		return charTable [x & 0xf];
[+] 		return charTable[x & 0xf];
[-] 	getHexCharValue (char x)
[+] 	getHexCharValue(char x)
[-] 	encode (
[+] 	encode(
[-] 	encode (
[+] 	encode(
[-] 		encode (&string, p, size, flags);
[+] 		encode(&string, p, size, flags);
[-] 	decode (
[+] 	decode(
[-] 		sl::Array <char>* buffer,
[+] 		sl::Array<char>* buffer,
[-] 	sl::Array <char>
[+] 	sl::Array<char>
[-] 	decode (const sl::StringRef& source)
[+] 	decode(const sl::StringRef& source)
[-] 		sl::Array <char> buffer;
[+] 		sl::Array<char> buffer;
[-] 		decode (&buffer, source);
[+] 		decode(&buffer, source);
[-] 	encode_l (
[+] 	encode_l(
[-] 	encode_u (
[+] 	encode_u(
[-] 	encode_nsl (
[+] 	encode_nsl(
[-] 	encode_nsu (
[+] 	encode_nsu(
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_enc\axl_enc_Utf.h
----------------------
[-] getUtfKindString (UtfKind utfKind);
[+] getUtfKindString(UtfKind utfKind);
[-] utfIsPrintable (utf32_t c);
[+] utfIsPrintable(utf32_t c);
[-] utfIsPrintableNonMark (utf32_t c);
[+] utfIsPrintableNonMark(utf32_t c);
[-] utfIsSpace (utf32_t c);
[+] utfIsSpace(utf32_t c);
[-] utfIsPunctuation (utf32_t c);
[+] utfIsPunctuation(utf32_t c);
[-] utfIsLetter (utf32_t c);
[+] utfIsLetter(utf32_t c);
[-] utfIsDigit (utf32_t c);
[+] utfIsDigit(utf32_t c);
[-] utfIsNumber (utf32_t c);
[+] utfIsNumber(utf32_t c);
[-] utfIsLetterOrDigit (utf32_t c);
[+] utfIsLetterOrDigit(utf32_t c);
[-] utfIsLetterOrNumber (utf32_t c);
[+] utfIsLetterOrNumber(utf32_t c);
[-] utfIsLowerCase (utf32_t c);
[+] utfIsLowerCase(utf32_t c);
[-] utfIsUpperCase (utf32_t c);
[+] utfIsUpperCase(utf32_t c);
[-] utfToLowerCase (utf32_t c);
[+] utfToLowerCase(utf32_t c);
[-] utfToUpperCase (utf32_t c);
[+] utfToUpperCase(utf32_t c);
[-] utfToCaseFolded (utf32_t c);
[+] utfToCaseFolded(utf32_t c);
[-] 		return utfToLowerCase (x);
[+] 		return utfToLowerCase(x);
[-] 		return utfToUpperCase (x);
[+] 		return utfToUpperCase(x);
[-] 		return utfToCaseFolded (x);
[+] 		return utfToCaseFolded(x);
[-] calcUtfCodePointCount (
[+] calcUtfCodePointCount(
[-] 		size_t srcCodePointLength = T::getDecodeCodePointLength (*p);
[+] 		size_t srcCodePointLength = T::getDecodeCodePointLength(*p);
[-] 	getUtfKind ()
[+] 	getUtfKind()
[-] 	getBom ()
[+] 	getBom()
[-] 		static uint8_t bom [] = { 0xef, 0xbb, 0xbf };
[+] 		static uint8_t bom[] = { 0xef, 0xbb, 0xbf };
[-] 	getBomLength ()
[+] 	getBomLength()
[-] 	getDecodeCodePointLength (utf8_t c)
[+] 	getDecodeCodePointLength(utf8_t c)
[-] 	getEncodeCodePointLength (utf32_t x)
[+] 	getEncodeCodePointLength(utf32_t x)
[-] 	decodeCodePoint (const utf8_t* p)
[+] 	decodeCodePoint(const utf8_t* p)
[-] 				((p [0] & 0x1f) << 6)  |
[+] 				((p[0] & 0x1f) << 6)  |
[-] 				 (p [1] & 0x3f) :
[+] 				 (p[1] & 0x3f) :
[-] 				((p [0] & 0x0f) << 12) |
[+] 				((p[0] & 0x0f) << 12) |
[-] 				((p [1] & 0x3f) << 6)  |
[+] 				((p[1] & 0x3f) << 6)  |
[-] 				 (p [2] & 0x3f) :
[+] 				 (p[2] & 0x3f) :
[-] 				((p [0] & 0x07) << 18) |
[+] 				((p[0] & 0x07) << 18) |
[-] 				((p [1] & 0x3f) << 12) |
[+] 				((p[1] & 0x3f) << 12) |
[-] 				((p [2] & 0x3f) << 6)  |
[+] 				((p[2] & 0x3f) << 6)  |
[-] 				 (p [3] & 0x3f) : 0xffff; // use non-character U+FFFF (needs no surrogate in UTF-16)
[+] 				 (p[3] & 0x3f) : 0xffff; // use non-character U+FFFF (needs no surrogate in UTF-16)
[-] 	encodeCodePoint (
[+] 	encodeCodePoint(
[-] 			p [0] = -1;
[+] 			p[0] = -1;
[-] 			p [0] = (uint8_t) x;
[+] 			p[0] = (uint8_t)x;
[-] 			p [0] = (uint8_t) (x >> 6)          | 0xc0;
[+] 			p[0] = (uint8_t)(x >> 6)          | 0xc0;
[-] 			p [1] = (uint8_t) (x & 0x3f)        | 0x80;
[+] 			p[1] = (uint8_t)(x & 0x3f)        | 0x80;
[-] 			p [0] = (uint8_t) (x >> 12)         | 0xe0;
[+] 			p[0] = (uint8_t)(x >> 12)         | 0xe0;
[-] 			p [1] = (uint8_t) ((x >> 6) & 0x3f) | 0x80;
[+] 			p[1] = (uint8_t)((x >> 6) & 0x3f) | 0x80;
[-] 			p [2] = (uint8_t) (x & 0x3f)        | 0x80;
[+] 			p[2] = (uint8_t)(x & 0x3f)        | 0x80;
[-] 			p [0] = (uint8_t) (x >> 18)         | 0xf0;
[+] 			p[0] = (uint8_t)(x >> 18)         | 0xf0;
[-] 			p [1] = (uint8_t) ((x >> 12) & 0x3f)| 0x80;
[+] 			p[1] = (uint8_t)((x >> 12) & 0x3f)| 0x80;
[-] 			p [2] = (uint8_t) ((x >> 6) & 0x3f) | 0x80;
[+] 			p[2] = (uint8_t)((x >> 6) & 0x3f) | 0x80;
[-] 			p [3] = (uint8_t) (x & 0x3f)        | 0x80;
[+] 			p[3] = (uint8_t)(x & 0x3f)        | 0x80;
[-] 			p [0] = -1;
[+] 			p[0] = -1;
[-] 	calcCodePointCount (
[+] 	calcCodePointCount(
[-] 		return calcUtfCodePointCount <Utf8> (p, length);
[+] 		return calcUtfCodePointCount<Utf8> (p, length);
[-] 	getUtfKind ()
[+] 	getUtfKind()
[-] 	getBom ()
[+] 	getBom()
[-] 		static uint8_t bom [] = { 0xff, 0xfe };
[+] 		static uint8_t bom[] = { 0xff, 0xfe };
[-] 	getBomLength ()
[+] 	getBomLength()
[-] 	isLeadSurrogate (uint16_t c)
[+] 	isLeadSurrogate(uint16_t c)
[-] 	isTrailSurrogate (uint16_t c)
[+] 	isTrailSurrogate(uint16_t c)
[-] 	needSurrogate (uint32_t x)
[+] 	needSurrogate(uint32_t x)
[-] 	getLeadSurrogate (uint32_t x)
[+] 	getLeadSurrogate(uint32_t x)
[-] 	getTrailSurrogate (uint32_t x)
[+] 	getTrailSurrogate(uint32_t x)
[-] 	getSurrogateCodePoint (
[+] 	getSurrogateCodePoint(
[-] 		ASSERT (isLeadSurrogate (lead) && isTrailSurrogate (trail));
[+] 		ASSERT(isLeadSurrogate(lead) && isTrailSurrogate(trail));
[-] 	getDecodeCodePointLength (utf16_t c)
[+] 	getDecodeCodePointLength(utf16_t c)
[-] 		return isLeadSurrogate (c) ? 2 : 1;
[+] 		return isLeadSurrogate(c) ? 2 : 1;
[-] 	getEncodeCodePointLength (utf32_t x)
[+] 	getEncodeCodePointLength(utf32_t x)
[-] 		return needSurrogate (x) ? 2 : 1;
[+] 		return needSurrogate(x) ? 2 : 1;
[-] 	decodeCodePoint (const utf16_t* p)
[+] 	decodeCodePoint(const utf16_t* p)
[-] 		return isLeadSurrogate (*p) ? getSurrogateCodePoint (p [0], p [1]) : (uint16_t) *p;
[+] 		return isLeadSurrogate(*p) ? getSurrogateCodePoint(p[0], p[1]) : (uint16_t)*p;
[-] 	encodeCodePoint (
[+] 	encodeCodePoint(
[-] 		if (!needSurrogate (x))
[+] 		if (!needSurrogate(x))
[-] 			*p = (utf16_t) x;
[+] 			*p = (utf16_t)x;
[-] 			p [0] = getLeadSurrogate (x);
[+] 			p[0] = getLeadSurrogate(x);
[-] 			p [1] = getTrailSurrogate (x);
[+] 			p[1] = getTrailSurrogate(x);
[-] 	calcCodePointCount (
[+] 	calcCodePointCount(
[-] 		return calcUtfCodePointCount <Utf16> (p, length);
[+] 		return calcUtfCodePointCount<Utf16> (p, length);
[-] 	getUtfKind ()
[+] 	getUtfKind()
[-] 	getBom ()
[+] 	getBom()
[-] 		static uint8_t bom [] = { 0xfe, 0xff };
[+] 		static uint8_t bom[] = { 0xfe, 0xff };
[-] 	getDecodeCodePointLength (utf16_t c)
[+] 	getDecodeCodePointLength(utf16_t c)
[-] 		return isTrailSurrogate (c) ? 2 : 1;
[+] 		return isTrailSurrogate(c) ? 2 : 1;
[-] 	decodeCodePoint (const utf16_t* p)
[+] 	decodeCodePoint(const utf16_t* p)
[-] 		return isTrailSurrogate (*p) ? getSurrogateCodePoint (p [1], p [0]) : (uint16_t) *p;
[+] 		return isTrailSurrogate(*p) ? getSurrogateCodePoint(p[1], p[0]) : (uint16_t)*p;
[-] 	encodeCodePoint (
[+] 	encodeCodePoint(
[-] 		if (!needSurrogate (x))
[+] 		if (!needSurrogate(x))
[-] 			*p = (utf16_t) x;
[+] 			*p = (utf16_t)x;
[-] 			p [0] = getTrailSurrogate (x);
[+] 			p[0] = getTrailSurrogate(x);
[-] 			p [1] = getLeadSurrogate (x);
[+] 			p[1] = getLeadSurrogate(x);
[-] 	calcCodePointCount (
[+] 	calcCodePointCount(
[-] 		return calcUtfCodePointCount <Utf16_be> (p, length);
[+] 		return calcUtfCodePointCount<Utf16_be> (p, length);
[-] 	getUtfKind ()
[+] 	getUtfKind()
[-] 	getBom ()
[+] 	getBom()
[-] 		static uint8_t bom [] = { 0xff, 0xfe, 0x00, 0x00 };
[+] 		static uint8_t bom[] = { 0xff, 0xfe, 0x00, 0x00 };
[-] 	getBomLength ()
[+] 	getBomLength()
[-] 	getDecodeCodePointLength (utf32_t c)
[+] 	getDecodeCodePointLength(utf32_t c)
[-] 	getEncodeCodePointLength (utf32_t x)
[+] 	getEncodeCodePointLength(utf32_t x)
[-] 	decodeCodePoint (const utf32_t* p)
[+] 	decodeCodePoint(const utf32_t* p)
[-] 	encodeCodePoint (
[+] 	encodeCodePoint(
[-] 	calcCodePointCount (
[+] 	calcCodePointCount(
[-] 	getUtfKind ()
[+] 	getUtfKind()
[-] 	getBom ()
[+] 	getBom()
[-] 		static uint8_t bom [] = { 0x00, 0x00, 0xfe, 0xff };
[+] 		static uint8_t bom[] = { 0x00, 0x00, 0xfe, 0xff };
[-] 	decodeCodePoint (const utf32_t* p)
[+] 	decodeCodePoint(const utf32_t* p)
[-] 		return sl::swapByteOrder32 (*p);
[+] 		return sl::swapByteOrder32(*p);
[-] 	encodeCodePoint (
[+] 	encodeCodePoint(
[-] 		*p = sl::swapByteOrder32 (x);
[+] 		*p = sl::swapByteOrder32(x);
[-] 	typename CaseOp = sl::NoOp <utf32_t>
[+] 	typename CaseOp = sl::NoOp<utf32_t>
[-] 	calcRequiredLength (
[+] 	calcRequiredLength(
[-] 			size_t srcCodePointLength = SrcEncoding::getDecodeCodePointLength (*p);
[+] 			size_t srcCodePointLength = SrcEncoding::getDecodeCodePointLength(*p);
[-] 			utf32_t x = CaseOp () (SrcEncoding::decodeCodePoint (p));
[+] 			utf32_t x = CaseOp() (SrcEncoding::decodeCodePoint(p));
[-] 			size_t dstCodePointLength = DstEncoding::getEncodeCodePointLength (x);
[+] 			size_t dstCodePointLength = DstEncoding::getEncodeCodePointLength(x);
[-] 	convert (
[+] 	convert(
[-] 			size_t srcCodePointLength = SrcEncoding::getDecodeCodePointLength (*src);
[+] 			size_t srcCodePointLength = SrcEncoding::getDecodeCodePointLength(*src);
[-] 			utf32_t x = CaseOp () (SrcEncoding::decodeCodePoint (src));
[+] 			utf32_t x = CaseOp() (SrcEncoding::decodeCodePoint(src));
[-] 			size_t dstCodePointLength = DstEncoding::getEncodeCodePointLength (x);
[+] 			size_t dstCodePointLength = DstEncoding::getEncodeCodePointLength(x);
[-] 			DstEncoding::encodeCodePoint (dst, x);
[+] 			DstEncoding::encodeCodePoint(dst, x);
[-] 	convert (
[+] 	convert(
[-] 			size_t srcCodePointLength = SrcEncoding::getDecodeCodePointLength (*src);
[+] 			size_t srcCodePointLength = SrcEncoding::getDecodeCodePointLength(*src);
[-] 			utf32_t x = CaseOp () (SrcEncoding::decodeCodePoint (src));
[+] 			utf32_t x = CaseOp() (SrcEncoding::decodeCodePoint(src));
[-] 			size_t dstCodePointLength = DstEncoding::getEncodeCodePointLength (x);
[+] 			size_t dstCodePointLength = DstEncoding::getEncodeCodePointLength(x);
[-] 			DstEncoding::encodeCodePoint (dst, x);
[+] 			DstEncoding::encodeCodePoint(dst, x);
[-] 			*cpl++ = (uchar_t) srcCodePointLength;
[+] 			*cpl++ = (uchar_t)srcCodePointLength;
[-] 	typename CaseOp = sl::NoOp <utf32_t>
[+] 	typename CaseOp = sl::NoOp<utf32_t>
[-] 	calcRequiredLength (
[+] 	calcRequiredLength(
[-] 			size_t srcCodePointLength = SrcEncoding::getDecodeCodePointLength (*p);
[+] 			size_t srcCodePointLength = SrcEncoding::getDecodeCodePointLength(*p);
[-] 	convert (
[+] 	convert(
[-] 			size_t srcCodePointLength = SrcEncoding::getDecodeCodePointLength (*src);
[+] 			size_t srcCodePointLength = SrcEncoding::getDecodeCodePointLength(*src);
[-] 			utf32_t x = CaseOp () (SrcEncoding::decodeCodePoint (src));
[+] 			utf32_t x = CaseOp() (SrcEncoding::decodeCodePoint(src));
[-] 			*dst = (char) x;
[+] 			*dst = (char)x;
[-] 	typename CaseOp = sl::NoOp <utf32_t>
[+] 	typename CaseOp = sl::NoOp<utf32_t>
[-] 	calcRequiredLength (
[+] 	calcRequiredLength(
[-] 			utf32_t x = CaseOp () ((uchar_t) *p); // don't propagate sign bit
[+] 			utf32_t x = CaseOp() ((uchar_t)*p); // don't propagate sign bit
[-] 			size_t dstCodePointLength = DstEncoding::getEncodeCodePointLength (x);
[+] 			size_t dstCodePointLength = DstEncoding::getEncodeCodePointLength(x);
[-] 	convert (
[+] 	convert(
[-] 			utf32_t x = CaseOp () ((uchar_t) *src); // don't propagate sign bit
[+] 			utf32_t x = CaseOp() ((uchar_t)*src); // don't propagate sign bit
[-] 			size_t dstCodePointLength = DstEncoding::getEncodeCodePointLength (x);
[+] 			size_t dstCodePointLength = DstEncoding::getEncodeCodePointLength(x);
[-] 			DstEncoding::encodeCodePoint (dst, x);
[+] 			DstEncoding::encodeCodePoint(dst, x);
[-] 	convert (
[+] 	convert(
[-] 			utf32_t x = CaseOp () ((uchar_t) *src); // don't propagate sign bit
[+] 			utf32_t x = CaseOp() ((uchar_t)*src); // don't propagate sign bit
[-] 			size_t dstCodePointLength = DstEncoding::getEncodeCodePointLength (x);
[+] 			size_t dstCodePointLength = DstEncoding::getEncodeCodePointLength(x);
[-] 			DstEncoding::encodeCodePoint (dst, x);
[+] 			DstEncoding::encodeCodePoint(dst, x);
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_err\axl_err_Errno.h
----------------------
[-] AXL_SL_DEFINE_GUID (
[+] AXL_SL_DEFINE_GUID(
[-] 	getErrorDescription (int code);
[+] 	getErrorDescription(int code);
[-] 	getErrorDescription (const ErrorRef& error)
[+] 	getErrorDescription(const ErrorRef& error)
[-] 		return getErrorDescription (error->m_code);
[+] 		return getErrorDescription(error->m_code);
[-] 	Errno ()
[+] 	Errno()
[-] 	Errno (int code)
[+] 	Errno(int code)
[-] 		create (code);
[+] 		create(code);
[-] 	create (int code)
[+] 	create(int code)
[-] 		return createSimpleError (g_errnoGuid, code);
[+] 		return createSimpleError(g_errnoGuid, code);
[-] setErrno (int code)
[+] setErrno(int code)
[-] 	return setError (Errno (code));
[+] 	return setError(Errno(code));
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_err\axl_err_Error.h
----------------------
[-] 	isKindOf (
[+] 	isKindOf(
[-] 	isStack () const
[+] 	isStack() const
[-] 			m_size >= sizeof (ErrorHdr) * 2 &&
[+] 			m_size >= sizeof(ErrorHdr)* 2 &&
[-] 			isKindOf (g_stdErrorGuid, StdErrorCode_Stack);
[+] 			isKindOf(g_stdErrorGuid, StdErrorCode_Stack);
[-] 	isStackTopKindOf (
[+] 	isStackTopKindOf(
[-] 		return isStack () && (this + 1)->isKindOf (guid, code);
[+] 		return isStack() && (this + 1)->isKindOf(guid, code);
[-] 	getDescription () const;
[+] 	getDescription() const;
[-] 		return AXL_MAX (error->m_size, sizeof (ErrorHdr));
[+] 		return AXL_MAX(error->m_size, sizeof(ErrorHdr));
[-] 	sizeof (ErrorHdr),
[+] 	sizeof(ErrorHdr),
[-] class ErrorRef: public ref::BufRef <ErrorHdr, SizeOfError>
[+] class ErrorRef: public ref::BufRef<ErrorHdr, SizeOfError>
[-] 	typedef ref::BufRef <ErrorHdr, SizeOfError> BaseType;
[+] 	typedef ref::BufRef<ErrorHdr, SizeOfError> BaseType;
[-] 	ErrorRef ()
[+] 	ErrorRef()
[-] 	ErrorRef (ErrorRef&& src):
[+] 	ErrorRef(ErrorRef&& src):
[-] 		BaseType (std::move (src))
[+] 		BaseType(std::move(src))
[-] 	ErrorRef (const ErrorRef& src):
[+] 	ErrorRef(const ErrorRef& src):
[-] 		BaseType (src)
[+] 		BaseType(src)
[-] 	ErrorRef (const ErrorHdr* src):
[+] 	ErrorRef(const ErrorHdr* src):
[-] 		BaseType (src)
[+] 		BaseType(src)
[-] 	ErrorRef (uint_t code);
[+] 	ErrorRef(uint_t code);
[-] 	ErrorRef (
[+] 	ErrorRef(
[-] 		this->move (std::move (src));
[+] 		this->move(std::move(src));
[-] 		attach (src);
[+] 		attach(src);
[-] 	isKindOf (
[+] 	isKindOf(
[-] 		return !isEmpty () && m_p->isKindOf (guid, code);
[+] 		return !isEmpty() && m_p->isKindOf(guid, code);
[-] 	getDescription () const;
[+] 	getDescription() const;
[-] class Error: public ref::Buf <ErrorHdr, SizeOfError, ErrorRef>
[+] class Error: public ref::Buf<ErrorHdr, SizeOfError, ErrorRef>
[-] 	Error ()
[+] 	Error()
[-] 	Error (Error&& src)
[+] 	Error(Error&& src)
[-] 		copy (std::move (src));
[+] 		copy(std::move(src));
[-] 	Error (ErrorRef&& src)
[+] 	Error(ErrorRef&& src)
[-] 		copy (std::move (src));
[+] 		copy(std::move(src));
[-] 	Error (const Error& src)
[+] 	Error(const Error& src)
[-] 		copy (src);
[+] 		copy(src);
[-] 	Error (const ErrorRef& src)
[+] 	Error(const ErrorRef& src)
[-] 		copy (src);
[+] 		copy(src);
[-] 	Error (const ErrorHdr* src)
[+] 	Error(const ErrorHdr* src)
[-] 		copy (src);
[+] 		copy(src);
[-] 	Error (uint_t code)
[+] 	Error(uint_t code)
[-] 		createSystemError (code);
[+] 		createSystemError(code);
[-] 	Error (
[+] 	Error(
[-] 		createSimpleError (guid, code);
[+] 		createSimpleError(guid, code);
[-] 	Error (const sl::StringRef& string)
[+] 	Error(const sl::StringRef& string)
[-] 		createStringError (string);
[+] 		createStringError(string);
[-] 	Error (const char* string) // may be useful for overload resolving
[+] 	Error(const char* string) // may be useful for overload resolving
[-] 		createStringError (string);
[+] 		createStringError(string);
[-] 	Error (
[+] 	Error(
[-] 		setBuffer (kind, p, size);
[+] 		setBuffer(kind, p, size);
[-] 		copy (std::move (src));
[+] 		copy(std::move(src));
[-] 		copy (std::move (src));
[+] 		copy(std::move(src));
[-] 		copy (src);
[+] 		copy(src);
[-] 		copy (src);
[+] 		copy(src);
[-] 		copy (src);
[+] 		copy(src);
[-] 		createSystemError (code);
[+] 		createSystemError(code);
[-] 	push (const ErrorRef& error);
[+] 	push(const ErrorRef& error);
[-] 	pack_va (
[+] 	pack_va(
[-] 		Pack () (NULL, &packSize, va);
[+] 		Pack() (NULL, &packSize, va);
[-] 		size_t size = sizeof (ErrorHdr) + packSize;
[+] 		size_t size = sizeof(ErrorHdr) + packSize;
[-] 		createBuffer (size);
[+] 		createBuffer(size);
[-] 		Pack () (m_p + 1, &packSize, va);
[+] 		Pack() (m_p + 1, &packSize, va);
[-] 	pack (
[+] 	pack(
[-] 		AXL_VA_DECL (va, code);
[+] 		AXL_VA_DECL(va, code);
[-] 		return pack_va <Pack> (guid, code, va);
[+] 		return pack_va<Pack> (guid, code, va);
[-] 	pushPack_va (
[+] 	pushPack_va(
[-] 			return pack_va <Pack> (guid, code, va);
[+] 			return pack_va<Pack> (guid, code, va);
[-] 		error.pack_va <Pack> (guid, code, va);
[+] 		error.pack_va<Pack> (guid, code, va);
[-] 		return push (error);
[+] 		return push(error);
[-] 	pushPack (
[+] 	pushPack(
[-] 		AXL_VA_DECL (va, code);
[+] 		AXL_VA_DECL(va, code);
[-] 		return pushPack_va <Pack> (guid, code, va);
[+] 		return pushPack_va<Pack> (guid, code, va);
[-] 	format_va (
[+] 	format_va(
[-] 	format (
[+] 	format(
[-] 		AXL_VA_DECL (va, formatString);
[+] 		AXL_VA_DECL(va, formatString);
[-] 		return format_va (guid, code, formatString, va);
[+] 		return format_va(guid, code, formatString, va);
[-] 	pushFormat_va (
[+] 	pushFormat_va(
[-] 			return format_va (guid, code, formatString, va);
[+] 			return format_va(guid, code, formatString, va);
[-] 		error.format_va (guid, code, formatString, va);
[+] 		error.format_va(guid, code, formatString, va);
[-] 		return push (error);
[+] 		return push(error);
[-] 	pushFormat (
[+] 	pushFormat(
[-] 		AXL_VA_DECL (va, formatString);
[+] 		AXL_VA_DECL(va, formatString);
[-] 		return pushFormat_va (guid, code, formatString, va);
[+] 		return pushFormat_va(guid, code, formatString, va);
[-] 	createSystemError (uint_t code)
[+] 	createSystemError(uint_t code)
[-] 		return createSimpleError (g_systemErrorGuid, code);
[+] 		return createSimpleError(g_systemErrorGuid, code);
[-] 	createSimpleError (
[+] 	createSimpleError(
[-] 	pushSimpleError (
[+] 	pushSimpleError(
[-] 			return createSimpleError (guid, code);
[+] 			return createSimpleError(guid, code);
[-] 		error.createSimpleError (guid, code);
[+] 		error.createSimpleError(guid, code);
[-] 		return push (error);
[+] 		return push(error);
[-] 	createStringError (const sl::StringRef& string);
[+] 	createStringError(const sl::StringRef& string);
[-] 	pushStringError (const sl::StringRef& string)
[+] 	pushStringError(const sl::StringRef& string)
[-] 			return createStringError (string);
[+] 			return createStringError(string);
[-] 		error.createStringError (string);
[+] 		error.createStringError(string);
[-] 		return push (error);
[+] 		return push(error);
[-] 	formatStringError_va (
[+] 	formatStringError_va(
[-] 	formatStringError (
[+] 	formatStringError(
[-] 		AXL_VA_DECL (va, formatString);
[+] 		AXL_VA_DECL(va, formatString);
[-] 		return formatStringError_va (formatString, va);
[+] 		return formatStringError_va(formatString, va);
[-] 	pushFormatStringError_va (
[+] 	pushFormatStringError_va(
[-] 			return formatStringError_va (formatString, va);
[+] 			return formatStringError_va(formatString, va);
[-] 		error.formatStringError_va (formatString, va);
[+] 		error.formatStringError_va(formatString, va);
[-] 		return push (error);
[+] 		return push(error);
[-] 	pushFormatStringError (
[+] 	pushFormatStringError(
[-] 		AXL_VA_DECL (va, formatString);
[+] 		AXL_VA_DECL(va, formatString);
[-] 		return pushFormatStringError_va (formatString, va);
[+] 		return pushFormatStringError_va(formatString, va);
[-] ErrorRef::ErrorRef (uint_t code):
[+] ErrorRef::ErrorRef(uint_t code):
[-] 	BaseType (Error (code))
[+] 	BaseType(Error(code))
[-] ErrorRef::ErrorRef (
[+] ErrorRef::ErrorRef(
[-] 	BaseType (Error (guid, code))
[+] 	BaseType(Error(guid, code))
[-] getLastError ();
[+] getLastError();
[-] setError (const ErrorRef& error);
[+] setError(const ErrorRef& error);
[-] pushError (const ErrorRef& error);
[+] pushError(const ErrorRef& error);
[-] getLastErrorDescription ();
[+] getLastErrorDescription();
[-] setPackError_va (
[+] setPackError_va(
[-] 	size_t result = error.pack_va <Pack> (guid, code, va);
[+] 	size_t result = error.pack_va<Pack> (guid, code, va);
[-] 	return result != -1 ? setError (error) : -1;
[+] 	return result != -1 ? setError(error) : -1;
[-] setPackError (
[+] setPackError(
[-] 	AXL_VA_DECL (va, code);
[+] 	AXL_VA_DECL(va, code);
[-] 	return setPackError_va <Pack> (guid, code, va);
[+] 	return setPackError_va<Pack> (guid, code, va);
[-] pushPackError_va (
[+] pushPackError_va(
[-] 	size_t result = error.pack_va <Pack> (guid, code, va);
[+] 	size_t result = error.pack_va<Pack> (guid, code, va);
[-] 	return result != -1 ? pushError (error) : -1;
[+] 	return result != -1 ? pushError(error) : -1;
[-] pushPackError (
[+] pushPackError(
[-] 	AXL_VA_DECL (va, code);
[+] 	AXL_VA_DECL(va, code);
[-] 	return pushPackError_va <Pack> (guid, code, va);
[+] 	return pushPackError_va<Pack> (guid, code, va);
[-] setFormatError_va (
[+] setFormatError_va(
[-] setFormatError (
[+] setFormatError(
[-] 	AXL_VA_DECL (va, formatString);
[+] 	AXL_VA_DECL(va, formatString);
[-] 	return setFormatError_va (guid, code, formatString, va);
[+] 	return setFormatError_va(guid, code, formatString, va);
[-] pushFormatError_va (
[+] pushFormatError_va(
[-] pushFormatError (
[+] pushFormatError(
[-] 	AXL_VA_DECL (va, formatString);
[+] 	AXL_VA_DECL(va, formatString);
[-] 	return pushFormatError_va (guid, code, formatString, va);
[+] 	return pushFormatError_va(guid, code, formatString, va);
[-] setError (
[+] setError(
[-] 	return setError (Error (guid, code));
[+] 	return setError(Error(guid, code));
[-] pushError (
[+] pushError(
[-] 	return pushError (Error (guid, code));
[+] 	return pushError(Error(guid, code));
[-] setError (const sl::StringRef& string);
[+] setError(const sl::StringRef& string);
[-] pushError (const sl::StringRef& string);
[+] pushError(const sl::StringRef& string);
[-] setFormatStringError_va (
[+] setFormatStringError_va(
[-] setFormatStringError (
[+] setFormatStringError(
[-] 	AXL_VA_DECL (va, formatString);
[+] 	AXL_VA_DECL(va, formatString);
[-] 	return setFormatStringError_va (formatString, va);
[+] 	return setFormatStringError_va(formatString, va);
[-] pushFormatStringError_va (
[+] pushFormatStringError_va(
[-] pushFormatStringError (
[+] pushFormatStringError(
[-] 	AXL_VA_DECL (va, formatString);
[+] 	AXL_VA_DECL(va, formatString);
[-] 	return pushFormatStringError_va (formatString, va);
[+] 	return pushFormatStringError_va(formatString, va);
[-] fail (
[+] fail(
[-] 	setError (error);
[+] 	setError(error);
[-] fail (const ErrorRef& error)
[+] fail(const ErrorRef& error)
[-] 	return fail <bool> (false, error);
[+] 	return fail<bool> (false, error);
[-] setLastSystemError ()
[+] setLastSystemError()
[-] 	return setError (getLastSystemErrorCode ());
[+] 	return setError(getLastSystemErrorCode());
[-] failWithLastSystemError (T failResult)
[+] failWithLastSystemError(T failResult)
[-] 	setLastSystemError ();
[+] 	setLastSystemError();
[-] failWithLastSystemError ()
[+] failWithLastSystemError()
[-] 	return failWithLastSystemError <bool> (false);
[+] 	return failWithLastSystemError<bool> (false);
[-] completeWithSystemError (
[+] completeWithSystemError(
[-] 		setError (errorCode);
[+] 		setError(errorCode);
[-] completeWithSystemError (
[+] completeWithSystemError(
[-] 	return completeWithSystemError <bool> (result != 0, false, errorCode);
[+] 	return completeWithSystemError<bool> (result != 0, false, errorCode);
[-] complete (
[+] complete(
[-] 		setLastSystemError ();
[+] 		setLastSystemError();
[-] complete (int result)
[+] complete(int result)
[-] 	return complete <bool> (result != 0, false);
[+] 	return complete<bool> (result != 0, false);
[-] 	getErrorDescription (const ErrorRef& error) = 0;
[+] 	getErrorDescription(const ErrorRef& error) = 0;
[-] 	getErrorDescription (const ErrorRef& error);
[+] 	getErrorDescription(const ErrorRef& error);
[-] 	getStackErrorDescription (const ErrorRef& error);
[+] 	getStackErrorDescription(const ErrorRef& error);
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_err\axl_err_ErrorMgr.h
----------------------
[-] 	routeError (const ErrorHdr* error) = 0;
[+] 	routeError(const ErrorHdr* error) = 0;
[-] 	sl::DuckTypeHashTable <sl::Guid, ErrorProvider*> m_providerMap;
[+] 	sl::DuckTypeHashTable<sl::Guid, ErrorProvider*> m_providerMap;
[-] 	ErrorMgr ();
[+] 	ErrorMgr();
[-] 	registerProvider (
[+] 	registerProvider(
[-] 	findProvider (const sl::Guid& guid);
[+] 	findProvider(const sl::Guid& guid);
[-] 	getLastError ();
[+] 	getLastError();
[-] 	setError (const ErrorRef& error);
[+] 	setError(const ErrorRef& error);
[-] 	getForwardRouter ()
[+] 	getForwardRouter()
[-] 	setForwardRouter (ErrorRouter* router)
[+] 	setForwardRouter(ErrorRouter* router)
[-] 		ASSERT (!m_forwardRouter && router != this);
[+] 		ASSERT(!m_forwardRouter && router != this);
[-] 	routeError (const ErrorHdr* error)
[+] 	routeError(const ErrorHdr* error)
[-] 		setError (error);
[+] 		setError(error);
[-] 	findThreadEntry ()
[+] 	findThreadEntry()
[-] 		return (ThreadEntry*) (void*) sys::getTlsMgr ()->getSlotValue (m_tlsSlot);
[+] 		return (ThreadEntry*)(void*)sys::getTlsMgr()->getSlotValue(m_tlsSlot);
[-] 	getThreadEntry ();
[+] 	getThreadEntry();
[-] getErrorMgr ()
[+] getErrorMgr()
[-] 	return sl::getSingleton <ErrorMgr> ();
[+] 	return sl::getSingleton<ErrorMgr> ();
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_err\axl_err_SystemError.h
----------------------
[-] getLastSystemErrorCode ()
[+] getLastSystemErrorCode()
[-] 	return ::GetLastError ();
[+] 	return ::GetLastError();
[-] getLastSystemErrorCode ()
[+] getLastSystemErrorCode()
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_fsm\axl_fsm_Dfa.h
----------------------
[-] 	sl::List <DfaTransition> m_transitionList;
[+] 	sl::List<DfaTransition> m_transitionList;
[-] 	DfaState ();
[+] 	DfaState();
[-] 	addNfaState (NfaState* state);
[+] 	addNfaState(NfaState* state);
[-] 	makeEpsilonClosure ();
[+] 	makeEpsilonClosure();
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_fsm\axl_fsm_Nfa.h
----------------------
[-] 	MatchCondition ();
[+] 	MatchCondition();
[-] 	addChar (uchar_t c);
[+] 	addChar(uchar_t c);
[-] 	NfaState ();
[+] 	NfaState();
[-] 	createEpsilonLink (NfaState* outState);
[+] 	createEpsilonLink(NfaState* outState);
[-] 	createEpsilonLink (
[+] 	createEpsilonLink(
[-] 	createCharMatch (
[+] 	createCharMatch(
[-] 	sl::Array <NfaState*> m_stateArray;
[+] 	sl::Array<NfaState*> m_stateArray;
[-] 	addState (NfaState* state);
[+] 	addState(NfaState* state);
[-] 	cmp (const NfaStateSet& set) const
[+] 	cmp(const NfaStateSet& set) const
[-] 		return m_stateSet.cmp (set.m_stateSet);
[+] 		return m_stateSet.cmp(set.m_stateSet);
[-] 	isEqual (const NfaStateSet& set) const
[+] 	isEqual(const NfaStateSet& set) const
[-] 		return m_stateSet.isEqual (set.m_stateSet);
[+] 		return m_stateSet.isEqual(set.m_stateSet);
[-] 	hash () const
[+] 	hash() const
[-] 		return m_stateSet.hash ();
[+] 		return m_stateSet.hash();
[-] class NfaStateSetMap: public sl::HashTable <
[+] class NfaStateSetMap: public sl::HashTable<
[-] 	sl::HashDuckType <NfaStateSet>,
[+] 	sl::HashDuckType<NfaStateSet>,
[-] 	sl::EqDuckType <NfaStateSet>
[+] 	sl::EqDuckType<NfaStateSet>
[-] 	sl::List <NfaTransition> m_transitionList;
[+] 	sl::List<NfaTransition> m_transitionList;
[-] 	NfaTransition* m_transitionMap [256];
[+] 	NfaTransition* m_transitionMap[256];
[-] 	clear ();
[+] 	clear();
[-] 	sl::ConstList <NfaTransition>
[+] 	sl::ConstList<NfaTransition>
[-] 	getTransitionList ()
[+] 	getTransitionList()
[-] 	addMatchState (NfaState* state);
[+] 	addMatchState(NfaState* state);
[-] 	finalize ();
[+] 	finalize();
[-] 	addMatchCharTransition (
[+] 	addMatchCharTransition(
[-] 	addMatchCharSetTransition (
[+] 	addMatchCharSetTransition(
[-] 	addMatchAnyTransition (NfaState* outState);
[+] 	addMatchAnyTransition(NfaState* outState);
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_fsm\axl_fsm_Regex.h
----------------------
[-] 	findName (const sl::StringRef& name) = 0;
[+] 	findName(const sl::StringRef& name) = 0;
[-] 	sl::List <NfaState> m_nfaStateList;
[+] 	sl::List<NfaState> m_nfaStateList;
[-] 	sl::Array <NfaState*> m_nfaStateArray;
[+] 	sl::Array<NfaState*> m_nfaStateArray;
[-] 	sl::List <DfaState> m_dfaStateList;
[+] 	sl::List<DfaState> m_dfaStateList;
[-] 	sl::Array <DfaState*> m_dfaStateArray;
[+] 	sl::Array<DfaState*> m_dfaStateArray;
[-] 	Regex ()
[+] 	Regex()
[-] 	isEmpty () const
[+] 	isEmpty() const
[-] 		return m_nfaStateList.isEmpty ();
[+] 		return m_nfaStateList.isEmpty();
[-] 	getGroupCount () const
[+] 	getGroupCount() const
[-] 	sl::ConstList <NfaState>
[+] 	sl::ConstList<NfaState>
[-] 	getNfaStateList () const
[+] 	getNfaStateList() const
[-] 	sl::Array <NfaState*>
[+] 	sl::Array<NfaState*>
[-] 	getNfaStateArray () const
[+] 	getNfaStateArray() const
[-] 	sl::ConstList <DfaState>
[+] 	sl::ConstList<DfaState>
[-] 	getDfaStateList () const
[+] 	getDfaStateList() const
[-] 	sl::Array <DfaState*>
[+] 	sl::Array<DfaState*>
[-] 	getDfaStateArray () const
[+] 	getDfaStateArray() const
[-] 	clear ();
[+] 	clear();
[-] 	compile (const sl::StringRef& regexp);
[+] 	compile(const sl::StringRef& regexp);
[-] 	match (const sl::StringRef& string);
[+] 	match(const sl::StringRef& string);
[-] 	print () const;
[+] 	print() const;
[-] 		isSpecialChar (char c)
[+] 		isSpecialChar(char c)
[-] 		isValidSingle ();
[+] 		isValidSingle();
[-] 	RegexCompiler (
[+] 	RegexCompiler(
[-] 		construct (0, regex, nameMgr);
[+] 		construct(0, regex, nameMgr);
[-] 	RegexCompiler (
[+] 	RegexCompiler(
[-] 		construct (flags, regex, nameMgr);
[+] 		construct(flags, regex, nameMgr);
[-] 	compile (
[+] 	compile(
[-] 	incrementalCompile (
[+] 	incrementalCompile(
[-] 	finalize ();
[+] 	finalize();
[-] 	construct (
[+] 	construct(
[-] 	readHexEscapeSequence (uchar_t* c);
[+] 	readHexEscapeSequence(uchar_t* c);
[-] 	readEscapeSequence (uchar_t* c);
[+] 	readEscapeSequence(uchar_t* c);
[-] 	readLiteral (sl::String* string);
[+] 	readLiteral(sl::String* string);
[-] 	readHexLiteral (sl::String* string);
[+] 	readHexLiteral(sl::String* string);
[-] 	readIdentifier (sl::String* name);
[+] 	readIdentifier(sl::String* name);
[-] 	readQuantifier (size_t* count);
[+] 	readQuantifier(size_t* count);
[-] 	getToken (Token* token);
[+] 	getToken(Token* token);
[-] 	expectSpecialChar (char c);
[+] 	expectSpecialChar(char c);
[-] 	expectEof ();
[+] 	expectEof();
[-] 	expression ();
[+] 	expression();
[-] 	concat ();
[+] 	concat();
[-] 	repeat ();
[+] 	repeat();
[-] 	question (NfaState* start);
[+] 	question(NfaState* start);
[-] 	star (NfaState* start);
[+] 	star(NfaState* start);
[-] 	plus (NfaState* start);
[+] 	plus(NfaState* start);
[-] 	quantify (
[+] 	quantify(
[-] 	single ();
[+] 	single();
[-] 	charClass ();
[+] 	charClass();
[-] 	stdCharClass (uint_t c);
[+] 	stdCharClass(uint_t c);
[-] 	namedRegex (const sl::StringRef& name);
[+] 	namedRegex(const sl::StringRef& name);
[-] 	stdCharClass (
[+] 	stdCharClass(
[-] 	literal (const sl::StringRef& string);
[+] 	literal(const sl::StringRef& string);
[-] 	ch (uint_t c);
[+] 	ch(uint_t c);
[-] 	ch (
[+] 	ch(
[-] 	any ();
[+] 	any();
[-] 	clone (
[+] 	clone(
[-] 	charClassItem (sl::BitMap* charSet);
[+] 	charClassItem(sl::BitMap* charSet);
[-] 	capturingGroup ();
[+] 	capturingGroup();
[-] 	nonCapturingGroup ();
[+] 	nonCapturingGroup();
[-] 	assignNfaIds ();
[+] 	assignNfaIds();
[-] 	assignDfaIds ();
[+] 	assignDfaIds();
[-] 	makeDfa ();
[+] 	makeDfa();
[-] 	minimizeDfa ();
[+] 	minimizeDfa();
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_fsm\axl_fsm_StdRegexNameMgr.h
----------------------
[-] 	sl::StringHashTable <sl::String> m_nameMap;
[+] 	sl::StringHashTable<sl::String> m_nameMap;
[-] 	clear ()
[+] 	clear()
[-] 		m_nameMap.clear ();
[+] 		m_nameMap.clear();
[-] 	findName (const sl::StringRef& name)
[+] 	findName(const sl::StringRef& name)
[-] 		return m_nameMap.findValue (name, NULL);
[+] 		return m_nameMap.findValue(name, NULL);
[-] 	addName (
[+] 	addName(
[-] 		m_nameMap [name] = source;
[+] 		m_nameMap[name] = source;
[-] 	removeName (const sl::StringRef& name)
[+] 	removeName(const sl::StringRef& name)
[-] 		return m_nameMap.eraseKey (name);
[+] 		return m_nameMap.eraseKey(name);
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_g\axl_g_Module.h
----------------------
[-] 	finalize () = 0;
[+] 	finalize() = 0;
[-] 		ref::Ptr <Finalizer> m_finalizer;
[+] 		ref::Ptr<Finalizer> m_finalizer;
[-] 	sl::List <FinalizerEntry> m_finalizerList;
[+] 	sl::List<FinalizerEntry> m_finalizerList;
[-] 	Module ();
[+] 	Module();
[-] 	~Module ();
[+] 	~Module();
[-] 	getTag ()
[+] 	getTag()
[-] 	setTag (const char* tag)
[+] 	setTag(const char* tag)
[-] 	getTag ()
[+] 	getTag()
[-] 	setTag (const char* tag)
[+] 	setTag(const char* tag)
[-] 	getModuleHandle ()
[+] 	getModuleHandle()
[-] 	getSystemInfo ()
[+] 	getSystemInfo()
[-] 	getMemTracker ()
[+] 	getMemTracker()
[-] 	addFinalizer (const ref::Ptr <Finalizer>& finalizer);
[+] 	addFinalizer(const ref::Ptr<Finalizer>& finalizer);
[-] getModule ()
[+] getModule()
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_g\axl_g_Pch.h
----------------------
[-] #	define countof(a) (sizeof (a) / sizeof ((a) [0]))
[+] #	define countof(a) (sizeof(a) / sizeof((a) [0]))
[-] #	define lengthof(s) (countof (s) - 1)
[+] #	define lengthof(s) (countof(s) - 1)
[-] 		((T*) ((char*) (p) - offsetof (T, f)))
[+] 		((T*)((char*)(p) - offsetof(T, f)))
[-] strlen_s (const char* p)
[+] strlen_s(const char* p)
[-] 	return p ? strlen (p) : 0;
[+] 	return p ? strlen(p) : 0;
[-] wcslen_s (const wchar_t* p)
[+] wcslen_s(const wchar_t* p)
[-] 	return p ? wcslen (p) : 0;
[+] 	return p ? wcslen(p) : 0;
[-] #	define AXL_SELECT_ANY  __declspec (selectany)
[+] #	define AXL_SELECT_ANY  __declspec(selectany)
[-] #	define AXL_EXPORT      __declspec (dllexport)
[+] #	define AXL_EXPORT      __declspec(dllexport)
[-] #		define AXL_CDECL   __attribute__ ((cdecl))
[+] #		define AXL_CDECL   __attribute__((cdecl))
[-] #		define AXL_STDCALL __attribute__ ((stdcall))
[+] #		define AXL_STDCALL __attribute__((stdcall))
[-] #	define AXL_SELECT_ANY  __attribute__ ((weak))
[+] #	define AXL_SELECT_ANY  __attribute__((weak))
[-] #	define AXL_EXPORT      __attribute__ ((visibility ("default")))
[+] #	define AXL_EXPORT      __attribute__((visibility("default")))
[-] #	define AXL_GCC_ALIGN(n) __attribute__((aligned (n)))
[+] #	define AXL_GCC_ALIGN(n) __attribute__((aligned(n)))
[-] #		if (__has_attribute (ms_struct))
[+] #		if (__has_attribute(ms_struct))
[-] #		if (__has_feature (address_sanitizer))
[+] #		if (__has_feature(address_sanitizer))
[-] #	elif (defined (__SANITIZE_ADDRESS__))
[+] #	elif (defined(__SANITIZE_ADDRESS__))
[-] 	Class (const Class&);  \
[+] 	Class(const Class&);  \
[-] #define AXL_ITOA(n)  AXL_ITOA_IMPL (n)
[+] #define AXL_ITOA(n)  AXL_ITOA_IMPL(n)
[-] #	define AXL_TODO(s) __pragma (message (AXL_SRC_POS ": TODO: " s))
[+] #	define AXL_TODO(s) __pragma(message(AXL_SRC_POS ": TODO: " s))
[-] #	define AXL_PRAGMA_IMPL(p) _Pragma (#p)
[+] #	define AXL_PRAGMA_IMPL(p) _Pragma(#p)
[-] #	define AXL_TODO(s) AXL_PRAGMA_IMPL (message "TODO: " s)
[+] #	define AXL_TODO(s) AXL_PRAGMA_IMPL(message "TODO: " s)
[-] 	axl_va_list ()
[+] 	axl_va_list()
[-] 	axl_va_list (const axl_va_list& src)
[+] 	axl_va_list(const axl_va_list& src)
[-] 		copy (src);
[+] 		copy(src);
[-] 	axl_va_list (va_list va)
[+] 	axl_va_list(va_list va)
[-] 		copy (va);
[+] 		copy(va);
[-] 	~axl_va_list ()
[+] 	~axl_va_list()
[-] 		end ();
[+] 		end();
[-] 		copy (src);
[+] 		copy(src);
[-] 		copy (va);
[+] 		copy(va);
[-] 		ASSERT (m_isInitialized);
[+] 		ASSERT(m_isInitialized);
[-] 	initialize ()
[+] 	initialize()
[-] 	end ()
[+] 	end()
[-] 			va_end (m_va);
[+] 			va_end(m_va);
[-] 	copy (const axl_va_list& src)
[+] 	copy(const axl_va_list& src)
[-] 		copy ((va_list&) src.m_va);
[+] 		copy((va_list&) src.m_va);
[-] 	copy (va_list va)
[+] 	copy(va_list va)
[-] 		end ();
[+] 		end();
[-] 		va_copy (m_va, va);
[+] 		va_copy(m_va, va);
[-] 	arg ()
[+] 	arg()
[-] 		ASSERT (m_isInitialized);
[+] 		ASSERT(m_isInitialized);
[-] 		return va_arg (m_va, T);
[+] 		return va_arg(m_va, T);
[-] 	va_start (*(va).initialize (), a)
[+] 	va_start(*(va).initialize(), a)
[-] 	((va).arg <T> ())
[+] 	((va).arg<T> ())
[-] 	((va).end ())
[+] 	((va).end())
[-] 	axl_va_start (va, a);
[+] 	axl_va_start(va, a);
[-] axl_trace_va (
[+] axl_trace_va(
[-] axl_trace_va (
[+] axl_trace_va(
[-] 	vfprintf (axl_g_traceFile, formatString, va);
[+] 	vfprintf(axl_g_traceFile, formatString, va);
[-] 	fflush (axl_g_traceFile);
[+] 	fflush(axl_g_traceFile);
[-] axl_trace (
[+] axl_trace(
[-] 	AXL_VA_DECL (va, formatString);
[+] 	AXL_VA_DECL(va, formatString);
[-] 	axl_trace_va (formatString, va);
[+] 	axl_trace_va(formatString, va);
[-] #	pragma warning (disable: 4146) // warning C4146: unary minus operator applied to unsigned type, result still unsigned
[+] #	pragma warning(disable: 4146) // warning C4146: unary minus operator applied to unsigned type, result still unsigned
[-] #	pragma warning (disable: 4267) // warning C4267: 'var' : conversion from 'size_t' to 'type', possible loss of data
[+] #	pragma warning(disable: 4267) // warning C4267: 'var' : conversion from 'size_t' to 'type', possible loss of data
[-] #	pragma warning (disable: 4355) // warning C4355: 'this' : used in base member initializer list
[+] #	pragma warning(disable: 4355) // warning C4355: 'this' : used in base member initializer list
[-] #	pragma warning (disable: 4477) // warning C4477: 'printf' : format string '...' requires an argument of type '...', but variadic argument ... has type '...'
[+] #	pragma warning(disable: 4477) // warning C4477: 'printf' : format string '...' requires an argument of type '...', but variadic argument ... has type '...'
[-] #	pragma warning (disable: 4838) // warning C4838: conversion from 'int' to 'std::size_t' requires a narrowing conversion
[+] #	pragma warning(disable: 4838) // warning C4838: conversion from 'int' to 'std::size_t' requires a narrowing conversion
[-] #		pragma comment (linker, "/NODEFAULTLIB:LIBCMT")
[+] #		pragma comment(linker, "/NODEFAULTLIB:LIBCMT")
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_AnsiAttrParser.h
----------------------
[-] 	AnsiAttrParser ();
[+] 	AnsiAttrParser();
[-] 	parse (
[+] 	parse(
[-] 	clear (uint_t);
[+] 	clear(uint_t);
[-] 	setFontFlag (uint_t flag);
[+] 	setFontFlag(uint_t flag);
[-] 	clearFontFlag (uint_t flag);
[+] 	clearFontFlag(uint_t flag);
[-] 	setBoldOn (uint_t)
[+] 	setBoldOn(uint_t)
[-] 		setFontFlag (FontFlag_Bold);
[+] 		setFontFlag(FontFlag_Bold);
[-] 	setBoldOff (uint_t)
[+] 	setBoldOff(uint_t)
[-] 		clearFontFlag (FontFlag_Bold);
[+] 		clearFontFlag(FontFlag_Bold);
[-] 	setItalicOn (uint_t)
[+] 	setItalicOn(uint_t)
[-] 		setFontFlag (FontFlag_Italic);
[+] 		setFontFlag(FontFlag_Italic);
[-] 	setItalicOff (uint_t)
[+] 	setItalicOff(uint_t)
[-] 		clearFontFlag (FontFlag_Italic);
[+] 		clearFontFlag(FontFlag_Italic);
[-] 	setUnderlineOn (uint_t)
[+] 	setUnderlineOn(uint_t)
[-] 		setFontFlag (FontFlag_Underline);
[+] 		setFontFlag(FontFlag_Underline);
[-] 	setUnderlineOff (uint_t)
[+] 	setUnderlineOff(uint_t)
[-] 		clearFontFlag (FontFlag_Underline);
[+] 		clearFontFlag(FontFlag_Underline);
[-] 	setFont (uint_t font)
[+] 	setFont(uint_t font)
[-] 		ASSERT (font >= 10 && font < 20);
[+] 		ASSERT(font >= 10 && font < 20);
[-] 	setInverse (bool isInversed);
[+] 	setInverse(bool isInversed);
[-] 	setInverseOn (uint_t)
[+] 	setInverseOn(uint_t)
[-] 		setInverse (true);
[+] 		setInverse(true);
[-] 	setInverseOff (uint_t)
[+] 	setInverseOff(uint_t)
[-] 		setInverse (false);
[+] 		setInverse(false);
[-] 	setTextColor (uint_t color)
[+] 	setTextColor(uint_t color)
[-] 		ASSERT (color >= 30 && color < 38);
[+] 		ASSERT(color >= 30 && color < 38);
[-] 	setBrightTextColor (uint_t color)
[+] 	setBrightTextColor(uint_t color)
[-] 		ASSERT (color >= 90 && color < 98);
[+] 		ASSERT(color >= 90 && color < 98);
[-] 	setBaseTextColor (uint_t)
[+] 	setBaseTextColor(uint_t)
[-] 	setBackColor (uint_t color)
[+] 	setBackColor(uint_t color)
[-] 		ASSERT (color >= 40 && color < 48);
[+] 		ASSERT(color >= 40 && color < 48);
[-] 	setBrightBackColor (uint_t color)
[+] 	setBrightBackColor(uint_t color)
[-] 		ASSERT (color >= 100 && color < 108);
[+] 		ASSERT(color >= 100 && color < 108);
[-] 	setBaseBackColor (uint_t)
[+] 	setBaseBackColor(uint_t)
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_Canvas.h
----------------------
[-] 	Canvas (Engine* engine):
[+] 	Canvas(Engine* engine):
[-] 		GuiItem (engine)
[+] 		GuiItem(engine)
[-] 		m_font = engine->getStdFont (StdFontKind_Gui);
[+] 		m_font = engine->getStdFont(StdFontKind_Gui);
[-] 		m_colorAttr.setup (StdPalColor_WidgetText, StdPalColor_WidgetBack);
[+] 		m_colorAttr.setup(StdPalColor_WidgetText, StdPalColor_WidgetBack);
[-] 	setTextAttr (const TextAttr& attr)
[+] 	setTextAttr(const TextAttr& attr)
[-] 		m_font = m_font->getFontMod (attr.m_fontFlags);
[+] 		m_font = m_font->getFontMod(attr.m_fontFlags);
[-] 	drawRect (
[+] 	drawRect(
[-] 		return m_engine->drawRect (this, left, top, right, bottom, color);
[+] 		return m_engine->drawRect(this, left, top, right, bottom, color);
[-] 	drawRect (
[+] 	drawRect(
[-] 		return drawRect (left, top, right, bottom, m_colorAttr.m_backColor);
[+] 		return drawRect(left, top, right, bottom, m_colorAttr.m_backColor);
[-] 	drawRect (
[+] 	drawRect(
[-] 		return drawRect (
[+] 		return drawRect(
[-] 	drawRect (const Rect& rect)
[+] 	drawRect(const Rect& rect)
[-] 		return drawRect (
[+] 		return drawRect(
[-] 	drawAlphaRect (
[+] 	drawAlphaRect(
[-] 		return m_engine->drawAlphaRect (this, left, top, right, bottom, color, alpha);
[+] 		return m_engine->drawAlphaRect(this, left, top, right, bottom, color, alpha);
[-] 	drawAlphaRect (
[+] 	drawAlphaRect(
[-] 		return drawAlphaRect (left, top, right, bottom, m_colorAttr.m_backColor, alpha);
[+] 		return drawAlphaRect(left, top, right, bottom, m_colorAttr.m_backColor, alpha);
[-] 	drawAlphaRect (
[+] 	drawAlphaRect(
[-] 		return drawAlphaRect (
[+] 		return drawAlphaRect(
[-] 	drawAlphaRect (
[+] 	drawAlphaRect(
[-] 		return drawAlphaRect (
[+] 		return drawAlphaRect(
[-] 	drawText (
[+] 	drawText(
[-] 		return drawText_utf8 (
[+] 		return drawText_utf8(
[-] 	drawText (
[+] 	drawText(
[-] 		return drawText_utf8 (x, y, left, top, right, bottom, text);
[+] 		return drawText_utf8(x, y, left, top, right, bottom, text);
[-] 	drawText (
[+] 	drawText(
[-] 		return drawText_utf8 (point, rect, textAttr, text);
[+] 		return drawText_utf8(point, rect, textAttr, text);
[-] 	drawText (
[+] 	drawText(
[-] 		return drawText_utf8 (point, rect, text);
[+] 		return drawText_utf8(point, rect, text);
[-] 	drawText_utf8 (
[+] 	drawText_utf8(
[-] 		return m_engine->drawText_utf8 (
[+] 		return m_engine->drawText_utf8(
[-] 	drawText_utf8 (
[+] 	drawText_utf8(
[-] 		return drawText_utf8 (
[+] 		return drawText_utf8(
[-] 	drawText_utf8 (
[+] 	drawText_utf8(
[-] 		return drawText_utf8 (
[+] 		return drawText_utf8(
[-] 	drawText_utf8 (
[+] 	drawText_utf8(
[-] 		return drawText_utf8 (
[+] 		return drawText_utf8(
[-] 	drawText_utf16 (
[+] 	drawText_utf16(
[-] 		return m_engine->drawText_utf16 (
[+] 		return m_engine->drawText_utf16(
[-] 	drawText_utf16 (
[+] 	drawText_utf16(
[-] 		return drawText_utf16 (
[+] 		return drawText_utf16(
[-] 	drawText_utf16 (
[+] 	drawText_utf16(
[-] 		return drawText_utf16 (
[+] 		return drawText_utf16(
[-] 	drawText_utf16 (
[+] 	drawText_utf16(
[-] 		return drawText_utf16 (
[+] 		return drawText_utf16(
[-] 	drawText_utf32 (
[+] 	drawText_utf32(
[-] 		return m_engine->drawText_utf32 (
[+] 		return m_engine->drawText_utf32(
[-] 	drawText_utf32 (
[+] 	drawText_utf32(
[-] 		return drawText_utf32 (
[+] 		return drawText_utf32(
[-] 	drawText_utf32 (
[+] 	drawText_utf32(
[-] 		return drawText_utf32 (
[+] 		return drawText_utf32(
[-] 	drawText_utf32 (
[+] 	drawText_utf32(
[-] 		return drawText_utf32 (
[+] 		return drawText_utf32(
[-] 	drawImage (
[+] 	drawImage(
[-] 		return m_engine->drawImage (
[+] 		return m_engine->drawImage(
[-] 	drawImage (
[+] 	drawImage(
[-] 		const Rect& rect = Rect ()
[+] 		const Rect& rect = Rect()
[-] 		return drawImage (
[+] 		return drawImage(
[-] 	copyRect (
[+] 	copyRect(
[-] 		return m_engine->copyRect (
[+] 		return m_engine->copyRect(
[-] 	copyRect (
[+] 	copyRect(
[-] 		return copyRect (
[+] 		return copyRect(
[-] 	Entry* m_canvasTable [FormFactor__Count];
[+] 	Entry* m_canvasTable[FormFactor__Count];
[-] 	OffscreenCanvasCache (Engine* engine)
[+] 	OffscreenCanvasCache(Engine* engine)
[-] 		memset (m_canvasTable, 0, sizeof (m_canvasTable));
[+] 		memset(m_canvasTable, 0, sizeof(m_canvasTable));
[-] 	~OffscreenCanvasCache ()
[+] 	~OffscreenCanvasCache()
[-] 		clear ();
[+] 		clear();
[-] 	clear ()
[+] 	clear()
[-] 		for (size_t i = 0; i < countof (m_canvasTable); i++)
[+] 		for (size_t i = 0; i < countof(m_canvasTable); i++)
[-] 			if (m_canvasTable [i])
[+] 			if (m_canvasTable[i])
[-] 				AXL_MEM_DELETE (m_canvasTable [i]);
[+] 				AXL_MEM_DELETE(m_canvasTable[i]);
[-] 		memset (m_canvasTable, 0, sizeof (m_canvasTable));
[+] 		memset(m_canvasTable, 0, sizeof(m_canvasTable));
[-] 	getCanvas (
[+] 	getCanvas(
[-] 		FormFactor formFactor = getFormFactor (width, height);
[+] 		FormFactor formFactor = getFormFactor(width, height);
[-] 		ASSERT (formFactor < countof (m_canvasTable));
[+] 		ASSERT(formFactor < countof(m_canvasTable));
[-] 		Entry* entry = m_canvasTable [formFactor];
[+] 		Entry* entry = m_canvasTable[formFactor];
[-] 			entry = AXL_MEM_NEW (Entry);
[+] 			entry = AXL_MEM_NEW(Entry);
[-] 			m_canvasTable [formFactor] = entry;
[+] 			m_canvasTable[formFactor] = entry;
[-] 			sl::align <16> (width);
[+] 			sl::align<16> (width);
[-] 			sl::align <16> (height);
[+] 			sl::align<16> (height);
[-] 		bool result = m_engine->createOffscreenCanvas (&entry->m_canvas, width, height);
[+] 		bool result = m_engine->createOffscreenCanvas(&entry->m_canvas, width, height);
[-] 	getCanvas (const Size& size)
[+] 	getCanvas(const Size& size)
[-] 		return getCanvas (size.m_width, size.m_height);
[+] 		return getCanvas(size.m_width, size.m_height);
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_Color.h
----------------------
[-] getColorIndex (uint_t color)
[+] getColorIndex(uint_t color)
[-] overlayColor (
[+] overlayColor(
[-] inverseRgb (uint_t rgb)
[+] inverseRgb(uint_t rgb)
[-] 	Palette ()
[+] 	Palette()
[-] 		setup (NULL, 0);
[+] 		setup(NULL, 0);
[-] 	Palette (
[+] 	Palette(
[-] 	getColorRgb (uint_t color);
[+] 	getColorRgb(uint_t color);
[-] 	setup (
[+] 	setup(
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_ColorAttr.h
----------------------
[-] 	ColorAttr ()
[+] 	ColorAttr()
[-] 		setup (-1, -1);
[+] 		setup(-1, -1);
[-] 	ColorAttr (
[+] 	ColorAttr(
[-] 		setup (foreColor, backColor);
[+] 		setup(foreColor, backColor);
[-] 	cmp (const ColorAttr& attr)
[+] 	cmp(const ColorAttr& attr)
[-] 		return memcmp (this, &attr, sizeof (ColorAttr));
[+] 		return memcmp(this, &attr, sizeof(ColorAttr));
[-] 	clear ()
[+] 	clear()
[-] 		setup (-1, -1);
[+] 		setup(-1, -1);
[-] 	setup (
[+] 	setup(
[-] 	overlay (
[+] 	overlay(
[-] 		m_foreColor = overlayColor (baseAttr.m_foreColor, overlayAttr.m_foreColor);
[+] 		m_foreColor = overlayColor(baseAttr.m_foreColor, overlayAttr.m_foreColor);
[-] 		m_backColor = overlayColor (baseAttr.m_backColor, overlayAttr.m_backColor);
[+] 		m_backColor = overlayColor(baseAttr.m_backColor, overlayAttr.m_backColor);
[-] 	overlay (const ColorAttr& overlayAttr)
[+] 	overlay(const ColorAttr& overlayAttr)
[-] 		overlay (*this, overlayAttr);
[+] 		overlay(*this, overlayAttr);
----------------------
27/02/2019 18:01:39 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_Def.h
----------------------
[-] getFirstMouseButton (uint_t buttons)
[+] getFirstMouseButton(uint_t buttons)
[-] 	return (MouseButton) sl::getLoBitIdx32 (buttons);
[+] 	return (MouseButton)sl::getLoBitIdx32(buttons);
[-] getFirstModifierKey (uint_t modifierKeys)
[+] getFirstModifierKey(uint_t modifierKeys)
[-] 	return (ModifierKey) sl::getLoBitIdx32 (modifierKeys);
[+] 	return (ModifierKey)sl::getLoBitIdx32(modifierKeys);
[-] 	Point ()
[+] 	Point()
[-] 	Point (
[+] 	Point(
[-] 		return Point (m_x + point2.m_x, m_y + point2.m_y);
[+] 		return Point(m_x + point2.m_x, m_y + point2.m_y);
[-] 		return Point (m_x - point2.m_x, m_y - point2.m_y);
[+] 		return Point(m_x - point2.m_x, m_y - point2.m_y);
[-] 	setup (
[+] 	setup(
[-] 	clipNegative ()
[+] 	clipNegative()
[-] 	Size ()
[+] 	Size()
[-] 	Size (
[+] 	Size(
[-] 		return Size (m_width + size2.m_width, m_height + size2.m_height);
[+] 		return Size(m_width + size2.m_width, m_height + size2.m_height);
[-] 		return Size (m_width - size2.m_width, m_height - size2.m_height);
[+] 		return Size(m_width - size2.m_width, m_height - size2.m_height);
[-] 	setup (
[+] 	setup(
[-] 	clipNegative ()
[+] 	clipNegative()
[-] 	Rect ()
[+] 	Rect()
[-] 	Rect (
[+] 	Rect(
[-] 	Rect (
[+] 	Rect(
[-] 	Rect (
[+] 	Rect(
[-] 	Rect (const Point& leftTop)
[+] 	Rect(const Point& leftTop)
[-] 	Rect (
[+] 	Rect(
[-] 	isEmpty () const
[+] 	isEmpty() const
[-] 	getWidth () const
[+] 	getWidth() const
[-] 	getHeight () const
[+] 	getHeight() const
[-] 	getSize () const
[+] 	getSize() const
[-] 		return Size (getWidth (), getHeight ());
[+] 		return Size(getWidth(), getHeight());
[-] 	setup (
[+] 	setup(
[-] 	clipNegative ()
[+] 	clipNegative()
[-] 	CaretPos ()
[+] 	CaretPos()
[-] 	CaretPos (
[+] 	CaretPos(
[-] 		setup (line, col);
[+] 		setup(line, col);
[-] 		return cmp (pos2) == 0;
[+] 		return cmp(pos2) == 0;
[-] 		return cmp (pos2) != 0;
[+] 		return cmp(pos2) != 0;
[-] 		return cmp (pos2) < 0;
[+] 		return cmp(pos2) < 0;
[-] 		return cmp (pos2) <= 0;
[+] 		return cmp(pos2) <= 0;
[-] 		return cmp (pos2) > 0;
[+] 		return cmp(pos2) > 0;
[-] 		return cmp (pos2) >= 0;
[+] 		return cmp(pos2) >= 0;
[-] 	cmp (const CaretPos& pos2) const
[+] 	cmp(const CaretPos& pos2) const
[-] 	cmp_u (const CaretPos& pos2) const
[+] 	cmp_u(const CaretPos& pos2) const
[-] 	setup (
[+] 	setup(
[-] 	clipNegative ()
[+] 	clipNegative()
[-] getFormFactor (
[+] getFormFactor(
[-] getFormFactor (
[+] getFormFactor(
[-] 	return getFormFactor (size.m_width, size.m_height, stripThreshold);
[+] 	return getFormFactor(size.m_width, size.m_height, stripThreshold);
[-] 	GuiItem (Engine* engine)
[+] 	GuiItem(Engine* engine)
[-] 	getEngine ()
[+] 	getEngine()
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_Engine.h
----------------------
[-] 	uint_t m_stdPalColorTable [StdPalColor__Count];
[+] 	uint_t m_stdPalColorTable[StdPalColor__Count];
[-] 	Engine ();
[+] 	Engine();
[-] 	getStdPalette ()
[+] 	getStdPalette()
[-] 		return Palette (m_stdPalColorTable, countof (m_stdPalColorTable));
[+] 		return Palette(m_stdPalColorTable, countof(m_stdPalColorTable));
[-] 	updateStdPalette () = 0;
[+] 	updateStdPalette() = 0;
[-] 	createOffscreenCanvas (
[+] 	createOffscreenCanvas(
[-] 	createOffscreenCanvas (
[+] 	createOffscreenCanvas(
[-] 		return createOffscreenCanvas (
[+] 		return createOffscreenCanvas(
[-] 	releaseOffscreenCanvas (Canvas* canvas) = 0;
[+] 	releaseOffscreenCanvas(Canvas* canvas) = 0;
[-] 	getSharedOffscreenCanvas (
[+] 	getSharedOffscreenCanvas(
[-] 	getSharedOffscreenCanvas (const Size& size)
[+] 	getSharedOffscreenCanvas(const Size& size)
[-] 		return getSharedOffscreenCanvas (
[+] 		return getSharedOffscreenCanvas(
[-] 	releaseAllSharedOffscreenCanvases () = 0;
[+] 	releaseAllSharedOffscreenCanvases() = 0;
[-] 	drawRect (
[+] 	drawRect(
[-] 	drawAlphaRect (
[+] 	drawAlphaRect(
[-] 		return drawRect (canvas, left, top, right, bottom, color); // draw opaque rect by default
[+] 		return drawRect(canvas, left, top, right, bottom, color); // draw opaque rect by default
[-] 	drawText_utf8 (
[+] 	drawText_utf8(
[-] 	drawText_utf16 (
[+] 	drawText_utf16(
[-] 	drawText_utf32 (
[+] 	drawText_utf32(
[-] 	drawImage (
[+] 	drawImage(
[-] 	copyRect (
[+] 	copyRect(
[-] 	clearFontTuple (FontTuple* fontTuple) = 0;
[+] 	clearFontTuple(FontTuple* fontTuple) = 0;
[-] 	getStdFontTuple (StdFontKind fontKind) = 0;
[+] 	getStdFontTuple(StdFontKind fontKind) = 0;
[-] 	getStdFont (
[+] 	getStdFont(
[-] 	createFont (
[+] 	createFont(
[-] 	createFont (
[+] 	createFont(
[-] 		return createFont (
[+] 		return createFont(
[-] 	getFontMod (
[+] 	getFontMod(
[-] 	getFontDesc (
[+] 	getFontDesc(
[-] 	isMonospaceFont (Font* font) = 0;
[+] 	isMonospaceFont(Font* font) = 0;
[-] 	calcTextSize_utf8 (
[+] 	calcTextSize_utf8(
[-] 	calcTextSize_utf16 (
[+] 	calcTextSize_utf16(
[-] 	calcTextSize_utf32 (
[+] 	calcTextSize_utf32(
[-] 	createImage (
[+] 	createImage(
[-] 	createImage (
[+] 	createImage(
[-] 		return createImage (
[+] 		return createImage(
[-] 	getImageDesc (
[+] 	getImageDesc(
[-] 	getStdCursor (StdCursorKind cursorKind) = 0;
[+] 	getStdCursor(StdCursorKind cursorKind) = 0;
[-] 	registerClipboardFormat (const sl::StringRef& formatName) = 0;
[+] 	registerClipboardFormat(const sl::StringRef& formatName) = 0;
[-] 	readClipboard (sl::String* string) = 0;
[+] 	readClipboard(sl::String* string) = 0;
[-] 	readClipboard (
[+] 	readClipboard(
[-] 		sl::Array <char>* data
[+] 		sl::Array<char>* data
[-] 	readClipboard ()
[+] 	readClipboard()
[-] 		readClipboard (&string);
[+] 		readClipboard(&string);
[-] 	sl::Array <char>
[+] 	sl::Array<char>
[-] 	readClipboard (uintptr_t format)
[+] 	readClipboard(uintptr_t format)
[-] 		sl::Array <char> data;
[+] 		sl::Array<char> data;
[-] 		readClipboard (format, &data);
[+] 		readClipboard(format, &data);
[-] 	writeClipboard (const sl::StringRef& string) = 0;
[+] 	writeClipboard(const sl::StringRef& string) = 0;
[-] 	writeClipboard (
[+] 	writeClipboard(
[-] 	writeClipboard (
[+] 	writeClipboard(
[-] 		const sl::Array <char>& data
[+] 		const sl::Array<char>& data
[-] 		return writeClipboard (format, data, data.getCount ());
[+] 		return writeClipboard(format, data, data.getCount());
[-] 	commitClipboard () = 0;
[+] 	commitClipboard() = 0;
[-] 	isWidgetFocused (WidgetDriver* widgetDriver) = 0;
[+] 	isWidgetFocused(WidgetDriver* widgetDriver) = 0;
[-] 	setWidgetFocus (WidgetDriver* widgetDriver) = 0;
[+] 	setWidgetFocus(WidgetDriver* widgetDriver) = 0;
[-] 	redrawWidget (
[+] 	redrawWidget(
[-] 	redrawWidgetImmediate (
[+] 	redrawWidgetImmediate(
[-] 	scrollWidget (
[+] 	scrollWidget(
[-] 	scrollWidgetRect (
[+] 	scrollWidgetRect(
[-] 	setWidgetCursor (
[+] 	setWidgetCursor(
[-] 	setMouseCapture (WidgetDriver* widgetDriver) = 0;
[+] 	setMouseCapture(WidgetDriver* widgetDriver) = 0;
[-] 	releaseMouse (WidgetDriver* widgetDriver) = 0;
[+] 	releaseMouse(WidgetDriver* widgetDriver) = 0;
[-] 	updateWidgetScrollBar (
[+] 	updateWidgetScrollBar(
[-] 	sendWidgetNotification (
[+] 	sendWidgetNotification(
[-] 	postWidgetThreadMsg (
[+] 	postWidgetThreadMsg(
[-] 		const ref::Ptr <void>& params
[+] 		const ref::Ptr<void>& params
[-] 	startWidgetAnimation (WidgetDriver* widgetDriver) = 0;
[+] 	startWidgetAnimation(WidgetDriver* widgetDriver) = 0;
[-] 	stopWidgetAnimation (WidgetDriver* widgetDriver) = 0;
[+] 	stopWidgetAnimation(WidgetDriver* widgetDriver) = 0;
[-] 	showCaret (
[+] 	showCaret(
[-] 	hideCaret (WidgetDriver* widgetDriver) = 0;
[+] 	hideCaret(WidgetDriver* widgetDriver) = 0;
[-] 	scheduleToolTipMsg (
[+] 	scheduleToolTipMsg(
[-] 	cancelToolTipMsg (WidgetDriver* widgetDriver) = 0;
[+] 	cancelToolTipMsg(WidgetDriver* widgetDriver) = 0;
[-] 	showToolTip (
[+] 	showToolTip(
[-] 	hideToolTip (WidgetDriver* widgetDriver) = 0;
[+] 	hideToolTip(WidgetDriver* widgetDriver) = 0;
[-] 	processUiEvents (uint32_t timeLimit = -1) = 0;
[+] 	processUiEvents(uint32_t timeLimit = -1) = 0;
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_Font.h
----------------------
[-] 	Font* m_fontModArray [0x10];
[+] 	Font* m_fontModArray[0x10];
[-] 	FontTuple (Engine* engine):
[+] 	FontTuple(Engine* engine):
[-] 		GuiItem (engine)
[+] 		GuiItem(engine)
[-] 		memset (m_fontModArray, 0, sizeof (m_fontModArray));
[+] 		memset(m_fontModArray, 0, sizeof(m_fontModArray));
[-] 	~FontTuple ()
[+] 	~FontTuple()
[-] 		clear ();
[+] 		clear();
[-] 	createFont (
[+] 	createFont(
[-] 		return m_engine->createFont (this, family, pointSize, flags);
[+] 		return m_engine->createFont(this, family, pointSize, flags);
[-] 	createFont (const FontDesc& fontDesc)
[+] 	createFont(const FontDesc& fontDesc)
[-] 		return m_engine->createFont (this, fontDesc);
[+] 		return m_engine->createFont(this, fontDesc);
[-] 	getFont (uint_t flags = 0)
[+] 	getFont(uint_t flags = 0)
[-] 		return m_fontModArray [flags] ? m_fontModArray [flags] : m_engine->getFontMod (this, flags);
[+] 		return m_fontModArray[flags] ? m_fontModArray[flags] : m_engine->getFontMod(this, flags);
[-] 	clear ()
[+] 	clear()
[-] 		m_engine->clearFontTuple (this);
[+] 		m_engine->clearFontTuple(this);
[-] 	Font (Engine* engine):
[+] 	Font(Engine* engine):
[-] 		GuiItem (engine)
[+] 		GuiItem(engine)
[-] 	getFontMod (uint_t flags)
[+] 	getFontMod(uint_t flags)
[-] 		return (flags & FontFlag_Undefined) ? this : m_tuple->getFont (flags);
[+] 		return (flags & FontFlag_Undefined) ? this : m_tuple->getFont(flags);
[-] 	getFontDesc (FontDesc* fontDesc)
[+] 	getFontDesc(FontDesc* fontDesc)
[-] 		return m_engine->getFontDesc (this, fontDesc);
[+] 		return m_engine->getFontDesc(this, fontDesc);
[-] 	isMonospace ()
[+] 	isMonospace()
[-] 		return m_engine->isMonospaceFont (this);
[+] 		return m_engine->isMonospaceFont(this);
[-] 	calcTextSize (const sl::StringRef& text)
[+] 	calcTextSize(const sl::StringRef& text)
[-] 		return calcTextSize_utf8 (text);
[+] 		return calcTextSize_utf8(text);
[-] 	calcTextSize_utf8 (const sl::StringRef_utf8& text)
[+] 	calcTextSize_utf8(const sl::StringRef_utf8& text)
[-] 		return m_engine->calcTextSize_utf8 (this, text);
[+] 		return m_engine->calcTextSize_utf8(this, text);
[-] 	calcTextSize_utf16 (const sl::StringRef_utf16& text)
[+] 	calcTextSize_utf16(const sl::StringRef_utf16& text)
[-] 		return m_engine->calcTextSize_utf16 (this, text);
[+] 		return m_engine->calcTextSize_utf16(this, text);
[-] 	calcTextSize_utf32 (const sl::StringRef_utf32& text)
[+] 	calcTextSize_utf32(const sl::StringRef_utf32& text)
[-] 		return m_engine->calcTextSize_utf32 (this, text);
[+] 		return m_engine->calcTextSize_utf32(this, text);
[-] 	calcTextSize (utf32_t c)
[+] 	calcTextSize(utf32_t c)
[-] 		return calcTextSize_utf32 (sl::StringRef_utf32 (&c, 1));
[+] 		return calcTextSize_utf32(sl::StringRef_utf32(&c, 1));
[-] Engine::getStdFont (
[+] Engine::getStdFont(
[-] 	return getStdFontTuple (fontKind)->getFont (flags);
[+] 	return getStdFontTuple(fontKind)->getFont(flags);
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_FontDesc.h
----------------------
[-] getFirstFontFlag (uint_t flags)
[+] getFirstFontFlag(uint_t flags)
[-] 	return (FontFlag) (1 << sl::getLoBitIdx (flags));
[+] 	return (FontFlag)(1 << sl::getLoBitIdx(flags));
[-] getFontFlagString (FontFlag flag);
[+] getFontFlagString(FontFlag flag);
[-] getFontFlagString (uint_t flags)
[+] getFontFlagString(uint_t flags)
[-] 	return getFontFlagString (getFirstFontFlag (flags));
[+] 	return getFontFlagString(getFirstFontFlag(flags));
[-] overlayFontFlags (
[+] overlayFontFlags(
[-] 	char m_family [32];
[+] 	char m_family[32];
[-] 	FontDesc ()
[+] 	FontDesc()
[-] 		memset (this, 0, sizeof (FontDesc));
[+] 		memset(this, 0, sizeof(FontDesc));
[-] 	FontDesc (
[+] 	FontDesc(
[-] 		setup (family, pointSize, flags);
[+] 		setup(family, pointSize, flags);
[-] 	setup (
[+] 	setup(
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_GdiCanvas.h
----------------------
[-] 	ScreenDc ()
[+] 	ScreenDc()
[-] 		m_hdc = ::GetDC (NULL);
[+] 		m_hdc = ::GetDC(NULL);
[-] 	~ScreenDc ()
[+] 	~ScreenDc()
[-] 		::ReleaseDC (NULL, m_hdc);
[+] 		::ReleaseDC(NULL, m_hdc);
[-] 	operator HDC ()
[+] 	operator HDC()
[-] 	public sl::Handle <HDC>
[+] 	public sl::Handle<HDC>
[-] 	GdiCanvas ();
[+] 	GdiCanvas();
[-] 	~GdiCanvas ()
[+] 	~GdiCanvas()
[-] 		release ();
[+] 		release();
[-] 	attach (
[+] 	attach(
[-] 	drawRect (
[+] 	drawRect(
[-] 	drawText_utf8 (
[+] 	drawText_utf8(
[-] 	drawText_utf16 (
[+] 	drawText_utf16(
[-] 	drawText_utf32 (
[+] 	drawText_utf32(
[-] 	drawImage (
[+] 	drawImage(
[-] 	copyRect (
[+] 	copyRect(
[-] 	release ();
[+] 	release();
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_GdiCursor.h
----------------------
[-] 	public sl::Handle <HCURSOR>
[+] 	public sl::Handle<HCURSOR>
[-] 	GdiCursor ();
[+] 	GdiCursor();
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_GdiEngine.h
----------------------
[-] 	GdiEngine ();
[+] 	GdiEngine();
[-] 	~GdiEngine ();
[+] 	~GdiEngine();
[-] 	getSingleton ()
[+] 	getSingleton()
[-] 		return sl::getSingleton <GdiEngine> ();
[+] 		return sl::getSingleton<GdiEngine> ();
[-] 	getDefaultGuiFont ();
[+] 	getDefaultGuiFont();
[-] 	getDefaultMonospaceFont ();
[+] 	getDefaultMonospaceFont();
[-] 	ref::Ptr <Font>
[+] 	ref::Ptr<Font>
[-] 	createFont (
[+] 	createFont(
[-] 	ref::Ptr <Font>
[+] 	ref::Ptr<Font>
[-] 	createStockFont (int stockFontKind);
[+] 	createStockFont(int stockFontKind);
[-] 	ref::Ptr <Font>
[+] 	ref::Ptr<Font>
[-] 	createFont (HFONT hFont);
[+] 	createFont(HFONT hFont);
[-] 	ref::Ptr <Cursor>
[+] 	ref::Ptr<Cursor>
[-] 	createStockCursor (LPCTSTR stockCursorRes);
[+] 	createStockCursor(LPCTSTR stockCursorRes);
[-] 	ref::Ptr <Image>
[+] 	ref::Ptr<Image>
[-] 	createImage ();
[+] 	createImage();
[-] 	ref::Ptr <Image>
[+] 	ref::Ptr<Image>
[-] 	createImage (
[+] 	createImage(
[-] 	ref::Ptr <Canvas>
[+] 	ref::Ptr<Canvas>
[-] 	createOffscreenCanvas (
[+] 	createOffscreenCanvas(
[-] 	registerClipboardFormat (const sl::StringRef& formatName);
[+] 	registerClipboardFormat(const sl::StringRef& formatName);
[-] 	readClipboard (sl::String* string);
[+] 	readClipboard(sl::String* string);
[-] 	readClipboard (
[+] 	readClipboard(
[-] 		sl::Array <char>* data
[+] 		sl::Array<char>* data
[-] 	writeClipboard (const sl::StringRef& string);
[+] 	writeClipboard(const sl::StringRef& string);
[-] 	writeClipboard (
[+] 	writeClipboard(
[-] 	commitClipboard ()
[+] 	commitClipboard()
[-] 	showCaret (
[+] 	showCaret(
[-] 	hideCaret ();
[+] 	hideCaret();
[-] 	openClipboard ();
[+] 	openClipboard();
[-] 	getFontMod (
[+] 	getFontMod(
[-] 	ref::Ptr <Font>
[+] 	ref::Ptr<Font>
[-] 	createStdFont (StdFontKind fontKind);
[+] 	createStdFont(StdFontKind fontKind);
[-] 	ref::Ptr <Cursor>
[+] 	ref::Ptr<Cursor>
[-] 	createStdCursor (StdCursorKind cursorKind);
[+] 	createStdCursor(StdCursorKind cursorKind);
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_GdiFont.h
----------------------
[-] buildLogFont (
[+] buildLogFont(
[-] getLogFontFromFontDesc (
[+] getLogFontFromFontDesc(
[-] 	return buildLogFont (
[+] 	return buildLogFont(
[-] 		sl::String_w (fontDesc.m_family),
[+] 		sl::String_w(fontDesc.m_family),
[-] modifyLogFont (
[+] modifyLogFont(
[-] getFontDescFromLogFont (
[+] getFontDescFromLogFont(
[-] 	public GdiObjectHandle <HFONT>
[+] 	public GdiObjectHandle<HFONT>
[-] 	GdiFont ();
[+] 	GdiFont();
[-] 	getLogFont (LOGFONTW* logFont);
[+] 	getLogFont(LOGFONTW* logFont);
[-] 	isMonospace ();
[+] 	isMonospace();
[-] 	calcTextSize_utf8 (const sl::StringRef_utf8& text);
[+] 	calcTextSize_utf8(const sl::StringRef_utf8& text);
[-] 	calcTextSize_utf16 (const sl::StringRef_utf16& text);
[+] 	calcTextSize_utf16(const sl::StringRef_utf16& text);
[-] 	calcTextSize_utf32 (const sl::StringRef_utf32& text);
[+] 	calcTextSize_utf32(const sl::StringRef_utf32& text);
[-] typedef FontTuple <GdiFont> GdiFontuple;
[+] typedef FontTuple<GdiFont> GdiFontuple;
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_GdiImage.h
----------------------
[-] 	public GdiObjectHandle <HBITMAP>
[+] 	public GdiObjectHandle<HBITMAP>
[-] 	GdiImage ();
[+] 	GdiImage();
[-] 	getData (
[+] 	getData(
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_GdiObjectHandle.h
----------------------
[-] 		::DeleteObject (h);
[+] 		::DeleteObject(h);
[-] class GdiObjectHandle: public sl::Handle <T, DeleteGdiObject>
[+] class GdiObjectHandle: public sl::Handle<T, DeleteGdiObject>
[-] 	GdiObjectHandle ()
[+] 	GdiObjectHandle()
[-] 	GdiObjectHandle (T h):
[+] 	GdiObjectHandle(T h):
[-] 		sl::Handle <T, DeleteGdiObject> (h)
[+] 		sl::Handle<T, DeleteGdiObject> (h)
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_GdiWidget.h
----------------------
[-] getScrollBarFromOrientation (Orientation orientation)
[+] getScrollBarFromOrientation(Orientation orientation)
[-] buildScrollInfo (
[+] buildScrollInfo(
[-] getScrollInfoFromScrollBar (
[+] getScrollInfoFromScrollBar(
[-] 	buildScrollInfo (scrollInfo, scrollBar.m_end - 1, scrollBar.m_page, scrollBar.m_pos);
[+] 	buildScrollInfo(scrollInfo, scrollBar.m_end - 1, scrollBar.m_page, scrollBar.m_pos);
[-] 	windowProc (
[+] 	windowProc(
[-] 	ref::Ptr <Canvas>
[+] 	ref::Ptr<Canvas>
[-] 	getCanvas (HWND hWnd);
[+] 	getCanvas(HWND hWnd);
[-] 	processWmMouse (
[+] 	processWmMouse(
[-] 	processWmMouseWheel (
[+] 	processWmMouseWheel(
[-] 	processWmKey (
[+] 	processWmKey(
[-] 	processWmSize (
[+] 	processWmSize(
[-] 	processWmScroll (
[+] 	processWmScroll(
[-] 	processWmPaint (
[+] 	processWmPaint(
[-] 	processWmSetCursor (
[+] 	processWmSetCursor(
[-] 	public g::win::WindowImpl <GdiWidget <T> >
[+] 	public g::win::WindowImpl<GdiWidget<T> >
[-] 	friend class g::win::WindowImpl <GdiWidget <T> >;
[+] 	friend class g::win::WindowImpl<GdiWidget<T> >;
[-] 	GdiWidget (): T (GdiEngine::getSingleton ())
[+] 	GdiWidget(): T(GdiEngine::getSingleton())
[-] 		m_baseTextAttr.m_foreColor = ::GetSysColor (COLOR_WINDOWTEXT);
[+] 		m_baseTextAttr.m_foreColor = ::GetSysColor(COLOR_WINDOWTEXT);
[-] 		m_baseTextAttr.m_backColor = ::GetSysColor (COLOR_WINDOW);
[+] 		m_baseTextAttr.m_backColor = ::GetSysColor(COLOR_WINDOW);
[-] 	ref::Ptr <Canvas>
[+] 	ref::Ptr<Canvas>
[-] 	getCanvas ()
[+] 	getCanvas()
[-] 		return getGdiWidget ()->getCanvas (m_h);
[+] 		return getGdiWidget()->getCanvas(m_h);
[-] 	redraw (
[+] 	redraw(
[-] 			::InvalidateRect (m_h, NULL, false);
[+] 			::InvalidateRect(m_h, NULL, false);
[-] 			::InvalidateRect (m_h, &rect, false);
[+] 			::InvalidateRect(m_h, &rect, false);
[-] 	isFocused ()
[+] 	isFocused()
[-] 		return ::GetFocus () == m_h;
[+] 		return ::GetFocus() == m_h;
[-] 	setFocus ()
[+] 	setFocus()
[-] 		::SetFocus (m_h);
[+] 		::SetFocus(m_h);
[-] 	setCursor (Cursor* cursor)
[+] 	setCursor(Cursor* cursor)
[-] 		ASSERT (cursor->getEngine ()->getEngineKind () == EngineKind_Gdi);
[+] 		ASSERT(cursor->getEngine()->getEngineKind() == EngineKind_Gdi);
[-] 		::SetCursor (*(Cursor*) cursor);
[+] 		::SetCursor(*(Cursor*)cursor);
[-] 	setMouseCapture ()
[+] 	setMouseCapture()
[-] 		HWND hPrevWnd = ::SetCapture (m_h);
[+] 		HWND hPrevWnd = ::SetCapture(m_h);
[-] 	releaseMouseCapture ()
[+] 	releaseMouseCapture()
[-] 		bool_t result = ::ReleaseCapture ();
[+] 		bool_t result = ::ReleaseCapture();
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	setCaretVisible (bool isVisible)
[+] 	setCaretVisible(bool isVisible)
[-] 	setCaretPos (
[+] 	setCaretPos(
[-] 	setCaretSize (
[+] 	setCaretSize(
[-] 	updateScrollBar (Orientation orientation)
[+] 	updateScrollBar(Orientation orientation)
[-] 		ASSERT (orientation < countof (m_scrollBarArray));
[+] 		ASSERT(orientation < countof(m_scrollBarArray));
[-] 		int bar = getScrollBarFromOrientation (orientation);
[+] 		int bar = getScrollBarFromOrientation(orientation);
[-] 		getScrollInfoFromScrollBar (m_scrollBarArray [orientation], &scrollInfo);
[+] 		getScrollInfoFromScrollBar(m_scrollBarArray[orientation], &scrollInfo);
[-] 		bool_t result = ::SetScrollInfo (m_h, bar, &scrollInfo, TRUE);
[+] 		bool_t result = ::SetScrollInfo(m_h, bar, &scrollInfo, TRUE);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	notifyParent (
[+] 	notifyParent(
[-] 		HWND hWndParent = ::GetParent (m_h);
[+] 		HWND hWndParent = ::GetParent(m_h);
[-] 		notify.idFrom = ::GetDlgCtrlID (m_h);
[+] 		notify.idFrom = ::GetDlgCtrlID(m_h);
[-] 		return ::SendMessageW (hWndParent, WM_NOTIFY, notify.idFrom, (LPARAM) &notify);
[+] 		return ::SendMessageW(hWndParent, WM_NOTIFY, notify.idFrom, (LPARAM) &notify);
[-] 	postThreadMsg (
[+] 	postThreadMsg(
[-] 		const ref::Ptr <void>& params
[+] 		const ref::Ptr<void>& params
[-] 		WidgetThreadMsg* msg = AXL_MEM_NEW (WidgetThreadMsg);
[+] 		WidgetThreadMsg* msg = AXL_MEM_NEW(WidgetThreadMsg);
[-] 		bool_t result = ::PostMessageW (m_h, WmKind_ThreadMsg, code, (LPARAM) msg);
[+] 		bool_t result = ::PostMessageW(m_h, WmKind_ThreadMsg, code, (LPARAM)msg);
[-] 			AXL_MEM_DELETE (msg);
[+] 			AXL_MEM_DELETE(msg);
[-] 	getGdiWidget ()
[+] 	getGdiWidget()
[-] 		return (GdiWidgetImpl*) (Widget*) this;
[+] 		return (GdiWidgetImpl*)(Widget*)this;
[-] 	windowProc (
[+] 	windowProc(
[-] 		return getGdiWidget ()->windowProc (m_h, wmMsg, wParam, lParam, isHandled_o);
[+] 		return getGdiWidget()->windowProc(m_h, wmMsg, wParam, lParam, isHandled_o);
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_HyperlinkAnchorArray.h
----------------------
[-] 	HyperlinkAnchor ()
[+] 	HyperlinkAnchor()
[-] 	sl::List <HyperlinkAnchor> m_list;
[+] 	sl::List<HyperlinkAnchor> m_list;
[-] 	sl::Array <HyperlinkAnchor*> m_array;
[+] 	sl::Array<HyperlinkAnchor*> m_array;
[-] 	isEmpty () const
[+] 	isEmpty() const
[-] 		return m_list.isEmpty ();
[+] 		return m_list.isEmpty();
[-] 	isHyperlinkOpened () const
[+] 	isHyperlinkOpened() const
[-] 		return !m_list.isEmpty () && !m_list.getTail ()->m_hyperlink.isEmpty ();
[+] 		return !m_list.isEmpty() && !m_list.getTail()->m_hyperlink.isEmpty();
[-] 	getCount () const
[+] 	getCount() const
[-] 		return m_list.getCount ();
[+] 		return m_list.getCount();
[-] 	sl::ConstIterator <HyperlinkAnchor>
[+] 	sl::ConstIterator<HyperlinkAnchor>
[-] 	getHead () const
[+] 	getHead() const
[-] 		return m_list.getHead ();
[+] 		return m_list.getHead();
[-] 	sl::ConstIterator <HyperlinkAnchor>
[+] 	sl::ConstIterator<HyperlinkAnchor>
[-] 	getTail () const
[+] 	getTail() const
[-] 		return m_list.getHead ();
[+] 		return m_list.getHead();
[-] 	clear ()
[+] 	clear()
[-] 		m_list.clear ();
[+] 		m_list.clear();
[-] 		m_array.clear ();
[+] 		m_array.clear();
[-] 	find (size_t offset) const;
[+] 	find(size_t offset) const;
[-] 	openHyperlink (
[+] 	openHyperlink(
[-] 	closeHyperlink (
[+] 	closeHyperlink(
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_HyperText.h
----------------------
[-] 	sl::Array <HyperlinkXMapEntry> m_hyperlinkXMap;
[+] 	sl::Array<HyperlinkXMapEntry> m_hyperlinkXMap;
[-] 	HyperText ()
[+] 	HyperText()
[-] 	HyperText (const sl::StringRef& source)
[+] 	HyperText(const sl::StringRef& source)
[-] 		setHyperText (source);
[+] 		setHyperText(source);
[-] 	HyperText (
[+] 	HyperText(
[-] 		setHyperText (baseAttr, source);
[+] 		setHyperText(baseAttr, source);
[-] 	getSource () const
[+] 	getSource() const
[-] 	getText () const
[+] 	getText() const
[-] 	getAttrArray () const
[+] 	getAttrArray() const
[-] 	clear ();
[+] 	clear();
[-] 	setHyperText (
[+] 	setHyperText(
[-] 		clear ();
[+] 		clear();
[-] 		return appendHyperText (baseAttr, text);
[+] 		return appendHyperText(baseAttr, text);
[-] 	setHyperText (const sl::StringRef& text)
[+] 	setHyperText(const sl::StringRef& text)
[-] 		return setHyperText (TextAttr (), text);
[+] 		return setHyperText(TextAttr(), text);
[-] 	setPlainText (const sl::StringRef& text)
[+] 	setPlainText(const sl::StringRef& text)
[-] 		clear ();
[+] 		clear();
[-] 		return appendPlainText (text);
[+] 		return appendPlainText(text);
[-] 	setChar (
[+] 	setChar(
[-] 		clear ();
[+] 		clear();
[-] 		return appendChar (c, count);
[+] 		return appendChar(c, count);
[-] 	appendHyperText (
[+] 	appendHyperText(
[-] 	appendHyperText (const sl::StringRef& text)
[+] 	appendHyperText(const sl::StringRef& text)
[-] 		return appendHyperText (TextAttr (), text);
[+] 		return appendHyperText(TextAttr(), text);
[-] 	appendPlainText (const sl::StringRef& text);
[+] 	appendPlainText(const sl::StringRef& text);
[-] 	appendChar (
[+] 	appendChar(
[-] 	backspace (size_t backLength);
[+] 	backspace(size_t backLength);
[-] 	calcTextSize (Font* font) const;
[+] 	calcTextSize(Font* font) const;
[-] 	calcHyperlinkXMap (Font* font);
[+] 	calcHyperlinkXMap(Font* font);
[-] 	findHyperlinkByX (int x) const;
[+] 	findHyperlinkByX(int x) const;
[-] 	findHyperlinkByOffset (size_t offset) const
[+] 	findHyperlinkByOffset(size_t offset) const
[-] 		const HyperlinkAnchor* anchor = m_hyperlinkArray.find (offset);
[+] 		const HyperlinkAnchor* anchor = m_hyperlinkArray.find(offset);
[-] 		return anchor && !anchor->m_hyperlink.isEmpty () ? anchor : NULL;
[+] 		return anchor && !anchor->m_hyperlink.isEmpty() ? anchor : NULL;
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_Image.h
----------------------
[-] 	Image (Engine* engine):
[+] 	Image(Engine* engine):
[-] 		GuiItem (engine)
[+] 		GuiItem(engine)
[-] 	getImageDesc (ImageDesc* imageDesc)
[+] 	getImageDesc(ImageDesc* imageDesc)
[-] 		return m_engine->getImageDesc (this, imageDesc);
[+] 		return m_engine->getImageDesc(this, imageDesc);
[-] 	getSize ()
[+] 	getSize()
[-] 		getImageDesc (&imageDesc);
[+] 		getImageDesc(&imageDesc);
[-] 	Cursor (Engine* engine):
[+] 	Cursor(Engine* engine):
[-] 		GuiItem (engine)
[+] 		GuiItem(engine)
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_ImageDesc.h
----------------------
[-] getPixelFormatString (PixelFormat pixelFormat);
[+] getPixelFormatString(PixelFormat pixelFormat);
[-] 	ImageDesc ()
[+] 	ImageDesc()
[-] 		memset (this, 0, sizeof (ImageDesc));
[+] 		memset(this, 0, sizeof(ImageDesc));
[-] 	ImageDesc (
[+] 	ImageDesc(
[-] 		m_size.setup (width, height);
[+] 		m_size.setup(width, height);
[-] 	ImageDesc (
[+] 	ImageDesc(
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_QtCaret.h
----------------------
[-] 	QtCaret ()
[+] 	QtCaret()
[-] 	isVisible ()
[+] 	isVisible()
[-] 	show (
[+] 	show(
[-] 	hide (WidgetDriver* widgetDriver);
[+] 	hide(WidgetDriver* widgetDriver);
[-] 	virtual void timerEvent (QTimerEvent* e);
[+] 	virtual void timerEvent(QTimerEvent* e);
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_QtEngine.h
----------------------
[-] getQtEngine ();
[+] getQtEngine();
[-] 	QtCanvas ():
[+] 	QtCanvas():
[-] 		Canvas (getQtEngine ())
[+] 		Canvas(getQtEngine())
[-] 	QtFontTuple ():
[+] 	QtFontTuple():
[-] 		FontTuple (getQtEngine ())
[+] 		FontTuple(getQtEngine())
[-] 	QtFont* attachFont (QFont qtFont);
[+] 	QtFont* attachFont(QFont qtFont);
[-] 	QtFont ():
[+] 	QtFont():
[-] 		Font (getQtEngine ())
[+] 		Font(getQtEngine())
[-] 	QtImage ():
[+] 	QtImage():
[-] 		Image (getQtEngine ())
[+] 		Image(getQtEngine())
[-] 	QtCursor ():
[+] 	QtCursor():
[-] 		Cursor (getQtEngine ())
[+] 		Cursor(getQtEngine())
[-] 	OffscreenCanvasCache <QtCanvas> m_sharedOffscreenCanvasCache;
[+] 	OffscreenCanvasCache<QtCanvas> m_sharedOffscreenCanvasCache;
[-] 	QtFontTuple* m_stdFontTupleArray [StdFontKind__Count];
[+] 	QtFontTuple* m_stdFontTupleArray[StdFontKind__Count];
[-] 	QtCursor* m_stdCursorArray [StdCursorKind__Count];
[+] 	QtCursor* m_stdCursorArray[StdCursorKind__Count];
[-] 	sl::StringHashTable <uintptr_t> m_clipboardFormatNameMap;
[+] 	sl::StringHashTable<uintptr_t> m_clipboardFormatNameMap;
[-] 	sl::Array <sl::String> m_clipboardFormatNameTable;
[+] 	sl::Array<sl::String> m_clipboardFormatNameTable;
[-] 	QtEngine ();
[+] 	QtEngine();
[-] 	~QtEngine ();
[+] 	~QtEngine();
[-] 	updateStdPalette ();
[+] 	updateStdPalette();
[-] 	createOffscreenCanvas (
[+] 	createOffscreenCanvas(
[-] 	releaseOffscreenCanvas (Canvas* canvas);
[+] 	releaseOffscreenCanvas(Canvas* canvas);
[-] 	getSharedOffscreenCanvas (
[+] 	getSharedOffscreenCanvas(
[-] 		return m_sharedOffscreenCanvasCache.getCanvas (width, height);
[+] 		return m_sharedOffscreenCanvasCache.getCanvas(width, height);
[-] 	releaseAllSharedOffscreenCanvases ()
[+] 	releaseAllSharedOffscreenCanvases()
[-] 		return m_sharedOffscreenCanvasCache.clear ();
[+] 		return m_sharedOffscreenCanvasCache.clear();
[-] 	drawRect (
[+] 	drawRect(
[-] 	drawAlphaRect (
[+] 	drawAlphaRect(
[-] 	drawText_qt (
[+] 	drawText_qt(
[-] 	drawText_utf8 (
[+] 	drawText_utf8(
[-] 	drawText_utf16 (
[+] 	drawText_utf16(
[-] 	drawText_utf32 (
[+] 	drawText_utf32(
[-] 	drawImage (
[+] 	drawImage(
[-] 	copyRect (
[+] 	copyRect(
[-] 	clearFontTuple (FontTuple* fontTuple);
[+] 	clearFontTuple(FontTuple* fontTuple);
[-] 	getStdFontTuple (StdFontKind fontKind);
[+] 	getStdFontTuple(StdFontKind fontKind);
[-] 	createFont (
[+] 	createFont(
[-] 	getFontMod (
[+] 	getFontMod(
[-] 	getFontDesc (
[+] 	getFontDesc(
[-] 	isMonospaceFont (Font* font);
[+] 	isMonospaceFont(Font* font);
[-] 	calcTextSize_qt (
[+] 	calcTextSize_qt(
[-] 	calcTextSize_utf8 (
[+] 	calcTextSize_utf8(
[-] 	calcTextSize_utf16 (
[+] 	calcTextSize_utf16(
[-] 	calcTextSize_utf32 (
[+] 	calcTextSize_utf32(
[-] 	createImage (
[+] 	createImage(
[-] 	getImageDesc (
[+] 	getImageDesc(
[-] 	getStdCursor (StdCursorKind cursorKind);
[+] 	getStdCursor(StdCursorKind cursorKind);
[-] 	registerClipboardFormat (const sl::StringRef& formatName);
[+] 	registerClipboardFormat(const sl::StringRef& formatName);
[-] 	readClipboard (sl::String* string);
[+] 	readClipboard(sl::String* string);
[-] 	readClipboard (
[+] 	readClipboard(
[-] 		sl::Array <char>* data
[+] 		sl::Array<char>* data
[-] 	writeClipboard (const sl::StringRef& string);
[+] 	writeClipboard(const sl::StringRef& string);
[-] 	writeClipboard (
[+] 	writeClipboard(
[-] 	commitClipboard ();
[+] 	commitClipboard();
[-] 	isWidgetFocused (WidgetDriver* widgetDriver);
[+] 	isWidgetFocused(WidgetDriver* widgetDriver);
[-] 	setWidgetFocus (WidgetDriver* widgetDriver);
[+] 	setWidgetFocus(WidgetDriver* widgetDriver);
[-] 	redrawWidget (
[+] 	redrawWidget(
[-] 	redrawWidgetImmediate (
[+] 	redrawWidgetImmediate(
[-] 	scrollWidget (
[+] 	scrollWidget(
[-] 	scrollWidgetRect (
[+] 	scrollWidgetRect(
[-] 	setWidgetCursor (
[+] 	setWidgetCursor(
[-] 	setMouseCapture (WidgetDriver* widgetDriver);
[+] 	setMouseCapture(WidgetDriver* widgetDriver);
[-] 	releaseMouse (WidgetDriver* widgetDriver);
[+] 	releaseMouse(WidgetDriver* widgetDriver);
[-] 	updateWidgetScrollBar (
[+] 	updateWidgetScrollBar(
[-] 	sendWidgetNotification (
[+] 	sendWidgetNotification(
[-] 	postWidgetThreadMsg (
[+] 	postWidgetThreadMsg(
[-] 		const ref::Ptr <void>& params
[+] 		const ref::Ptr<void>& params
[-] 	startWidgetAnimation (WidgetDriver* widgetDriver);
[+] 	startWidgetAnimation(WidgetDriver* widgetDriver);
[-] 	stopWidgetAnimation (WidgetDriver* widgetDriver);
[+] 	stopWidgetAnimation(WidgetDriver* widgetDriver);
[-] 	showCaret (
[+] 	showCaret(
[-] 		return m_qtCaret.show (widgetDriver, rect);
[+] 		return m_qtCaret.show(widgetDriver, rect);
[-] 	hideCaret (WidgetDriver* widgetDriver)
[+] 	hideCaret(WidgetDriver* widgetDriver)
[-] 		m_qtCaret.hide (widgetDriver);
[+] 		m_qtCaret.hide(widgetDriver);
[-] 	isCaretVisible ()
[+] 	isCaretVisible()
[-] 		return m_qtCaret.isVisible ();
[+] 		return m_qtCaret.isVisible();
[-] 	scheduleToolTipMsg (
[+] 	scheduleToolTipMsg(
[-] 	cancelToolTipMsg (WidgetDriver* widgetDriver);
[+] 	cancelToolTipMsg(WidgetDriver* widgetDriver);
[-] 	showToolTip (
[+] 	showToolTip(
[-] 	hideToolTip (WidgetDriver* widgetDriver);
[+] 	hideToolTip(WidgetDriver* widgetDriver);
[-] 	processUiEvents (uint32_t timeLimit);
[+] 	processUiEvents(uint32_t timeLimit);
[-] getQtEngine ()
[+] getQtEngine()
[-] 	return sl::getSingleton <QtEngine> ();
[+] 	return sl::getSingleton<QtEngine> ();
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_QtWidget.h
----------------------
[-] 	QtWidgetBase (
[+] 	QtWidgetBase(
[-] 	~QtWidgetBase ()
[+] 	~QtWidgetBase()
[-] 		m_widgetDriver->setCaretVisible (false); // important for QT
[+] 		m_widgetDriver->setCaretVisible(false); // important for QT
[-] 	postThreadMsg (
[+] 	postThreadMsg(
[-] 		const ref::Ptr <void>& params
[+] 		const ref::Ptr<void>& params
[-] 	emitNotificationSignal (
[+] 	emitNotificationSignal(
[-] 	threadMsgSlot (WidgetThreadMsg* msg);
[+] 	threadMsgSlot(WidgetThreadMsg* msg);
[-] 	toolTipTimerSlot ();
[+] 	toolTipTimerSlot();
[-] 	threadMsgSignal (WidgetThreadMsg* msg);
[+] 	threadMsgSignal(WidgetThreadMsg* msg);
[-] 	mousePressEvent (QMouseEvent* e)
[+] 	mousePressEvent(QMouseEvent* e)
[-] 		mouseEventImpl (e, WidgetMsgCode_MouseButtonDown);
[+] 		mouseEventImpl(e, WidgetMsgCode_MouseButtonDown);
[-] 	mouseReleaseEvent (QMouseEvent* e)
[+] 	mouseReleaseEvent(QMouseEvent* e)
[-] 		mouseEventImpl (e, WidgetMsgCode_MouseButtonUp);
[+] 		mouseEventImpl(e, WidgetMsgCode_MouseButtonUp);
[-] 	mouseDoubleClickEvent (QMouseEvent* e)
[+] 	mouseDoubleClickEvent(QMouseEvent* e)
[-] 		mouseEventImpl (e, WidgetMsgCode_MouseButtonDoubleClick);
[+] 		mouseEventImpl(e, WidgetMsgCode_MouseButtonDoubleClick);
[-] 	mouseMoveEvent (QMouseEvent* e)
[+] 	mouseMoveEvent(QMouseEvent* e)
[-] 		mouseEventImpl (e, WidgetMsgCode_MouseMove);
[+] 		mouseEventImpl(e, WidgetMsgCode_MouseMove);
[-] 	wheelEvent (QWheelEvent* e);
[+] 	wheelEvent(QWheelEvent* e);
[-] 	keyPressEvent (QKeyEvent* e)
[+] 	keyPressEvent(QKeyEvent* e)
[-] 		keyEventImpl (e, WidgetMsgCode_KeyDown);
[+] 		keyEventImpl(e, WidgetMsgCode_KeyDown);
[-] 	keyReleaseEvent (QKeyEvent* e)
[+] 	keyReleaseEvent(QKeyEvent* e)
[-] 		keyEventImpl (e, WidgetMsgCode_KeyUp);
[+] 		keyEventImpl(e, WidgetMsgCode_KeyUp);
[-] 	focusInEvent (QFocusEvent* e)
[+] 	focusInEvent(QFocusEvent* e)
[-] 		genericEventImpl (e, WidgetMsgCode_SetFocus);
[+] 		genericEventImpl(e, WidgetMsgCode_SetFocus);
[-] 	focusOutEvent (QFocusEvent* e)
[+] 	focusOutEvent(QFocusEvent* e)
[-] 		genericEventImpl (e, WidgetMsgCode_KillFocus);
[+] 		genericEventImpl(e, WidgetMsgCode_KillFocus);
[-] 	leaveEvent (QEvent* e)
[+] 	leaveEvent(QEvent* e)
[-] 		genericEventImpl (e, WidgetMsgCode_MouseLeave);
[+] 		genericEventImpl(e, WidgetMsgCode_MouseLeave);
[-] 	paintEvent (QPaintEvent* e);
[+] 	paintEvent(QPaintEvent* e);
[-] 	resizeEvent (QResizeEvent* e);
[+] 	resizeEvent(QResizeEvent* e);
[-] 	closeEvent (QCloseEvent* e)
[+] 	closeEvent(QCloseEvent* e)
[-] 		genericEventImpl (e, WidgetMsgCode_Close);
[+] 		genericEventImpl(e, WidgetMsgCode_Close);
[-] 	timerEvent (QTimerEvent* e)
[+] 	timerEvent(QTimerEvent* e)
[-] 		if (e->timerId () == m_animationTimer.timerId ())
[+] 		if (e->timerId() == m_animationTimer.timerId())
[-] 			genericEventImpl (e, WidgetMsgCode_Animate);
[+] 			genericEventImpl(e, WidgetMsgCode_Animate);
[-] 	scrollContentsBy (
[+] 	scrollContentsBy(
[-] 	genericEventImpl (
[+] 	genericEventImpl(
[-] 	mouseEventImpl (
[+] 	mouseEventImpl(
[-] 	keyEventImpl (
[+] 	keyEventImpl(
[-] 	QtWidget (QWidget* parent = NULL):
[+] 	QtWidget(QWidget* parent = NULL):
[-] 		QtWidgetBase (&(T::m_widgetDriver), parent),
[+] 		QtWidgetBase(&(T::m_widgetDriver), parent),
[-] 		T (WidgetConstructParam (getQtEngine (), (QtWidgetBase*) this))
[+] 		T(WidgetConstructParam(getQtEngine(), (QtWidgetBase*)this))
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_TextAttr.h
----------------------
[-] 	TextAttr ()
[+] 	TextAttr()
[-] 	TextAttr (
[+] 	TextAttr(
[-] 		setup (foreColor, backColor, fontFlags);
[+] 		setup(foreColor, backColor, fontFlags);
[-] 	TextAttr (
[+] 	TextAttr(
[-] 		setup (colorAttr, fontFlags);
[+] 		setup(colorAttr, fontFlags);
[-] 	cmp (const TextAttr& attr)
[+] 	cmp(const TextAttr& attr)
[-] 		return memcmp (this, &attr, sizeof (TextAttr));
[+] 		return memcmp(this, &attr, sizeof(TextAttr));
[-] 	clear ()
[+] 	clear()
[-] 		ColorAttr::clear ();
[+] 		ColorAttr::clear();
[-] 	setup (
[+] 	setup(
[-] 	setup (
[+] 	setup(
[-] 		*(ColorAttr*) this = colorAttr;
[+] 		*(ColorAttr*)this = colorAttr;
[-] 	overlay (
[+] 	overlay(
[-] 		ColorAttr::overlay (baseAttr, overlayAttr);
[+] 		ColorAttr::overlay(baseAttr, overlayAttr);
[-] 		m_fontFlags = overlayFontFlags (baseAttr.m_fontFlags, overlayAttr.m_fontFlags);
[+] 		m_fontFlags = overlayFontFlags(baseAttr.m_fontFlags, overlayAttr.m_fontFlags);
[-] 	overlay (const TextAttr& overlayAttr)
[+] 	overlay(const TextAttr& overlayAttr)
[-] 		overlay (*this, overlayAttr);
[+] 		overlay(*this, overlayAttr);
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_TextAttrAnchorArray.h
----------------------
[-] 	TextAttrAnchor ()
[+] 	TextAttrAnchor()
[-] 	TextAttrAnchor (
[+] 	TextAttrAnchor(
[-] 	sl::Array <TextAttrAnchor> m_array;
[+] 	sl::Array<TextAttrAnchor> m_array;
[-] 	isEmpty () const
[+] 	isEmpty() const
[-] 		return m_array.isEmpty ();
[+] 		return m_array.isEmpty();
[-] 	getCount () const
[+] 	getCount() const
[-] 		return m_array.getCount ();
[+] 		return m_array.getCount();
[-] 	cp () const
[+] 	cp() const
[-] 		return m_array.cp ();
[+] 		return m_array.cp();
[-] 	clear ()
[+] 	clear()
[-] 		m_array.clear ();
[+] 		m_array.clear();
[-] 	clearBefore (size_t offset);
[+] 	clearBefore(size_t offset);
[-] 	copy (
[+] 	copy(
[-] 		m_array.copy (attrAnchorArray, attrAnchorCount);
[+] 		m_array.copy(attrAnchorArray, attrAnchorCount);
[-] 	getAttr (size_t offset) const
[+] 	getAttr(size_t offset) const
[-] 		size_t anchor = findAnchor (offset);
[+] 		size_t anchor = findAnchor(offset);
[-] 		return anchor == -1 ? m_array [anchor].m_attr : TextAttr ();
[+] 		return anchor == -1 ? m_array[anchor].m_attr : TextAttr();
[-] 	setAttr (
[+] 	setAttr(
[-] 	trace ();
[+] 	trace();
[-] 	findAnchor (size_t offset) const;
[+] 	findAnchor(size_t offset) const;
[-] 	getStartAnchor (size_t offset);
[+] 	getStartAnchor(size_t offset);
[-] 	getEndAnchor (size_t offset);
[+] 	getEndAnchor(size_t offset);
[-] 	normalize (
[+] 	normalize(
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_TextPainter.h
----------------------
[-] 	sl::Array <utf32_t> m_binTextBuffer;
[+] 	sl::Array<utf32_t> m_binTextBuffer;
[-] 	TextPainter ()
[+] 	TextPainter()
[-] 		init ();
[+] 		init();
[-] 	TextPainter (Canvas* canvas)
[+] 	TextPainter(Canvas* canvas)
[-] 		init (canvas);
[+] 		init(canvas);
[-] 	getPoint ()
[+] 	getPoint()
[-] 	drawSpace (
[+] 	drawSpace(
[-] 	drawSpace (size_t length)
[+] 	drawSpace(size_t length)
[-] 		return drawSpace (length, m_canvas->m_colorAttr.m_backColor);
[+] 		return drawSpace(length, m_canvas->m_colorAttr.m_backColor);
[-] 	drawSpace_p (
[+] 	drawSpace_p(
[-] 	drawSpace_p (int width) // in pixels
[+] 	drawSpace_p(int width) // in pixels
[-] 		return drawSpace_p (width, m_canvas->m_colorAttr.m_backColor);
[+] 		return drawSpace_p(width, m_canvas->m_colorAttr.m_backColor);
[-] 	drawText (
[+] 	drawText(
[-] 		return drawText_utf8 (textColor, backColor, fontFlags, text);
[+] 		return drawText_utf8(textColor, backColor, fontFlags, text);
[-] 	drawText (
[+] 	drawText(
[-] 		return drawText_utf8 (attr, text);
[+] 		return drawText_utf8(attr, text);
[-] 	drawText (const sl::StringRef& text)
[+] 	drawText(const sl::StringRef& text)
[-] 		return drawText_utf8 (text);
[+] 		return drawText_utf8(text);
[-] 	drawText_utf8 (
[+] 	drawText_utf8(
[-] 	drawText_utf8 (
[+] 	drawText_utf8(
[-] 		return drawText_utf8 (
[+] 		return drawText_utf8(
[-] 	drawText_utf8 (const sl::StringRef_utf8& text)
[+] 	drawText_utf8(const sl::StringRef_utf8& text)
[-] 		return drawText_utf8 (
[+] 		return drawText_utf8(
[-] 	drawText_utf32 (
[+] 	drawText_utf32(
[-] 	drawText_utf32 (
[+] 	drawText_utf32(
[-] 		return drawText_utf32 (
[+] 		return drawText_utf32(
[-] 	drawText_utf32 (const sl::StringRef_utf32& text)
[+] 	drawText_utf32(const sl::StringRef_utf32& text)
[-] 		return drawText_utf32 (
[+] 		return drawText_utf32(
[-] 	drawHyperText (
[+] 	drawHyperText(
[-] 		return drawHyperText_utf8 (
[+] 		return drawHyperText_utf8(
[-] 	drawHyperText (
[+] 	drawHyperText(
[-] 		return drawHyperText_utf8 (attr, attrArray, text);
[+] 		return drawHyperText_utf8(attr, attrArray, text);
[-] 	drawHyperText (
[+] 	drawHyperText(
[-] 		return drawHyperText_utf8 (attrArray, text);
[+] 		return drawHyperText_utf8(attrArray, text);
[-] 	drawHyperText_utf8 (
[+] 	drawHyperText_utf8(
[-] 	drawHyperText_utf8 (
[+] 	drawHyperText_utf8(
[-] 		return drawHyperText_utf8 (
[+] 		return drawHyperText_utf8(
[-] 	drawHyperText_utf8 (
[+] 	drawHyperText_utf8(
[-] 		return drawHyperText_utf8 (
[+] 		return drawHyperText_utf8(
[-] 	drawHyperText_utf32 (
[+] 	drawHyperText_utf32(
[-] 	drawHyperText_utf32 (
[+] 	drawHyperText_utf32(
[-] 		return drawHyperText_utf32 (
[+] 		return drawHyperText_utf32(
[-] 	drawHyperText_utf32 (
[+] 	drawHyperText_utf32(
[-] 		return drawHyperText_utf32 (
[+] 		return drawHyperText_utf32(
[-] 	drawSelHyperText (
[+] 	drawSelHyperText(
[-] 		return drawSelHyperText_utf8 (
[+] 		return drawSelHyperText_utf8(
[-] 	drawSelHyperText (
[+] 	drawSelHyperText(
[-] 		return drawSelHyperText_utf8 (
[+] 		return drawSelHyperText_utf8(
[-] 	drawSelHyperText (
[+] 	drawSelHyperText(
[-] 		return drawSelHyperText_utf8 (
[+] 		return drawSelHyperText_utf8(
[-] 	drawSelHyperText_utf8 (
[+] 	drawSelHyperText_utf8(
[-] 	drawSelHyperText_utf8 (
[+] 	drawSelHyperText_utf8(
[-] 		return drawSelHyperText_utf8 (
[+] 		return drawSelHyperText_utf8(
[-] 	drawSelHyperText_utf8 (
[+] 	drawSelHyperText_utf8(
[-] 		return drawSelHyperText_utf8 (
[+] 		return drawSelHyperText_utf8(
[-] 	drawSelHyperText_utf32 (
[+] 	drawSelHyperText_utf32(
[-] 	drawSelHyperText_utf32 (
[+] 	drawSelHyperText_utf32(
[-] 		return drawSelHyperText_utf32 (
[+] 		return drawSelHyperText_utf32(
[-] 	drawSelHyperText_utf32 (
[+] 	drawSelHyperText_utf32(
[-] 		return drawSelHyperText_utf32 (
[+] 		return drawSelHyperText_utf32(
[-] 	drawBinHex (
[+] 	drawBinHex(
[-] 	drawBinHex (
[+] 	drawBinHex(
[-] 		return drawBinHex (
[+] 		return drawBinHex(
[-] 	drawBinHex (
[+] 	drawBinHex(
[-] 		return drawBinHex (
[+] 		return drawBinHex(
[-] 	drawHyperBinHex (
[+] 	drawHyperBinHex(
[-] 	drawHyperBinHex (
[+] 	drawHyperBinHex(
[-] 		return drawHyperBinHex (
[+] 		return drawHyperBinHex(
[-] 	drawHyperBinHex (
[+] 	drawHyperBinHex(
[-] 		return drawHyperBinHex (
[+] 		return drawHyperBinHex(
[-] 	drawSelHyperBinHex (
[+] 	drawSelHyperBinHex(
[-] 	drawSelHyperBinHex (
[+] 	drawSelHyperBinHex(
[-] 		return drawSelHyperBinHex (
[+] 		return drawSelHyperBinHex(
[-] 	drawSelHyperBinHex (
[+] 	drawSelHyperBinHex(
[-] 		return drawSelHyperBinHex (
[+] 		return drawSelHyperBinHex(
[-] 	drawBinText (
[+] 	drawBinText(
[-] 	drawBinText (
[+] 	drawBinText(
[-] 		return drawBinText (
[+] 		return drawBinText(
[-] 	drawBinText (
[+] 	drawBinText(
[-] 		return drawBinText (
[+] 		return drawBinText(
[-] 	drawHyperBinText (
[+] 	drawHyperBinText(
[-] 	drawHyperBinText (
[+] 	drawHyperBinText(
[-] 		return drawHyperBinText (
[+] 		return drawHyperBinText(
[-] 	drawHyperBinText (
[+] 	drawHyperBinText(
[-] 		return drawHyperBinText (
[+] 		return drawHyperBinText(
[-] 	drawSelHyperBinText (
[+] 	drawSelHyperBinText(
[-] 	drawSelHyperBinText (
[+] 	drawSelHyperBinText(
[-] 		return drawSelHyperBinText (
[+] 		return drawSelHyperBinText(
[-] 	drawSelHyperBinText (
[+] 	drawSelHyperBinText(
[-] 		return drawSelHyperBinText (
[+] 		return drawSelHyperBinText(
[-] 	buildBinTextString (
[+] 	buildBinTextString(
[-] 		sl::Array <utf32_t>* binTextBuffer,
[+] 		sl::Array<utf32_t>* binTextBuffer,
[-] 	buildBinTextString (
[+] 	buildBinTextString(
[-] 	init (Canvas* canvas = NULL);
[+] 	init(Canvas* canvas = NULL);
[-] 	buildBinTextBuffer (
[+] 	buildBinTextBuffer(
[-] 		sl::Array <utf32_t>* binTextBuffer,
[+] 		sl::Array<utf32_t>* binTextBuffer,
[-] 	buildBinTextBuffer (
[+] 	buildBinTextBuffer(
[-] 		return buildBinTextBuffer (
[+] 		return buildBinTextBuffer(
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_gui\axl_gui_Widget.h
----------------------
[-] 	WidgetMsg ()
[+] 	WidgetMsg()
[-] 	WidgetMsg (WidgetMsgCode msgCode)
[+] 	WidgetMsg(WidgetMsgCode msgCode)
[-] 	WidgetMsgParam ()
[+] 	WidgetMsgParam()
[-] 	WidgetMsgParam (
[+] 	WidgetMsgParam(
[-] 	Rect m_region [4];
[+] 	Rect m_region[4];
[-] 	WidgetPaintMsg (Canvas* canvas)
[+] 	WidgetPaintMsg(Canvas* canvas)
[-] 	WidgetMouseMsg ()
[+] 	WidgetMouseMsg()
[-] 	WidgetMouseWheelMsg ()
[+] 	WidgetMouseWheelMsg()
[-] 	WidgetKeyMsg ()
[+] 	WidgetKeyMsg()
[-] 	ref::Ptr <void> m_params;
[+] 	ref::Ptr<void> m_params;
[-] 	WidgetGdiMsg (
[+] 	WidgetGdiMsg(
[-] 		WidgetMsg (WidgetMsgCode_Gdi)
[+] 		WidgetMsg(WidgetMsgCode_Gdi)
[-] 	WidgetQtMsg ():
[+] 	WidgetQtMsg():
[-] 		WidgetMsg (WidgetMsgCode_Qt)
[+] 		WidgetMsg(WidgetMsgCode_Qt)
[-] 	WidgetGtkMsg ():
[+] 	WidgetGtkMsg():
[-] 		WidgetMsg (WidgetMsgCode_Gtk)
[+] 		WidgetMsg(WidgetMsgCode_Gtk)
[-] 	WidgetScrollBar ()
[+] 	WidgetScrollBar()
[-] 	WidgetScrollBar (
[+] 	WidgetScrollBar(
[-] 	isRelevant () const
[+] 	isRelevant() const
[-] 	isMaxed () const
[+] 	isMaxed() const
[-] 	getMaxPos ()
[+] 	getMaxPos()
[-] 	WidgetMsgProc m_msgProcTable [WidgetMsgCode__Count];
[+] 	WidgetMsgProc m_msgProcTable[WidgetMsgCode__Count];
[-] 	WidgetConstructParam (
[+] 	WidgetConstructParam(
[-] 	WidgetScrollBar m_scrollBarArray [2];
[+] 	WidgetScrollBar m_scrollBarArray[2];
[-] 	WidgetDriver (const WidgetConstructParam& param);
[+] 	WidgetDriver(const WidgetConstructParam& param);
[-] 	getEngineWidget ()
[+] 	getEngineWidget()
[-] 	getFont ()
[+] 	getFont()
[-] 	setFont (Font* font);
[+] 	setFont(Font* font);
[-] 	getColorAttr ()
[+] 	getColorAttr()
[-] 	setColorAttr (
[+] 	setColorAttr(
[-] 		m_colorAttr.setup (foreColor, backColor);
[+] 		m_colorAttr.setup(foreColor, backColor);
[-] 		return redraw ();
[+] 		return redraw();
[-] 	setColorAttr (const ColorAttr& attr)
[+] 	setColorAttr(const ColorAttr& attr)
[-] 		return redraw ();
[+] 		return redraw();
[-] 	getPalette ()
[+] 	getPalette()
[-] 	setPalette (
[+] 	setPalette(
[-] 		m_palette.setup (colorArray, count);
[+] 		m_palette.setup(colorArray, count);
[-] 		return redraw ();
[+] 		return redraw();
[-] 	setPalette (const Palette& palette)
[+] 	setPalette(const Palette& palette)
[-] 		return redraw ();
[+] 		return redraw();
[-] 	redraw (
[+] 	redraw(
[-] 		return m_engine->redrawWidget (this, left, top, right, bottom);
[+] 		return m_engine->redrawWidget(this, left, top, right, bottom);
[-] 	redraw (const Rect& rect)
[+] 	redraw(const Rect& rect)
[-] 		return redraw (rect.m_left, rect.m_top, rect.m_right, rect.m_bottom);
[+] 		return redraw(rect.m_left, rect.m_top, rect.m_right, rect.m_bottom);
[-] 	redraw ()
[+] 	redraw()
[-] 		return redraw (0, 0, 0, 0);
[+] 		return redraw(0, 0, 0, 0);
[-] 	redrawImmediate (
[+] 	redrawImmediate(
[-] 		return m_engine->redrawWidgetImmediate (this, left, top, right, bottom);
[+] 		return m_engine->redrawWidgetImmediate(this, left, top, right, bottom);
[-] 	redrawImmediate (const Rect& rect)
[+] 	redrawImmediate(const Rect& rect)
[-] 		return redrawImmediate (rect.m_left, rect.m_top, rect.m_right, rect.m_bottom);
[+] 		return redrawImmediate(rect.m_left, rect.m_top, rect.m_right, rect.m_bottom);
[-] 	redrawImmediate ()
[+] 	redrawImmediate()
[-] 		return redrawImmediate (0, 0, 0, 0);
[+] 		return redrawImmediate(0, 0, 0, 0);
[-] 	scroll (
[+] 	scroll(
[-] 		return m_engine->scrollWidget (this, dx, dy);
[+] 		return m_engine->scrollWidget(this, dx, dy);
[-] 	scrollRect (
[+] 	scrollRect(
[-] 		return m_engine->scrollWidgetRect (this, left, top, right, bottom, dx, dy);
[+] 		return m_engine->scrollWidgetRect(this, left, top, right, bottom, dx, dy);
[-] 	scrollRect (
[+] 	scrollRect(
[-] 		return scrollRect (rect.m_left, rect.m_top, rect.m_right, rect.m_bottom, dx, dy);
[+] 		return scrollRect(rect.m_left, rect.m_top, rect.m_right, rect.m_bottom, dx, dy);
[-] 	scrollRect (
[+] 	scrollRect(
[-] 		return scrollRect (0, 0, m_size.m_width, m_size.m_height, dx, dy);
[+] 		return scrollRect(0, 0, m_size.m_width, m_size.m_height, dx, dy);
[-] 	isFocused ()
[+] 	isFocused()
[-] 		return m_engine->isWidgetFocused (this);
[+] 		return m_engine->isWidgetFocused(this);
[-] 	setFocus ()
[+] 	setFocus()
[-] 		return m_engine->setWidgetFocus (this);
[+] 		return m_engine->setWidgetFocus(this);
[-] 	getCursor ()
[+] 	getCursor()
[-] 	setCursor (Cursor* cursor)
[+] 	setCursor(Cursor* cursor)
[-] 		return m_engine->setWidgetCursor (this, cursor);
[+] 		return m_engine->setWidgetCursor(this, cursor);
[-] 	setMouseCapture ()
[+] 	setMouseCapture()
[-] 		return m_engine->setMouseCapture (this);
[+] 		return m_engine->setMouseCapture(this);
[-] 	releaseMouseCapture ()
[+] 	releaseMouseCapture()
[-] 		return m_engine->releaseMouse (this);
[+] 		return m_engine->releaseMouse(this);
[-] 	isCaretVisible ()
[+] 	isCaretVisible()
[-] 	setCaretVisible (bool isVisible);
[+] 	setCaretVisible(bool isVisible);
[-] 	getCaretSize ()
[+] 	getCaretSize()
[-] 	setCaretWidth (uint_t width)
[+] 	setCaretWidth(uint_t width)
[-] 		return setCaretSize (width, m_caretSize.m_height);
[+] 		return setCaretSize(width, m_caretSize.m_height);
[-] 	setCaretHeight (uint_t height)
[+] 	setCaretHeight(uint_t height)
[-] 		return setCaretSize (m_caretSize.m_width, height);
[+] 		return setCaretSize(m_caretSize.m_width, height);
[-] 	setCaretSize (
[+] 	setCaretSize(
[-] 	setCaretSize (const Size& size)
[+] 	setCaretSize(const Size& size)
[-] 		return setCaretSize (size.m_width, size.m_height);
[+] 		return setCaretSize(size.m_width, size.m_height);
[-] 	getCaretPos ()
[+] 	getCaretPos()
[-] 	setCaretPos (
[+] 	setCaretPos(
[-] 	setCaretPos (const Point& point)
[+] 	setCaretPos(const Point& point)
[-] 		return setCaretPos (point.m_x, point.m_y);
[+] 		return setCaretPos(point.m_x, point.m_y);
[-] 	scheduleToolTipMsg (uint_t timeout = 0) // 0 -- use engine default
[+] 	scheduleToolTipMsg(uint_t timeout = 0) // 0 -- use engine default
[-] 		return m_engine->scheduleToolTipMsg (this, timeout);
[+] 		return m_engine->scheduleToolTipMsg(this, timeout);
[-] 	cancelToolTipMsg ()
[+] 	cancelToolTipMsg()
[-] 		return m_engine->cancelToolTipMsg (this);
[+] 		return m_engine->cancelToolTipMsg(this);
[-] 	showToolTip (
[+] 	showToolTip(
[-] 		return m_engine->showToolTip (this, x, y, toolTip);
[+] 		return m_engine->showToolTip(this, x, y, toolTip);
[-] 	showToolTip (
[+] 	showToolTip(
[-] 		return m_engine->showToolTip (this, point.m_x, point.m_y, toolTip);
[+] 		return m_engine->showToolTip(this, point.m_x, point.m_y, toolTip);
[-] 	hideToolTip ()
[+] 	hideToolTip()
[-] 		return m_engine->hideToolTip (this);
[+] 		return m_engine->hideToolTip(this);
[-] 	updateScrollBar (Orientation orientation)
[+] 	updateScrollBar(Orientation orientation)
[-] 		return m_engine->updateWidgetScrollBar (this, orientation);
[+] 		return m_engine->updateWidgetScrollBar(this, orientation);
[-] 	updateScrollBars ()
[+] 	updateScrollBars()
[-] 			updateScrollBar (Orientation_Vertical) &&
[+] 			updateScrollBar(Orientation_Vertical) &&
[-] 			updateScrollBar (Orientation_Horizontal);
[+] 			updateScrollBar(Orientation_Horizontal);
[-] 	updateScrollBars (uint_t mask);
[+] 	updateScrollBars(uint_t mask);
[-] 	notify (
[+] 	notify(
[-] 		m_engine->sendWidgetNotification (this, code, params);
[+] 		m_engine->sendWidgetNotification(this, code, params);
[-] 	postThreadMsg (
[+] 	postThreadMsg(
[-] 		const ref::Ptr <void>& params
[+] 		const ref::Ptr<void>& params
[-] 		return m_engine->postWidgetThreadMsg (this, code, params);
[+] 		return m_engine->postWidgetThreadMsg(this, code, params);
[-] 	postThreadMsg (
[+] 	postThreadMsg(
[-] 	postThreadMsg (
[+] 	postThreadMsg(
[-] 		return m_engine->postWidgetThreadMsg (this, code, ref::Ptr <void> ((void*) param, NULL));
[+] 		return m_engine->postWidgetThreadMsg(this, code, ref::Ptr<void> ((void*)param, NULL));
[-] 	postThreadMsg (uint_t code)
[+] 	postThreadMsg(uint_t code)
[-] 		return m_engine->postWidgetThreadMsg (this, code, ref::Ptr <void> (NULL, NULL));
[+] 		return m_engine->postWidgetThreadMsg(this, code, ref::Ptr<void> (NULL, NULL));
[-] 	startAnimation ()
[+] 	startAnimation()
[-] 		return m_engine->startWidgetAnimation (this);
[+] 		return m_engine->startWidgetAnimation(this);
[-] 	stopAnimation ()
[+] 	stopAnimation()
[-] 		m_engine->stopWidgetAnimation (this);
[+] 		m_engine->stopWidgetAnimation(this);
[-] 	checkMsgMap (WidgetMsgCode msgCode)
[+] 	checkMsgMap(WidgetMsgCode msgCode)
[-] 		ASSERT (msgCode < WidgetMsgCode__Count);
[+] 		ASSERT(msgCode < WidgetMsgCode__Count);
[-] 		return m_msgMap ? m_msgMap->m_msgProcTable [msgCode] != NULL : true;
[+] 		return m_msgMap ? m_msgMap->m_msgProcTable[msgCode] != NULL : true;
[-] 	processMsg (
[+] 	processMsg(
[-] 	Widget (const WidgetConstructParam& param):
[+] 	Widget(const WidgetConstructParam& param):
[-] 		m_widgetDriver (param)
[+] 		m_widgetDriver(param)
[-] 	getGuiEngine ()
[+] 	getGuiEngine()
[-] 		return m_widgetDriver.getEngine ();
[+] 		return m_widgetDriver.getEngine();
[-] 	getWidgetMsgMap ()
[+] 	getWidgetMsgMap()
[-] getWidgetMsgMap () \
[+] getWidgetMsgMap() \
[-] 	map.m_baseMap = BaseClass::getWidgetMsgMap (); \
[+] 	map.m_baseMap = BaseClass::getWidgetMsgMap(); \
[-] 		memcpy (map.m_msgProcTable, map.m_baseMap->m_msgProcTable, sizeof (map.m_msgProcTable));
[+] 		memcpy(map.m_msgProcTable, map.m_baseMap->m_msgProcTable, sizeof(map.m_msgProcTable));
[-] 	map.m_msgProcTable [msgCode] = (axl::gui::WidgetMsgProc) handler;
[+] 	map.m_msgProcTable[msgCode] = (axl::gui::WidgetMsgProc)handler;
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_ini\axl_ini_GenericParser.h
----------------------
[-] 	getName () const
[+] 	getName() const
[-] 	getValue () const
[+] 	getValue() const
[-] 	sl::StringHashTable <NamedValue*> m_namedValueMap;
[+] 	sl::StringHashTable<NamedValue*> m_namedValueMap;
[-] 	sl::List <NamedValue> m_namedValueList;
[+] 	sl::List<NamedValue> m_namedValueList;
[-] 	sl::BoxList <sl::String> m_unnamedValueList;
[+] 	sl::BoxList<sl::String> m_unnamedValueList;
[-] 	getName ()
[+] 	getName()
[-] 	getNamedValue (const sl::StringRef& name) const
[+] 	getNamedValue(const sl::StringRef& name) const
[-] 		sl::ConstStringHashTableIterator <NamedValue*> it = m_namedValueMap.find (name);
[+] 		sl::ConstStringHashTableIterator<NamedValue*> it = m_namedValueMap.find(name);
[-] 	sl::ConstBoxList <sl::String>
[+] 	sl::ConstBoxList<sl::String>
[-] 	getUnnamedValueList () const
[+] 	getUnnamedValueList() const
[-] 	sl::StringHashTable <Section*> m_namedSectionMap;
[+] 	sl::StringHashTable<Section*> m_namedSectionMap;
[-] 	sl::List <Section> m_namedSectionList;
[+] 	sl::List<Section> m_namedSectionList;
[-] 	getSection (const sl::StringRef& name) const
[+] 	getSection(const sl::StringRef& name) const
[-] 		sl::ConstStringHashTableIterator <Section*> it = m_namedSectionMap.find (name);
[+] 		sl::ConstStringHashTableIterator<Section*> it = m_namedSectionMap.find(name);
[-] 	getUnnamedSection () const
[+] 	getUnnamedSection() const
[-] class GenericParser: public Parser <GenericParser>
[+] class GenericParser: public Parser<GenericParser>
[-] 	GenericParser (GenericIni* ini = NULL)
[+] 	GenericParser(GenericIni* ini = NULL)
[-] 		setIni (ini);
[+] 		setIni(ini);
[-] 	getIni () const
[+] 	getIni() const
[-] 	setIni (GenericIni* ini)
[+] 	setIni(GenericIni* ini)
[-] 	onSection (const sl::StringRef& sectionName);
[+] 	onSection(const sl::StringRef& sectionName);
[-] 	onKeyValue (
[+] 	onKeyValue(
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_ini\axl_ini_Lexer.h
----------------------
[-] 	Lexer ()
[+] 	Lexer()
[-] 		reset ();
[+] 		reset();
[-] 	create (
[+] 	create(
[-] 	parseSection (
[+] 	parseSection(
[-] 	parseKeyValue (
[+] 	parseKeyValue(
[-] 	scanLine ();
[+] 	scanLine();
[-] 	setLineCol (
[+] 	setLineCol(
[-] 	setLineCol (const lex::LineCol& lineCol)
[+] 	setLineCol(const lex::LineCol& lineCol)
[-] 		setLineCol (lineCol.m_line, lineCol.m_col);
[+] 		setLineCol(lineCol.m_line, lineCol.m_col);
[-] 	reset ();
[+] 	reset();
[-] 	newLine (char* line);
[+] 	newLine(char* line);
[-] 	stop ()
[+] 	stop()
[-] 	init ();
[+] 	init();
[-] 	exec ();
[+] 	exec();
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_ini\axl_ini_Parser.h
----------------------
[-] 	parseFile (const sl::StringRef& filePath)
[+] 	parseFile(const sl::StringRef& filePath)
[-] 			file.open (filePath, io::FileFlag_ReadOnly) &&
[+] 			file.open(filePath, io::FileFlag_ReadOnly) &&
[-] 			parse (filePath, sl::StringRef ((const char*) file.p (), file.getMappingSize ()));
[+] 			parse(filePath, sl::StringRef((const char*) file.p(), file.getMappingSize()));
[-] 	parse (const sl::StringRef& source)
[+] 	parse(const sl::StringRef& source)
[-] 		return parse ("INI", source);
[+] 		return parse("INI", source);
[-] 	parse (
[+] 	parse(
[-] 		Lexer::create (filePath, source);
[+] 		Lexer::create(filePath, source);
[-] 			ScanResultKind scanResult = scanLine ();
[+] 			ScanResultKind scanResult = scanLine();
[-] 			switch (scanResult)
[+] 			switch(scanResult)
[-] 				return static_cast <T*> (this)->finalize ();
[+] 				return static_cast<T*> (this)->finalize();
[-] 				result = static_cast <T*> (this)->onSection (m_sectionName);
[+] 				result = static_cast<T*> (this)->onSection(m_sectionName);
[-] 				result = static_cast <T*> (this)->onKeyValue (m_keyName, m_value);
[+] 				result = static_cast<T*> (this)->onKeyValue(m_keyName, m_value);
[-] 				ASSERT (false);
[+] 				ASSERT(false);
[-] 	onSection (const sl::StringRef& sectionName) // overridable
[+] 	onSection(const sl::StringRef& sectionName) // overridable
[-] 	finalize () // overridable
[+] 	finalize() // overridable
[-] 	parseBoolValue (const sl::StringRef& value)
[+] 	parseBoolValue(const sl::StringRef& value)
[-] 		return _stricmp (value.sz (), "true") == 0 || atoi (value.sz ()) != 0;
[+] 		return _stricmp(value.sz(), "true") == 0 || atoi (value.sz ()) != 0;
----------------------
27/02/2019 18:01:40 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_File.h
----------------------
[-] 	getInvalidHandle ()
[+] 	getInvalidHandle()
[-] 		return FileImpl::getInvalidHandle ();
[+] 		return FileImpl::getInvalidHandle();
[-] 	getHandle () const
[+] 	getHandle() const
[-] 	isOpen () const
[+] 	isOpen() const
[-] 		return m_file.isOpen ();
[+] 		return m_file.isOpen();
[-] 	close ()
[+] 	close()
[-] 		m_file.close ();
[+] 		m_file.close();
[-] 	open (
[+] 	open(
[-] 	duplicate (Handle h)
[+] 	duplicate(Handle h)
[-] 		return m_file.duplicate (
[+] 		return m_file.duplicate(
[-] 			::GetCurrentProcess (),
[+] 			::GetCurrentProcess(),
[-] 			::GetCurrentProcess (),
[+] 			::GetCurrentProcess(),
[-] 		return m_file.duplicate (h);
[+] 		return m_file.duplicate(h);
[-] 	duplicate (const File* file)
[+] 	duplicate(const File* file)
[-] 		ASSERT (file->isOpen ());
[+] 		ASSERT(file->isOpen());
[-] 		return duplicate (file->m_file);
[+] 		return duplicate(file->m_file);
[-] 	getSize () const
[+] 	getSize() const
[-] 		return m_file.getSize ();
[+] 		return m_file.getSize();
[-] 	setSize (uint64_t size)
[+] 	setSize(uint64_t size)
[-] 		return m_file.setSize (size);
[+] 		return m_file.setSize(size);
[-] 	getPosition () const
[+] 	getPosition() const
[-] 		return m_file.getPosition ();
[+] 		return m_file.getPosition();
[-] 	setPosition (uint64_t offset) const
[+] 	setPosition(uint64_t offset) const
[-] 		return m_file.setPosition (offset);
[+] 		return m_file.setPosition(offset);
[-] 	read (
[+] 	read(
[-] 		return m_file.read (p, size);
[+] 		return m_file.read(p, size);
[-] 	write (
[+] 	write(
[-] 		return m_file.write (p, size);
[+] 		return m_file.write(p, size);
[-] 	readAt (
[+] 	readAt(
[-] 		return setPosition (offset) ? read (p, size) : -1;
[+] 		return setPosition(offset) ? read(p, size) : -1;
[-] 		return setPosition (offset) ? write (p, size) : -1;
[+] 		return setPosition(offset) ? write(p, size) : -1;
[-] 	flush ()
[+] 	flush()
[-] 		return m_file.flush ();
[+] 		return m_file.flush();
[-] renameFile (
[+] renameFile(
[-] 	bool_t result = ::MoveFileA (srcFileName.sz (), dstFileName.sz ());
[+] 	bool_t result = ::MoveFileA(srcFileName.sz(), dstFileName.sz());
[-] 	return err::complete (result);
[+] 	return err::complete(result);
[-] deleteFile (const sl::StringRef& fileName)
[+] deleteFile(const sl::StringRef& fileName)
[-] 	bool_t result = ::DeleteFileA (fileName.sz ());
[+] 	bool_t result = ::DeleteFileA(fileName.sz());
[-] 	return err::complete (result);
[+] 	return err::complete(result);
[-] renameFile (
[+] renameFile(
[-] 	int result = ::rename (srcFileName.sz (), dstFileName.sz ());
[+] 	int result = ::rename(srcFileName.sz(), dstFileName.sz());
[-] 	return err::complete (result == 0);
[+] 	return err::complete(result == 0);
[-] deleteFile (const sl::StringRef& fileName)
[+] deleteFile(const sl::StringRef& fileName)
[-] 	int result = ::unlink (fileName.sz ());
[+] 	int result = ::unlink(fileName.sz());
[-] 	return err::complete (result == 0);
[+] 	return err::complete(result == 0);
[-] copyFile (
[+] copyFile(
[-] copyFile (
[+] copyFile(
[-] copyFile (
[+] copyFile(
[-] 	AutoDeleteFile ()
[+] 	AutoDeleteFile()
[-] 	AutoDeleteFile (const sl::StringRef& fileName)
[+] 	AutoDeleteFile(const sl::StringRef& fileName)
[-] 	~AutoDeleteFile ()
[+] 	~AutoDeleteFile()
[-] 		if (!m_fileName.isEmpty ())
[+] 		if (!m_fileName.isEmpty())
[-] 			deleteFile (m_fileName);
[+] 			deleteFile(m_fileName);
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_FileEnumerator.h
----------------------
[-] 		::FindClose (h);
[+] 		::FindClose(h);
[-] typedef sl::Handle <HANDLE, CloseFileEnumeratorHandle, sl::MinusOne <HANDLE> > FileEnumeratorHandle;
[+] typedef sl::Handle<HANDLE, CloseFileEnumeratorHandle, sl::MinusOne<HANDLE> > FileEnumeratorHandle;
[-] 		::closedir (h);
[+] 		::closedir(h);
[-] typedef sl::Handle <DIR*, CloseFileEnumeratorHandle> FileEnumeratorHandle;
[+] typedef sl::Handle<DIR*, CloseFileEnumeratorHandle> FileEnumeratorHandle;
[-] 	openDir (const sl::StringRef& dir);
[+] 	openDir(const sl::StringRef& dir);
[-] 	hasNextFile ()
[+] 	hasNextFile()
[-] 		return !m_nextFileName.isEmpty ();
[+] 		return !m_nextFileName.isEmpty();
[-] 	getNextFileName ();
[+] 	getNextFileName();
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_FilePathUtils.h
----------------------
[-] getTempDir ();
[+] getTempDir();
[-] getCurrentDir ();
[+] getCurrentDir();
[-] setCurrentDir (const sl::StringRef& dir);
[+] setCurrentDir(const sl::StringRef& dir);
[-] getExeFilePath ();
[+] getExeFilePath();
[-] getExeDir ();
[+] getExeDir();
[-] doesFileExist (const sl::StringRef& fileName);
[+] doesFileExist(const sl::StringRef& fileName);
[-] ensureDirExists (const sl::StringRef& fileName);
[+] ensureDirExists(const sl::StringRef& fileName);
[-] isDir (const sl::StringRef& fileName);
[+] isDir(const sl::StringRef& fileName);
[-] getFullFilePath (const sl::StringRef& fileName);
[+] getFullFilePath(const sl::StringRef& fileName);
[-] getDir (const sl::StringRef& filePath);
[+] getDir(const sl::StringRef& filePath);
[-] getFileName (const sl::StringRef& filePath);
[+] getFileName(const sl::StringRef& filePath);
[-] getExtension (const sl::StringRef& filePath);
[+] getExtension(const sl::StringRef& filePath);
[-] concatFilePath (
[+] concatFilePath(
[-] concatFilePath (
[+] concatFilePath(
[-] 	return concatFilePath (&filePath, fileName);
[+] 	return concatFilePath(&filePath, fileName);
[-] findFilePath (
[+] findFilePath(
[-] 	const sl::BoxList <sl::String>* dirList,
[+] 	const sl::BoxList<sl::String>* dirList,
[-] findFilePath (
[+] findFilePath(
[-] 	const sl::BoxList <sl::String>* dirList,
[+] 	const sl::BoxList<sl::String>* dirList,
[-] 	return findFilePath (fileName, NULL, dirList, doFindInCurrentDir);
[+] 	return findFilePath(fileName, NULL, dirList, doFindInCurrentDir);
[-] getSymbolicLinkTarget (
[+] getSymbolicLinkTarget(
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_FileTransport.h
----------------------
[-] 	FileTransport ()
[+] 	FileTransport()
[-] 	attach (File* file)
[+] 	attach(File* file)
[-] 	attach (
[+] 	attach(
[-] 	detach ()
[+] 	detach()
[-] 	transmit (
[+] 	transmit(
[-] 		ASSERT (m_transmitFile);
[+] 		ASSERT(m_transmitFile);
[-] 		return m_transmitFile->write (p, size);
[+] 		return m_transmitFile->write(p, size);
[-] 	receive (
[+] 	receive(
[-] 		ASSERT (m_receiveFile);
[+] 		ASSERT(m_receiveFile);
[-] 		return m_receiveFile->read (p, size);
[+] 		return m_receiveFile->read(p, size);
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_MappedFile.h
----------------------
[-] 	typedef sl::RbTree <uint64_t, ViewEntry*> ViewMap;
[+] 	typedef sl::RbTree<uint64_t, ViewEntry*> ViewMap;
[-] 	sl::List <ViewEntry> m_viewList;
[+] 	sl::List<ViewEntry> m_viewList;
[-] 	MappedViewMgr (size_t offset) // protected construction only
[+] 	MappedViewMgr(size_t offset) // protected construction only
[-] 	getMappedFile ()
[+] 	getMappedFile()
[-] 		return (MappedFile*) ((char*) this - m_parentOffset);
[+] 		return (MappedFile*)((char*)this - m_parentOffset);
[-] 	isEmpty ()
[+] 	isEmpty()
[-] 		return m_viewList.isEmpty ();
[+] 		return m_viewList.isEmpty();
[-] 	find (
[+] 	find(
[-] 	view (
[+] 	view(
[-] 	clear ()
[+] 	clear()
[-] 		m_viewList.clear ();
[+] 		m_viewList.clear();
[-] 		m_viewMap.clear ();
[+] 		m_viewMap.clear();
[-] 	limitViewCount (size_t maxViewCount);
[+] 	limitViewCount(size_t maxViewCount);
[-] 	MappedFile ();
[+] 	MappedFile();
[-] 	~MappedFile ()
[+] 	~MappedFile()
[-] 		close ();
[+] 		close();
[-] 	isOpen () const
[+] 	isOpen() const
[-] 		return m_file.isOpen ();
[+] 		return m_file.isOpen();
[-] 	getFlags () const
[+] 	getFlags() const
[-] 	getFile () const
[+] 	getFile() const
[-] 	getSize () const
[+] 	getSize() const
[-] 		return m_file.getSize ();
[+] 		return m_file.getSize();
[-] 	setSize (uint64_t size); // can only be called when no views are mapped
[+] 	setSize(uint64_t size); // can only be called when no views are mapped
[-] 	close ();
[+] 	close();
[-] 	open (
[+] 	open(
[-] 	duplicate (
[+] 	duplicate(
[-] 	duplicate (
[+] 	duplicate(
[-] 		ASSERT (file->isOpen ());
[+] 		ASSERT(file->isOpen());
[-] 		return duplicate (file->getHandle (), flags);
[+] 		return duplicate(file->getHandle(), flags);
[-] 	attach (
[+] 	attach(
[-] 	detach ();
[+] 	detach();
[-] 	setup (
[+] 	setup(
[-] 	view (
[+] 	view(
[-] 		return ((MappedFile*) this)->view (offset, size, isPermanent);
[+] 		return ((MappedFile*)this)->view(offset, size, isPermanent);
[-] 	view (
[+] 	view(
[-] 		return view (offset, size, NULL, isPermanent);
[+] 		return view(offset, size, NULL, isPermanent);
[-] 	view (
[+] 	view(
[-] 		return ((MappedFile*) this)->view (offset, size, actualSize, isPermanent);
[+] 		return ((MappedFile*)this)->view(offset, size, actualSize, isPermanent);
[-] 	view (
[+] 	view(
[-] 	unmapAllViews ();
[+] 	unmapAllViews();
[-] 	viewImpl (
[+] 	viewImpl(
[-] 	SimpleMappedFile ()
[+] 	SimpleMappedFile()
[-] 	isOpen ()
[+] 	isOpen()
[-] 		return m_mapping.isOpen ();
[+] 		return m_mapping.isOpen();
[-] 	p ()
[+] 	p()
[-] 		return m_mapping.p ();
[+] 		return m_mapping.p();
[-] 	getFileSize ()
[+] 	getFileSize()
[-] 		return m_file.getSize ();
[+] 		return m_file.getSize();
[-] 	getMappingSize ()
[+] 	getMappingSize()
[-] 		return m_mapping.getSize ();
[+] 		return m_mapping.getSize();
[-] 	open (
[+] 	open(
[-] 	open (
[+] 	open(
[-] 		return open (fileName, 0, -1, flags);
[+] 		return open(fileName, 0, -1, flags);
[-] 	view (
[+] 	view(
[-] 		return m_mapping.open (&m_file, offset, size, m_openFlags);
[+] 		return m_mapping.open(&m_file, offset, size, m_openFlags);
[-] 	close ()
[+] 	close()
[-] 		m_file.close ();
[+] 		m_file.close();
[-] 		m_mapping.close ();
[+] 		m_mapping.close();
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_Mapping.h
----------------------
[-] 	Mapping ()
[+] 	Mapping()
[-] 	isOpen ()
[+] 	isOpen()
[-] 	p ()
[+] 	p()
[-] 	getSize ()
[+] 	getSize()
[-] 	open (
[+] 	open(
[-] 	open (
[+] 	open(
[-] 		return open (file, 0, -1, flags);
[+] 		return open(file, 0, -1, flags);
[-] 	open (
[+] 	open(
[-] 	close ();
[+] 	close();
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_NetworkAdapter.h
----------------------
[-] getNetworkAdapterTypeString (NetworkAdapterType adapterKind);
[+] getNetworkAdapterTypeString(NetworkAdapterType adapterKind);
[-] getFirstNetworkAdapterFlag (uint_t flags)
[+] getFirstNetworkAdapterFlag(uint_t flags)
[-] 	return (NetworkAdapterFlag) (1 << sl::getLoBitIdx (flags));
[+] 	return (NetworkAdapterFlag)(1 << sl::getLoBitIdx(flags));
[-] getNetworkAdapterFlagString (NetworkAdapterFlag flag);
[+] getNetworkAdapterFlagString(NetworkAdapterFlag flag);
[-] getNetworkAdapterFlagString (uint_t flags);
[+] getNetworkAdapterFlagString(uint_t flags);
[-] 	uchar_t m_mac [6];
[+] 	uchar_t m_mac[6];
[-] 	sl::List <NetworkAdapterAddress> m_addressList;
[+] 	sl::List<NetworkAdapterAddress> m_addressList;
[-] 	NetworkAdapterDesc ();
[+] 	NetworkAdapterDesc();
[-] 	getType () const
[+] 	getType() const
[-] 	getFlags () const
[+] 	getFlags() const
[-] 	getName () const
[+] 	getName() const
[-] 	getDescription () const
[+] 	getDescription() const
[-] 	getMac () const
[+] 	getMac() const
[-] 	sl::ConstList <NetworkAdapterAddress>
[+] 	sl::ConstList<NetworkAdapterAddress>
[-] 	getAddressList () const
[+] 	getAddressList() const
[-] createNetworkAdapterDescList (sl::List <NetworkAdapterDesc>* adapterList);
[+] createNetworkAdapterDescList(sl::List<NetworkAdapterDesc>* adapterList);
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_Pcap.h
----------------------
[-] 		::pcap_close (h);
[+] 		::pcap_close(h);
[-] class Pcap: public sl::Handle <pcap_t*, ClosePcap>
[+] class Pcap: public sl::Handle<pcap_t*, ClosePcap>
[-] 	openDevice (
[+] 	openDevice(
[-] 	openFile (const sl::StringRef& fileName);
[+] 	openFile(const sl::StringRef& fileName);
[-] 	setFilter (const sl::StringRef& filter);
[+] 	setFilter(const sl::StringRef& filter);
[-] 	setBlockingMode (bool isBlocking);
[+] 	setBlockingMode(bool isBlocking);
[-] 	read (
[+] 	read(
[-] 	read (
[+] 	read(
[-] 		return read (p, size, NULL);
[+] 		return read(p, size, NULL);
[-] 	write (
[+] 	write(
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_Serial.h
----------------------
[-] 	isOpen ()
[+] 	isOpen()
[-] 		return m_serial.isOpen ();
[+] 		return m_serial.isOpen();
[-] 	open (
[+] 	open(
[-] 	close ()
[+] 	close()
[-] 		return m_serial.close ();
[+] 		return m_serial.close();
[-] 	setSettings (
[+] 	setSettings(
[-] 	getSettings (SerialSettings* settings);
[+] 	getSettings(SerialSettings* settings);
[-] 	setDtr (bool isSet)
[+] 	setDtr(bool isSet)
[-] 		return m_serial.setDtr (isSet);
[+] 		return m_serial.setDtr(isSet);
[-] 	setRts (bool isSet)
[+] 	setRts(bool isSet)
[-] 		return m_serial.setRts (isSet);
[+] 		return m_serial.setRts(isSet);
[-] 	getStatusLines ();
[+] 	getStatusLines();
[-] 	read (
[+] 	read(
[-] 		return m_serial.overlappedRead (p, size);
[+] 		return m_serial.overlappedRead(p, size);
[-] 	write (
[+] 	write(
[-] 		return m_serial.overlappedWrite (p, size);
[+] 		return m_serial.overlappedWrite(p, size);
[-] 	read (
[+] 	read(
[-] 		return m_serial.read (p, size);
[+] 		return m_serial.read(p, size);
[-] 	write (
[+] 	write(
[-] 		return m_serial.write (p, size);
[+] 		return m_serial.write(p, size);
[-] 	getDeviceName ()
[+] 	getDeviceName()
[-] 	getDescription ()
[+] 	getDescription()
[-] createSerialPortDescList (sl::List <SerialPortDesc>* portList);
[+] createSerialPortDescList(sl::List<SerialPortDesc>* portList);
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_SerialSettings.h
----------------------
[-] 	SerialSettings ()
[+] 	SerialSettings()
[-] 		setup (38400);
[+] 		setup(38400);
[-] 	SerialSettings (
[+] 	SerialSettings(
[-] 		setup (baudRate, dataBits, stopBits, parity, flowControl, readInterval, dtr, rts);
[+] 		setup(baudRate, dataBits, stopBits, parity, flowControl, readInterval, dtr, rts);
[-] 	setup (
[+] 	setup(
[-] 	setDcb (const DCB* dcb);
[+] 	setDcb(const DCB* dcb);
[-] 	setAttr (const termios* attr);
[+] 	setAttr(const termios* attr);
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_SharedMemoryTransport.h
----------------------
[-] 	SharedMemoryTransportBase ();
[+] 	SharedMemoryTransportBase();
[-] 	~SharedMemoryTransportBase ()
[+] 	~SharedMemoryTransportBase()
[-] 		close ();
[+] 		close();
[-] 	getFlags ()
[+] 	getFlags()
[-] 	getFile () const
[+] 	getFile() const
[-] 	isOpen ()
[+] 	isOpen()
[-] 	close ();
[+] 	close();
[-] 	open (
[+] 	open(
[-] 	attach (
[+] 	attach(
[-] 	disconnect ();
[+] 	disconnect();
[-] 	closeImpl ();
[+] 	closeImpl();
[-] 	initializeMapping (
[+] 	initializeMapping(
[-] 		return ensureMappingSize (size);
[+] 		return ensureMappingSize(size);
[-] 	initializeMapping (
[+] 	initializeMapping(
[-] 	ensureMappingSize (size_t size);
[+] 	ensureMappingSize(size_t size);
[-] 	ensureOffsetMapped (size_t offset)
[+] 	ensureOffsetMapped(size_t offset)
[-] 		return ensureMappingSize (offset + sizeof (SharedMemoryTransportHdr));
[+] 		return ensureMappingSize(offset + sizeof(SharedMemoryTransportHdr));
[-] 	read (sl::Array <char>* buffer);
[+] 	read(sl::Array<char>* buffer);
[-] 	sl::Array <char>
[+] 	sl::Array<char>
[-] 	read ()
[+] 	read()
[-] 		sl::Array <char> buffer;
[+] 		sl::Array<char> buffer;
[-] 		read (&buffer);
[+] 		read(&buffer);
[-] 	SharedMemoryWriter ()
[+] 	SharedMemoryWriter()
[-] 	open (
[+] 	open(
[-] 	attach (
[+] 	attach(
[-] 	write (
[+] 	write(
[-] 		return write (&p, &size, 1);
[+] 		return write(&p, &size, 1);
[-] 	write (
[+] 	write(
[-] 	copyWriteChain (
[+] 	copyWriteChain(
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_SockAddr.h
----------------------
[-] getSockAddrFamilyString (uint_t family);
[+] getSockAddrFamilyString(uint_t family);
[-] getSockAddrFamilySize (uint_t family);
[+] getSockAddrFamilySize(uint_t family);
[-] getSockAddrSize (const sockaddr* addr)
[+] getSockAddrSize(const sockaddr* addr)
[-] 	return getSockAddrFamilySize (addr->sa_family);
[+] 	return getSockAddrFamilySize(addr->sa_family);
[-] getSockProtoString (uint_t proto);
[+] getSockProtoString(uint_t proto);
[-] getSockAddrNetMaskBitCount_ip4 (const sockaddr_in* addr);
[+] getSockAddrNetMaskBitCount_ip4(const sockaddr_in* addr);
[-] getSockAddrNetMaskBitCount_ip6 (const sockaddr_in6* addr);
[+] getSockAddrNetMaskBitCount_ip6(const sockaddr_in6* addr);
[-] getSockAddrNetMaskBitCount (const sockaddr* addr);
[+] getSockAddrNetMaskBitCount(const sockaddr* addr);
[-] createSockAddrNetMask_ip4 (
[+] createSockAddrNetMask_ip4(
[-] createSockAddrNetMask_ip6 (
[+] createSockAddrNetMask_ip6(
[-] isSockAddrEqual_ip4 (
[+] isSockAddrEqual_ip4(
[-] isSockAddrEqual_ip6 (
[+] isSockAddrEqual_ip6(
[-] isSockAddrEqual (
[+] isSockAddrEqual(
[-] isSockAddrMatch_ip4 (
[+] isSockAddrMatch_ip4(
[-] isSockAddrMatch_ip6 (
[+] isSockAddrMatch_ip6(
[-] isSockAddrMatch (
[+] isSockAddrMatch(
[-] parseAddr_ip4 (
[+] parseAddr_ip4(
[-] parseAddr_ip6 (
[+] parseAddr_ip6(
[-] parseSockAddr_ip4 (
[+] parseSockAddr_ip4(
[-] parseSockAddr_ip6 (
[+] parseSockAddr_ip6(
[-] parseSockAddr (
[+] parseSockAddr(
[-] getAddrString_ip4 (
[+] getAddrString_ip4(
[-] getAddrString_ip4 (const in_addr* addr)
[+] getAddrString_ip4(const in_addr* addr)
[-] 	getAddrString_ip4 (&string, addr);
[+] 	getAddrString_ip4(&string, addr);
[-] getAddrString_ip6 (
[+] getAddrString_ip6(
[-] getAddrString_ip6 (const in6_addr* addr)
[+] getAddrString_ip6(const in6_addr* addr)
[-] 	getAddrString_ip6 (&string, addr);
[+] 	getAddrString_ip6(&string, addr);
[-] getSockAddrString_ip4 (
[+] getSockAddrString_ip4(
[-] getSockAddrString_ip4 (const sockaddr_in* addr)
[+] getSockAddrString_ip4(const sockaddr_in* addr)
[-] 	getSockAddrString_ip4 (&string, addr);
[+] 	getSockAddrString_ip4(&string, addr);
[-] getSockAddrString_ip6 (
[+] getSockAddrString_ip6(
[-] getSockAddrString_ip6 (const sockaddr_in6* addr)
[+] getSockAddrString_ip6(const sockaddr_in6* addr)
[-] 	getSockAddrString_ip6 (&string, addr);
[+] 	getSockAddrString_ip6(&string, addr);
[-] getSockAddrString (
[+] getSockAddrString(
[-] getSockAddrString (const sockaddr* addr)
[+] getSockAddrString(const sockaddr* addr)
[-] 	getSockAddrString (&string, addr);
[+] 	getSockAddrString(&string, addr);
[-] 	SockAddr ()
[+] 	SockAddr()
[-] 		clear ();
[+] 		clear();
[-] 	SockAddr (const sockaddr* addr)
[+] 	SockAddr(const sockaddr* addr)
[-] 		setup (addr);
[+] 		setup(addr);
[-] 	SockAddr (
[+] 	SockAddr(
[-] 		setup_ip4 (addr, port);
[+] 		setup_ip4(addr, port);
[-] 	SockAddr (
[+] 	SockAddr(
[-] 		setup_ip4 (ip, port);
[+] 		setup_ip4(ip, port);
[-] 	SockAddr (
[+] 	SockAddr(
[-] 		setup_ip6 (addr, port, scope);
[+] 		setup_ip6(addr, port, scope);
[-] 	SockAddr (
[+] 	SockAddr(
[-] 		setup_ip6 (ip, port, scope);
[+] 		setup_ip6(ip, port, scope);
[-] 	SockAddr (const sl::StringRef& string)
[+] 	SockAddr(const sl::StringRef& string)
[-] 		parse (string);
[+] 		parse(string);
[-] 	clear ()
[+] 	clear()
[-] 		memset (this, 0, sizeof (SockAddr));
[+] 		memset(this, 0, sizeof(SockAddr));
[-] 	isEqual (const sockaddr* addr) const
[+] 	isEqual(const sockaddr* addr) const
[-] 		return isSockAddrEqual (&m_addr, addr);
[+] 		return isSockAddrEqual(&m_addr, addr);
[-] 	isEqual (const SockAddr* addr) const
[+] 	isEqual(const SockAddr* addr) const
[-] 		return isSockAddrEqual (&m_addr, &addr->m_addr);
[+] 		return isSockAddrEqual(&m_addr, &addr->m_addr);
[-] 	isMatch (const sockaddr* addr) const
[+] 	isMatch(const sockaddr* addr) const
[-] 		return isSockAddrMatch (&m_addr, addr);
[+] 		return isSockAddrMatch(&m_addr, addr);
[-] 	isMatch (const SockAddr* addr) const
[+] 	isMatch(const SockAddr* addr) const
[-] 		return isSockAddrMatch (&m_addr, &addr->m_addr);
[+] 		return isSockAddrMatch(&m_addr, &addr->m_addr);
[-] 	getPort ()
[+] 	getPort()
[-] 		return sl::swapByteOrder16 (m_addr_ip4.sin_port);
[+] 		return sl::swapByteOrder16(m_addr_ip4.sin_port);
[-] 	setPort (uint_t port)
[+] 	setPort(uint_t port)
[-] 		m_addr_ip4.sin_port = sl::swapByteOrder16 ((uint16_t) port);
[+] 		m_addr_ip4.sin_port = sl::swapByteOrder16((uint16_t)port);
[-] 	setup (const sockaddr* addr);
[+] 	setup(const sockaddr* addr);
[-] 	setup (
[+] 	setup(
[-] 	setup_ip4 (
[+] 	setup_ip4(
[-] 	setup_ip4 (
[+] 	setup_ip4(
[-] 		setup_ip4 ((const in_addr*) &ip, port);
[+] 		setup_ip4((const in_addr*) &ip, port);
[-] 	setup_ip6 (
[+] 	setup_ip6(
[-] 	setup_ip6 (
[+] 	setup_ip6(
[-] 		setup_ip6 ((const in6_addr*) ip, port);
[+] 		setup_ip6((const in6_addr*) ip, port);
[-] 	getNetMaskBitCount ()
[+] 	getNetMaskBitCount()
[-] 		return getSockAddrNetMaskBitCount (&m_addr);
[+] 		return getSockAddrNetMaskBitCount(&m_addr);
[-] 	getNetMaskBitCount_ip4 ()
[+] 	getNetMaskBitCount_ip4()
[-] 		return getSockAddrNetMaskBitCount_ip4 (&m_addr_ip4);
[+] 		return getSockAddrNetMaskBitCount_ip4(&m_addr_ip4);
[-] 	getNetMaskBitCount_ip6 ()
[+] 	getNetMaskBitCount_ip6()
[-] 		return getSockAddrNetMaskBitCount_ip6 (&m_addr_ip6);
[+] 		return getSockAddrNetMaskBitCount_ip6(&m_addr_ip6);
[-] 	createNetMask (
[+] 	createNetMask(
[-] 	createNetMask_ip4 (size_t bitCount)
[+] 	createNetMask_ip4(size_t bitCount)
[-] 		createSockAddrNetMask_ip4 (&m_addr_ip4, bitCount);
[+] 		createSockAddrNetMask_ip4(&m_addr_ip4, bitCount);
[-] 	createNetMask_ip6 (size_t bitCount)
[+] 	createNetMask_ip6(size_t bitCount)
[-] 		createSockAddrNetMask_ip6 (&m_addr_ip6, bitCount);
[+] 		createSockAddrNetMask_ip6(&m_addr_ip6, bitCount);
[-] 	parse (const sl::StringRef& string)
[+] 	parse(const sl::StringRef& string)
[-] 		return parseSockAddr (&m_addr, sizeof (SockAddr), string);
[+] 		return parseSockAddr(&m_addr, sizeof(SockAddr), string);
[-] 	parse_ip4 (const sl::StringRef& string)
[+] 	parse_ip4(const sl::StringRef& string)
[-] 		return parseSockAddr_ip4 (&m_addr_ip4, string);
[+] 		return parseSockAddr_ip4(&m_addr_ip4, string);
[-] 	parse_ip6 (const sl::StringRef& string)
[+] 	parse_ip6(const sl::StringRef& string)
[-] 		return parseSockAddr_ip6 (&m_addr_ip6, string);
[+] 		return parseSockAddr_ip6(&m_addr_ip6, string);
[-] 	getString (sl::String* string) const
[+] 	getString(sl::String* string) const
[-] 		return getSockAddrString (string, &m_addr);
[+] 		return getSockAddrString(string, &m_addr);
[-] 	getString () const
[+] 	getString() const
[-] 		return getSockAddrString (&m_addr);
[+] 		return getSockAddrString(&m_addr);
[-] 	getString_ip4 (sl::String* string) const
[+] 	getString_ip4(sl::String* string) const
[-] 		return getSockAddrString_ip4 (string, &m_addr_ip4);
[+] 		return getSockAddrString_ip4(string, &m_addr_ip4);
[-] 	getString_ip4 () const
[+] 	getString_ip4() const
[-] 		return getSockAddrString_ip4 (&m_addr_ip4);
[+] 		return getSockAddrString_ip4(&m_addr_ip4);
[-] 	getString_ip6 (sl::String* string) const
[+] 	getString_ip6(sl::String* string) const
[-] 		return getSockAddrString_ip6 (string, &m_addr_ip6);
[+] 		return getSockAddrString_ip6(string, &m_addr_ip6);
[-] 	getString_ip6 (const sockaddr_in6* addr) const
[+] 	getString_ip6(const sockaddr_in6* addr) const
[-] 		return getSockAddrString_ip6 (&m_addr_ip6);
[+] 		return getSockAddrString_ip6(&m_addr_ip6);
[-] resolveHostName (
[+] resolveHostName(
[-] 	sl::Array <SockAddr>* addrArray,
[+] 	sl::Array<SockAddr>* addrArray,
[-] sl::Array <SockAddr>
[+] sl::Array<SockAddr>
[-] resolveHostName (
[+] resolveHostName(
[-] 	sl::Array <SockAddr> addrArray;
[+] 	sl::Array<SockAddr> addrArray;
[-] 	resolveHostName (&addrArray, name, family);
[+] 	resolveHostName(&addrArray, name, family);
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_Socket.h
----------------------
[-] 	isOpen ()
[+] 	isOpen()
[-] 		return m_socket.isOpen ();
[+] 		return m_socket.isOpen();
[-] 	open (
[+] 	open(
[-] 		return m_socket.open (addressFamily, sockKind, protocol);
[+] 		return m_socket.open(addressFamily, sockKind, protocol);
[-] 	close ()
[+] 	close()
[-] 		m_socket.close ();
[+] 		m_socket.close();
[-] 	getError ()
[+] 	getError()
[-] 		return m_socket.getError ();
[+] 		return m_socket.getError();
[-] 	setBlockingMode (bool isBlocking)
[+] 	setBlockingMode(bool isBlocking)
[-] 		return m_socket.setBlockingMode (isBlocking);
[+] 		return m_socket.setBlockingMode(isBlocking);
[-] 	getIncomingDataSize ()
[+] 	getIncomingDataSize()
[-] 		return m_socket.getIncomingDataSize ();
[+] 		return m_socket.getIncomingDataSize();
[-] 	bind (const sockaddr* addr)
[+] 	bind(const sockaddr* addr)
[-] 		return m_socket.bind (addr);
[+] 		return m_socket.bind(addr);
[-] 	bind (const SockAddr& addr)
[+] 	bind(const SockAddr& addr)
[-] 		return m_socket.bind (addr);
[+] 		return m_socket.bind(addr);
[-] 	getAddress (SockAddr* addr)
[+] 	getAddress(SockAddr* addr)
[-] 		return m_socket.getAddress (addr);
[+] 		return m_socket.getAddress(addr);
[-] 	getPeerAddress (SockAddr* addr)
[+] 	getPeerAddress(SockAddr* addr)
[-] 		return m_socket.getPeerAddress (addr);
[+] 		return m_socket.getPeerAddress(addr);
[-] 	getOption (
[+] 	getOption(
[-] 		return m_socket.getOption (level, option, p, size);
[+] 		return m_socket.getOption(level, option, p, size);
[-] 	setOption (
[+] 	setOption(
[-] 		return m_socket.setOption (level, option, p, size);
[+] 		return m_socket.setOption(level, option, p, size);
[-] 	listen (size_t backLog)
[+] 	listen(size_t backLog)
[-] 		return m_socket.listen (backLog);
[+] 		return m_socket.listen(backLog);
[-] 	accept (
[+] 	accept(
[-] 	connect (const sockaddr* addr)
[+] 	connect(const sockaddr* addr)
[-] 		return m_socket.connect (addr);
[+] 		return m_socket.connect(addr);
[-] 	connect (const SockAddr& addr)
[+] 	connect(const SockAddr& addr)
[-] 		return m_socket.connect (addr);
[+] 		return m_socket.connect(addr);
[-] 	shutdown (SocketShutdownKind shutdownKind = SocketShutdownKind_All)
[+] 	shutdown(SocketShutdownKind shutdownKind = SocketShutdownKind_All)
[-] 		return m_socket.shutdown (shutdownKind);
[+] 		return m_socket.shutdown(shutdownKind);
[-] 	send (
[+] 	send(
[-] 		return m_socket.send (p, size);
[+] 		return m_socket.send(p, size);
[-] 	recv (
[+] 	recv(
[-] 		return m_socket.recv (p, size);
[+] 		return m_socket.recv(p, size);
[-] 	sendTo (
[+] 	sendTo(
[-] 		return m_socket.sendTo (p, size, addr);
[+] 		return m_socket.sendTo(p, size, addr);
[-] 	sendTo (
[+] 	sendTo(
[-] 		return m_socket.sendTo (p, size, addr);
[+] 		return m_socket.sendTo(p, size, addr);
[-] 	recvFrom (
[+] 	recvFrom(
[-] 		return m_socket.recvFrom (p, size, addr);
[+] 		return m_socket.recvFrom(p, size, addr);
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_SocketTransport.h
----------------------
[-] 	public sl::Handle <SOCKET>
[+] 	public sl::Handle<SOCKET>
[-] 	transmit (
[+] 	transmit(
[-] 		int result = send (m_h, (const char*) p, size, 0);
[+] 		int result = send(m_h, (const char*) p, size, 0);
[-] 		return err::complete (result, SOCKET_ERROR);
[+] 		return err::complete(result, SOCKET_ERROR);
[-] 	receive (
[+] 	receive(
[-] 		int result = recv (m_h, (char*) p, size, 0);
[+] 		int result = recv(m_h, (char*)p, size, 0);
[-] 		return err::complete (result, SOCKET_ERROR);
[+] 		return err::complete(result, SOCKET_ERROR);
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_Transport.h
----------------------
[-] 	transmit (
[+] 	transmit(
[-] 	receive (
[+] 	receive(
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_UsbContext.h
----------------------
[-] 		libusb_exit (h);
[+] 		libusb_exit(h);
[-] class UsbContext: public sl::Handle <
[+] class UsbContext: public sl::Handle<
[-] 	sl::MinusOne <libusb_context*>
[+] 	sl::MinusOne<libusb_context*>
[-] 	create ();
[+] 	create();
[-] 	createDefault ();
[+] 	createDefault();
[-] 	setDebugLevel (int level)
[+] 	setDebugLevel(int level)
[-] 		libusb_set_debug (m_h, level);
[+] 		libusb_set_debug(m_h, level);
[-] 	handleEvents ()
[+] 	handleEvents()
[-] 		int result = libusb_handle_events (m_h);
[+] 		int result = libusb_handle_events(m_h);
[-] 		return result == 0 ? true : err::fail (UsbError ((int) result));
[+] 		return result == 0 ? true : err::fail(UsbError((int)result));
[-] 	handleEvents (uint_t timeout);
[+] 	handleEvents(uint_t timeout);
[-] getUsbDefaultContext ()
[+] getUsbDefaultContext()
[-] 	return sl::getSingleton <UsbContext> (&flag);
[+] 	return sl::getSingleton<UsbContext> (&flag);
[-] hasUsbCapability (uint32_t capability)
[+] hasUsbCapability(uint32_t capability)
[-] 	return libusb_has_capability (capability) != 0;
[+] 	return libusb_has_capability(capability) != 0;
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_UsbDevice.h
----------------------
[-] getUsbSpeedString (libusb_speed speed);
[+] getUsbSpeedString(libusb_speed speed);
[-] getUsbClassCodeString (libusb_class_code classCode);
[+] getUsbClassCodeString(libusb_class_code classCode);
[-] getUsbTransferTypeString (libusb_transfer_type transferType);
[+] getUsbTransferTypeString(libusb_transfer_type transferType);
[-] findUsbInterfaceDescriptor (
[+] findUsbInterfaceDescriptor(
[-] findUsbEndpointDescriptor (
[+] findUsbEndpointDescriptor(
[-] findUsbEndpointDescriptor (
[+] findUsbEndpointDescriptor(
[-] 	const libusb_interface_descriptor* ifaceDesc = findUsbInterfaceDescriptor (configDesc, interfaceId, altSettingId);
[+] 	const libusb_interface_descriptor* ifaceDesc = findUsbInterfaceDescriptor(configDesc, interfaceId, altSettingId);
[-] 	return ifaceDesc ? findUsbEndpointDescriptor (ifaceDesc, endpointId) : NULL;
[+] 	return ifaceDesc ? findUsbEndpointDescriptor(ifaceDesc, endpointId) : NULL;
[-] 		libusb_free_device_list (h, true);
[+] 		libusb_free_device_list(h, true);
[-] class UsbDeviceList: public sl::Handle <libusb_device**, FreeUsbDeviceList>
[+] class UsbDeviceList: public sl::Handle<libusb_device**, FreeUsbDeviceList>
[-] 	enumerateDevices (libusb_context* context = NULL);
[+] 	enumerateDevices(libusb_context* context = NULL);
[-] 		libusb_free_config_descriptor (h);
[+] 		libusb_free_config_descriptor(h);
[-] typedef sl::Handle <libusb_config_descriptor*, FreeUsbConfigDescriptor> UsbConfigDescriptor;
[+] typedef sl::Handle<libusb_config_descriptor*, FreeUsbConfigDescriptor> UsbConfigDescriptor;
[-] 	UsbDevice ()
[+] 	UsbDevice()
[-] 	~UsbDevice ()
[+] 	~UsbDevice()
[-] 		setDevice (NULL);
[+] 		setDevice(NULL);
[-] 	getDevice ()
[+] 	getDevice()
[-] 	getOpenHandle ()
[+] 	getOpenHandle()
[-] 	isOpen ()
[+] 	isOpen()
[-] 	getDeviceAddress ()
[+] 	getDeviceAddress()
[-] 		ASSERT (m_device);
[+] 		ASSERT(m_device);
[-] 		return libusb_get_device_address (m_device);
[+] 		return libusb_get_device_address(m_device);
[-] 	getBusNumber ()
[+] 	getBusNumber()
[-] 		ASSERT (m_device);
[+] 		ASSERT(m_device);
[-] 		return libusb_get_bus_number (m_device);
[+] 		return libusb_get_bus_number(m_device);
[-] 	getPortNumber ()
[+] 	getPortNumber()
[-] 		ASSERT (m_device);
[+] 		ASSERT(m_device);
[-] 		return libusb_get_port_number (m_device);
[+] 		return libusb_get_port_number(m_device);
[-] 	getPortPath (
[+] 	getPortPath(
[-] 	getDeviceSpeed ()
[+] 	getDeviceSpeed()
[-] 		ASSERT (m_device);
[+] 		ASSERT(m_device);
[-] 		return (libusb_speed) libusb_get_device_speed (m_device);
[+] 		return (libusb_speed)libusb_get_device_speed(m_device);
[-] 	getMaxPacketSize (uint_t endpointId);
[+] 	getMaxPacketSize(uint_t endpointId);
[-] 	getMaxIsoPacketSize (uint_t endpointId);
[+] 	getMaxIsoPacketSize(uint_t endpointId);
[-] 	refDevice ()
[+] 	refDevice()
[-] 		ASSERT (m_device);
[+] 		ASSERT(m_device);
[-] 		libusb_ref_device (m_device);
[+] 		libusb_ref_device(m_device);
[-] 	unrefDevice ()
[+] 	unrefDevice()
[-] 		ASSERT (m_device);
[+] 		ASSERT(m_device);
[-] 		libusb_unref_device (m_device);
[+] 		libusb_unref_device(m_device);
[-] 	setDevice (libusb_device* device);
[+] 	setDevice(libusb_device* device);
[-] 	close ();
[+] 	close();
[-] 	open ();
[+] 	open();
[-] 	open (libusb_device* device)
[+] 	open(libusb_device* device)
[-] 		setDevice (device);
[+] 		setDevice(device);
[-] 		return open ();
[+] 		return open();
[-] 	open (
[+] 	open(
[-] 		return open (NULL, vendorId, productId);
[+] 		return open(NULL, vendorId, productId);
[-] 	open (
[+] 	open(
[-] 	getConfiguration ();
[+] 	getConfiguration();
[-] 	setConfiguration (uint_t configurationId);
[+] 	setConfiguration(uint_t configurationId);
[-] 	claimInterface (uint_t ifaceId);
[+] 	claimInterface(uint_t ifaceId);
[-] 	releaseInterface (uint_t ifaceId);
[+] 	releaseInterface(uint_t ifaceId);
[-] 	setInterfaceAltSetting (
[+] 	setInterfaceAltSetting(
[-] 	clearHalt (uint_t endpointId);
[+] 	clearHalt(uint_t endpointId);
[-] 	resetDevice ();
[+] 	resetDevice();
[-] 	isKernelDriverActive (uint_t ifaceId);
[+] 	isKernelDriverActive(uint_t ifaceId);
[-] 	attachKernelDriver (uint_t ifaceId);
[+] 	attachKernelDriver(uint_t ifaceId);
[-] 	detachKernelDriver (uint_t ifaceId);
[+] 	detachKernelDriver(uint_t ifaceId);
[-] 	setAutoDetachKernelDriver (bool isAutoDetach);
[+] 	setAutoDetachKernelDriver(bool isAutoDetach);
[-] 	sl::Array <char>
[+] 	sl::Array<char>
[-] 	getDescriptor (
[+] 	getDescriptor(
[-] 		sl::Array <char> descriptor;
[+] 		sl::Array<char> descriptor;
[-] 		getDescriptor (descriptorType, descriptorId, &descriptor);
[+] 		getDescriptor(descriptorType, descriptorId, &descriptor);
[-] 	getDescriptor (
[+] 	getDescriptor(
[-] 		sl::Array <char>* descriptor
[+] 		sl::Array<char>* descriptor
[-] 	getDeviceDescriptor (libusb_device_descriptor* descriptor);
[+] 	getDeviceDescriptor(libusb_device_descriptor* descriptor);
[-] 	getConfigDescriptor (
[+] 	getConfigDescriptor(
[-] 	getActiveConfigDescriptor (UsbConfigDescriptor* desc);
[+] 	getActiveConfigDescriptor(UsbConfigDescriptor* desc);
[-] 	getStringDesrciptor (
[+] 	getStringDesrciptor(
[-] 		getStringDesrciptor (stringId, langId, &string);
[+] 		getStringDesrciptor(stringId, langId, &string);
[-] 	getStringDesrciptor (
[+] 	getStringDesrciptor(
[-] 	getStringDesrciptor (uint_t stringId)
[+] 	getStringDesrciptor(uint_t stringId)
[-] 		getStringDesrciptor (stringId, &string);
[+] 		getStringDesrciptor(stringId, &string);
[-] 	getStringDesrciptor (
[+] 	getStringDesrciptor(
[-] 	controlTransfer (
[+] 	controlTransfer(
[-] 	bulkTransfer (
[+] 	bulkTransfer(
[-] 	interruptTransfer (
[+] 	interruptTransfer(
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_UsbError.h
----------------------
[-] AXL_SL_DEFINE_GUID (
[+] AXL_SL_DEFINE_GUID(
[-] 	getErrorDescription (int code)
[+] 	getErrorDescription(int code)
[-] 		return libusb_error_name (code);
[+] 		return libusb_error_name(code);
[-] 	getErrorDescription (const err::ErrorRef& error)
[+] 	getErrorDescription(const err::ErrorRef& error)
[-] 		return getErrorDescription (error->m_code);
[+] 		return getErrorDescription(error->m_code);
[-] registerUsbErrorProvider ()
[+] registerUsbErrorProvider()
[-] 	err::getErrorMgr ()->registerProvider (
[+] 	err::getErrorMgr()->registerProvider(
[-] 		sl::getSimpleSingleton <UsbErrorProvider> ()
[+] 		sl::getSimpleSingleton<UsbErrorProvider> ()
[-] 	UsbError ()
[+] 	UsbError()
[-] 	UsbError (int code)
[+] 	UsbError(int code)
[-] 		create (code);
[+] 		create(code);
[-] 	create (int code);
[+] 	create(int code);
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_UsbEventThread.h
----------------------
[-] class UsbEventThread: public sys::ThreadImpl <UsbEventThread>
[+] class UsbEventThread: public sys::ThreadImpl<UsbEventThread>
[-] 	UsbEventThread ()
[+] 	UsbEventThread()
[-] 	~UsbEventThread ()
[+] 	~UsbEventThread()
[-] 		stop ();
[+] 		stop();
[-] 	start (libusb_context* context = NULL);
[+] 	start(libusb_context* context = NULL);
[-] 	stop ()
[+] 	stop()
[-] 		waitAndClose ();
[+] 		waitAndClose();
[-] 	threadFunc ();
[+] 	threadFunc();
[-] getUsbDefaultContextEventThread ()
[+] getUsbDefaultContextEventThread()
[-] 	return sl::getSingleton <UsbEventThread> (&flag);
[+] 	return sl::getSingleton<UsbEventThread> (&flag);
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_UsbPch.h
----------------------
[-] #	pragma warning (disable: 4200) // warning C4200: nonstandard extension used : zero-sized array in struct/union
[+] #	pragma warning(disable: 4200) // warning C4200: nonstandard extension used : zero-sized array in struct/union
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io\axl_io_UsbTransfer.h
----------------------
[-] getUsbTransferStatusString (libusb_transfer_status status);
[+] getUsbTransferStatusString(libusb_transfer_status status);
[-] 		libusb_free_transfer (h);
[+] 		libusb_free_transfer(h);
[-] class UsbTransfer: public sl::Handle <libusb_transfer*, FreeUsbTransfer>
[+] class UsbTransfer: public sl::Handle<libusb_transfer*, FreeUsbTransfer>
[-] 	create (size_t isochronousPacketCount = 0);
[+] 	create(size_t isochronousPacketCount = 0);
[-] 	submit ();
[+] 	submit();
[-] 	cancel ();
[+] 	cancel();
[-] 	fillControlSetup (
[+] 	fillControlSetup(
[-] 		libusb_fill_control_setup ((uchar_t*) setup, requestType, requestCode, value, index, size);
[+] 		libusb_fill_control_setup((uchar_t*)setup, requestType, requestCode, value, index, size);
[-] 	fillControlTransfer (
[+] 	fillControlTransfer(
[-] 		ASSERT (m_h);
[+] 		ASSERT(m_h);
[-] 		libusb_fill_control_transfer (
[+] 		libusb_fill_control_transfer(
[-] 			(uchar_t*) setup,
[+] 			(uchar_t*)setup,
[-] 	fillBulkTransfer (
[+] 	fillBulkTransfer(
[-] 		ASSERT (m_h);
[+] 		ASSERT(m_h);
[-] 		libusb_fill_bulk_transfer (
[+] 		libusb_fill_bulk_transfer(
[-] 			(uchar_t*) buffer,
[+] 			(uchar_t*)buffer,
[-] 	fillInterruptTransfer (
[+] 	fillInterruptTransfer(
[-] 		ASSERT (m_h);
[+] 		ASSERT(m_h);
[-] 		libusb_fill_interrupt_transfer (
[+] 		libusb_fill_interrupt_transfer(
[-] 			(uchar_t*) buffer,
[+] 			(uchar_t*)buffer,
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_iok\axl_iok_Iterator.h
----------------------
[-] class Iterator: public ObjectBase <io_iterator_t>
[+] class Iterator: public ObjectBase<io_iterator_t>
[-] 	Iterator ()
[+] 	Iterator()
[-] 	Iterator (const Iterator& src)
[+] 	Iterator(const Iterator& src)
[-] 		copy (src);
[+] 		copy(src);
[-] 	Iterator (
[+] 	Iterator(
[-] 		isAttach ? copy (p) : attach (p);
[+] 		isAttach ? copy(p) : attach(p);
[-] 	isValid ()
[+] 	isValid()
[-] 		return ::IOIteratorIsValid (m_p);
[+] 		return ::IOIteratorIsValid(m_p);
[-] 	next ();
[+] 	next();
[-] 	reset ()
[+] 	reset()
[-] 		::IOIteratorReset (m_p);
[+] 		::IOIteratorReset(m_p);
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_iok\axl_iok_Object.h
----------------------
[-] 	ObjectBase ()
[+] 	ObjectBase()
[-] 	ObjectBase (const ObjectBase& src)
[+] 	ObjectBase(const ObjectBase& src)
[-] 			::IOObjectRetain (src.m_p);
[+] 			::IOObjectRetain(src.m_p);
[-] 	ObjectBase (
[+] 	ObjectBase(
[-] 			::IOObjectRetain (p);
[+] 			::IOObjectRetain(p);
[-] 	operator T () const
[+] 	operator T() const
[-] 		copy (src.m_p);
[+] 		copy(src.m_p);
[-] 		copy (p);
[+] 		copy(p);
[-] 	p () const
[+] 	p() const
[-] 	attach (T p)
[+] 	attach(T p)
[-] 		clear ();
[+] 		clear();
[-] 	detach ()
[+] 	detach()
[-] 	clear ()
[+] 	clear()
[-] 			::IOObjectRelease (m_p);
[+] 			::IOObjectRelease(m_p);
[-] 	copy (T p)
[+] 	copy(T p)
[-] 			::IOObjectRetain (p);
[+] 			::IOObjectRetain(p);
[-] 			::IOObjectRelease (m_p);
[+] 			::IOObjectRelease(m_p);
[-] 	retain ()
[+] 	retain()
[-] 		::IOObjectRetain (m_p);
[+] 		::IOObjectRetain(m_p);
[-] 	release ()
[+] 	release()
[-] 		::IOObjectRelease (m_p);
[+] 		::IOObjectRelease(m_p);
[-] typedef ObjectBase <io_object_t> Object;
[+] typedef ObjectBase<io_object_t> Object;
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_iok\axl_iok_RegistryEntry.h
----------------------
[-] class RegistryEntry: public ObjectBase <io_registry_entry_t>
[+] class RegistryEntry: public ObjectBase<io_registry_entry_t>
[-] 	RegistryEntry ()
[+] 	RegistryEntry()
[-] 	RegistryEntry (const RegistryEntry& src)
[+] 	RegistryEntry(const RegistryEntry& src)
[-] 		copy (src);
[+] 		copy(src);
[-] 	RegistryEntry (
[+] 	RegistryEntry(
[-] 		isAttach ? copy (p) : attach (p);
[+] 		isAttach ? copy(p) : attach(p);
[-] 	isInPlane (const char* plane) const
[+] 	isInPlane(const char* plane) const
[-] 	getName () const;
[+] 	getName() const;
[-] 	getNameInPlane (const char* plane) const;
[+] 	getNameInPlane(const char* plane) const;
[-] 	getPath (const char* plane = kIOServicePlane) const;
[+] 	getPath(const char* plane = kIOServicePlane) const;
[-] 	getAllProperties () const;
[+] 	getAllProperties() const;
[-] 	getProperty (const char* key) const
[+] 	getProperty(const char* key) const
[-] 		CFTypeRef p = ::IORegistryEntryCreateCFProperty (m_p, cf::StringRef (key), kCFAllocatorDefault, 0);
[+] 		CFTypeRef p = ::IORegistryEntryCreateCFProperty(m_p, cf::StringRef(key), kCFAllocatorDefault, 0);
[-] 		return cf::TypeRef (p, true);
[+] 		return cf::TypeRef(p, true);
[-] 	getParentEntry (const char* plane = kIOServicePlane) const;
[+] 	getParentEntry(const char* plane = kIOServicePlane) const;
[-] 	getChildEntry (const char* plane = kIOServicePlane) const;
[+] 	getChildEntry(const char* plane = kIOServicePlane) const;
[-] createServiceMatchingDictionary (const char* service)
[+] createServiceMatchingDictionary(const char* service)
[-] 	CFMutableDictionaryRef p = ::IOServiceMatching (service);
[+] 	CFMutableDictionaryRef p = ::IOServiceMatching(service);
[-] 	return cf::MutableDictionaryRef (p, true);
[+] 	return cf::MutableDictionaryRef(p, true);
[-] findMatchingServices (CFMutableDictionaryRef dict);
[+] findMatchingServices(CFMutableDictionaryRef dict);
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io_psx\axl_io_psx_File.h
----------------------
[-] 		::close (h);
[+] 		::close(h);
[-] class File: public sl::Handle <int, CloseFile, sl::MinusOne <int> >
[+] class File: public sl::Handle<int, CloseFile, sl::MinusOne<int> >
[-] 	File ()
[+] 	File()
[-] 	File (int h):
[+] 	File(int h):
[-] 		sl::Handle <int, CloseFile, sl::MinusOne <int> > (h)
[+] 		sl::Handle<int, CloseFile, sl::MinusOne<int> > (h)
[-] 	open (
[+] 	open(
[-] 	duplicate (int fd);
[+] 	duplicate(int fd);
[-] 	setBlockingMode (bool isBlocking);
[+] 	setBlockingMode(bool isBlocking);
[-] 	getSize () const;
[+] 	getSize() const;
[-] 	setSize (uint64_t size)
[+] 	setSize(uint64_t size)
[-] 		int result = ::ftruncate (m_h, size);
[+] 		int result = ::ftruncate(m_h, size);
[-] 		int result = ::ftruncate64 (m_h, size);
[+] 		int result = ::ftruncate64(m_h, size);
[-] 		return err::complete (result != -1);
[+] 		return err::complete(result != -1);
[-] 	getPosition () const;
[+] 	getPosition() const;
[-] 	setPosition (uint64_t offset) const
[+] 	setPosition(uint64_t offset) const
[-] 		uint64_t actualOffset = ::lseek (m_h, offset, SEEK_SET);
[+] 		uint64_t actualOffset = ::lseek(m_h, offset, SEEK_SET);
[-] 		uint64_t actualOffset = ::lseek64 (m_h, offset, SEEK_SET);
[+] 		uint64_t actualOffset = ::lseek64(m_h, offset, SEEK_SET);
[-] 		return err::complete (actualOffset != -1);
[+] 		return err::complete(actualOffset != -1);
[-] 	getIncomingDataSize ();
[+] 	getIncomingDataSize();
[-] 	flush ()
[+] 	flush()
[-] 		int result = ::fsync (m_h);
[+] 		int result = ::fsync(m_h);
[-] 		return err::complete (result != -1);
[+] 		return err::complete(result != -1);
[-] 	ioctl (int code)
[+] 	ioctl(int code)
[-] 		int result = ::ioctl (m_h, code);
[+] 		int result = ::ioctl(m_h, code);
[-] 		return err::complete (result, -1);
[+] 		return err::complete(result, -1);
[-] 	ioctl (
[+] 	ioctl(
[-] 		int result = ::ioctl (m_h, code, param);
[+] 		int result = ::ioctl(m_h, code, param);
[-] 			err::setLastSystemError ();
[+] 			err::setLastSystemError();
[-] 	fcntl (int code)
[+] 	fcntl(int code)
[-] 		int result = ::fcntl (m_h, code);
[+] 		int result = ::fcntl(m_h, code);
[-] 		return err::complete (result, -1);
[+] 		return err::complete(result, -1);
[-] 	fcntl (
[+] 	fcntl(
[-] 		int result = ::fcntl (m_h, code, param);
[+] 		int result = ::fcntl(m_h, code, param);
[-] 			err::setLastSystemError ();
[+] 			err::setLastSystemError();
[-] 	read (
[+] 	read(
[-] 	write (
[+] 	write(
----------------------
27/02/2019 18:01:41 - C:\Projects\repos\ioninja\axl\include\axl_io_psx\axl_io_psx_Mapping.h
----------------------
[-] 	Mapping ()
[+] 	Mapping()
[-] 	~Mapping ()
[+] 	~Mapping()
[-] 		close ();
[+] 		close();
[-] 	p () const
[+] 	p() const
[-] 	getSize ()
[+] 	getSize()
[-] 	isOpen () const
[+] 	isOpen() const
[-] 	close ()
[+] 	close()
[-] 		unmap ();
[+] 		unmap();
[-] 	map (
[+] 	map(
[-] 	protect (int protection)
[+] 	protect(int protection)
[-] 		int result = ::mprotect (m_p, m_size, protection);
[+] 		int result = ::mprotect(m_p, m_size, protection);
[-] 		return err::complete (result != -1);
[+] 		return err::complete(result != -1);
[-] 	unmap (size_t size = -1);
[+] 	unmap(size_t size = -1);
[-] 	open (
[+] 	open(
[-] 	unlink (const sl::StringRef& name)
[+] 	unlink(const sl::StringRef& name)
[-] 		int result = ::shm_unlink (name.sz ());
[+] 		int result = ::shm_unlink(name.sz());
[-] 		return err::complete (result != -1);
[+] 		return err::complete(result != -1);
[-] 	AutoUnlinkSharedMemory ()
[+] 	AutoUnlinkSharedMemory()
[-] 	AutoUnlinkSharedMemory (const sl::StringRef& name)
[+] 	AutoUnlinkSharedMemory(const sl::StringRef& name)
[-] 	~AutoUnlinkSharedMemory ()
[+] 	~AutoUnlinkSharedMemory()
[-] 		if (!m_name.isEmpty ())
[+] 		if (!m_name.isEmpty())
[-] 			::shm_unlink (m_name.sz ());;
[+] 			::shm_unlink(m_name.sz());;
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_io_psx\axl_io_psx_Pipe.h
----------------------
[-] 	create ();
[+] 	create();
[-] 	close ()
[+] 	close()
[-] 		m_readFile.close ();
[+] 		m_readFile.close();
[-] 		m_writeFile.close ();
[+] 		m_writeFile.close();
[-] 	read (
[+] 	read(
[-] 		return m_readFile.read (p, size);
[+] 		return m_readFile.read(p, size);
[-] 	write (
[+] 	write(
[-] 		return m_writeFile.write (p, size);
[+] 		return m_writeFile.write(p, size);
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_io_psx\axl_io_psx_Serial.h
----------------------
[-] 	open (
[+] 	open(
[-] 		return File::open (name, openFlags, 0);
[+] 		return File::open(name, openFlags, 0);
[-] 	getAttr (termios* attr) const
[+] 	getAttr(termios* attr) const
[-] 		int result = ::tcgetattr (m_h, attr);
[+] 		int result = ::tcgetattr(m_h, attr);
[-] 		return err::complete (result != -1);
[+] 		return err::complete(result != -1);
[-] 	setAttr (
[+] 	setAttr(
[-] 		int result = ::tcsetattr (m_h, action, attr);
[+] 		int result = ::tcsetattr(m_h, action, attr);
[-] 		return err::complete (result != -1);
[+] 		return err::complete(result != -1);
[-] 	drain ()
[+] 	drain()
[-] 		int result = ::tcdrain (m_h);
[+] 		int result = ::tcdrain(m_h);
[-] 		return err::complete (result != -1);
[+] 		return err::complete(result != -1);
[-] 	flush (int queueSelector = TCIOFLUSH)
[+] 	flush(int queueSelector = TCIOFLUSH)
[-] 		int result = ::tcflush (m_h, queueSelector);
[+] 		int result = ::tcflush(m_h, queueSelector);
[-] 		return err::complete (result != -1);
[+] 		return err::complete(result != -1);
[-] 	flow (int action)
[+] 	flow(int action)
[-] 		int result = ::tcflow (m_h, action);
[+] 		int result = ::tcflow(m_h, action);
[-] 		return err::complete (result != -1);
[+] 		return err::complete(result != -1);
[-] 	getStatusLines () const;
[+] 	getStatusLines() const;
[-] 	setDtr (bool isSet);
[+] 	setDtr(bool isSet);
[-] 	setRts (bool isSet);
[+] 	setRts(bool isSet);
[-] 	wait (uint_t mask)
[+] 	wait(uint_t mask)
[-] 		int result = ::ioctl (m_h, TIOCMIWAIT, mask);
[+] 		int result = ::ioctl(m_h, TIOCMIWAIT, mask);
[-] 		return err::complete (result != -1);
[+] 		return err::complete(result != -1);
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_io_psx\axl_io_psx_Socket.h
----------------------
[-] 	open (
[+] 	open(
[-] 	setBlockingMode (bool isBlocking); // blocking mode is set a bit differently
[+] 	setBlockingMode(bool isBlocking); // blocking mode is set a bit differently
[-] 	getError ();
[+] 	getError();
[-] 	bind (const sockaddr* addr)
[+] 	bind(const sockaddr* addr)
[-] 		int result = ::bind (m_h, addr, getSockAddrSize (addr));
[+] 		int result = ::bind(m_h, addr, getSockAddrSize(addr));
[-] 		return err::complete (result != -1);
[+] 		return err::complete(result != -1);
[-] 	getAddress (SockAddr* addr);
[+] 	getAddress(SockAddr* addr);
[-] 	getPeerAddress (SockAddr* addr);
[+] 	getPeerAddress(SockAddr* addr);
[-] 	getOption (
[+] 	getOption(
[-] 		int result = ::getsockopt (m_h, level, option, p, &size);
[+] 		int result = ::getsockopt(m_h, level, option, p, &size);
[-] 		return err::complete (result != -1);
[+] 		return err::complete(result != -1);
[-] 	setOption (
[+] 	setOption(
[-] 		int result = ::setsockopt (m_h, level, option, p, size);
[+] 		int result = ::setsockopt(m_h, level, option, p, size);
[-] 		return err::complete (result != -1);
[+] 		return err::complete(result != -1);
[-] 	listen (size_t backLog)
[+] 	listen(size_t backLog)
[-] 		int result = ::listen (m_h, (int) backLog);
[+] 		int result = ::listen(m_h, (int)backLog);
[-] 		return err::complete (result != -1);
[+] 		return err::complete(result != -1);
[-] 	accept (SockAddr* addr = NULL);
[+] 	accept(SockAddr* addr = NULL);
[-] 	connect (const sockaddr* addr);
[+] 	connect(const sockaddr* addr);
[-] 	shutdown (int mode = SHUT_RDWR)
[+] 	shutdown(int mode = SHUT_RDWR)
[-] 		int result = ::shutdown (m_h, mode);
[+] 		int result = ::shutdown(m_h, mode);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	send (
[+] 	send(
[-] 		int result = ::send (m_h, p, size, 0);
[+] 		int result = ::send(m_h, p, size, 0);
[-] 		return err::complete (result, -1);
[+] 		return err::complete(result, -1);
[-] 	recv (
[+] 	recv(
[-] 		int result = ::recv (m_h, p, size, 0);
[+] 		int result = ::recv(m_h, p, size, 0);
[-] 		return err::complete (result, -1);
[+] 		return err::complete(result, -1);
[-] 	sendTo (
[+] 	sendTo(
[-] 		int result = ::sendto (m_h, p, size, 0, addr, getSockAddrSize (addr));
[+] 		int result = ::sendto(m_h, p, size, 0, addr, getSockAddrSize(addr));
[-] 		return err::complete (result, -1);
[+] 		return err::complete(result, -1);
[-] 	recvFrom (
[+] 	recvFrom(
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_io_win\axl_io_win_File.h
----------------------
[-] class File: public sl::Handle <HANDLE, sys::win::CloseHandle, sl::MinusOne <HANDLE> >
[+] class File: public sl::Handle<HANDLE, sys::win::CloseHandle, sl::MinusOne<HANDLE> >
[-] 	create (
[+] 	create(
[-] 	duplicate (
[+] 	duplicate(
[-] 	getSize () const;
[+] 	getSize() const;
[-] 	setSize (uint64_t size);
[+] 	setSize(uint64_t size);
[-] 	getPosition () const;
[+] 	getPosition() const;
[-] 	setPosition (uint64_t offset) const;
[+] 	setPosition(uint64_t offset) const;
[-] 	flush ()
[+] 	flush()
[-] 		bool_t result = ::FlushFileBuffers (m_h);
[+] 		bool_t result = ::FlushFileBuffers(m_h);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	read (
[+] 	read(
[-] 		bool_t result = ::ReadFile (m_h, p, size, actualSize, NULL);
[+] 		bool_t result = ::ReadFile(m_h, p, size, actualSize, NULL);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	write (
[+] 	write(
[-] 		bool_t result = ::WriteFile (m_h, p, size, actualSize, NULL);
[+] 		bool_t result = ::WriteFile(m_h, p, size, actualSize, NULL);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	ioctl (
[+] 	ioctl(
[-] 		bool_t result = ::DeviceIoControl (m_h, code, (void*) inData, inDataSize, outData, outDataSize, actualSize, NULL);
[+] 		bool_t result = ::DeviceIoControl(m_h, code, (void*)inData, inDataSize, outData, outDataSize, actualSize, NULL);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	overlappedRead (
[+] 	overlappedRead(
[-] 		bool_t result = ::ReadFile (m_h, p, size, NULL, overlapped);
[+] 		bool_t result = ::ReadFile(m_h, p, size, NULL, overlapped);
[-] 		return completeOverlappedRequest (result);
[+] 		return completeOverlappedRequest(result);
[-] 	overlappedWrite (
[+] 	overlappedWrite(
[-] 		bool_t result = ::WriteFile (m_h, p, size, NULL, overlapped);
[+] 		bool_t result = ::WriteFile(m_h, p, size, NULL, overlapped);
[-] 		return completeOverlappedRequest (result);
[+] 		return completeOverlappedRequest(result);
[-] 	overlappedIoctl (
[+] 	overlappedIoctl(
[-] 		bool_t result = ::DeviceIoControl (m_h, code, (void*) inData, inDataSize, outData, outDataSize, NULL, overlapped);
[+] 		bool_t result = ::DeviceIoControl(m_h, code, (void*)inData, inDataSize, outData, outDataSize, NULL, overlapped);
[-] 		return completeOverlappedRequest (result);
[+] 		return completeOverlappedRequest(result);
[-] 	readEx (
[+] 	readEx(
[-] 		bool_t result = ::ReadFileEx (m_h, p, size, overlapped, completionFunc);
[+] 		bool_t result = ::ReadFileEx(m_h, p, size, overlapped, completionFunc);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	writeEx (
[+] 	writeEx(
[-] 		bool_t result = ::WriteFileEx (m_h, p, size, overlapped, completionFunc);
[+] 		bool_t result = ::WriteFileEx(m_h, p, size, overlapped, completionFunc);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	read (
[+] 	read(
[-] 	write (
[+] 	write(
[-] 	overlappedRead (
[+] 	overlappedRead(
[-] 	overlappedWrite (
[+] 	overlappedWrite(
[-] 	overlappedRead (
[+] 	overlappedRead(
[-] 	overlappedWrite (
[+] 	overlappedWrite(
[-] 	overlappedIoctl (
[+] 	overlappedIoctl(
[-] 	completeOverlappedRequest (bool_t result);
[+] 	completeOverlappedRequest(bool_t result);
[-] 	getOverlappedResult (
[+] 	getOverlappedResult(
[-] 	getOverlappedResult (OVERLAPPED* overlapped) const;
[+] 	getOverlappedResult(OVERLAPPED* overlapped) const;
[-] 	StdOverlapped ()
[+] 	StdOverlapped()
[-] 		memset (this, 0, sizeof (OVERLAPPED));
[+] 		memset(this, 0, sizeof(OVERLAPPED));
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_io_win\axl_io_win_Iocp.h
----------------------
[-] 	create (dword_t threadCount);
[+] 	create(dword_t threadCount);
[-] 	associate (
[+] 	associate(
[-] 		HANDLE h = ::CreateIoCompletionPort (hIo, m_h, (uintptr_t) context, 0);
[+] 		HANDLE h = ::CreateIoCompletionPort(hIo, m_h, (uintptr_t)context, 0);
[-] 		return err::complete (h != NULL);
[+] 		return err::complete(h != NULL);
[-] 	postCompletionStatus (
[+] 	postCompletionStatus(
[-] 		bool_t result = ::PostQueuedCompletionStatus (m_h, actualSize, (uintptr_t) context, overlapped);
[+] 		bool_t result = ::PostQueuedCompletionStatus(m_h, actualSize, (uintptr_t)context, overlapped);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	getCompletionStatus (
[+] 	getCompletionStatus(
[-] 		bool_t result = ::GetQueuedCompletionStatus (m_h, actualSize, (ULONG_PTR*) context, overlapped, timeout);
[+] 		bool_t result = ::GetQueuedCompletionStatus(m_h, actualSize, (ULONG_PTR*)context, overlapped, timeout);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_io_win\axl_io_win_Mapping.h
----------------------
[-] 	create (
[+] 	create(
[-] 	open (
[+] 	open(
[-] 		::UnmapViewOfFile (p);
[+] 		::UnmapViewOfFile(p);
[-] class MappedView: public sl::Handle <void*, UnmapViewOfFile>
[+] class MappedView: public sl::Handle<void*, UnmapViewOfFile>
[-] 	view (
[+] 	view(
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_io_win\axl_io_win_NamedPipe.h
----------------------
[-] 	create (
[+] 	create(
[-] 	open (
[+] 	open(
[-] 	connect ()
[+] 	connect()
[-] 		bool_t result = ::ConnectNamedPipe (m_h, NULL);
[+] 		bool_t result = ::ConnectNamedPipe(m_h, NULL);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	overlappedConnect (OVERLAPPED* overlapped)
[+] 	overlappedConnect(OVERLAPPED* overlapped)
[-] 		bool_t result = ::ConnectNamedPipe (m_h, overlapped);
[+] 		bool_t result = ::ConnectNamedPipe(m_h, overlapped);
[-] 		return completeOverlappedRequest (result);
[+] 		return completeOverlappedRequest(result);
[-] 	overlappedConnect ();
[+] 	overlappedConnect();
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_io_win\axl_io_win_Serial.h
----------------------
[-] 	open (
[+] 	open(
[-] 	clearError (
[+] 	clearError(
[-] 		bool_t result = ::ClearCommError (m_h, errors, stat);
[+] 		bool_t result = ::ClearCommError(m_h, errors, stat);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	getSettings (DCB* dcb)
[+] 	getSettings(DCB* dcb)
[-] 		bool_t result = ::GetCommState (m_h, dcb);
[+] 		bool_t result = ::GetCommState(m_h, dcb);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	setSettings (const DCB* dcb)
[+] 	setSettings(const DCB* dcb)
[-] 		bool_t result = ::SetCommState (m_h, (DCB*) dcb);
[+] 		bool_t result = ::SetCommState(m_h, (DCB*)dcb);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	getTimeouts (COMMTIMEOUTS* timeouts)
[+] 	getTimeouts(COMMTIMEOUTS* timeouts)
[-] 		bool_t result = ::GetCommTimeouts (m_h, timeouts);
[+] 		bool_t result = ::GetCommTimeouts(m_h, timeouts);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	setTimeouts (const COMMTIMEOUTS* timeouts)
[+] 	setTimeouts(const COMMTIMEOUTS* timeouts)
[-] 		bool_t result = ::SetCommTimeouts (m_h, (COMMTIMEOUTS*) timeouts);
[+] 		bool_t result = ::SetCommTimeouts(m_h, (COMMTIMEOUTS*)timeouts);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	escape (uint_t function)
[+] 	escape(uint_t function)
[-] 		bool_t result = ::EscapeCommFunction (m_h, function);
[+] 		bool_t result = ::EscapeCommFunction(m_h, function);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	getStatusLines ();
[+] 	getStatusLines();
[-] 	setDtr (bool isSet)
[+] 	setDtr(bool isSet)
[-] 		return escape (isSet ? SETDTR : CLRDTR);
[+] 		return escape(isSet ? SETDTR : CLRDTR);
[-] 	setRts (bool isSet)
[+] 	setRts(bool isSet)
[-] 		return escape (isSet ? SETRTS : CLRRTS);
[+] 		return escape(isSet ? SETRTS : CLRRTS);
[-] 	getWaitMask ();
[+] 	getWaitMask();
[-] 	setWaitMask (dword_t mask)
[+] 	setWaitMask(dword_t mask)
[-] 		bool_t result = ::SetCommMask (m_h, mask);
[+] 		bool_t result = ::SetCommMask(m_h, mask);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	wait (dword_t* events)
[+] 	wait(dword_t* events)
[-] 		bool_t result = ::WaitCommEvent (m_h, events, NULL);
[+] 		bool_t result = ::WaitCommEvent(m_h, events, NULL);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	overlappedWait (
[+] 	overlappedWait(
[-] 		bool_t result = ::WaitCommEvent (m_h, events, overlapped);
[+] 		bool_t result = ::WaitCommEvent(m_h, events, overlapped);
[-] 		return completeOverlappedRequest (result);
[+] 		return completeOverlappedRequest(result);
[-] 	overlappedWait (dword_t* events);
[+] 	overlappedWait(dword_t* events);
[-] 	read (
[+] 	read(
[-] 	write (
[+] 	write(
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_io_win\axl_io_win_Socket.h
----------------------
[-] 		::closesocket (socket);
[+] 		::closesocket(socket);
[-] class Socket: public sl::Handle <SOCKET, CloseSocket, sl::MinusOne <SOCKET> >
[+] class Socket: public sl::Handle<SOCKET, CloseSocket, sl::MinusOne<SOCKET> >
[-] 	open (
[+] 	open(
[-] 	getError ();
[+] 	getError();
[-] 	setBlockingMode (bool isBlocking);
[+] 	setBlockingMode(bool isBlocking);
[-] 	getIncomingDataSize ();
[+] 	getIncomingDataSize();
[-] 	bind (const sockaddr* addr)
[+] 	bind(const sockaddr* addr)
[-] 		int result = ::bind (m_h, addr, getSockAddrSize (addr));
[+] 		int result = ::bind(m_h, addr, getSockAddrSize(addr));
[-] 		return complete (result != SOCKET_ERROR);
[+] 		return complete(result != SOCKET_ERROR);
[-] 	getAddress (SockAddr* addr);
[+] 	getAddress(SockAddr* addr);
[-] 	getPeerAddress (SockAddr* addr);
[+] 	getPeerAddress(SockAddr* addr);
[-] 	getOption (
[+] 	getOption(
[-] 		int result = ::getsockopt (m_h, level, option, (char*) p, (int*) &size);
[+] 		int result = ::getsockopt(m_h, level, option, (char*)p, (int*) &size);
[-] 		return complete (result != SOCKET_ERROR);
[+] 		return complete(result != SOCKET_ERROR);
[-] 	setOption (
[+] 	setOption(
[-] 		int result = ::setsockopt (m_h, level, option, (char*) p, size);
[+] 		int result = ::setsockopt(m_h, level, option, (char*)p, size);
[-] 		return complete (result != SOCKET_ERROR);
[+] 		return complete(result != SOCKET_ERROR);
[-] 	listen (size_t backLog)
[+] 	listen(size_t backLog)
[-] 		int result = ::listen (m_h, (int) backLog);
[+] 		int result = ::listen(m_h, (int)backLog);
[-] 		return complete (result != SOCKET_ERROR);
[+] 		return complete(result != SOCKET_ERROR);
[-] 	accept (SockAddr* addr = NULL);
[+] 	accept(SockAddr* addr = NULL);
[-] 	connect (const sockaddr* addr)
[+] 	connect(const sockaddr* addr)
[-] 		int result = ::connect (m_h, addr, getSockAddrSize (addr));
[+] 		int result = ::connect(m_h, addr, getSockAddrSize(addr));
[-] 		return completeAsyncRequest (result, WSAEWOULDBLOCK);
[+] 		return completeAsyncRequest(result, WSAEWOULDBLOCK);
[-] 	shutdown (int mode = SD_BOTH)
[+] 	shutdown(int mode = SD_BOTH)
[-] 		int result = ::shutdown (m_h, mode);
[+] 		int result = ::shutdown(m_h, mode);
[-] 		return complete (result);
[+] 		return complete(result);
[-] 	send (
[+] 	send(
[-] 		int result = ::send (m_h, (const char*) p, (int) size, 0);
[+] 		int result = ::send(m_h, (const char*) p, (int)size, 0);
[-] 		return complete (result, SOCKET_ERROR);
[+] 		return complete(result, SOCKET_ERROR);
[-] 	recv (
[+] 	recv(
[-] 		int result = ::recv (m_h, (char*) p, (int) size, 0);
[+] 		int result = ::recv(m_h, (char*)p, (int)size, 0);
[-] 		return complete (result, SOCKET_ERROR);
[+] 		return complete(result, SOCKET_ERROR);
[-] 	sendTo (
[+] 	sendTo(
[-] 		int result = ::sendto (m_h, (char*) p, (int) size, 0, addr, getSockAddrSize (addr));
[+] 		int result = ::sendto(m_h, (char*)p, (int)size, 0, addr, getSockAddrSize(addr));
[-] 		return complete (result, SOCKET_ERROR);
[+] 		return complete(result, SOCKET_ERROR);
[-] 	recvFrom (
[+] 	recvFrom(
[-] 	wsaOpen (
[+] 	wsaOpen(
[-] 	wsaEventSelect (
[+] 	wsaEventSelect(
[-] 		int result = ::WSAEventSelect (m_h, hEvent, mask);
[+] 		int result = ::WSAEventSelect(m_h, hEvent, mask);
[-] 		return complete (result != SOCKET_ERROR);
[+] 		return complete(result != SOCKET_ERROR);
[-] 	wsaEnumEvents (
[+] 	wsaEnumEvents(
[-] 		int result = ::WSAEnumNetworkEvents (m_h, hEvent, events);
[+] 		int result = ::WSAEnumNetworkEvents(m_h, hEvent, events);
[-] 		return complete (result != SOCKET_ERROR);
[+] 		return complete(result != SOCKET_ERROR);
[-] 	wsaConnect (const sockaddr* addr)
[+] 	wsaConnect(const sockaddr* addr)
[-] 		int result = ::WSAConnect (m_h, addr, getSockAddrSize (addr), NULL, NULL, NULL, NULL);
[+] 		int result = ::WSAConnect(m_h, addr, getSockAddrSize(addr), NULL, NULL, NULL, NULL);
[-] 		return completeAsyncRequest (result, WSAEWOULDBLOCK);
[+] 		return completeAsyncRequest(result, WSAEWOULDBLOCK);
[-] 	wsaAccept (SockAddr* addr);
[+] 	wsaAccept(SockAddr* addr);
[-] 	wsaSend (
[+] 	wsaSend(
[-] 	wsaRecv (
[+] 	wsaRecv(
[-] 	wsaSendTo (
[+] 	wsaSendTo(
[-] 	wsaRecvFrom (
[+] 	wsaRecvFrom(
[-] 	wsaIoctl (
[+] 	wsaIoctl(
[-] 	wsaGetOverlappedResult (
[+] 	wsaGetOverlappedResult(
[-] 	wsaGetOverlappedResult (WSAOVERLAPPED* overlapped) const;
[+] 	wsaGetOverlappedResult(WSAOVERLAPPED* overlapped) const;
[-] 	complete (
[+] 	complete(
[-] 			err::setError (::WSAGetLastError ());
[+] 			err::setError(::WSAGetLastError());
[-] 	complete (int result)
[+] 	complete(int result)
[-] 		return complete <bool> (result != 0, false);
[+] 		return complete<bool> (result != 0, false);
[-] 	completeAsyncRequest (
[+] 	completeAsyncRequest(
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_lex\axl_lex_Lexer.h
----------------------
[-] 	typedef sl::BoxList <Token, const Token&> TokenList;
[+] 	typedef sl::BoxList<Token, const Token&> TokenList;
[-] 	typedef sl::BoxListEntry <Token> TokenEntry;
[+] 	typedef sl::BoxListEntry<Token> TokenEntry;
[-] 	Lexer ()
[+] 	Lexer()
[-] 	reset ()
[+] 	reset()
[-] 		m_freeTokenList.insertListTail (&m_tokenList);
[+] 		m_freeTokenList.insertListTail(&m_tokenList);
[-] 		m_lastTokenPos.clear ();
[+] 		m_lastTokenPos.clear();
[-] 		static_cast <T*> (this)->onReset ();
[+] 		static_cast<T*> (this)->onReset();
[-] 	getChannelToken (
[+] 	getChannelToken(
[-] 		sl::BoxIterator <Token> it = m_tokenList.getHead ();
[+] 		sl::BoxIterator<Token> it = m_tokenList.getHead();
[-] 			sl::BoxIterator <Token> tail = m_tokenList.getTail ();
[+] 			sl::BoxIterator<Token> tail = m_tokenList.getTail();
[-] 			size_t oldCount = m_tokenList.getCount ();
[+] 			size_t oldCount = m_tokenList.getCount();
[-] 				((T*) (this))->tokenize ();
[+] 				((T*)(this))->tokenize();
[-] 			} while (m_tokenList.getCount () == oldCount);
[+] 			} while (m_tokenList.getCount() == oldCount);
[-] 			it = tail ? tail + 1 : m_tokenList.getHead ();
[+] 			it = tail ? tail + 1 : m_tokenList.getHead();
[-] 	nextChannelToken (
[+] 	nextChannelToken(
[-] 			while (!m_tokenList.isEmpty ())
[+] 			while (!m_tokenList.isEmpty())
[-] 				sl::BoxIterator <Token> it = m_tokenList.getHead ();
[+] 				sl::BoxIterator<Token> it = m_tokenList.getHead();
[-] 				TokenEntry* entry = it.getEntry ();
[+] 				TokenEntry* entry = it.getEntry();
[-] 				m_tokenList.removeEntry (entry);
[+] 				m_tokenList.removeEntry(entry);
[-] 				m_freeTokenList.insertHeadEntry (entry);
[+] 				m_freeTokenList.insertHeadEntry(entry);
[-] 	getToken (size_t index = 0)
[+] 	getToken(size_t index = 0)
[-] 		return getChannelToken (m_channelMask, index);
[+] 		return getChannelToken(m_channelMask, index);
[-] 	nextToken (size_t count = 1)
[+] 	nextToken(size_t count = 1)
[-] 		return nextChannelToken (m_channelMask, count);
[+] 		return nextChannelToken(m_channelMask, count);
[-] 	onReset ()
[+] 	onReset()
[-] 	allocateToken ()
[+] 	allocateToken()
[-] 		TokenEntry* entry = !m_freeTokenList.isEmpty () ?
[+] 		TokenEntry* entry = !m_freeTokenList.isEmpty() ?
[-] 			m_freeTokenList.removeHeadEntry () :
[+] 			m_freeTokenList.removeHeadEntry() :
[-] 			AXL_MEM_NEW (TokenEntry);
[+] 			AXL_MEM_NEW(TokenEntry);
[-] 		m_tokenList.insertTailEntry (entry);
[+] 		m_tokenList.insertTailEntry(entry);
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_lex\axl_lex_ParseError.h
----------------------
[-] AXL_SL_DEFINE_GUID (g_parseErrorGuid, 0x56fc601e, 0x5d2c, 0x4bbe, 0xb4, 0x55, 0x3d, 0x8b, 0x81, 0xaa, 0xd8, 0xff);
[+] AXL_SL_DEFINE_GUID(g_parseErrorGuid, 0x56fc601e, 0x5d2c, 0x4bbe, 0xb4, 0x55, 0x3d, 0x8b, 0x81, 0xaa, 0xd8, 0xff);
[-] 	getErrorDescription (const err::ErrorRef& error);
[+] 	getErrorDescription(const err::ErrorRef& error);
[-] registerParseErrorProvider ()
[+] registerParseErrorProvider()
[-] 	err::getErrorMgr ()->registerProvider (
[+] 	err::getErrorMgr()->registerProvider(
[-] 		sl::getSimpleSingleton <ParseErrorProvider> ()
[+] 		sl::getSimpleSingleton<ParseErrorProvider> ()
[-] pushSrcPosError (
[+] pushSrcPosError(
[-] 	return err::pushPackError <sl::PackSeq_3 <const char*, int, int> > (
[+] 	return err::pushPackError<sl::PackSeq_3<const char*, int, int> > (
[-] 		filePath.sz (),
[+] 		filePath.sz(),
[-] pushSrcPosError (
[+] pushSrcPosError(
[-] 	return pushSrcPosError (filePath, lineCol.m_line, lineCol.m_col);
[+] 	return pushSrcPosError(filePath, lineCol.m_line, lineCol.m_col);
[-] pushSrcPosError (const SrcPos& srcPos)
[+] pushSrcPosError(const SrcPos& srcPos)
[-] 	return pushSrcPosError (srcPos.m_filePath, srcPos.m_line, srcPos.m_col);
[+] 	return pushSrcPosError(srcPos.m_filePath, srcPos.m_line, srcPos.m_col);
[-] isSrcPosError (const err::ErrorHdr* error)
[+] isSrcPosError(const err::ErrorHdr* error)
[-] 		error->m_size >= sizeof (err::ErrorHdr) * 2 + sizeof (char) + sizeof (int) * 2 &&
[+] 		error->m_size >= sizeof(err::ErrorHdr)* 2 + sizeof(char) + sizeof(int)* 2 &&
[-] 		error->isStackTopKindOf (g_parseErrorGuid, ParseErrorCode_SrcPos);
[+] 		error->isStackTopKindOf(g_parseErrorGuid, ParseErrorCode_SrcPos);
[-] decodeSrcPosError (
[+] decodeSrcPosError(
[-] decodeSrcPosError (
[+] decodeSrcPosError(
[-] 	decodeSrcPosError (NULL, lineCol, error);
[+] 	decodeSrcPosError(NULL, lineCol, error);
[-] decodeSrcPosError (
[+] decodeSrcPosError(
[-] 	decodeSrcPosError (&srcPos->m_filePath, srcPos, error);
[+] 	decodeSrcPosError(&srcPos->m_filePath, srcPos, error);
[-] isLastSrcPosError ()
[+] isLastSrcPosError()
[-] 	return isSrcPosError (err::getLastError ());
[+] 	return isSrcPosError(err::getLastError());
[-] ensureSrcPosError (
[+] ensureSrcPosError(
[-] 	if (!isLastSrcPosError ())
[+] 	if (!isLastSrcPosError())
[-] 		pushSrcPosError (filePath, line, col);
[+] 		pushSrcPosError(filePath, line, col);
[-] ensureSrcPosError (
[+] ensureSrcPosError(
[-] 	ensureSrcPosError (filePath, lineCol.m_line, lineCol.m_col);
[+] 	ensureSrcPosError(filePath, lineCol.m_line, lineCol.m_col);
[-] ensureSrcPosError (const SrcPos& srcPos)
[+] ensureSrcPosError(const SrcPos& srcPos)
[-] 	ensureSrcPosError (srcPos.m_filePath, srcPos.m_line, srcPos.m_col);
[+] 	ensureSrcPosError(srcPos.m_filePath, srcPos.m_line, srcPos.m_col);
[-] setSyntaxError ()
[+] setSyntaxError()
[-] 	return err::setError (g_parseErrorGuid, ParseErrorCode_InvalidSyntax);
[+] 	return err::setError(g_parseErrorGuid, ParseErrorCode_InvalidSyntax);
[-] setSyntaxError (const sl::StringRef& location)
[+] setSyntaxError(const sl::StringRef& location)
[-] 	return err::setPackError <sl::Pack <const char*> > (
[+] 	return err::setPackError<sl::Pack<const char*> > (
[-] 		location.sz ()
[+] 		location.sz()
[-] setExpectedTokenError (
[+] setExpectedTokenError(
[-] 	return err::setPackError <sl::PackSeq_2 <const char*, const char*> > (
[+] 	return err::setPackError<sl::PackSeq_2<const char*, const char*> > (
[-] 		expectedToken.sz (),
[+] 		expectedToken.sz(),
[-] 		actualToken.sz ()
[+] 		actualToken.sz()
[-] setUnexpectedTokenError (const sl::StringRef& token)
[+] setUnexpectedTokenError(const sl::StringRef& token)
[-] 	return err::setPackError <sl::Pack <const char*> > (
[+] 	return err::setPackError<sl::Pack<const char*> > (
[-] 		token.sz ()
[+] 		token.sz()
[-] setUnexpectedTokenError (
[+] setUnexpectedTokenError(
[-] 	return err::setPackError <sl::PackSeq_2 <const char*, const char*> > (
[+] 	return err::setPackError<sl::PackSeq_2<const char*, const char*> > (
[-] 		token.sz (),
[+] 		token.sz(),
[-] 		location.sz ()
[+] 		location.sz()
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_lex\axl_lex_RagelLexer.h
----------------------
[-] 	RagelTokenPos ()
[+] 	RagelTokenPos()
[-] class RagelToken: public Token <Enum, GetName, Data, RagelTokenPos>
[+] class RagelToken: public Token<Enum, GetName, Data, RagelTokenPos>
[-] 	getText () const
[+] 	getText() const
[-] 		return sl::StringRef (this->m_pos.m_p, this->m_pos.m_length);
[+] 		return sl::StringRef(this->m_pos.m_p, this->m_pos.m_length);
[-] 	getTokenListString (const sl::ConstBoxList <RagelToken>& list)
[+] 	getTokenListString(const sl::ConstBoxList<RagelToken>& list)
[-] 		if (list.isEmpty ())
[+] 		if (list.isEmpty())
[-] 			return sl::String ();
[+] 			return sl::String();
[-] 		sl::ConstBoxIterator <RagelToken> token = list.getHead ();
[+] 		sl::ConstBoxIterator<RagelToken> token = list.getHead();
[-] 		sl::String string (token->m_pos.m_p, token->m_pos.m_length);
[+] 		sl::String string(token->m_pos.m_p, token->m_pos.m_length);
[-] 			string.append (' ');
[+] 			string.append(' ');
[-] 			string.append (token->m_pos.m_p, token->m_pos.m_length);
[+] 			string.append(token->m_pos.m_p, token->m_pos.m_length);
[-] typedef RagelToken <int, StdTokenData> StdRagelToken;
[+] typedef RagelToken<int, StdTokenData> StdRagelToken;
[-] class RagelLexer: public Lexer <T, Token>
[+] class RagelLexer: public Lexer<T, Token>
[-] 	friend class Lexer <T, Token>;
[+] 	friend class Lexer<T, Token>;
[-] 	sl::Array <int> m_stack; // stack of states
[+] 	sl::Array<int> m_stack; // stack of states
[-] 	RagelLexer ()
[+] 	RagelLexer()
[-] 		onReset ();
[+] 		onReset();
[-] 	getTokenizeLimit ()
[+] 	getTokenizeLimit()
[-] 	setTokenizeLimit (size_t tokenizeLimit)
[+] 	setTokenizeLimit(size_t tokenizeLimit)
[-] 		ASSERT (tokenizeLimit);
[+] 		ASSERT(tokenizeLimit);
[-] 	create (
[+] 	create(
[-] 		create (filePath, source);
[+] 		create(filePath, source);
[-] 	create (
[+] 	create(
[-] 		this->reset ();
[+] 		this->reset();
[-] 		static_cast <T*> (this)->init ();
[+] 		static_cast<T*> (this)->init();
[-] 		p   = (char*) source.cp ();
[+] 		p   = (char*)source.cp();
[-] 		eof = (char*) source.getEnd ();
[+] 		eof = (char*)source.getEnd();
[-] 	expectToken (int tokenKind)
[+] 	expectToken(int tokenKind)
[-] 		const Token* token = this->getToken ();
[+] 		const Token* token = this->getToken();
[-] 		lex::setExpectedTokenError (Token::getName (tokenKind), token->getName ());
[+] 		lex::setExpectedTokenError(Token::getName(tokenKind), token->getName());
[-] 	ensureSrcPosError ()
[+] 	ensureSrcPosError()
[-] 		if (!lex::isLastSrcPosError ())
[+] 		if (!lex::isLastSrcPosError())
[-] 			lex::pushSrcPosError (m_filePath, this->m_lastTokenPos);
[+] 			lex::pushSrcPosError(m_filePath, this->m_lastTokenPos);
[-] 	gotoState (
[+] 	gotoState(
[-] 	callState (int state)
[+] 	callState(int state)
[-] 		gotoState (state);
[+] 		gotoState(state);
[-] 		stack = prePush ();
[+] 		stack = prePush();
[-] 		stack [top++] = oldState;
[+] 		stack[top++] = oldState;
[-] 	setLineCol (
[+] 	setLineCol(
[-] 	setLineCol (const LineCol& lineCol)
[+] 	setLineCol(const LineCol& lineCol)
[-] 		setLineCol (lineCol.m_line, lineCol.m_col);
[+] 		setLineCol(lineCol.m_line, lineCol.m_col);
[-] 	newLine (char* line)
[+] 	newLine(char* line)
[-] 		ASSERT (line [-1] == '\n');
[+] 		ASSERT(line[-1] == '\n');
[-] 	prePush ()
[+] 	prePush()
[-] 		size_t count = m_stack.getCount ();
[+] 		size_t count = m_stack.getCount();
[-] 		m_stack.setCount (count + 1);
[+] 		m_stack.setCount(count + 1);
[-] 	postPop ()
[+] 	postPop()
[-] 		size_t count = m_stack.getCount ();
[+] 		size_t count = m_stack.getCount();
[-] 		m_stack.setCount (count - 1);
[+] 		m_stack.setCount(count - 1);
[-] 	stop ()
[+] 	stop()
[-] 	onLexerError ()
[+] 	onLexerError()
[-] 	preCreateToken (
[+] 	preCreateToken(
[-] 		Token* token = this->allocateToken ();
[+] 		Token* token = this->allocateToken();
[-] 	postCreateToken ()
[+] 	postCreateToken()
[-] 			stop ();
[+] 			stop();
[-] 	createToken (
[+] 	createToken(
[-] 		Token* token = preCreateToken (tokenKind, channelMask);
[+] 		Token* token = preCreateToken(tokenKind, channelMask);
[-] 		postCreateToken ();
[+] 		postCreateToken();
[-] 	createErrorToken (int c)
[+] 	createErrorToken(int c)
[-] 		Token* token = createToken (-1);
[+] 		Token* token = createToken(-1);
[-] 		postCreateToken ();
[+] 		postCreateToken();
[-] 	onReset ()
[+] 	onReset()
[-] 		m_filePath.clear ();
[+] 		m_filePath.clear();
[-] 		m_stack.clear ();
[+] 		m_stack.clear();
[-] 	tokenize ()
[+] 	tokenize()
[-] 			static_cast <T*> (this)->exec ();
[+] 			static_cast<T*> (this)->exec();
[-] 			createToken (0);
[+] 			createToken(0);
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_lex\axl_lex_Token.h
----------------------
[-] 	LineCol ()
[+] 	LineCol()
[-] 	LineCol (
[+] 	LineCol(
[-] 	clear ()
[+] 	clear()
[-] 	count (const sl::StringRef& string)
[+] 	count(const sl::StringRef& string)
[-] 		clear ();
[+] 		clear();
[-] 		incrementalCount (string);
[+] 		incrementalCount(string);
[-] 	incrementalCount (const sl::StringRef& string);
[+] 	incrementalCount(const sl::StringRef& string);
[-] 	SrcPos ()
[+] 	SrcPos()
[-] 	SrcPos (
[+] 	SrcPos(
[-] 		LineCol (lineCol)
[+] 		LineCol(lineCol)
[-] 	SrcPos (
[+] 	SrcPos(
[-] 		LineCol (line, col)
[+] 		LineCol(line, col)
[-] 		*(LineCol*) this = lineCol;
[+] 		*(LineCol*)this = lineCol;
[-] 	StdTokenData ()
[+] 	StdTokenData()
[-] 	Token ()
[+] 	Token()
[-] 	getName (int token)
[+] 	getName(int token)
[-] 		return Name () (token);
[+] 		return Name() (token);
[-] 	getName () const
[+] 	getName() const
[-] 		return getName (m_token);
[+] 		return getName(m_token);
[-] 		switch (tokenKind) \
[+] 		switch(tokenKind) \
[-] 			return isprint ((uchar_t) tokenKind) ? axl::sl::getCharLiteral ((uchar_t) tokenKind) : unknownName; \
[+] 			return isprint((uchar_t)tokenKind) ? axl::sl::getCharLiteral((uchar_t)tokenKind) : unknownName; \
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_lua\axl_lua_LuaState.h
----------------------
[-] 		lua_close (lua);
[+] 		lua_close(lua);
[-] class LuaState: public sl::Handle <lua_State*, LuaClose>
[+] class LuaState: public sl::Handle<lua_State*, LuaClose>
[-] 	LuaState ()
[+] 	LuaState()
[-] 	LuaState (lua_State* h)
[+] 	LuaState(lua_State* h)
[-] 		attach (h);
[+] 		attach(h);
[-] 	create ();
[+] 	create();
[-] 	load (
[+] 	load(
[-] 	trace ();
[+] 	trace();
[-] 	openLibs ()
[+] 	openLibs()
[-] 		luaL_openlibs (m_h);
[+] 		luaL_openlibs(m_h);
[-] 	where (int level = 1)
[+] 	where(int level = 1)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		luaL_where (m_h, level);
[+] 		luaL_where(m_h, level);
[-] 	prepareErrorString (const sl::StringRef& string);
[+] 	prepareErrorString(const sl::StringRef& string);
[-] 	prepareLastErrorString ()
[+] 	prepareLastErrorString()
[-] 		prepareErrorString (err::getLastErrorDescription ());
[+] 		prepareErrorString(err::getLastErrorDescription());
[-] 	error ()
[+] 	error()
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_error (m_h);
[+] 		lua_error(m_h);
[-] 	clearStack ()
[+] 	clearStack()
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_settop (m_h, 0);
[+] 		lua_settop(m_h, 0);
[-] 	getTop ()
[+] 	getTop()
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		return lua_gettop (m_h);
[+] 		return lua_gettop(m_h);
[-] 	setTop (int index)
[+] 	setTop(int index)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_settop (m_h, index);
[+] 		lua_settop(m_h, index);
[-] 	tryCheckStack (int extraSlotCount);
[+] 	tryCheckStack(int extraSlotCount);
[-] 	checkStack (int extraSlotCount);
[+] 	checkStack(int extraSlotCount);
[-] 	getType (int index)
[+] 	getType(int index)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		return lua_type (m_h, index);
[+] 		return lua_type(m_h, index);
[-] 	getTypeName (int type)
[+] 	getTypeName(int type)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		return lua_typename (m_h, type);
[+] 		return lua_typename(m_h, type);
[-] 	getLen (int index = -1)
[+] 	getLen(int index = -1)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_len (m_h, index);
[+] 		lua_len(m_h, index);
[-] 	getRawLen (int index = -1)
[+] 	getRawLen(int index = -1)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		return lua_rawlen (m_h, index);
[+] 		return lua_rawlen(m_h, index);
[-] 	insert (int index)
[+] 	insert(int index)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_insert (m_h, index);
[+] 		lua_insert(m_h, index);
[-] 	remove (int index)
[+] 	remove(int index)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_remove (m_h, index);
[+] 		lua_remove(m_h, index);
[-] 	swap ()
[+] 	swap()
[-] 		insert (-2);
[+] 		insert(-2);
[-] 	concatenate (int count = 2)
[+] 	concatenate(int count = 2)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_concat (m_h, count);
[+] 		lua_concat(m_h, count);
[-] 	pushNil ()
[+] 	pushNil()
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_pushnil (m_h);
[+] 		lua_pushnil(m_h);
[-] 	pushValue (int index = -1)
[+] 	pushValue(int index = -1)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_pushvalue (m_h, index);
[+] 		lua_pushvalue(m_h, index);
[-] 	pushInteger (lua_Integer value)
[+] 	pushInteger(lua_Integer value)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_pushinteger (m_h, value);
[+] 		lua_pushinteger(m_h, value);
[-] 	pushBoolean (bool value)
[+] 	pushBoolean(bool value)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_pushboolean (m_h, value);
[+] 		lua_pushboolean(m_h, value);
[-] 	pushString (const sl::StringRef& string)
[+] 	pushString(const sl::StringRef& string)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_pushlstring (m_h, string.cp (), string.getLength ());
[+] 		lua_pushlstring(m_h, string.cp(), string.getLength());
[-] 	pushFormatString_va (
[+] 	pushFormatString_va(
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_pushvfstring (m_h, format, va);
[+] 		lua_pushvfstring(m_h, format, va);
[-] 	pushFormatString (
[+] 	pushFormatString(
[-] 		AXL_VA_DECL (va, format);
[+] 		AXL_VA_DECL(va, format);
[-] 		pushFormatString_va (format, va);
[+] 		pushFormatString_va(format, va);
[-] 	pushClosure (
[+] 	pushClosure(
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_pushcclosure (m_h, func, contextArgumentCount);
[+] 		lua_pushcclosure(m_h, func, contextArgumentCount);
[-] 	pushFunction (lua_CFunction func)
[+] 	pushFunction(lua_CFunction func)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_pushcfunction (m_h, func);
[+] 		lua_pushcfunction(m_h, func);
[-] 	pushFunction (
[+] 	pushFunction(
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_pushlightuserdata (m_h, context);
[+] 		lua_pushlightuserdata(m_h, context);
[-] 		pushClosure (func, 1);
[+] 		pushClosure(func, 1);
[-] 	tryCreateTable (
[+] 	tryCreateTable(
[-] 	createTable (
[+] 	createTable(
[-] 	getTable (int index = -2)
[+] 	getTable(int index = -2)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_gettable (m_h, index);
[+] 		lua_gettable(m_h, index);
[-] 	setTable (int index = -3)
[+] 	setTable(int index = -3)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_settable (m_h, index);
[+] 		lua_settable(m_h, index);
[-] 	getMember (const sl::StringRef& name)
[+] 	getMember(const sl::StringRef& name)
[-] 		pushString (name);
[+] 		pushString(name);
[-] 		getTable ();
[+] 		getTable();
[-] 	setMember (const sl::StringRef& name)
[+] 	setMember(const sl::StringRef& name)
[-] 		pushString (name);
[+] 		pushString(name);
[-] 		swap ();
[+] 		swap();
[-] 		setTable ();
[+] 		setTable();
[-] 	getArrayElement (int index)
[+] 	getArrayElement(int index)
[-] 		pushInteger (index);
[+] 		pushInteger(index);
[-] 		getTable ();
[+] 		getTable();
[-] 	setArrayElement (int index)
[+] 	setArrayElement(int index)
[-] 		pushInteger (index);
[+] 		pushInteger(index);
[-] 		swap ();
[+] 		swap();
[-] 		setTable ();
[+] 		setTable();
[-] 	setMemberInteger (
[+] 	setMemberInteger(
[-] 		pushString (name);
[+] 		pushString(name);
[-] 		pushInteger (value);
[+] 		pushInteger(value);
[-] 		setTable ();
[+] 		setTable();
[-] 	setMemberBoolean (
[+] 	setMemberBoolean(
[-] 		pushString (name);
[+] 		pushString(name);
[-] 		pushBoolean (value);
[+] 		pushBoolean(value);
[-] 		setTable ();
[+] 		setTable();
[-] 	setMemberString (
[+] 	setMemberString(
[-] 		pushString (name);
[+] 		pushString(name);
[-] 		pushString (string);
[+] 		pushString(string);
[-] 		setTable ();
[+] 		setTable();
[-] 	setArrayElementInteger (
[+] 	setArrayElementInteger(
[-] 		pushInteger (index);
[+] 		pushInteger(index);
[-] 		pushInteger (value);
[+] 		pushInteger(value);
[-] 		setTable ();
[+] 		setTable();
[-] 	setArrayElementString (
[+] 	setArrayElementString(
[-] 		pushInteger (index);
[+] 		pushInteger(index);
[-] 		pushString (string);
[+] 		pushString(string);
[-] 		setTable ();
[+] 		setTable();
[-] 	pop (size_t count = 1)
[+] 	pop(size_t count = 1)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_pop (m_h, count);
[+] 		lua_pop(m_h, count);
[-] 	getInteger (int index = -1)
[+] 	getInteger(int index = -1)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		return lua_tointeger (m_h, index);
[+] 		return lua_tointeger(m_h, index);
[-] 	getNumber (int index = -1)
[+] 	getNumber(int index = -1)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		return lua_tonumber (m_h, index);
[+] 		return lua_tonumber(m_h, index);
[-] 	getBoolean (int index = -1)
[+] 	getBoolean(int index = -1)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		return lua_toboolean (m_h, index) != 0;
[+] 		return lua_toboolean(m_h, index) != 0;
[-] 	getString (int index = -1)
[+] 	getString(int index = -1)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		return lua_tostring (m_h, index);
[+] 		return lua_tostring(m_h, index);
[-] 	popInteger ()
[+] 	popInteger()
[-] 		lua_Integer value = getInteger (-1);
[+] 		lua_Integer value = getInteger(-1);
[-] 		pop ();
[+] 		pop();
[-] 	popBoolean ()
[+] 	popBoolean()
[-] 		bool value = getBoolean (-1);
[+] 		bool value = getBoolean(-1);
[-] 		pop ();
[+] 		pop();
[-] 	popString ()
[+] 	popString()
[-] 		sl::String string = getString (-1);
[+] 		sl::String string = getString(-1);
[-] 		pop ();
[+] 		pop();
[-] 	getGlobal (const sl::StringRef& name)
[+] 	getGlobal(const sl::StringRef& name)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_getglobal (m_h, name.sz ());
[+] 		lua_getglobal(m_h, name.sz());
[-] 	setGlobal (const sl::StringRef& name)
[+] 	setGlobal(const sl::StringRef& name)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_setglobal (m_h, name.sz ());
[+] 		lua_setglobal(m_h, name.sz());
[-] 	getGlobalArrayLen (const sl::StringRef& name);
[+] 	getGlobalArrayLen(const sl::StringRef& name);
[-] 	getGlobalArrayElement (
[+] 	getGlobalArrayElement(
[-] 		getGlobal (name);
[+] 		getGlobal(name);
[-] 		getArrayElement (index);
[+] 		getArrayElement(index);
[-] 		remove (-2);
[+] 		remove(-2);
[-] 	setGlobalArrayElement (
[+] 	setGlobalArrayElement(
[-] 	getGlobalMember (
[+] 	getGlobalMember(
[-] 		getGlobal (name);
[+] 		getGlobal(name);
[-] 		getMember (member);
[+] 		getMember(member);
[-] 		remove (-2);
[+] 		remove(-2);
[-] 	setGlobalMember (
[+] 	setGlobalMember(
[-] 	getGlobalInteger (const sl::StringRef& name)
[+] 	getGlobalInteger(const sl::StringRef& name)
[-] 		getGlobal (name);
[+] 		getGlobal(name);
[-] 		return popInteger ();
[+] 		return popInteger();
[-] 	setGlobalInteger (
[+] 	setGlobalInteger(
[-] 		pushInteger (value);
[+] 		pushInteger(value);
[-] 		setGlobal (name);
[+] 		setGlobal(name);
[-] 	getGlobalBoolean (const sl::StringRef& name)
[+] 	getGlobalBoolean(const sl::StringRef& name)
[-] 		getGlobal (name);
[+] 		getGlobal(name);
[-] 		return popBoolean ();
[+] 		return popBoolean();
[-] 	setGlobalBoolean (
[+] 	setGlobalBoolean(
[-] 		pushBoolean (value);
[+] 		pushBoolean(value);
[-] 		setGlobal (name);
[+] 		setGlobal(name);
[-] 	getGlobalString (const sl::StringRef& name)
[+] 	getGlobalString(const sl::StringRef& name)
[-] 		getGlobal (name);
[+] 		getGlobal(name);
[-] 		return popString ();
[+] 		return popString();
[-] 	setGlobalString (
[+] 	setGlobalString(
[-] 		pushString (string);
[+] 		pushString(string);
[-] 		setGlobal (name);
[+] 		setGlobal(name);
[-] 	registerFunction (
[+] 	registerFunction(
[-] 		pushFunction (func);
[+] 		pushFunction(func);
[-] 		setGlobal (name);
[+] 		setGlobal(name);
[-] 	registerFunction (
[+] 	registerFunction(
[-] 		pushFunction (func, context);
[+] 		pushFunction(func, context);
[-] 		setGlobal (name);
[+] 		setGlobal(name);
[-] 	getContext ()
[+] 	getContext()
[-] 		int index = getUpValueIndex ();
[+] 		int index = getUpValueIndex();
[-] 		return lua_touserdata (m_h, index);
[+] 		return lua_touserdata(m_h, index);
[-] 	getUpValueIndex (int index = 1)
[+] 	getUpValueIndex(int index = 1)
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		return lua_upvalueindex (index);
[+] 		return lua_upvalueindex(index);
[-] 	call (
[+] 	call(
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		lua_call (m_h, argumentCount, resultCount);
[+] 		lua_call(m_h, argumentCount, resultCount);
[-] 	PCall (
[+] 	PCall(
[-] 		ASSERT (isOpen ());
[+] 		ASSERT(isOpen());
[-] 		return complete (lua_pcall (m_h, argumentCount, resultCount, 0));
[+] 		return complete(lua_pcall(m_h, argumentCount, resultCount, 0));
[-] 	complete (int result);
[+] 	complete(int result);
[-] 	LuaNonOwnerState (lua_State* h)
[+] 	LuaNonOwnerState(lua_State* h)
[-] 		attach (h);
[+] 		attach(h);
[-] 	~LuaNonOwnerState ()
[+] 	~LuaNonOwnerState()
[-] 		detach ();
[+] 		detach();
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_mem\axl_mem_Allocator.h
----------------------
[-] _AXL_MEM_ALLOCATE_IMPL (size_t size);
[+] _AXL_MEM_ALLOCATE_IMPL(size_t size);
[-] _AXL_MEM_FREE_IMPL (void* size);
[+] _AXL_MEM_FREE_IMPL(void* size);
[-] setOutOfMemoryError ();
[+] setOutOfMemoryError();
[-] 	allocate (size_t size)
[+] 	allocate(size_t size)
[-] 		return ::_AXL_MEM_ALLOCATE_IMPL (size);
[+] 		return ::_AXL_MEM_ALLOCATE_IMPL(size);
[-] 	free (void* p)
[+] 	free(void* p)
[-] 		::_AXL_MEM_FREE_IMPL (p);
[+] 		::_AXL_MEM_FREE_IMPL(p);
[-] 	allocate (size_t size)
[+] 	allocate(size_t size)
[-] 		void* p = ::malloc (size);
[+] 		void* p = ::malloc(size);
[-] 			err::setOutOfMemoryError ();
[+] 			err::setOutOfMemoryError();
[-] 		memset (p, 0xcd, size);
[+] 		memset(p, 0xcd, size);
[-] 	free (void* p)
[+] 	free(void* p)
[-] 		::free (p);
[+] 		::free(p);
[-] 	allocate (size_t size)
[+] 	allocate(size_t size)
[-] 		void* p = DirectAllocator::allocate (size);
[+] 		void* p = DirectAllocator::allocate(size);
[-] 			memset (p, 0, size);
[+] 			memset(p, 0, size);
[-] 	allocate (
[+] 	allocate(
[-] 		size_t allocSize = size + sizeof (TrackerBlockHdr);
[+] 		size_t allocSize = size + sizeof(TrackerBlockHdr);
[-] 		TrackerBlockHdr* hdr = (TrackerBlockHdr*) BaseAllocator::allocate (allocSize);
[+] 		TrackerBlockHdr* hdr = (TrackerBlockHdr*)BaseAllocator::allocate(allocSize);
[-] 		addTrackerBlock (hdr);
[+] 		addTrackerBlock(hdr);
[-] 	free (void* p)
[+] 	free(void* p)
[-] 		TrackerBlockHdr* hdr = (TrackerBlockHdr*) p - 1;
[+] 		TrackerBlockHdr* hdr = (TrackerBlockHdr*)p - 1;
[-] 		removeTrackerBlock (hdr);
[+] 		removeTrackerBlock(hdr);
[-] 		BaseAllocator::free (hdr);
[+] 		BaseAllocator::free(hdr);
[-] 		return BaseAllocator::allocate (size);
[+] 		return BaseAllocator::allocate(size);
[-] 		BaseAllocator::free (p);
[+] 		BaseAllocator::free(p);
[-] 		return TrackingAllocator <BaseAllocator>::allocate (size, tag, filePath, line);
[+] 		return TrackingAllocator<BaseAllocator>::allocate(size, tag, filePath, line);
[-] 		TrackingAllocator <BaseAllocator>::free (p);
[+] 		TrackingAllocator<BaseAllocator>::free(p);
[-] typedef TrackingAllocator <DirectAllocator> StdAllocator;
[+] typedef TrackingAllocator<DirectAllocator> StdAllocator;
[-] typedef TrackingAllocator <ZeroAllocator>   StdZeroAllocator;
[+] typedef TrackingAllocator<ZeroAllocator>   StdZeroAllocator;
[-] typedef TrackingAllocate <DirectAllocator>  StdAllocate;
[+] typedef TrackingAllocate<DirectAllocator>  StdAllocate;
[-] typedef TrackingAllocate <ZeroAllocator>    StdZeroAllocate;
[+] typedef TrackingAllocate<ZeroAllocator>    StdZeroAllocate;
[-] typedef TrackingFree <DirectAllocator>      StdFree;
[+] typedef TrackingFree<DirectAllocator>      StdFree;
[-] typedef Allocate <DirectAllocator> StdAllocate;
[+] typedef Allocate<DirectAllocator> StdAllocate;
[-] typedef Allocate <ZeroAllocator>   StdZeroAllocate;
[+] typedef Allocate<ZeroAllocator>   StdZeroAllocate;
[-] typedef Free <DirectAllocator>     StdFree;
[+] typedef Free<DirectAllocator>     StdFree;
[-] 	(axl::mem::StdAllocator::allocate (size, tag, __FILE__, __LINE__))
[+] 	(axl::mem::StdAllocator::allocate(size, tag, __FILE__, __LINE__))
[-] 	(axl::mem::StdZeroAllocator::allocate (size, tag, __FILE__, __LINE__))
[+] 	(axl::mem::StdZeroAllocator::allocate(size, tag, __FILE__, __LINE__))
[-] 	(axl::mem::StdAllocator::allocate (size))
[+] 	(axl::mem::StdAllocator::allocate(size))
[-] 	(axl::mem::StdZeroAllocator::allocate (size))
[+] 	(axl::mem::StdZeroAllocator::allocate(size))
[-] 	AXL_MEM_ALLOCATE_EX (size, "<buffer>")
[+] 	AXL_MEM_ALLOCATE_EX(size, "<buffer>")
[-] 	AXL_MEM_ZERO_ALLOCATE_EX (size, "<buffer>")
[+] 	AXL_MEM_ZERO_ALLOCATE_EX(size, "<buffer>")
[-] 	(axl::mem::StdAllocator::free (p))
[+] 	(axl::mem::StdAllocator::free(p))
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_mem\axl_mem_Block.h
----------------------
[-] 	Block ()
[+] 	Block()
[-] 		setup (NULL, 0);
[+] 		setup(NULL, 0);
[-] 	Block (
[+] 	Block(
[-] 		setup (p, size);
[+] 		setup(p, size);
[-] 	setup (
[+] 	setup(
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_mem\axl_mem_New.h
----------------------
[-] 		p->~T ();
[+] 		p->~T();
[-] 		StdAllocator::free (p);
[+] 		StdAllocator::free(p);
[-] stdDelete (T* p)
[+] stdDelete(T* p)
[-] 	p->~T ();
[+] 	p->~T();
[-] 	StdAllocator::free (p);
[+] 	StdAllocator::free(p);
[-] 	(new (AXL_MEM_ALLOCATE_EX (sizeof (T), #T)) T)
[+] 	(new(AXL_MEM_ALLOCATE_EX(sizeof(T), #T)) T)
[-] 	(new (AXL_MEM_ALLOCATE_EX (sizeof (T) + extra, #T)) T)
[+] 	(new(AXL_MEM_ALLOCATE_EX(sizeof(T) + extra, #T)) T)
[-] 	(new (AXL_MEM_ALLOCATE_EX (sizeof (T), #T)) T args)
[+] 	(new(AXL_MEM_ALLOCATE_EX(sizeof(T), #T)) T args)
[-] 	(new (AXL_MEM_ALLOCATE_EX (sizeof (T) + extra, #T)) T args)
[+] 	(new(AXL_MEM_ALLOCATE_EX(sizeof(T) + extra, #T)) T args)
[-] 	(new (AXL_MEM_ZERO_ALLOCATE_EX (sizeof (T), #T)) T)
[+] 	(new(AXL_MEM_ZERO_ALLOCATE_EX(sizeof(T), #T)) T)
[-] 	(new (AXL_MEM_ZERO_ALLOCATE_EX (sizeof (T) + extra, #T)) T)
[+] 	(new(AXL_MEM_ZERO_ALLOCATE_EX(sizeof(T) + extra, #T)) T)
[-] 	(new (AXL_MEM_ZERO_ALLOCATE_EX (sizeof (T), #T)) T args)
[+] 	(new(AXL_MEM_ZERO_ALLOCATE_EX(sizeof(T), #T)) T args)
[-] 	(new (AXL_MEM_ZERO_ALLOCATE_EX (sizeof (T) + extra, #T)) T args)
[+] 	(new(AXL_MEM_ZERO_ALLOCATE_EX(sizeof(T) + extra, #T)) T args)
[-] 	(new (AXL_MEM_ALLOCATE (sizeof (T))) T)
[+] 	(new(AXL_MEM_ALLOCATE(sizeof(T))) T)
[-] 	(new (AXL_MEM_ALLOCATE (sizeof (T) + extra)) T)
[+] 	(new(AXL_MEM_ALLOCATE(sizeof(T) + extra)) T)
[-] 	(new (AXL_MEM_ALLOCATE (sizeof (T))) T args)
[+] 	(new(AXL_MEM_ALLOCATE(sizeof(T))) T args)
[-] 	(new (AXL_MEM_ALLOCATE (sizeof (T) + extra)) T args)
[+] 	(new(AXL_MEM_ALLOCATE(sizeof(T) + extra)) T args)
[-] 	(new (AXL_MEM_ZERO_ALLOCATE (sizeof (T))) T)
[+] 	(new(AXL_MEM_ZERO_ALLOCATE(sizeof(T))) T)
[-] 	(new (AXL_MEM_ZERO_ALLOCATE (sizeof (T) + extra)) T)
[+] 	(new(AXL_MEM_ZERO_ALLOCATE(sizeof(T) + extra)) T)
[-] 	(new (AXL_MEM_ZERO_ALLOCATE (sizeof (T))) T args)
[+] 	(new(AXL_MEM_ZERO_ALLOCATE(sizeof(T))) T args)
[-] 	(new (AXL_MEM_ZERO_ALLOCATE (sizeof (T) + extra)) T args)
[+] 	(new(AXL_MEM_ZERO_ALLOCATE(sizeof(T) + extra)) T args)
[-] 	(axl::mem::stdDelete (p))
[+] 	(axl::mem::stdDelete(p))
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_mem\axl_mem_Pool.h
----------------------
[-] 	sl::List <T> m_freeList;
[+] 	sl::List<T> m_freeList;
[-] 	get ()
[+] 	get()
[-] 		return !m_freeList.isEmpty () ? m_freeList.removeHead () : AXL_MEM_NEW (T);
[+] 		return !m_freeList.isEmpty() ? m_freeList.removeHead() : AXL_MEM_NEW(T);
[-] 	put (T* p)
[+] 	put(T* p)
[-] 		putFront (p); // by default, use stack rather than queue semantics
[+] 		putFront(p); // by default, use stack rather than queue semantics
[-] 	putFront (T* p)
[+] 	putFront(T* p)
[-] 		m_freeList.insertHead (p);
[+] 		m_freeList.insertHead(p);
[-] 	putBack (T* p)
[+] 	putBack(T* p)
[-] 		m_freeList.insertTail (p);
[+] 		m_freeList.insertTail(p);
[-] 	put (sl::List <T>* list)
[+] 	put(sl::List<T>* list)
[-] 		m_freeList.insertListTail (list);
[+] 		m_freeList.insertListTail(list);
[-] 	reserve (size_t count)
[+] 	reserve(size_t count)
[-] 		size_t freeCount = m_freeList.getCount ();
[+] 		size_t freeCount = m_freeList.getCount();
[-] 			T* p = AXL_MEM_NEW (T);
[+] 			T* p = AXL_MEM_NEW(T);
[-] 			m_freeList.insertTail (p);
[+] 			m_freeList.insertTail(p);
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_mem\axl_mem_Tracker.h
----------------------
[-] 	sl::AuxList <TrackerBlockHdr> m_blockList;
[+] 	sl::AuxList<TrackerBlockHdr> m_blockList;
[-] 	Tracker ();
[+] 	Tracker();
[-] 	add (TrackerBlockHdr* hdr);
[+] 	add(TrackerBlockHdr* hdr);
[-] 	remove (TrackerBlockHdr* hdr);
[+] 	remove(TrackerBlockHdr* hdr);
[-] 	trace ();
[+] 	trace();
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_mem\axl_mem_TrackerBlock.h
----------------------
[-] addTrackerBlock (TrackerBlockHdr* hdr);
[+] addTrackerBlock(TrackerBlockHdr* hdr);
[-] removeTrackerBlock (TrackerBlockHdr* hdr);
[+] removeTrackerBlock(TrackerBlockHdr* hdr);
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_ref\axl_ref_Buf.h
----------------------
[-] 	cp () const
[+] 	cp() const
[-] 	getEnd () const
[+] 	getEnd() const
[-] 		return (char*) (this + 1) + m_bufferSize;
[+] 		return (char*)(this + 1) + m_bufferSize;
[-] 	isInsideBuffer (const void* p) const
[+] 	isInsideBuffer(const void* p) const
[-] 		return p >= cp () && p < getEnd ();
[+] 		return p >= cp() && p < getEnd();
[-] 	getLeftoverBufferSize (const void* p) const
[+] 	getLeftoverBufferSize(const void* p) const
[-] 		ASSERT (isInsideBuffer (p));
[+] 		ASSERT(isInsideBuffer(p));
[-] 		return (char*) getEnd () - (char*) p;
[+] 		return (char*)getEnd() - (char*)p;
[-] 	typename SizeOf = sl::SizeOf <T>
[+] 	typename SizeOf = sl::SizeOf<T>
[-] 	BufRef ()
[+] 	BufRef()
[-] 		initialize ();
[+] 		initialize();
[-] 	BufRef (BufRef&& src)
[+] 	BufRef(BufRef&& src)
[-] 		initialize ();
[+] 		initialize();
[-] 		move (std::move (src));
[+] 		move(std::move(src));
[-] 	BufRef (const BufRef& src)
[+] 	BufRef(const BufRef& src)
[-] 		initialize ();
[+] 		initialize();
[-] 		attach (src);
[+] 		attach(src);
[-] 	BufRef (const T* p)
[+] 	BufRef(const T* p)
[-] 		initialize ();
[+] 		initialize();
[-] 			attach (NULL, p, SizeOf () (p));
[+] 			attach(NULL, p, SizeOf() (p));
[-] 	BufRef (
[+] 	BufRef(
[-] 		initialize ();
[+] 		initialize();
[-] 		attach (NULL, p, size);
[+] 		attach(NULL, p, size);
[-] 	BufRef (
[+] 	BufRef(
[-] 		initialize ();
[+] 		initialize();
[-] 		attach (NULL, p, (char*) end - (char*) p);
[+] 		attach(NULL, p, (char*)end - (char*)p);
[-] 	BufRef (
[+] 	BufRef(
[-] 		initialize ();
[+] 		initialize();
[-] 		attach (hdr, p, SizeOf () (p));
[+] 		attach(hdr, p, SizeOf() (p));
[-] 	BufRef (
[+] 	BufRef(
[-] 		initialize ();
[+] 		initialize();
[-] 		attach (hdr, p, size);
[+] 		attach(hdr, p, size);
[-] 	BufRef (
[+] 	BufRef(
[-] 		initialize ();
[+] 		initialize();
[-] 		attach (hdr, p, (char*) end - (char*) p);
[+] 		attach(hdr, p, (char*)end - (char*)p);
[-] 	~BufRef ()
[+] 	~BufRef()
[-] 		release ();
[+] 		release();
[-] 		ASSERT (m_p);
[+] 		ASSERT(m_p);
[-] 		move (std::move (src));
[+] 		move(std::move(src));
[-] 		attach (src);
[+] 		attach(src);
[-] 	cp () const
[+] 	cp() const
[-] 	getSize () const
[+] 	getSize() const
[-] 	getHdr () const
[+] 	getHdr() const
[-] 	getEnd () const
[+] 	getEnd() const
[-] 		return (T*) ((char*) m_p + m_size);
[+] 		return (T*)((char*)m_p + m_size);
[-] 	isEmpty () const
[+] 	isEmpty() const
[-] 	release ()
[+] 	release()
[-] 			m_hdr->release ();
[+] 			m_hdr->release();
[-] 		initialize ();
[+] 		initialize();
[-] 	initialize ()
[+] 	initialize()
[-] 	move (BufRef&& src)
[+] 	move(BufRef&& src)
[-] 			m_hdr->release ();
[+] 			m_hdr->release();
[-] 		src.initialize ();
[+] 		src.initialize();
[-] 	attachBufHdr (BufHdr* hdr)
[+] 	attachBufHdr(BufHdr* hdr)
[-] 			hdr->addRef ();
[+] 			hdr->addRef();
[-] 			m_hdr->release ();
[+] 			m_hdr->release();
[-] 	attach (const BufRef& src)
[+] 	attach(const BufRef& src)
[-] 			attach (src.m_hdr, src.m_p, src.m_size);
[+] 			attach(src.m_hdr, src.m_p, src.m_size);
[-] 	attach (
[+] 	attach(
[-] 		attachBufHdr (hdr);
[+] 		attachBufHdr(hdr);
[-] 		m_p = (T*) p;
[+] 		m_p = (T*)p;
[-] 	typename SizeOf = sl::SizeOf <T>,
[+] 	typename SizeOf = sl::SizeOf<T>,
[-] 	typename Ref = BufRef <T, SizeOf>
[+] 	typename Ref = BufRef<T, SizeOf>
[-] 		~Hdr ()
[+] 		~Hdr()
[-] 			((T*) (this + 1))->~T ();
[+] 			((T*)(this + 1))->~T();
[-] 		MinBufSize = sizeof (Hdr) + sizeof (T)
[+] 		MinBufSize = sizeof(Hdr) + sizeof(T)
[-] 	Buf ()
[+] 	Buf()
[-] 	Buf (Buf&& src)
[+] 	Buf(Buf&& src)
[-] 		copy (std::move (src));
[+] 		copy(std::move(src));
[-] 	Buf (Ref&& src)
[+] 	Buf(Ref&& src)
[-] 		copy (std::move (src));
[+] 		copy(std::move(src));
[-] 	Buf (const Buf& src)
[+] 	Buf(const Buf& src)
[-] 		copy (src);
[+] 		copy(src);
[-] 	Buf (const Ref& src)
[+] 	Buf(const Ref& src)
[-] 		copy (src);
[+] 		copy(src);
[-] 	Buf (
[+] 	Buf(
[-] 		copy (src, size);
[+] 		copy(src, size);
[-] 	Buf (
[+] 	Buf(
[-] 		setBuffer (kind, p, size);
[+] 		setBuffer(kind, p, size);
[-] 		ASSERT (this->m_p);
[+] 		ASSERT(this->m_p);
[-] 		ASSERT (this->m_p);
[+] 		ASSERT(this->m_p);
[-] 		copy (std::move (src));
[+] 		copy(std::move(src));
[-] 		copy (std::move (src));
[+] 		copy(std::move(src));
[-] 		copy (src);
[+] 		copy(src);
[-] 		copy (src);
[+] 		copy(src);
[-] 		copy (p, -1);
[+] 		copy(p, -1);
[-] 	p ()
[+] 	p()
[-] 		return ensureExclusive () ? this->m_p : NULL;
[+] 		return ensureExclusive() ? this->m_p : NULL;
[-] 	clear ()
[+] 	clear()
[-] 			ASSERT (!this->m_size);
[+] 			ASSERT(!this->m_size);
[-] 		if (this->m_hdr->getRefCount () != 1)
[+] 		if (this->m_hdr->getRefCount() != 1)
[-] 			this->release ();
[+] 			this->release();
[-] 			this->m_p->~T ();
[+] 			this->m_p->~T();
[-] 		this->m_p = (T*) (this->m_hdr + 1);
[+] 		this->m_p = (T*)(this->m_hdr + 1);
[-] 	copy (Ref&& src)
[+] 	copy(Ref&& src)
[-] 		if (src.isEmpty ())
[+] 		if (src.isEmpty())
[-] 			clear ();
[+] 			clear();
[-] 			src.release ();
[+] 			src.release();
[-] 		BufHdr* hdr = src.getHdr ();
[+] 		BufHdr* hdr = src.getHdr();
[-] 		if (!hdr || (hdr->getFlags () & BufHdrFlag_Exclusive))
[+] 		if (!hdr || (hdr->getFlags() & BufHdrFlag_Exclusive))
[-] 			copy (src, src.getSize ());
[+] 			copy(src, src.getSize());
[-] 			src.release ();
[+] 			src.release();
[-] 		this->move (std::move (src));
[+] 		this->move(std::move(src));
[-] 	copy (const Ref& src)
[+] 	copy(const Ref& src)
[-] 		if (src.isEmpty ())
[+] 		if (src.isEmpty())
[-] 			clear ();
[+] 			clear();
[-] 		BufHdr* hdr = src.getHdr ();
[+] 		BufHdr* hdr = src.getHdr();
[-] 		if (!hdr || (hdr->getFlags () & BufHdrFlag_Exclusive))
[+] 		if (!hdr || (hdr->getFlags() & BufHdrFlag_Exclusive))
[-] 			return copy (src, src.getSize ());
[+] 			return copy(src, src.getSize());
[-] 		this->attach (src);
[+] 		this->attach(src);
[-] 	copy (
[+] 	copy(
[-] 			clear ();
[+] 			clear();
[-] 			size = SizeOf () (p);
[+] 			size = SizeOf() (p);
[-] 		if (size < sizeof (T))
[+] 		if (size < sizeof(T))
[-] 			size = sizeof (T);
[+] 			size = sizeof(T);
[-] 		if (this->m_hdr && this->m_hdr->isInsideBuffer (p))
[+] 		if (this->m_hdr && this->m_hdr->isInsideBuffer(p))
[-] 			T* end = (T*) this->m_hdr->getEnd ();
[+] 			T* end = (T*)this->m_hdr->getEnd();
[-] 			ASSERT (p + size <= end);
[+] 			ASSERT(p + size <= end);
[-] 			this->m_p = (T*) p;
[+] 			this->m_p = (T*)p;
[-] 		if (!createBuffer (size, false))
[+] 		if (!createBuffer(size, false))
[-] 		if (size > sizeof (T))
[+] 		if (size > sizeof(T))
[-] 			memcpy (this->m_p + 1, p + 1, size - sizeof (T));
[+] 			memcpy(this->m_p + 1, p + 1, size - sizeof(T));
[-] 	isExclusive ()
[+] 	isExclusive()
[-] 		return !this->m_size || this->m_hdr && this->m_hdr->getRefCount () == 1;
[+] 		return !this->m_size || this->m_hdr && this->m_hdr->getRefCount() == 1;
[-] 	ensureExclusive ()
[+] 	ensureExclusive()
[-] 		return this->m_size ? createBuffer (this->m_size, true) != NULL : true;
[+] 		return this->m_size ? createBuffer(this->m_size, true) != NULL : true;
[-] 	getBuffer (size_t* size = NULL)
[+] 	getBuffer(size_t* size = NULL)
[-] 		T* p = createBuffer (this->m_size, true);
[+] 		T* p = createBuffer(this->m_size, true);
[-] 			*size = this->m_hdr->getLeftoverBufferSize (this->m_p);
[+] 			*size = this->m_hdr->getLeftoverBufferSize(this->m_p);
[-] 	createBuffer (
[+] 	createBuffer(
[-] 		size_t size = sizeof (T),
[+] 		size_t size = sizeof(T),
[-] 		if (size < sizeof (T))
[+] 		if (size < sizeof(T))
[-] 			size = sizeof (T);
[+] 			size = sizeof(T);
[-] 			this->m_hdr->getRefCount () == 1)
[+] 			this->m_hdr->getRefCount() == 1)
[-] 				ASSERT (this->m_p == (T*) (this->m_hdr + 1));
[+] 				ASSERT(this->m_p == (T*)(this->m_hdr + 1));
[-] 				new (this->m_p) T;
[+] 				new(this->m_p) T;
[-] 				this->m_p = (T*) (this->m_hdr + 1);
[+] 				this->m_p = (T*)(this->m_hdr + 1);
[-] 			if (this->m_hdr->getLeftoverBufferSize (this->m_p) >= size)
[+] 			if (this->m_hdr->getLeftoverBufferSize(this->m_p) >= size)
[-] 		size_t bufferSize = sl::getAllocSize (size);
[+] 		size_t bufferSize = sl::getAllocSize(size);
[-] 		Ptr <Hdr> hdr = AXL_REF_NEW_EXTRA (Hdr, bufferSize);
[+] 		Ptr<Hdr> hdr = AXL_REF_NEW_EXTRA(Hdr, bufferSize);
[-] 		T* p = (T*) (hdr + 1);
[+] 		T* p = (T*)(hdr + 1);
[-] 			new (p) T (*this->m_p);
[+] 			new(p)T(*this->m_p);
[-] 			size_t copySize = AXL_MIN (size, this->m_size);
[+] 			size_t copySize = AXL_MIN(size, this->m_size);
[-] 			if (copySize > sizeof (T))
[+] 			if (copySize > sizeof(T))
[-] 				memcpy (p + 1, this->m_p + 1, copySize - sizeof (T));
[+] 				memcpy(p + 1, this->m_p + 1, copySize - sizeof(T));
[-] 			new (p) T;
[+] 			new(p)T;
[-] 			this->m_hdr->release ();
[+] 			this->m_hdr->release();
[-] 		this->m_hdr = hdr.detach ();
[+] 		this->m_hdr = hdr.detach();
[-] 	setBuffer (
[+] 	setBuffer(
[-] 		ASSERT (size >= MinBufSize);
[+] 		ASSERT(size >= MinBufSize);
[-] 		size_t bufferSize = size - sizeof (ref::BufHdr);
[+] 		size_t bufferSize = size - sizeof(ref::BufHdr);
[-] 		Ptr <Hdr> hdr = AXL_REF_NEW_INPLACE (Hdr, p, NULL, flags);
[+] 		Ptr<Hdr> hdr = AXL_REF_NEW_INPLACE(Hdr, p, NULL, flags);
[-] 			this->m_hdr->release ();
[+] 			this->m_hdr->release();
[-] 		this->m_p = (T*) (hdr + 1);
[+] 		this->m_p = (T*)(hdr + 1);
[-] 		this->m_hdr = hdr.detach ();
[+] 		this->m_hdr = hdr.detach();
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_ref\axl_ref_Child.h
----------------------
[-] 	AXL_DISABLE_COPY (Child)
[+] 	AXL_DISABLE_COPY(Child)
[-] 	char m_buffer [sizeof (T) + extra];
[+] 	char m_buffer[sizeof(T) + extra];
[-] 	Child (RefCount* parent)
[+] 	Child(RefCount* parent)
[-] 		memset (m_buffer, 0, sizeof (m_buffer));
[+] 		memset(m_buffer, 0, sizeof(m_buffer));
[-] 		T* p = AXL_REF_NEW_INPLACE (T, m_buffer, parent, 0);
[+] 		T* p = AXL_REF_NEW_INPLACE(T, m_buffer, parent, 0);
[-] 		p->addRef ();
[+] 		p->addRef();
[-] 	~Child ()
[+] 	~Child()
[-] 		p ()->release ();
[+] 		p()->release();
[-] 		return p ();
[+] 		return p();
[-] 		return p ();
[+] 		return p();
[-] 		return p ();
[+] 		return p();
[-] 	T* p ()
[+] 	T* p()
[-] 		return (T*) m_buffer;
[+] 		return (T*)m_buffer;
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_ref\axl_ref_New.h
----------------------
[-] postAllocateRefCount (
[+] postAllocateRefCount(
[-] 	RefCountAllocHdr* hdr = (RefCountAllocHdr*) p;
[+] 	RefCountAllocHdr* hdr = (RefCountAllocHdr*)p;
[-] primeAllocatedRefCount (T* p)
[+] primeAllocatedRefCount(T* p)
[-] 	p->prime (NULL, RefCountFlag_Allocated);
[+] 	p->prime(NULL, RefCountFlag_Allocated);
[-] primeInPlaceRefCount (
[+] primeInPlaceRefCount(
[-] 	ASSERT (p);
[+] 	ASSERT(p);
[-] 	p->prime (parent, flags);
[+] 	p->prime(parent, flags);
[-] 	(sizeof (axl::ref::RefCountAllocHdr) + sizeof (T))
[+] 	(sizeof(axl::ref::RefCountAllocHdr) + sizeof(T))
[-] 	axl::ref::postAllocateRefCount (AXL_MEM_ALLOCATE_EX (AXL_REF_ALLOC_SIZEOF(T), #T))
[+] 	axl::ref::postAllocateRefCount(AXL_MEM_ALLOCATE_EX(AXL_REF_ALLOC_SIZEOF(T), #T))
[-] 	axl::ref::postAllocateRefCount (AXL_MEM_ALLOCATE_EX (AXL_REF_ALLOC_SIZEOF(T) + extra, #T))
[+] 	axl::ref::postAllocateRefCount(AXL_MEM_ALLOCATE_EX(AXL_REF_ALLOC_SIZEOF(T) + extra, #T))
[-] 	axl::ref::postAllocateRefCount (AXL_MEM_ALLOCATE (AXL_REF_ALLOC_SIZEOF(T)))
[+] 	axl::ref::postAllocateRefCount(AXL_MEM_ALLOCATE(AXL_REF_ALLOC_SIZEOF(T)))
[-] 	axl::ref::postAllocateRefCount (AXL_MEM_ALLOCATE (AXL_REF_ALLOC_SIZEOF(T) + extra))
[+] 	axl::ref::postAllocateRefCount(AXL_MEM_ALLOCATE(AXL_REF_ALLOC_SIZEOF(T) + extra))
[-] 	(axl::ref::primeAllocatedRefCount (new (AXL_REF_ALLOCATE (T)) T))
[+] 	(axl::ref::primeAllocatedRefCount(new(AXL_REF_ALLOCATE(T)) T))
[-] 	(axl::ref::primeAllocatedRefCount (new (AXL_REF_ALLOCATE_EXTRA (T, extra)) T))
[+] 	(axl::ref::primeAllocatedRefCount(new(AXL_REF_ALLOCATE_EXTRA(T, extra)) T))
[-] 	(axl::ref::primeInPlaceRefCount (new (p) T, parent, flags))
[+] 	(axl::ref::primeInPlaceRefCount(new(p)T, parent, flags))
[-] 	(axl::ref::primeAllocatedRefCount (new (AXL_REF_ALLOCATE (T)) T args))
[+] 	(axl::ref::primeAllocatedRefCount(new(AXL_REF_ALLOCATE(T)) T args))
[-] 	(axl::ref::primeAllocatedRefCount (new (AXL_REF_ALLOCATE_EXTRA (T, extra)) T args))
[+] 	(axl::ref::primeAllocatedRefCount(new(AXL_REF_ALLOCATE_EXTRA(T, extra)) T args))
[-] 	(axl::ref::primeInPlaceRefCount (new (p) T args, parent, flags))
[+] 	(axl::ref::primeInPlaceRefCount(new(p)T args, parent, flags))
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_ref\axl_ref_Ptr.h
----------------------
[-] 	Ptr ()
[+] 	Ptr()
[-] 	Ptr (const NullPtr&)
[+] 	Ptr(const NullPtr&)
[-] 	Ptr (const Ptr& src)
[+] 	Ptr(const Ptr& src)
[-] 		copy (src.m_p, src.m_refCount);
[+] 		copy(src.m_p, src.m_refCount);
[-] 	Ptr (const Ptr <A>& src)
[+] 	Ptr(const Ptr<A>& src)
[-] 		copy (src.m_p, src.m_refCount);
[+] 		copy(src.m_p, src.m_refCount);
[-] 	Ptr (const WeakPtr <A>& src)
[+] 	Ptr(const WeakPtr<A>& src)
[-] 		if (src.m_refCount && src.m_refCount->addRefByWeakPtr ())
[+] 		if (src.m_refCount && src.m_refCount->addRefByWeakPtr())
[-] 			attach (src.m_p, src.m_refCount);
[+] 			attach(src.m_p, src.m_refCount);
[-] 	Ptr (A* p)
[+] 	Ptr(A* p)
[-] 		copy (p, p);
[+] 		copy(p, p);
[-] 	Ptr (
[+] 	Ptr(
[-] 		copy (p, refCount);
[+] 		copy(p, refCount);
[-] 	~Ptr ()
[+] 	~Ptr()
[-] 		clear ();
[+] 		clear();
[-] 		ASSERT (m_p);
[+] 		ASSERT(m_p);
[-] 		clear ();
[+] 		clear();
[-] 		copy (src.m_p, src.m_refCount);
[+] 		copy(src.m_p, src.m_refCount);
[-] 	p () const
[+] 	p() const
[-] 	getRefCount () const
[+] 	getRefCount() const
[-] 	copy (
[+] 	copy(
[-] 			refCount->addRef ();
[+] 			refCount->addRef();
[-] 			m_refCount->release ();
[+] 			m_refCount->release();
[-] 	attach (
[+] 	attach(
[-] 			m_refCount->release ();
[+] 			m_refCount->release();
[-] 	detach (RefCount** refCount = NULL)
[+] 	detach(RefCount** refCount = NULL)
[-] 	clear ()
[+] 	clear()
[-] 			m_refCount->release ();
[+] 			m_refCount->release();
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_ref\axl_ref_RefCount.h
----------------------
[-] FreeFunc (void* p);
[+] FreeFunc(void* p);
[-] 	AXL_DISABLE_COPY (RefCount)
[+] 	AXL_DISABLE_COPY(RefCount)
[-] 	RefCount ();
[+] 	RefCount();
[-] 	~RefCount ()
[+] 	~RefCount()
[-] 		ASSERT (m_refCount == 0 && m_weakRefCount > 0);
[+] 		ASSERT(m_refCount == 0 && m_weakRefCount > 0);
[-] 	prime (
[+] 	prime(
[-] 	getRefCount ()
[+] 	getRefCount()
[-] 	getWeakRefCount ()
[+] 	getWeakRefCount()
[-] 	getFlags ()
[+] 	getFlags()
[-] 	addRef ()
[+] 	addRef()
[-] 		return sys::atomicInc (&m_refCount);
[+] 		return sys::atomicInc(&m_refCount);
[-] 	release ();
[+] 	release();
[-] 	addWeakRef ()
[+] 	addWeakRef()
[-] 		return sys::atomicInc (&m_weakRefCount);
[+] 		return sys::atomicInc(&m_weakRefCount);
[-] 	weakRelease ();
[+] 	weakRelease();
[-] 	addRefByWeakPtr ();
[+] 	addRefByWeakPtr();
[-] RefCount::RefCount ()
[+] RefCount::RefCount()
[-] RefCount::prime (
[+] RefCount::prime(
[-] 	ASSERT (m_refCount == 0); // should only be called once in the very beginning
[+] 	ASSERT(m_refCount == 0); // should only be called once in the very beginning
[-] 		ASSERT (parent < this);
[+] 		ASSERT(parent < this);
[-] 		m_parentOffset = (uint_t) ((char*) this - (char*) parent);
[+] 		m_parentOffset = (uint_t)((char*)this - (char*)parent);
[-] 		parent->addWeakRef ();
[+] 		parent->addWeakRef();
[-] RefCount::release ()
[+] RefCount::release()
[-] 	intptr_t refCount = sys::atomicDec (&m_refCount);
[+] 	intptr_t refCount = sys::atomicDec(&m_refCount);
[-] 		this->~RefCount ();
[+] 		this->~RefCount();
[-] 		weakRelease (); // weakRelease () should be here, not in ~RefCount ()
[+] 		weakRelease(); // weakRelease () should be here, not in ~RefCount ()
[-] RefCount::weakRelease ()
[+] RefCount::weakRelease()
[-] 	intptr_t refCount = sys::atomicDec (&m_weakRefCount);
[+] 	intptr_t refCount = sys::atomicDec(&m_weakRefCount);
[-] 			RefCountAllocHdr* hdr = (RefCountAllocHdr*) this - 1;
[+] 			RefCountAllocHdr* hdr = (RefCountAllocHdr*)this - 1;
[-] 			hdr->m_freeFunc (hdr);
[+] 			hdr->m_freeFunc(hdr);
[-] 			RefCount* parent = (RefCount*) ((char*) this - m_parentOffset);
[+] 			RefCount* parent = (RefCount*)((char*)this - m_parentOffset);
[-] 			parent->weakRelease ();
[+] 			parent->weakRelease();
[-] RefCount::addRefByWeakPtr ()
[+] RefCount::addRefByWeakPtr()
[-] 		if (sys::atomicCmpXchg (&m_refCount, old, old + 1) == old)
[+] 		if (sys::atomicCmpXchg(&m_refCount, old, old + 1) == old)
[-] 		p->release ();
[+] 		p->release();
[-] 		p->weakRelease ();
[+] 		p->weakRelease();
----------------------
27/02/2019 18:01:42 - C:\Projects\repos\ioninja\axl\include\axl_ref\axl_ref_RtFactory.h
----------------------
[-] 		public obj::ITypeSimpleImplT <Box>
[+] 		public obj::ITypeSimpleImplT<Box>
[-] 		Box ()
[+] 		Box()
[-] 		~Box ()
[+] 		~Box()
[-] 			ASSERT (m_type);
[+] 			ASSERT(m_type);
[-] 			m_type->destruct (this + 1);
[+] 			m_type->destruct(this + 1);
[-] 		setType (obj::IType* type)
[+] 		setType(obj::IType* type)
[-] 			m_guid = type->getGuid ();
[+] 			m_guid = type->getGuid();
[-] 		getObject (obj::IType** type_o)
[+] 		getObject(obj::IType** type_o)
[-] 		getInterfaceOffset (const sl::Guid& guid)
[+] 		getInterfaceOffset(const sl::Guid& guid)
[-] 			ASSERT (m_type);
[+] 			ASSERT(m_type);
[-] 			if (guid == AXL_OBJ_GUIDOF (RefCount))
[+] 			if (guid == AXL_OBJ_GUIDOF(RefCount))
[-] 			size_t offset = m_type->getInterfaceOffset (guid);
[+] 			size_t offset = m_type->getInterfaceOffset(guid);
[-] 			return offset != -1 ? offset + sizeof (Box) : -1;
[+] 			return offset != -1 ? offset + sizeof(Box) : -1;
[-] 		Ptr <void>
[+] 		Ptr<void>
[-] 			size_t size = type->getSize () + extra;
[+] 			size_t size = type->getSize() + extra;
[-] 			size_t refCountOffset = type->getInterfaceOffset (AXL_OBJ_GUIDOF (RefCount));
[+] 			size_t refCountOffset = type->getInterfaceOffset(AXL_OBJ_GUIDOF(RefCount));
[-] 				void* p = Alloc::alloc (size, type->getName (), filePath, line);
[+] 				void* p = Alloc::alloc(size, type->getName(), filePath, line);
[-] 				type->construct (p);
[+] 				type->construct(p);
[-] 				RefCount* refCount = (RefCount*) ((uchar_t*) p + refCountOffset);
[+] 				RefCount* refCount = (RefCount*)((uchar_t*)p + refCountOffset);
[-] 				refCount->setFree (&Alloc::free);
[+] 				refCount->setFree(&Alloc::free);
[-] 				return Ptr <void> (p, refCount);
[+] 				return Ptr<void> (p, refCount);
[-] 				Ptr <Box> box = mem::StdFactory <Box, Alloc>::operatorNew (filePath, line, size);
[+] 				Ptr<Box> box = mem::StdFactory<Box, Alloc>::operatorNew(filePath, line, size);
[-] 				type->construct (box + 1);
[+] 				type->construct(box + 1);
[-] 				box->setType (type);
[+] 				box->setType(type);
[-] 				box->setFree (&Alloc::free);
[+] 				box->setFree(&Alloc::free);
[-] 				return Ptr <void> (box + 1, box.getRefCount ());
[+] 				return Ptr<void> (box + 1, box.getRefCount());
[-] 		Ptr <void>
[+] 		Ptr<void>
[-] 			size_t size = type->getSize () + extra;
[+] 			size_t size = type->getSize() + extra;
[-] 			size_t refCountOffset = type->getInterfaceOffset (AXL_OBJ_GUIDOF (RefCount));
[+] 			size_t refCountOffset = type->getInterfaceOffset(AXL_OBJ_GUIDOF(RefCount));
[-] 				void* p = Alloc::alloc (size);
[+] 				void* p = Alloc::alloc(size);
[-] 				type->construct (p);
[+] 				type->construct(p);
[-] 				RefCount* refCount = (RefCount*) ((uchar_t*) p + refCountOffset);
[+] 				RefCount* refCount = (RefCount*)((uchar_t*)p + refCountOffset);
[-] 				refCount->setFree (&Alloc::free);
[+] 				refCount->setFree(&Alloc::free);
[-] 				return Ptr <void> (p, refCount);
[+] 				return Ptr<void> (p, refCount);
[-] 				Ptr <Box> box = mem::StdFactory <Box, Alloc>::operatorNew (size);
[+] 				Ptr<Box> box = mem::StdFactory<Box, Alloc>::operatorNew(size);
[-] 				box->setClass (type);
[+] 				box->setClass(type);
[-] 				box->setFree (&Alloc::free);
[+] 				box->setFree(&Alloc::free);
[-] 				return Ptr <void> (box + 1, box.getRefCount ());
[+] 				return Ptr<void> (box + 1, box.getRefCount());
[-] 	Ptr <void>
[+] 	Ptr<void>
[-] 	operatorNew (
[+] 	operatorNew(
[-] 		return New () (type, filePath, line, extra);
[+] 		return New() (type, filePath, line, extra);
[-] 	Ptr <void>
[+] 	Ptr<void>
[-] 	operatorNew (
[+] 	operatorNew(
[-] 		return New () (type, extra);
[+] 		return New() (type, extra);
[-] typedef RtFactory <mem::StdAllocator> RtFactory;
[+] typedef RtFactory<mem::StdAllocator> RtFactory;
[-] 	ref::RtFactory::operatorNew (Type, __FILE__, __LINE__)
[+] 	ref::RtFactory::operatorNew(Type, __FILE__, __LINE__)
[-] 	ref::RtFactory::operatorNew (Type, __FILE__, __LINE__, extra)
[+] 	ref::RtFactory::operatorNew(Type, __FILE__, __LINE__, extra)
[-] 	ref::RtFactory::operatorNew (Type)
[+] 	ref::RtFactory::operatorNew(Type)
[-] 	ref::RtFactory::operatorNew (Type, extra)
[+] 	ref::RtFactory::operatorNew(Type, extra)
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_ref\axl_ref_WeakPtr.h
----------------------
[-] 	WeakPtr ()
[+] 	WeakPtr()
[-] 	WeakPtr (const NullPtr&)
[+] 	WeakPtr(const NullPtr&)
[-] 	WeakPtr (const WeakPtr& src)
[+] 	WeakPtr(const WeakPtr& src)
[-] 		copy (src.m_p, src.m_refCount);
[+] 		copy(src.m_p, src.m_refCount);
[-] 	WeakPtr (const WeakPtr <T2>& src)
[+] 	WeakPtr(const WeakPtr<T2>& src)
[-] 		copy (src.m_p, src.m_refCount);
[+] 		copy(src.m_p, src.m_refCount);
[-] 	WeakPtr (const Ptr <T2>& src)
[+] 	WeakPtr(const Ptr<T2>& src)
[-] 		copy (src.m_p, src.m_refCount);
[+] 		copy(src.m_p, src.m_refCount);
[-] 	WeakPtr (T2* p)
[+] 	WeakPtr(T2* p)
[-] 		copy (p, p);
[+] 		copy(p, p);
[-] 	WeakPtr (
[+] 	WeakPtr(
[-] 		copy (p, refCount);
[+] 		copy(p, refCount);
[-] 	~WeakPtr ()
[+] 	~WeakPtr()
[-] 		clear ();
[+] 		clear();
[-] 		clear ();
[+] 		clear();
[-] 		copy (src.m_p, src.m_refCount);
[+] 		copy(src.m_p, src.m_refCount);
[-] 	copy (
[+] 	copy(
[-] 			refCount->addWeakRef ();
[+] 			refCount->addWeakRef();
[-] 			m_refCount->weakRelease ();
[+] 			m_refCount->weakRelease();
[-] 	attach (
[+] 	attach(
[-] 			m_refCount->weakRelease ();
[+] 			m_refCount->weakRelease();
[-] 	detach (
[+] 	detach(
[-] 	clear ()
[+] 	clear()
[-] 			m_refCount->weakRelease ();
[+] 			m_refCount->weakRelease();
[-] 	getRefCount () const
[+] 	getRefCount() const
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_ArgType.h
----------------------
[-] class ArgType <char>: public SimpleArgType <char>
[+] class ArgType<char>: public SimpleArgType<char>
[-] class ArgType <wchar_t>: public SimpleArgType <wchar_t>
[+] class ArgType<wchar_t>: public SimpleArgType<wchar_t>
[-] class ArgType <float>: public SimpleArgType <float>
[+] class ArgType<float>: public SimpleArgType<float>
[-] class ArgType <double>: public SimpleArgType <double>
[+] class ArgType<double>: public SimpleArgType<double>
[-] class ArgType <int8_t>: public SimpleArgType <int8_t>
[+] class ArgType<int8_t>: public SimpleArgType<int8_t>
[-] class ArgType <uint8_t>: public SimpleArgType <uint8_t>
[+] class ArgType<uint8_t>: public SimpleArgType<uint8_t>
[-] class ArgType <int16_t>: public SimpleArgType <int16_t>
[+] class ArgType<int16_t>: public SimpleArgType<int16_t>
[-] class ArgType <uint16_t>: public SimpleArgType <uint16_t>
[+] class ArgType<uint16_t>: public SimpleArgType<uint16_t>
[-] class ArgType <int32_t>: public SimpleArgType <int32_t>
[+] class ArgType<int32_t>: public SimpleArgType<int32_t>
[-] class ArgType <uint32_t>: public SimpleArgType <uint32_t>
[+] class ArgType<uint32_t>: public SimpleArgType<uint32_t>
[-] class ArgType <int64_t>: public SimpleArgType <int64_t>
[+] class ArgType<int64_t>: public SimpleArgType<int64_t>
[-] class ArgType <uint64_t>: public SimpleArgType <uint64_t>
[+] class ArgType<uint64_t>: public SimpleArgType<uint64_t>
[-] class ArgType <T*>: public SimpleArgType <T*>
[+] class ArgType<T*>: public SimpleArgType<T*>
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_Array.h
----------------------
[-] 	typename Details0 = ArrayDetails <T>
[+] 	typename Details0 = ArrayDetails<T>
[-] 	ArrayRef ()
[+] 	ArrayRef()
[-] 		initialize ();
[+] 		initialize();
[-] 	ArrayRef (ArrayRef&& src)
[+] 	ArrayRef(ArrayRef&& src)
[-] 		initialize ();
[+] 		initialize();
[-] 		move (std::move (src));
[+] 		move(std::move(src));
[-] 	ArrayRef (const ArrayRef& src)
[+] 	ArrayRef(const ArrayRef& src)
[-] 		initialize ();
[+] 		initialize();
[-] 		attach (src);
[+] 		attach(src);
[-] 	ArrayRef (
[+] 	ArrayRef(
[-] 		initialize ();
[+] 		initialize();
[-] 		attach (NULL, p, count);
[+] 		attach(NULL, p, count);
[-] 	ArrayRef (
[+] 	ArrayRef(
[-] 		initialize ();
[+] 		initialize();
[-] 		attach (NULL, p, (T*) end - p);
[+] 		attach(NULL, p, (T*)end - p);
[-] 	ArrayRef (
[+] 	ArrayRef(
[-] 		initialize ();
[+] 		initialize();
[-] 		attach (hdr, p, count);
[+] 		attach(hdr, p, count);
[-] 	ArrayRef (
[+] 	ArrayRef(
[-] 		initialize ();
[+] 		initialize();
[-] 		attach (hdr, p, (T*) end - p);
[+] 		attach(hdr, p, (T*)end - p);
[-] 	~ArrayRef ()
[+] 	~ArrayRef()
[-] 		release ();
[+] 		release();
[-] 		move (std::move (src));
[+] 		move(std::move(src));
[-] 		attach (src);
[+] 		attach(src);
[-] 		ASSERT ((size_t) i < m_count);
[+] 		ASSERT((size_t)i < m_count);
[-] 		return m_p [i];
[+] 		return m_p[i];
[-] 	cp () const
[+] 	cp() const
[-] 	getCount () const
[+] 	getCount() const
[-] 	getHdr () const
[+] 	getHdr() const
[-] 	isEmpty () const
[+] 	isEmpty() const
[-] 	getBegin () const
[+] 	getBegin() const
[-] 	getEnd () const
[+] 	getEnd() const
[-] 	getFront () const
[+] 	getFront() const
[-] 		ASSERT (m_count);
[+] 		ASSERT(m_count);
[-] 		return m_p [0];
[+] 		return m_p[0];
[-] 	getBack () const
[+] 	getBack() const
[-] 		ASSERT (m_count);
[+] 		ASSERT(m_count);
[-] 		return m_p [m_count - 1];
[+] 		return m_p[m_count - 1];
[-] 	find (ValueArg e) const
[+] 	find(ValueArg e) const
[-] 			if (m_p [i] == e)
[+] 			if (m_p[i] == e)
[-] 	findReverse (ValueArg e) const
[+] 	findReverse(ValueArg e) const
[-] 			if (m_p [i] == e)
[+] 			if (m_p[i] == e)
[-] 	release ()
[+] 	release()
[-] 			m_hdr->release ();
[+] 			m_hdr->release();
[-] 		initialize ();
[+] 		initialize();
[-] 	initialize ()
[+] 	initialize()
[-] 	move (ArrayRef&& src)
[+] 	move(ArrayRef&& src)
[-] 			m_hdr->release ();
[+] 			m_hdr->release();
[-] 		src.initialize ();
[+] 		src.initialize();
[-] 	attach (const ArrayRef& src)
[+] 	attach(const ArrayRef& src)
[-] 			attach (src.m_hdr, src.m_p, src.m_count);
[+] 			attach(src.m_hdr, src.m_p, src.m_count);
[-] 	attach (
[+] 	attach(
[-] 				hdr->addRef ();
[+] 				hdr->addRef();
[-] 				m_hdr->release ();
[+] 				m_hdr->release();
[-] 	typename Details0 = ArrayDetails <T>
[+] 	typename Details0 = ArrayDetails<T>
[-] class Array: public ArrayRef <T, Details0>
[+] class Array: public ArrayRef<T, Details0>
[-] 	typedef sl::ArrayRef <T, Details0> ArrayRef;
[+] 	typedef sl::ArrayRef<T, Details0> ArrayRef;
[-] 	Array ()
[+] 	Array()
[-] 	Array (Array&& src)
[+] 	Array(Array&& src)
[-] 		copy (std::move (src));
[+] 		copy(std::move(src));
[-] 	Array (ArrayRef&& src)
[+] 	Array(ArrayRef&& src)
[-] 		copy (std::move (src));
[+] 		copy(std::move(src));
[-] 	Array (const Array& src)
[+] 	Array(const Array& src)
[-] 		copy (src);
[+] 		copy(src);
[-] 	Array (const ArrayRef& src)
[+] 	Array(const ArrayRef& src)
[-] 		copy (src);
[+] 		copy(src);
[-] 	explicit Array (size_t count)
[+] 	explicit Array(size_t count)
[-] 		setCount (count);
[+] 		setCount(count);
[-] 	Array (
[+] 	Array(
[-] 		copy (p, count);
[+] 		copy(p, count);
[-] 	Array (
[+] 	Array(
[-] 		copy (p, (T*) end - p);
[+] 		copy(p, (T*)end - p);
[-] 	Array (
[+] 	Array(
[-] 		setBuffer (bufKind, p, size);
[+] 		setBuffer(bufKind, p, size);
[-] 		copy (std::move (src));
[+] 		copy(std::move(src));
[-] 		copy (std::move (src));
[+] 		copy(std::move(src));
[-] 		copy (src);
[+] 		copy(src);
[-] 		copy (src);
[+] 		copy(src);
[-] 	p ()
[+] 	p()
[-] 		return ensureExclusive () ? this->m_p : NULL;
[+] 		return ensureExclusive() ? this->m_p : NULL;
[-] 	getBegin () const
[+] 	getBegin() const
[-] 		return this->cp ();
[+] 		return this->cp();
[-] 	getBegin ()
[+] 	getBegin()
[-] 		return p ();
[+] 		return p();
[-] 	getEnd () const
[+] 	getEnd() const
[-] 		return ArrayRef::getEnd ();
[+] 		return ArrayRef::getEnd();
[-] 	getEnd ()
[+] 	getEnd()
[-] 		return (T*) ArrayRef::getEnd ();
[+] 		return (T*)ArrayRef::getEnd();
[-] 	getFront () const
[+] 	getFront() const
[-] 		return ArrayRef::getFront ();
[+] 		return ArrayRef::getFront();
[-] 	getFront ()
[+] 	getFront()
[-] 		return (T&) ArrayRef::getFront ();
[+] 		return (T&) ArrayRef::getFront();
[-] 	getBack () const
[+] 	getBack() const
[-] 		return ArrayRef::getBack ();
[+] 		return ArrayRef::getBack();
[-] 	getBack ()
[+] 	getBack()
[-] 		return (T&) ArrayRef::getBack ();
[+] 		return (T&) ArrayRef::getBack();
[-] 	clear ()
[+] 	clear()
[-] 		setCount (0);
[+] 		setCount(0);
[-] 	zeroConstruct (
[+] 	zeroConstruct(
[-] 		Details::destruct (p, count);
[+] 		Details::destruct(p, count);
[-] 		ZeroConstruct () (p, count);
[+] 		ZeroConstruct() (p, count);
[-] 	zeroConstruct ()
[+] 	zeroConstruct()
[-] 		Details::destruct (this->m_p, this->m_count);
[+] 		Details::destruct(this->m_p, this->m_count);
[-] 		ZeroConstruct () (this->m_p, this->m_count);
[+] 		ZeroConstruct() (this->m_p, this->m_count);
[-] 	copy (ArrayRef&& src)
[+] 	copy(ArrayRef&& src)
[-] 		if (src.isEmpty ())
[+] 		if (src.isEmpty())
[-] 			clear ();
[+] 			clear();
[-] 			src.release ();
[+] 			src.release();
[-] 		Hdr* hdr = src.getHdr ();
[+] 		Hdr* hdr = src.getHdr();
[-] 		if (!hdr || (hdr->getFlags () & ref::BufHdrFlag_Exclusive))
[+] 		if (!hdr || (hdr->getFlags() & ref::BufHdrFlag_Exclusive))
[-] 			copy (src, src.getCount ());
[+] 			copy(src, src.getCount());
[-] 			src.release ();
[+] 			src.release();
[-] 		this->move (std::move (src));
[+] 		this->move(std::move(src));
[-] 	copy (const ArrayRef& src)
[+] 	copy(const ArrayRef& src)
[-] 		if (src.isEmpty ())
[+] 		if (src.isEmpty())
[-] 			clear ();
[+] 			clear();
[-] 		Hdr* hdr = src.getHdr ();
[+] 		Hdr* hdr = src.getHdr();
[-] 		if (!hdr || (hdr->getFlags () & ref::BufHdrFlag_Exclusive))
[+] 		if (!hdr || (hdr->getFlags() & ref::BufHdrFlag_Exclusive))
[-] 			return copy (src, src.getCount ());
[+] 			return copy(src, src.getCount());
[-] 		this->attach (src);
[+] 		this->attach(src);
[-] 	copyReverse (const ArrayRef& src)
[+] 	copyReverse(const ArrayRef& src)
[-] 		return copyReverse (src, src.m_count);
[+] 		return copyReverse(src, src.m_count);
[-] 	copy (
[+] 	copy(
[-] 			clear ();
[+] 			clear();
[-] 		ref::Ptr <void> shadow;
[+] 		ref::Ptr<void> shadow;
[-] 		if (this->m_hdr && this->m_hdr->isInsideBuffer (p))
[+] 		if (this->m_hdr && this->m_hdr->isInsideBuffer(p))
[-] 				T* end = (T*) this->m_hdr->getEnd ();
[+] 				T* end = (T*)this->m_hdr->getEnd();
[-] 				ASSERT (p + count <= end);
[+] 				ASSERT(p + count <= end);
[-] 				this->m_p = (T*) p;
[+] 				this->m_p = (T*)p;
[-] 		bool result = setCount (count);
[+] 		bool result = setCount(count);
[-] 		Details::copy (this->m_p, p, count);
[+] 		Details::copy(this->m_p, p, count);
[-] 	copyReverse (
[+] 	copyReverse(
[-] 			clear ();
[+] 			clear();
[-] 		ref::Ptr <void> shadow;
[+] 		ref::Ptr<void> shadow;
[-] 		if (this->m_hdr && this->m_hdr->isInsideBuffer (p))
[+] 		if (this->m_hdr && this->m_hdr->isInsideBuffer(p))
[-] 		bool result = setCount (count);
[+] 		bool result = setCount(count);
[-] 		Details::copyReverse (this->m_p, p, count);
[+] 		Details::copyReverse(this->m_p, p, count);
[-] 	copy (ValueArg e)
[+] 	copy(ValueArg e)
[-] 		return copy (&e, 1);
[+] 		return copy(&e, 1);
[-] 	appendEmptySpace (size_t count)
[+] 	appendEmptySpace(size_t count)
[-] 		return insertEmptySpace (-1, count);
[+] 		return insertEmptySpace(-1, count);
[-] 	appendZeroConstruct (size_t count)
[+] 	appendZeroConstruct(size_t count)
[-] 		return insertZeroConstruct (-1, count);
[+] 		return insertZeroConstruct(-1, count);
[-] 	append (
[+] 	append(
[-] 		return insert (-1, p, count);
[+] 		return insert(-1, p, count);
[-] 	appendReverse (
[+] 	appendReverse(
[-] 		return insertReverse (-1, p, count);
[+] 		return insertReverse(-1, p, count);
[-] 	append (ValueArg e)
[+] 	append(ValueArg e)
[-] 		return insert (-1, e);
[+] 		return insert(-1, e);
[-] 	appendMultiply (
[+] 	appendMultiply(
[-] 		return insertMultiply (-1, e, count);
[+] 		return insertMultiply(-1, e, count);
[-] 	append (const ArrayRef& src)
[+] 	append(const ArrayRef& src)
[-] 		return insert (-1, src, src.getCount ());
[+] 		return insert(-1, src, src.getCount());
[-] 	appendReverse (const ArrayRef& src)
[+] 	appendReverse(const ArrayRef& src)
[-] 		return insertReverse (-1, src, src.getCount ());
[+] 		return insertReverse(-1, src, src.getCount());
[-] 	insertEmptySpace (
[+] 	insertEmptySpace(
[-] 		T* dst = insertSpace (index, count);
[+] 		T* dst = insertSpace(index, count);
[-] 	insertZeroConstruct (
[+] 	insertZeroConstruct(
[-] 		T* dst = insertSpace (index, count);
[+] 		T* dst = insertSpace(index, count);
[-] 		Details::destruct (dst, count);
[+] 		Details::destruct(dst, count);
[-] 		ZeroConstruct () (dst, count);
[+] 		ZeroConstruct() (dst, count);
[-] 	insert (
[+] 	insert(
[-] 		ref::Ptr <void> shadow;
[+] 		ref::Ptr<void> shadow;
[-] 		if (this->m_hdr && this->m_hdr->isInsideBuffer (p))
[+] 		if (this->m_hdr && this->m_hdr->isInsideBuffer(p))
[-] 		T* dst = insertSpace (index, count);
[+] 		T* dst = insertSpace(index, count);
[-] 			Details::copy (dst, p, count);
[+] 			Details::copy(dst, p, count);
[-] 	insertReverse (
[+] 	insertReverse(
[-] 		ref::Ptr <void> shadow;
[+] 		ref::Ptr<void> shadow;
[-] 		if (this->m_hdr && this->m_hdr->isInsideBuffer (p))
[+] 		if (this->m_hdr && this->m_hdr->isInsideBuffer(p))
[-] 		T* dst = insertSpace (index, count);
[+] 		T* dst = insertSpace(index, count);
[-] 			Details::copyReverse (dst, p, count);
[+] 			Details::copyReverse(dst, p, count);
[-] 	insert (
[+] 	insert(
[-] 		T* dst = insertSpace (index, 1);
[+] 		T* dst = insertSpace(index, 1);
[-] 	insertMultiply (
[+] 	insertMultiply(
[-] 		T* dst = insertSpace (index, count);
[+] 		T* dst = insertSpace(index, count);
[-] 	insert (
[+] 	insert(
[-] 		return insert (index, src, src.getCount ());
[+] 		return insert(index, src, src.getCount());
[-] 	insertReverse (
[+] 	insertReverse(
[-] 		return insertReverse (index, src, src.getCount ());
[+] 		return insertReverse(index, src, src.getCount());
[-] 	remove (
[+] 	remove(
[-] 			return setCount (index);
[+] 			return setCount(index);
[-] 		bool result = ensureExclusive ();
[+] 		bool result = ensureExclusive();
[-] 		Details::copy (dst, dst + count, newCount - index);
[+] 		Details::copy(dst, dst + count, newCount - index);
[-] 		result = setCount (newCount);
[+] 		result = setCount(newCount);
[-] 	pop (size_t count = 1)
[+] 	pop(size_t count = 1)
[-] 		bool result = setCount (newCount);
[+] 		bool result = setCount(newCount);
[-] 	getBackAndPop ()
[+] 	getBackAndPop()
[-] 		T e = this->getBack ();
[+] 		T e = this->getBack();
[-] 		pop ();
[+] 		pop();
[-] 	reverse (
[+] 	reverse(
[-] 		Details::reverse (this->m_p + index, count);
[+] 		Details::reverse(this->m_p + index, count);
[-] 	reverse ()
[+] 	reverse()
[-] 		reverse (0, -1);
[+] 		reverse(0, -1);
[-] 	reverseFrom (size_t index)
[+] 	reverseFrom(size_t index)
[-] 		reverse (index, -1);
[+] 		reverse(index, -1);
[-] 	reverseUntil (size_t index)
[+] 	reverseUntil(size_t index)
[-] 		reverse (0, index);
[+] 		reverse(0, index);
[-] 	isExclusive ()
[+] 	isExclusive()
[-] 		return !this->m_count || this->m_hdr && this->m_hdr->getRefCount () == 1;
[+] 		return !this->m_count || this->m_hdr && this->m_hdr->getRefCount() == 1;
[-] 	ensureExclusive ()
[+] 	ensureExclusive()
[-] 		return this->m_count ? setCount (this->m_count) : true;
[+] 		return this->m_count ? setCount(this->m_count) : true;
[-] 	reserve (size_t count)
[+] 	reserve(size_t count)
[-] 		size_t size = count * sizeof (T);
[+] 		size_t size = count * sizeof(T);
[-] 			this->m_hdr->getRefCount () == 1 &&
[+] 			this->m_hdr->getRefCount() == 1 &&
[-] 		size_t bufferSize = getAllocSize (size);
[+] 		size_t bufferSize = getAllocSize(size);
[-] 		ref::Ptr <Hdr> hdr = AXL_REF_NEW_EXTRA (Hdr, bufferSize);
[+] 		ref::Ptr<Hdr> hdr = AXL_REF_NEW_EXTRA(Hdr, bufferSize);
[-] 		Details::setHdrCount (hdr, this->m_count);
[+] 		Details::setHdrCount(hdr, this->m_count);
[-] 		T* p = (T*) (hdr + 1);
[+] 		T* p = (T*)(hdr + 1);
[-] 			Details::constructCopy (p, this->m_p, this->m_count);
[+] 			Details::constructCopy(p, this->m_p, this->m_count);
[-] 			this->m_hdr->release ();
[+] 			this->m_hdr->release();
[-] 		this->m_hdr = hdr.detach ();
[+] 		this->m_hdr = hdr.detach();
[-] 	setCount (size_t count)
[+] 	setCount(size_t count)
[-] 		return setCountImpl <Construct> (count);
[+] 		return setCountImpl<Construct> (count);
[-] 	setCountZeroConstruct (size_t count)
[+] 	setCountZeroConstruct(size_t count)
[-] 		return setCountImpl <ZeroConstruct> (count);
[+] 		return setCountImpl<ZeroConstruct> (count);
[-] 	ensureCount (size_t count)
[+] 	ensureCount(size_t count)
[-] 			setCount (count);
[+] 			setCount(count);
[-] 	ensureCountZeroConstruct (size_t count)
[+] 	ensureCountZeroConstruct(size_t count)
[-] 			setCountZeroConstruct (count);
[+] 			setCountZeroConstruct(count);
[-] 	setBuffer (
[+] 	setBuffer(
[-] 		ASSERT (size >= sizeof (Hdr) + sizeof (T));
[+] 		ASSERT(size >= sizeof(Hdr) + sizeof(T));
[-] 		size_t bufferSize = size - sizeof (Hdr);
[+] 		size_t bufferSize = size - sizeof(Hdr);
[-] 		ref::Ptr <Hdr> hdr = AXL_REF_NEW_INPLACE (Hdr, p, NULL, flags);
[+] 		ref::Ptr<Hdr> hdr = AXL_REF_NEW_INPLACE(Hdr, p, NULL, flags);
[-] 		Details::setHdrCount (hdr, 0);
[+] 		Details::setHdrCount(hdr, 0);
[-] 			this->m_hdr->release ();
[+] 			this->m_hdr->release();
[-] 		this->m_p = (T*) (hdr + 1);
[+] 		this->m_p = (T*)(hdr + 1);
[-] 		this->m_hdr = hdr.detach ();
[+] 		this->m_hdr = hdr.detach();
[-] 		return bufferSize / sizeof (T);
[+] 		return bufferSize / sizeof(T);
[-] 	insertSpace (
[+] 	insertSpace(
[-] 		bool result = setCount (this->m_count + count);
[+] 		bool result = setCount(this->m_count + count);
[-] 			Details::copy (dst + count, dst, oldCount - index);
[+] 			Details::copy(dst + count, dst, oldCount - index);
[-] 	setCountImpl (size_t count)
[+] 	setCountImpl(size_t count)
[-] 		size_t size = count * sizeof (T);
[+] 		size_t size = count * sizeof(T);
[-] 			this->m_hdr->getRefCount () == 1)
[+] 			this->m_hdr->getRefCount() == 1)
[-] 					Construct () (this->m_p + this->m_count, count - this->m_count);
[+] 					Construct() (this->m_p + this->m_count, count - this->m_count);
[-] 					Details::destruct (this->m_p + count, this->m_count - count);
[+] 					Details::destruct(this->m_p + count, this->m_count - count);
[-] 				Details::setHdrCount (this->m_hdr, count);
[+] 				Details::setHdrCount(this->m_hdr, count);
[-] 			this->release ();
[+] 			this->release();
[-] 			bool result = reserve (count);
[+] 			bool result = reserve(count);
[-] 			Construct () (this->m_p, count);
[+] 			Construct() (this->m_p, count);
[-] 			Details::setHdrCount (this->m_hdr, count);
[+] 			Details::setHdrCount(this->m_hdr, count);
[-] 		ASSERT (this->m_hdr);
[+] 		ASSERT(this->m_hdr);
[-] 		size_t bufferSize = getAllocSize (size);
[+] 		size_t bufferSize = getAllocSize(size);
[-] 		ref::Ptr <Hdr> hdr = AXL_REF_NEW_EXTRA (Hdr, bufferSize);
[+] 		ref::Ptr<Hdr> hdr = AXL_REF_NEW_EXTRA(Hdr, bufferSize);
[-] 		Details::setHdrCount (hdr, count);
[+] 		Details::setHdrCount(hdr, count);
[-] 		T* p = (T*) (hdr + 1);
[+] 		T* p = (T*)(hdr + 1);
[-] 			Details::constructCopy (p, this->m_p, count);
[+] 			Details::constructCopy(p, this->m_p, count);
[-] 			Details::constructCopy (p, this->m_p, this->m_count);
[+] 			Details::constructCopy(p, this->m_p, this->m_count);
[-] 			Construct () (p + this->m_count, count - this->m_count);
[+] 			Construct() (p + this->m_count, count - this->m_count);
[-] 		this->m_hdr->release ();
[+] 		this->m_hdr->release();
[-] 		this->m_hdr = hdr.detach ();
[+] 		this->m_hdr = hdr.detach();
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_ArrayDetails.h
----------------------
[-] 	typedef typename ArgType <T>::Type ValueArg;
[+] 	typedef typename ArgType<T>::Type ValueArg;
[-] 	reverse (
[+] 	reverse(
[-] 	copyReverse (
[+] 	copyReverse(
[-] 			reverse (dst, count);
[+] 			reverse(dst, count);
[-] 			copyReverseImpl (dst, src, count);
[+] 			copyReverseImpl(dst, src, count);
[-] 			reverse (dst, overlapCount);
[+] 			reverse(dst, overlapCount);
[-] 			copyReverseImpl (dst + overlapCount, src, nonOverlapCount);
[+] 			copyReverseImpl(dst + overlapCount, src, nonOverlapCount);
[-] 			reverse (dst + nonOverlapCount, overlapCount);
[+] 			reverse(dst + nonOverlapCount, overlapCount);
[-] 			copyReverseImpl (dst, src + overlapCount, nonOverlapCount);
[+] 			copyReverseImpl(dst, src + overlapCount, nonOverlapCount);
[-] 	copyReverseImpl (
[+] 	copyReverseImpl(
[-] class ArrayDetails: public ReverseArray <T>
[+] class ArrayDetails: public ReverseArray<T>
[-] 		~Hdr ()
[+] 		~Hdr()
[-] 			destruct ((T*) (this + 1), m_count);
[+] 			destruct((T*)(this + 1), m_count);
[-] 				new (p) T;
[+] 				new(p)T;
[-] 			memset (p, 0, count * sizeof (T));
[+] 			memset(p, 0, count * sizeof(T));
[-] 			Construct () (p, count);
[+] 			Construct() (p, count);
[-] 	setHdrCount (
[+] 	setHdrCount(
[-] 	constructCopy (
[+] 	constructCopy(
[-] 			new (dst) T (*src);
[+] 			new(dst)T(*src);
[-] 	destruct (
[+] 	destruct(
[-] 			p->~T ();
[+] 			p->~T();
[-] 	copy (
[+] 	copy(
[-] class SimpleArrayDetails: public ReverseArray <T>
[+] class SimpleArrayDetails: public ReverseArray<T>
[-] 			memset (p, 0, count * sizeof (T));
[+] 			memset(p, 0, count * sizeof(T));
[-] 	setHdrCount (
[+] 	setHdrCount(
[-] 	constructCopy (
[+] 	constructCopy(
[-] 		memcpy (dst, src, count * sizeof (T));
[+] 		memcpy(dst, src, count * sizeof(T));
[-] 	destruct (
[+] 	destruct(
[-] 	copy (
[+] 	copy(
[-] 		memmove (dst, src, count * sizeof (T));
[+] 		memmove(dst, src, count * sizeof(T));
[-] class ArrayDetails <char>: public SimpleArrayDetails <char>
[+] class ArrayDetails<char>: public SimpleArrayDetails<char>
[-] class ArrayDetails <wchar_t>: public SimpleArrayDetails <wchar_t>
[+] class ArrayDetails<wchar_t>: public SimpleArrayDetails<wchar_t>
[-] class ArrayDetails <float>: public SimpleArrayDetails <float>
[+] class ArrayDetails<float>: public SimpleArrayDetails<float>
[-] class ArrayDetails <double>: public SimpleArrayDetails <double>
[+] class ArrayDetails<double>: public SimpleArrayDetails<double>
[-] class ArrayDetails <int8_t>: public SimpleArrayDetails <int8_t>
[+] class ArrayDetails<int8_t>: public SimpleArrayDetails<int8_t>
[-] class ArrayDetails <uint8_t>: public SimpleArrayDetails <uint8_t>
[+] class ArrayDetails<uint8_t>: public SimpleArrayDetails<uint8_t>
[-] class ArrayDetails <int16_t>: public SimpleArrayDetails <int16_t>
[+] class ArrayDetails<int16_t>: public SimpleArrayDetails<int16_t>
[-] class ArrayDetails <uint16_t>: public SimpleArrayDetails <uint16_t>
[+] class ArrayDetails<uint16_t>: public SimpleArrayDetails<uint16_t>
[-] class ArrayDetails <int32_t>: public SimpleArrayDetails <int32_t>
[+] class ArrayDetails<int32_t>: public SimpleArrayDetails<int32_t>
[-] class ArrayDetails <uint32_t>: public SimpleArrayDetails <uint32_t>
[+] class ArrayDetails<uint32_t>: public SimpleArrayDetails<uint32_t>
[-] class ArrayDetails <int64_t>: public SimpleArrayDetails <int64_t>
[+] class ArrayDetails<int64_t>: public SimpleArrayDetails<int64_t>
[-] class ArrayDetails <uint64_t>: public SimpleArrayDetails <uint64_t>
[+] class ArrayDetails<uint64_t>: public SimpleArrayDetails<uint64_t>
[-] class ArrayDetails <T*>: public SimpleArrayDetails <T*>
[+] class ArrayDetails<T*>: public SimpleArrayDetails<T*>
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_ArrayList.h
----------------------
[-] 	typedef sl::Iterator <T> Iterator;
[+] 	typedef sl::Iterator<T> Iterator;
[-] 	sl::List <T> m_list;
[+] 	sl::List<T> m_list;
[-] 	sl::Array <T*> m_array;
[+] 	sl::Array<T*> m_array;
[-] 	isEmpty () const
[+] 	isEmpty() const
[-] 		return m_list.isEmpty ();
[+] 		return m_list.isEmpty();
[-] 	getCount () const
[+] 	getCount() const
[-] 		ASSERT (m_list.getCount () == m_array.getCount ());
[+] 		ASSERT(m_list.getCount() == m_array.getCount());
[-] 		return m_list.getCount ();
[+] 		return m_list.getCount();
[-] 	getHead () const
[+] 	getHead() const
[-] 		return m_list.getHead ();
[+] 		return m_list.getHead();
[-] 	getTail () const
[+] 	getTail() const
[-] 		return m_list.getTail ();
[+] 		return m_list.getTail();
[-] 	add ()
[+] 	add()
[-] 		T* p = AXL_MEM_NEW (T);
[+] 		T* p = AXL_MEM_NEW(T);
[-] 		m_list.insertTail (p);
[+] 		m_list.insertTail(p);
[-] 		size_t count = m_array.getCount ();
[+] 		size_t count = m_array.getCount();
[-] 		m_array.setCount (count + 1);
[+] 		m_array.setCount(count + 1);
[-] 		m_array [count] = p;
[+] 		m_array[count] = p;
[-] 	get (size_t index)
[+] 	get(size_t index)
[-] 		size_t count = m_array.getCount ();
[+] 		size_t count = m_array.getCount();
[-] 			return m_array [index];
[+] 			return m_array[index];
[-] 		m_array.setCount (index + 1);
[+] 		m_array.setCount(index + 1);
[-] 			T* p = AXL_MEM_NEW (T);
[+] 			T* p = AXL_MEM_NEW(T);
[-] 			m_list.insertTail (p);
[+] 			m_list.insertTail(p);
[-] 			m_array [i] = p;
[+] 			m_array[i] = p;
[-] 		return m_array [index];
[+] 		return m_array[index];
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_AutoPtrArray.h
----------------------
[-] 	typename Delete0 = typename mem::StdDelete <T>
[+] 	typename Delete0 = typename mem::StdDelete<T>
[-] class AutoPtrArray: public Array <T*>
[+] class AutoPtrArray: public Array<T*>
[-] 	AXL_DISABLE_COPY (AutoPtrArray)
[+] 	AXL_DISABLE_COPY(AutoPtrArray)
[-] 	typedef Array <T*> BaseType;
[+] 	typedef Array<T*> BaseType;
[-] 	AutoPtrArray ():
[+] 	AutoPtrArray():
[-] 		BaseType ()
[+] 		BaseType()
[-] 	AutoPtrArray (T* e):
[+] 	AutoPtrArray(T* e):
[-] 		BaseType (e)
[+] 		BaseType(e)
[-] 	AutoPtrArray (
[+] 	AutoPtrArray(
[-] 		BaseType (p, count)
[+] 		BaseType(p, count)
[-] 	AutoPtrArray (
[+] 	AutoPtrArray(
[-] 		BaseType (bufKind, p, size)
[+] 		BaseType(bufKind, p, size)
[-] 	~AutoPtrArray ()
[+] 	~AutoPtrArray()
[-] 		deleteElements ();
[+] 		deleteElements();
[-] 	clear ()
[+] 	clear()
[-] 		deleteElements ();
[+] 		deleteElements();
[-] 		BaseType::clear ();
[+] 		BaseType::clear();
[-] 	deleteElements ()
[+] 	deleteElements()
[-] 		size_t count = this->getCount ();
[+] 		size_t count = this->getCount();
[-] 			T* e = this->m_p [i];
[+] 			T* e = this->m_p[i];
[-] 				Delete () (e);
[+] 				Delete() (e);
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_BinTree.h
----------------------
[-] struct BinTreeNodeBase: MapEntry <Key, Value>
[+] struct BinTreeNodeBase: MapEntry<Key, Value>
[-] 	onXcg (
[+] 	onXcg(
[-] 	typedef sl::Iterator <Node> Iterator;
[+] 	typedef sl::Iterator<Node> Iterator;
[-] 	typedef sl::ConstIterator <Node> ConstIterator;
[+] 	typedef sl::ConstIterator<Node> ConstIterator;
[-] 	List <Node> m_nodeList;
[+] 	List<Node> m_nodeList;
[-] 	explicit BinTreeBase (const Cmp& cmp = Cmp ())
[+] 	explicit BinTreeBase(const Cmp& cmp = Cmp())
[-] 		return visit (key)->m_value;
[+] 		return visit(key)->m_value;
[-] 		return visit (key)->m_value;
[+] 		return visit(key)->m_value;
[-] 	isEmpty () const
[+] 	isEmpty() const
[-] 		return m_nodeList.isEmpty ();
[+] 		return m_nodeList.isEmpty();
[-] 	getCount () const
[+] 	getCount() const
[-] 		return m_nodeList.getCount ();
[+] 		return m_nodeList.getCount();
[-] 	getHead ()
[+] 	getHead()
[-] 		return m_nodeList.getHead ();
[+] 		return m_nodeList.getHead();
[-] 	getHead () const
[+] 	getHead() const
[-] 		return m_nodeList.getHead ();
[+] 		return m_nodeList.getHead();
[-] 	getTail ()
[+] 	getTail()
[-] 		return m_nodeList.getTail ();
[+] 		return m_nodeList.getTail();
[-] 	getTail () const
[+] 	getTail() const
[-] 		return m_nodeList.getTail ();
[+] 		return m_nodeList.getTail();
[-] 	find (KeyArg key)
[+] 	find(KeyArg key)
[-] 			int cmp = m_cmp (key, node->m_key);
[+] 			int cmp = m_cmp(key, node->m_key);
[-] 	find (KeyArg key) const
[+] 	find(KeyArg key) const
[-] 		return ((BinTreeBase*) this)->find (key); // a simple const-cast
[+] 		return ((BinTreeBase*)this)->find(key); // a simple const-cast
[-] 	find (
[+] 	find(
[-] 		if (isEmpty ())
[+] 		if (isEmpty())
[-] 			int cmp = m_cmp (key, node->m_key);
[+] 			int cmp = m_cmp(key, node->m_key);
[-] 		ASSERT (node || prevNode);
[+] 		ASSERT(node || prevNode);
[-] 		switch (relOp)
[+] 		switch(relOp)
[-] 			return node ? node->m_left : prevCmp > 0 ? prevNode : Iterator (prevNode).getPrev ();
[+] 			return node ? node->m_left : prevCmp > 0 ? prevNode : Iterator(prevNode).getPrev();
[-] 			return node ? node : prevCmp > 0 ? prevNode : Iterator (prevNode).getPrev ();
[+] 			return node ? node : prevCmp > 0 ? prevNode : Iterator(prevNode).getPrev();
[-] 			return node ? node->m_right : prevCmp < 0 ? prevNode : Iterator (prevNode).getNext ();
[+] 			return node ? node->m_right : prevCmp < 0 ? prevNode : Iterator(prevNode).getNext();
[-] 			return node ? node : prevCmp < 0 ? prevNode : Iterator (prevNode).getNext ();
[+] 			return node ? node : prevCmp < 0 ? prevNode : Iterator(prevNode).getNext();
[-] 	find (
[+] 	find(
[-] 		return ((BinTreeBase*) this)->find (key, relOp); // a simple const-cast
[+] 		return ((BinTreeBase*)this)->find(key, relOp); // a simple const-cast
[-] 	findValue (
[+] 	findValue(
[-] 		ConstIterator it = find (key);
[+] 		ConstIterator it = find(key);
[-] 	findValue (
[+] 	findValue(
[-] 		ConstIterator it = find (key, relOp);
[+] 		ConstIterator it = find(key, relOp);
[-] 	visit (KeyArg key)
[+] 	visit(KeyArg key)
[-] 			cmp = m_cmp (key, node->m_key);
[+] 			cmp = m_cmp(key, node->m_key);
[-] 		node = AXL_MEM_ZERO_NEW (Node);
[+] 		node = AXL_MEM_ZERO_NEW(Node);
[-] 			m_nodeList.insertTail (node);
[+] 			m_nodeList.insertTail(node);
[-] 			m_nodeList.insertBefore (node, parent);
[+] 			m_nodeList.insertBefore(node, parent);
[-] 			m_nodeList.insertAfter (node, parent);
[+] 			m_nodeList.insertAfter(node, parent);
[-] 		static_cast <T*> (this)->onInsert (node);
[+] 		static_cast<T*> (this)->onInsert(node);
[-] 	add (
[+] 	add(
[-] 		size_t prevCount = getCount ();
[+] 		size_t prevCount = getCount();
[-] 		Iterator it = visit (key);
[+] 		Iterator it = visit(key);
[-] 			*isNew = getCount () > prevCount;
[+] 			*isNew = getCount() > prevCount;
[-] 	addIfNotExists (
[+] 	addIfNotExists(
[-] 		size_t prevCount = getCount ();
[+] 		size_t prevCount = getCount();
[-] 		Iterator it = visit (key);
[+] 		Iterator it = visit(key);
[-] 		if (getCount () == prevCount)
[+] 		if (getCount() == prevCount)
[-] 	erase (Iterator it)
[+] 	erase(Iterator it)
[-] 			Node* next = (Node*) node->m_next;
[+] 			Node* next = (Node*)node->m_next;
[-] 			ASSERT (next == getLeftmostChild (node->m_right));
[+] 			ASSERT(next == getLeftmostChild(node->m_right));
[-] 			xcg (node, next);
[+] 			xcg(node, next);
[-] 		static_cast <T*> (this)->onErase (node);
[+] 		static_cast<T*> (this)->onErase(node);
[-] 		m_nodeList.erase (node);
[+] 		m_nodeList.erase(node);
[-] 	eraseKey (KeyArg key)
[+] 	eraseKey(KeyArg key)
[-] 		Iterator it = find (key);
[+] 		Iterator it = find(key);
[-] 		erase (it);
[+] 		erase(it);
[-] 	clear ()
[+] 	clear()
[-] 		m_nodeList.clear ();
[+] 		m_nodeList.clear();
[-] 	getLeftmostChild (Node* node)
[+] 	getLeftmostChild(Node* node)
[-] 	getRightmostChild (Node* node)
[+] 	getRightmostChild(Node* node)
[-] 	xcg (
[+] 	xcg(
[-] 		Node::onXcg (node1, node2);
[+] 		Node::onXcg(node1, node2);
[-] 	replaceWithChild (Node* node)
[+] 	replaceWithChild(Node* node)
[-] 			ASSERT (node == m_root);
[+] 			ASSERT(node == m_root);
[-] 	rotateLeft (Node* x)
[+] 	rotateLeft(Node* x)
[-] 		ASSERT (y);
[+] 		ASSERT(y);
[-] 	rotateRight (Node* x)
[+] 	rotateRight(Node* x)
[-] 		ASSERT (y);
[+] 		ASSERT(y);
[-] 	onInsert (Node* node)
[+] 	onInsert(Node* node)
[-] 	onErase (Node* node)
[+] 	onErase(Node* node)
[-] 		replaceWithChild (node);
[+] 		replaceWithChild(node);
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_BitIdx.h
----------------------
[-] geLoBit8 (uint8_t x)
[+] geLoBit8(uint8_t x)
[-] getLoBit16 (uint16_t x)
[+] getLoBit16(uint16_t x)
[-] getLoBit32 (uint32_t x)
[+] getLoBit32(uint32_t x)
[-] getLoBit64 (uint64_t x)
[+] getLoBit64(uint64_t x)
[-] getHiBit8 (uint8_t x)
[+] getHiBit8(uint8_t x)
[-] getHiBit16 (uint16_t x)
[+] getHiBit16(uint16_t x)
[-] getHiBit32 (uint32_t x)
[+] getHiBit32(uint32_t x)
[-] getHiBit64 (uint64_t x)
[+] getHiBit64(uint64_t x)
[-] getPowerOf2Ge8 (uint8_t x)
[+] getPowerOf2Ge8(uint8_t x)
[-] getPowerOf2Ge16 (uint16_t x)
[+] getPowerOf2Ge16(uint16_t x)
[-] getPowerOf2Ge32 (uint32_t x)
[+] getPowerOf2Ge32(uint32_t x)
[-] getPowerOf2Ge64 (uint64_t x)
[+] getPowerOf2Ge64(uint64_t x)
[-] getLoBitIdx8 (uint8_t x)
[+] getLoBitIdx8(uint8_t x)
[-] getLoBitIdx16 (uint16_t x)
[+] getLoBitIdx16(uint16_t x)
[-] 		getLoBitIdx8 ((uint8_t) x) :
[+] 		getLoBitIdx8((uint8_t)x) :
[-] 		(8 + getLoBitIdx8 ((uint8_t) (x >> 8)));
[+] 		(8 + getLoBitIdx8((uint8_t)(x >> 8)));
[-] getLoBitIdx32 (uint32_t x)
[+] getLoBitIdx32(uint32_t x)
[-] 		getLoBitIdx16 ((uint16_t) x) :
[+] 		getLoBitIdx16((uint16_t)x) :
[-] 		(16 + getLoBitIdx16 ((uint16_t) (x >> 16)));
[+] 		(16 + getLoBitIdx16((uint16_t)(x >> 16)));
[-] getLoBitIdx64 (uint64_t x)
[+] getLoBitIdx64(uint64_t x)
[-] 		getLoBitIdx32 ((uint32_t) x) :
[+] 		getLoBitIdx32((uint32_t)x) :
[-] 		(32 + getLoBitIdx32 ((uint32_t) (x >> 32)));
[+] 		(32 + getLoBitIdx32((uint32_t)(x >> 32)));
[-] getHiBitIdx8 (uint8_t x)
[+] getHiBitIdx8(uint8_t x)
[-] getHiBitIdx16 (uint16_t x)
[+] getHiBitIdx16(uint16_t x)
[-] 		(8 + getHiBitIdx8 ((uint8_t) (x >> 8))) :
[+] 		(8 + getHiBitIdx8((uint8_t)(x >> 8))) :
[-] 		getHiBitIdx8 ((uint8_t) x);
[+] 		getHiBitIdx8((uint8_t)x);
[-] getHiBitIdx32 (uint32_t x)
[+] getHiBitIdx32(uint32_t x)
[-] 		(16 + getHiBitIdx16 ((uint16_t) (x >> 16))) :
[+] 		(16 + getHiBitIdx16((uint16_t)(x >> 16))) :
[-] 		getHiBitIdx16 ((uint16_t) x);
[+] 		getHiBitIdx16((uint16_t)x);
[-] getHiBitIdx64 (uint64_t x)
[+] getHiBitIdx64(uint64_t x)
[-] 		(32 + getHiBitIdx32 ((uint32_t) (x >> 32))) :
[+] 		(32 + getHiBitIdx32((uint32_t)(x >> 32))) :
[-] 		getHiBitIdx32 ((uint32_t) x);
[+] 		getHiBitIdx32((uint32_t)x);
[-] getLoBitmask8 (size_t to)
[+] getLoBitmask8(size_t to)
[-] 	return ((uint8_t) 1 << (uint8_t) to) - 1;
[+] 	return ((uint8_t) 1 << (uint8_t)to) - 1;
[-] getHiBitmask8 (size_t from)
[+] getHiBitmask8(size_t from)
[-] 	return ~(((uint8_t) 1 << (uint8_t) from) - 1);
[+] 	return ~(((uint8_t) 1 << (uint8_t)from) - 1);
[-] getBitmask8 (
[+] getBitmask8(
[-] 	return getLoBitmask8 (to) & getHiBitmask8 (from);
[+] 	return getLoBitmask8(to) & getHiBitmask8(from);
[-] getLoBitmask16 (size_t to)
[+] getLoBitmask16(size_t to)
[-] 	return ((uint16_t) 1 << (uint16_t) to) - 1;
[+] 	return ((uint16_t) 1 << (uint16_t)to) - 1;
[-] getHiBitmask16 (size_t from)
[+] getHiBitmask16(size_t from)
[-] 	return ~(((uint16_t) 1 << (uint16_t) from) - 1);
[+] 	return ~(((uint16_t) 1 << (uint16_t)from) - 1);
[-] getBitmask16 (
[+] getBitmask16(
[-] 	return getLoBitmask16 (to) & getHiBitmask16 (from);
[+] 	return getLoBitmask16(to) & getHiBitmask16(from);
[-] getLoBitmask32 (size_t to)
[+] getLoBitmask32(size_t to)
[-] 	return ((uint32_t) 1 << (uint32_t) to) - 1;
[+] 	return ((uint32_t) 1 << (uint32_t)to) - 1;
[-] getHiBitmask32 (size_t from)
[+] getHiBitmask32(size_t from)
[-] 	return ~(((uint32_t) 1 << (uint32_t) from) - 1);
[+] 	return ~(((uint32_t) 1 << (uint32_t)from) - 1);
[-] getBitmask32 (
[+] getBitmask32(
[-] 	return getLoBitmask32 (to) & getHiBitmask32 (from);
[+] 	return getLoBitmask32(to) & getHiBitmask32(from);
[-] getLoBitmask64 (size_t to)
[+] getLoBitmask64(size_t to)
[-] 	return ((uint64_t) 1 << (uint64_t) to) - 1;
[+] 	return ((uint64_t) 1 << (uint64_t)to) - 1;
[-] getHiBitmask64 (size_t from)
[+] getHiBitmask64(size_t from)
[-] 	return ~(((uint64_t) 1 << (uint64_t) from) - 1);
[+] 	return ~(((uint64_t) 1 << (uint64_t)from) - 1);
[-] getBitmask64 (
[+] getBitmask64(
[-] 	return getLoBitmask64 (to) & getHiBitmask64 (from);
[+] 	return getLoBitmask64(to) & getHiBitmask64(from);
[-] isPowerOf2 (T x)
[+] isPowerOf2(T x)
[-] isAligned (
[+] isAligned(
[-] 	ASSERT (isPowerOf2 (factor));
[+] 	ASSERT(isPowerOf2(factor));
[-] isAligned (T x)
[+] isAligned(T x)
[-] 	ASSERT (isPowerOf2 (factor));
[+] 	ASSERT(isPowerOf2(factor));
[-] align (
[+] align(
[-] 	ASSERT (isPowerOf2 (factor));
[+] 	ASSERT(isPowerOf2(factor));
[-] align (T x)
[+] align(T x)
[-] 	ASSERT (isPowerOf2 (factor));
[+] 	ASSERT(isPowerOf2(factor));
[-] getAllocSize (size_t size)
[+] getAllocSize(size_t size)
[-] 	return size < growLimit ? getPowerOf2Ge (size) : align <alignFactor> (size);
[+] 	return size < growLimit ? getPowerOf2Ge(size) : align<alignFactor> (size);
[-] getAllocSize (size_t size)
[+] getAllocSize(size_t size)
[-] 	return getAllocSize <AXL_PTR_SIZE, AXL_PTR_SIZE * 1024 * 1024> (size);
[+] 	return getAllocSize<AXL_PTR_SIZE, AXL_PTR_SIZE * 1024 * 1024> (size);
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_BitMap.h
----------------------
[-] getBit (
[+] getBit(
[-] setBit (
[+] setBit(
[-] setBitRange (
[+] setBitRange(
[-] mergeBitMaps (
[+] mergeBitMaps(
[-] inverseBitMap (
[+] inverseBitMap(
[-] 		map [i] = ~map [i];
[+] 		map[i] = ~map[i];
[-] findBit (
[+] findBit(
[-] 	size_t m_map [pageCount];
[+] 	size_t m_map[pageCount];
[-] 	BitMapN ()
[+] 	BitMapN()
[-] 		clear ();
[+] 		clear();
[-] 		memset (m_map, 0, sizeof (m_map));
[+] 		memset(m_map, 0, sizeof(m_map));
[-] 	copy (const BitMapN& src)
[+] 	copy(const BitMapN& src)
[-] 		memcpy (m_map, src.m_map, sizeof (m_map));
[+] 		memcpy(m_map, src.m_map, sizeof(m_map));
[-] 	hash () const
[+] 	hash() const
[-] 		return djb2 (m_map, sizeof (m_map));
[+] 		return djb2(m_map, sizeof(m_map));
[-] 	cmp (const BitMapN& src) const
[+] 	cmp(const BitMapN& src) const
[-] 		return memcmp (m_map, src.m_map, sizeof (m_map));
[+] 		return memcmp(m_map, src.m_map, sizeof(m_map));
[-] 	getMap () const
[+] 	getMap() const
[-] 	getMap ()
[+] 	getMap()
[-] 	getPageCount () const
[+] 	getPageCount() const
[-] 	getBit (size_t bit) const
[+] 	getBit(size_t bit) const
[-] 		return sl::getBit (m_map, pageCount, bit);
[+] 		return sl::getBit(m_map, pageCount, bit);
[-] 	setBit (
[+] 	setBit(
[-] 		return sl::setBit (m_map, pageCount, bit, value);
[+] 		return sl::setBit(m_map, pageCount, bit, value);
[-] 	setBitRange (
[+] 	setBitRange(
[-] 		return sl::setBitRange (m_map, pageCount, from, to, value);
[+] 		return sl::setBitRange(m_map, pageCount, from, to, value);
[-] 	merge (
[+] 	merge(
[-] 		return sl::mergeBitMaps (m_map, bitMap2.m_map, pageCount, op);
[+] 		return sl::mergeBitMaps(m_map, bitMap2.m_map, pageCount, op);
[-] 	inverse ()
[+] 	inverse()
[-] 		sl::inverseBitMap (m_map, pageCount);
[+] 		sl::inverseBitMap(m_map, pageCount);
[-] 	findBit (
[+] 	findBit(
[-] 		return sl::findBit (m_map, pageCount, start, value);
[+] 		return sl::findBit(m_map, pageCount, start, value);
[-] 	Array <size_t> m_map;
[+] 	Array<size_t> m_map;
[-] 	BitMap (size_t bitCount = 0)
[+] 	BitMap(size_t bitCount = 0)
[-] 		create (bitCount);
[+] 		create(bitCount);
[-] 	BitMap (const BitMap& src)
[+] 	BitMap(const BitMap& src)
[-] 		copy (src);
[+] 		copy(src);
[-] 		copy (src);
[+] 		copy(src);
[-] 		return isEqual (src);
[+] 		return isEqual(src);
[-] 		return !isEqual (src);
[+] 		return !isEqual(src);
[-] 	getMap () const
[+] 	getMap() const
[-] 	getMap ()
[+] 	getMap()
[-] 	getPageCount () const
[+] 	getPageCount() const
[-] 		return m_map.getCount ();
[+] 		return m_map.getCount();
[-] 	getBitCount () const
[+] 	getBitCount() const
[-] 		return getPageCount () * AXL_PTR_BITS;
[+] 		return getPageCount() * AXL_PTR_BITS;
[-] 		memset (m_map, 0, m_map.getCount () * sizeof (size_t));
[+] 		memset(m_map, 0, m_map.getCount() * sizeof(size_t));
[-] 	copy (const BitMap& src)
[+] 	copy(const BitMap& src)
[-] 		m_map.copy (src.m_map, src.m_map.getCount ());
[+] 		m_map.copy(src.m_map, src.m_map.getCount());
[-] 	hash () const
[+] 	hash() const
[-] 		return djb2 (m_map, m_map.getCount () * sizeof (size_t));
[+] 		return djb2(m_map, m_map.getCount() * sizeof(size_t));
[-] 	cmp (const BitMap& src) const;
[+] 	cmp(const BitMap& src) const;
[-] 	isEqual (const BitMap& src) const
[+] 	isEqual(const BitMap& src) const
[-] 		return cmp (src) == 0;
[+] 		return cmp(src) == 0;
[-] 	create (size_t bitCount);
[+] 	create(size_t bitCount);
[-] 	setBitCount (size_t bitCount);
[+] 	setBitCount(size_t bitCount);
[-] 	ensureBitCount (size_t bitCount)
[+] 	ensureBitCount(size_t bitCount)
[-] 		return bitCount > getBitCount () ? setBitCount (bitCount) : true;
[+] 		return bitCount > getBitCount() ? setBitCount(bitCount) : true;
[-] 	getBit (size_t bit) const
[+] 	getBit(size_t bit) const
[-] 		return sl::getBit (m_map, m_map.getCount (), bit);
[+] 		return sl::getBit(m_map, m_map.getCount(), bit);
[-] 	setBit (
[+] 	setBit(
[-] 		return sl::setBit (m_map, m_map.getCount (), bit, value);
[+] 		return sl::setBit(m_map, m_map.getCount(), bit, value);
[-] 	setBitResize (
[+] 	setBitResize(
[-] 		ensureBitCount (bit + 1);
[+] 		ensureBitCount(bit + 1);
[-] 		return sl::setBit (m_map, m_map.getCount (), bit, value);
[+] 		return sl::setBit(m_map, m_map.getCount(), bit, value);
[-] 	setBitRange (
[+] 	setBitRange(
[-] 		return sl::setBitRange (m_map, m_map.getCount (), from, to, value);
[+] 		return sl::setBitRange(m_map, m_map.getCount(), from, to, value);
[-] 	setBitRangeResize (
[+] 	setBitRangeResize(
[-] 		ensureBitCount (to);
[+] 		ensureBitCount(to);
[-] 		return sl::setBitRange (m_map, m_map.getCount (), from, to, value);
[+] 		return sl::setBitRange(m_map, m_map.getCount(), from, to, value);
[-] 	merge (
[+] 	merge(
[-] 	mergeResize (
[+] 	mergeResize(
[-] 	inverse ()
[+] 	inverse()
[-] 		sl::inverseBitMap (m_map, m_map.getCount ());
[+] 		sl::inverseBitMap(m_map, m_map.getCount());
[-] 	findBit (
[+] 	findBit(
[-] 		return sl::findBit (m_map, m_map.getCount (), start, value);
[+] 		return sl::findBit(m_map, m_map.getCount(), start, value);
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_BmhFind.h
----------------------
[-] 	Array <uchar_t> m_buffer; // work size of buffer is 2 * m_PatternSize
[+] 	Array<uchar_t> m_buffer; // work size of buffer is 2 * m_PatternSize
[-] 	size_t m_nextBadCharTable [256];
[+] 	size_t m_nextBadCharTable[256];
[-] 	size_t m_prevBadCharTable [256];
[+] 	size_t m_prevBadCharTable[256];
[-] 	BmhFind ();
[+] 	BmhFind();
[-] 	clear ();
[+] 	clear();
[-] 	isEmpty ()
[+] 	isEmpty()
[-] 	getPatternSize ()
[+] 	getPatternSize()
[-] 	getPattern ()
[+] 	getPattern()
[-] 	setPattern (
[+] 	setPattern(
[-] 	find (
[+] 	find(
[-] 	reverseFind (
[+] 	reverseFind(
[-] 	incrementalFind (
[+] 	incrementalFind(
[-] 	reverseIncrementalFind (
[+] 	reverseIncrementalFind(
[-] 	resetIncrementalFind (size_t incFindOffset = 0)
[+] 	resetIncrementalFind(size_t incFindOffset = 0)
[-] 	getIncrementalFindOffset ()
[+] 	getIncrementalFindOffset()
[-] 	getIncrementalFindTailSize ()
[+] 	getIncrementalFindTailSize()
[-] 	rebuildTables ();
[+] 	rebuildTables();
[-] 	cmpPattern (uchar_t* _p);
[+] 	cmpPattern(uchar_t* _p);
[-] 	reverseCmpPattern (uchar_t* _p);
[+] 	reverseCmpPattern(uchar_t* _p);
[-] 	incrementalCmpPattern (
[+] 	incrementalCmpPattern(
[-] 	reverseIncrementalCmpPattern (
[+] 	reverseIncrementalCmpPattern(
[-] 	updateIncrementalTail (
[+] 	updateIncrementalTail(
[-] 	updateReverseIncrementalTail (
[+] 	updateReverseIncrementalTail(
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_BoxList.h
----------------------
[-] 	BoxListEntry ()
[+] 	BoxListEntry()
[-] 	BoxListEntry (const T& value)
[+] 	BoxListEntry(const T& value)
[-] class BoxIteratorImpl: public IteratorBase <
[+] class BoxIteratorImpl: public IteratorBase<
[-] 	ImplicitCast <Entry*, Link*>
[+] 	ImplicitCast<Entry*, Link*>
[-] 		return r ();
[+] 		return r();
[-] 		return p ();
[+] 		return p();
[-] 	r () const
[+] 	r() const
[-] 		ASSERT (this->m_p);
[+] 		ASSERT(this->m_p);
[-] 	p () const
[+] 	p() const
[-] class BoxIterator: public BoxIteratorImpl <
[+] class BoxIterator: public BoxIteratorImpl<
[-] 	BoxIterator <T>,
[+] 	BoxIterator<T>,
[-] 	BoxListEntry <T>,
[+] 	BoxListEntry<T>,
[-] 	BoxIterator ()
[+] 	BoxIterator()
[-] 	BoxIterator (BoxListEntry <T>* p)
[+] 	BoxIterator(BoxListEntry<T>* p)
[-] class ConstBoxIterator: public BoxIteratorImpl <
[+] class ConstBoxIterator: public BoxIteratorImpl<
[-] 	ConstBoxIterator <T>,
[+] 	ConstBoxIterator<T>,
[-] 	const BoxListEntry <T>,
[+] 	const BoxListEntry<T>,
[-] 	ConstBoxIterator ()
[+] 	ConstBoxIterator()
[-] 	ConstBoxIterator (const BoxListEntry <T>* p)
[+] 	ConstBoxIterator(const BoxListEntry<T>* p)
[-] 	ConstBoxIterator (const BoxIterator <T>& it)
[+] 	ConstBoxIterator(const BoxIterator<T>& it)
[-] 		this->m_p = it.getEntry ();
[+] 		this->m_p = it.getEntry();
[-] 	typename ValueArg = typename ArgType <T>::Type
[+] 	typename ValueArg = typename ArgType<T>::Type
[-] class BoxList: public ListBase <
[+] class BoxList: public ListBase<
[-] 	BoxListEntry <T>,
[+] 	BoxListEntry<T>,
[-] 	ImplicitPtrCast <BoxListEntry <T>, ListLink>,
[+] 	ImplicitPtrCast<BoxListEntry<T>, ListLink>,
[-] 	BoxIterator <T>,
[+] 	BoxIterator<T>,
[-] 	ConstBoxIterator <T>,
[+] 	ConstBoxIterator<T>,
[-] 	typename mem::StdDelete <BoxListEntry <T> >
[+] 	typename mem::StdDelete<BoxListEntry<T> >
[-] 	typedef ListBase <
[+] 	typedef ListBase<
[-] 		BoxListEntry <T>,
[+] 		BoxListEntry<T>,
[-] 		ImplicitPtrCast <BoxListEntry <T>, ListLink>,
[+] 		ImplicitPtrCast<BoxListEntry<T>, ListLink>,
[-] 		BoxIterator <T>,
[+] 		BoxIterator<T>,
[-] 		ConstBoxIterator <T>,
[+] 		ConstBoxIterator<T>,
[-] 		typename mem::StdDelete <BoxListEntry <T> >
[+] 		typename mem::StdDelete<BoxListEntry<T> >
[-] 	copy (const L& list)
[+] 	copy(const L& list)
[-] 		this->clear ();
[+] 		this->clear();
[-] 		typename L::Iterator it = list.getHead ();
[+] 		typename L::Iterator it = list.getHead();
[-] 			insertTail (*it);
[+] 			insertTail(*it);
[-] 	remove (Iterator it)
[+] 	remove(Iterator it)
[-] 		Entry* entry = it.getEntry ();
[+] 		Entry* entry = it.getEntry();
[-] 		BaseType::remove (entry);
[+] 		BaseType::remove(entry);
[-] 		AXL_MEM_DELETE (entry);
[+] 		AXL_MEM_DELETE(entry);
[-] 	removeHead ()
[+] 	removeHead()
[-] 		return this->m_head ? remove (this->m_head) : T ();
[+] 		return this->m_head ? remove(this->m_head) : T();
[-] 	removeTail ()
[+] 	removeTail()
[-] 		return this->m_tail ? remove (this->m_tail) : T ();
[+] 		return this->m_tail ? remove(this->m_tail) : T();
[-] 	insertHead (ValueArg value)
[+] 	insertHead(ValueArg value)
[-] 		Entry* entry = AXL_MEM_NEW (Entry);
[+] 		Entry* entry = AXL_MEM_NEW(Entry);
[-] 		return insertHeadEntry (entry);
[+] 		return insertHeadEntry(entry);
[-] 	insertTail (ValueArg value)
[+] 	insertTail(ValueArg value)
[-] 		Entry* entry = AXL_MEM_NEW (Entry);
[+] 		Entry* entry = AXL_MEM_NEW(Entry);
[-] 		return insertTailEntry (entry);
[+] 		return insertTailEntry(entry);
[-] 	insertBefore (
[+] 	insertBefore(
[-] 		Entry* entry = AXL_MEM_NEW (Entry);
[+] 		Entry* entry = AXL_MEM_NEW(Entry);
[-] 		return insertBeforeEntry (entry, before);
[+] 		return insertBeforeEntry(entry, before);
[-] 	insertAfter (
[+] 	insertAfter(
[-] 		Entry* entry = AXL_MEM_NEW (Entry);
[+] 		Entry* entry = AXL_MEM_NEW(Entry);
[-] 		return insertAfterEntry (entry, after);
[+] 		return insertAfterEntry(entry, after);
[-] 	insertHead ()
[+] 	insertHead()
[-] 		Entry* entry = AXL_MEM_NEW (Entry);
[+] 		Entry* entry = AXL_MEM_NEW(Entry);
[-] 		return insertHeadEntry (entry);
[+] 		return insertHeadEntry(entry);
[-] 	insertTail ()
[+] 	insertTail()
[-] 		Entry* entry = AXL_MEM_NEW (Entry);
[+] 		Entry* entry = AXL_MEM_NEW(Entry);
[-] 		return insertTailEntry (entry);
[+] 		return insertTailEntry(entry);
[-] 	insertBefore (Iterator before)
[+] 	insertBefore(Iterator before)
[-] 		Entry* entry = AXL_MEM_NEW (Entry);
[+] 		Entry* entry = AXL_MEM_NEW(Entry);
[-] 		return insertBeforeEntry (entry, before);
[+] 		return insertBeforeEntry(entry, before);
[-] 	insertAfter (Iterator after)
[+] 	insertAfter(Iterator after)
[-] 		Entry* entry = AXL_MEM_NEW (Entry);
[+] 		Entry* entry = AXL_MEM_NEW(Entry);
[-] 		return insertAfterEntry (entry, after);
[+] 		return insertAfterEntry(entry, after);
[-] 	removeEntry (Iterator it)
[+] 	removeEntry(Iterator it)
[-] 		return BaseType::remove (it);
[+] 		return BaseType::remove(it);
[-] 	removeHeadEntry ()
[+] 	removeHeadEntry()
[-] 		return BaseType::removeHead ();
[+] 		return BaseType::removeHead();
[-] 	removeTailEntry ()
[+] 	removeTailEntry()
[-] 		return BaseType::removeTail ();
[+] 		return BaseType::removeTail();
[-] 	insertHeadEntry (Entry* entry)
[+] 	insertHeadEntry(Entry* entry)
[-] 		return BaseType::insertHead (entry);
[+] 		return BaseType::insertHead(entry);
[-] 	insertTailEntry (Entry* entry)
[+] 	insertTailEntry(Entry* entry)
[-] 		return BaseType::insertTail (entry);
[+] 		return BaseType::insertTail(entry);
[-] 	insertBeforeEntry (
[+] 	insertBeforeEntry(
[-] 		return BaseType::insertBefore (entry, before);
[+] 		return BaseType::insertBefore(entry, before);
[-] 	insertAfterEntry (
[+] 	insertAfterEntry(
[-] 		return BaseType::insertAfter (entry, after);
[+] 		return BaseType::insertAfter(entry, after);
[-] class ConstBoxList: public ConstListBase <
[+] class ConstBoxList: public ConstListBase<
[-] 	BoxListEntry <T>,
[+] 	BoxListEntry<T>,
[-] 	ImplicitPtrCast <BoxListEntry <T>, ListLink>,
[+] 	ImplicitPtrCast<BoxListEntry<T>, ListLink>,
[-] 	ConstBoxIterator <T>
[+] 	ConstBoxIterator<T>
[-] 	ConstBoxList ()
[+] 	ConstBoxList()
[-] 	ConstBoxList (const BoxList <T, ValueArg>& list)
[+] 	ConstBoxList(const BoxList<T, ValueArg>& list)
[-] 		this->m_listData = list.getListData ();
[+] 		this->m_listData = list.getListData();
[-] 	ConstBoxList (
[+] 	ConstBoxList(
[-] 		const List <
[+] 		const List<
[-] 			BoxListEntry <T>,
[+] 			BoxListEntry<T>,
[-] 		this->m_listData = list.getListData ();
[+] 		this->m_listData = list.getListData();
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_BoyerMooreFind.h
----------------------
[-] 	Array <T> m_tail;
[+] 	Array<T> m_tail;
[-] 	BoyerMooreIncrementalContext ()
[+] 	BoyerMooreIncrementalContext()
[-] 	reset ()
[+] 	reset()
[-] 		m_tail.clear ();
[+] 		m_tail.clear();
[-] 	typedef BoyerMooreIncrementalContext <T> IncrementalContext;
[+] 	typedef BoyerMooreIncrementalContext<T> IncrementalContext;
[-] 	Array <T> m_pattern;
[+] 	Array<T> m_pattern;
[-] 	Array <size_t, ArrayDetails <size_t> > m_badSkipTable;
[+] 	Array<size_t, ArrayDetails<size_t> > m_badSkipTable;
[-] 	Array <size_t, ArrayDetails <size_t> > m_goodSkipTable;
[+] 	Array<size_t, ArrayDetails<size_t> > m_goodSkipTable;
[-] 	BoyerMooreFindBase ()
[+] 	BoyerMooreFindBase()
[-] 	isEmpty ()
[+] 	isEmpty()
[-] 		return m_pattern.isEmpty ();
[+] 		return m_pattern.isEmpty();
[-] 	Array <T>
[+] 	Array<T>
[-] 	getPattern ()
[+] 	getPattern()
[-] 	getFlags ()
[+] 	getFlags()
[-] 	clear ()
[+] 	clear()
[-] 		m_pattern.clear ();
[+] 		m_pattern.clear();
[-] 		m_badSkipTable.clear ();
[+] 		m_badSkipTable.clear();
[-] 		m_goodSkipTable.clear ();
[+] 		m_goodSkipTable.clear();
[-] 	isPrefix (intptr_t pos)
[+] 	isPrefix(intptr_t pos)
[-] 		intptr_t suffixSize = m_pattern.getCount () - pos;
[+] 		intptr_t suffixSize = m_pattern.getCount() - pos;
[-] 			if (m_pattern [i] != m_pattern [j])
[+] 			if (m_pattern[i] != m_pattern[j])
[-] 	calcSuffixSize (intptr_t pos)
[+] 	calcSuffixSize(intptr_t pos)
[-] 		intptr_t k = m_pattern.getCount () - 1;
[+] 		intptr_t k = m_pattern.getCount() - 1;
[-] 		while (i < pos && m_pattern [j] == m_pattern [k])
[+] 		while (i < pos && m_pattern[j] == m_pattern[k])
[-] 	buildGoodSkipTable ()
[+] 	buildGoodSkipTable()
[-] 		intptr_t patternSize = m_pattern.getCount ();
[+] 		intptr_t patternSize = m_pattern.getCount();
[-] 		bool result = m_goodSkipTable.setCount (patternSize);
[+] 		bool result = m_goodSkipTable.setCount(patternSize);
[-] 			if (isPrefix (i + 1))
[+] 			if (isPrefix(i + 1))
[-] 			m_goodSkipTable [i] = lastPrefixPos + patternSize - 1 - i;
[+] 			m_goodSkipTable[i] = lastPrefixPos + patternSize - 1 - i;
[-] 			intptr_t suffixSize = calcSuffixSize (i);
[+] 			intptr_t suffixSize = calcSuffixSize(i);
[-] 			if (m_pattern [i - suffixSize] != m_pattern [patternSize - 1 - suffixSize])
[+] 			if (m_pattern[i - suffixSize] != m_pattern[patternSize - 1 - suffixSize])
[-] 				m_goodSkipTable [patternSize - 1 - suffixSize] = patternSize - 1 - i + suffixSize;
[+] 				m_goodSkipTable[patternSize - 1 - suffixSize] = patternSize - 1 - i + suffixSize;
[-] class BinaryBoyerMooreFind: public BoyerMooreFindBase <uchar_t>
[+] class BinaryBoyerMooreFind: public BoyerMooreFindBase<uchar_t>
[-] 	BinaryBoyerMooreFind ()
[+] 	BinaryBoyerMooreFind()
[-] 	BinaryBoyerMooreFind (
[+] 	BinaryBoyerMooreFind(
[-] 		setPattern (p, size, flags);
[+] 		setPattern(p, size, flags);
[-] 	setPattern (
[+] 	setPattern(
[-] 	find (
[+] 	find(
[-] 	find (
[+] 	find(
[-] 	buildBadSkipTable ();
[+] 	buildBadSkipTable();
[-] 	findImpl (
[+] 	findImpl(
[-] class TextBoyerMooreFind: public BoyerMooreFindBase <utf32_t>
[+] class TextBoyerMooreFind: public BoyerMooreFindBase<utf32_t>
[-] 	Array <utf32_t> m_buffer;
[+] 	Array<utf32_t> m_buffer;
[-] 	setPattern (
[+] 	setPattern(
[-] 	setPattern (
[+] 	setPattern(
[-] 		return setPattern (badSkipTableSize, enc::getCharCodec (codecKind), p, size, flags);
[+] 		return setPattern(badSkipTableSize, enc::getCharCodec(codecKind), p, size, flags);
[-] 	setPattern (
[+] 	setPattern(
[-] 		return setPattern (Def_BadSkipTableSize, codec, p, size, flags);
[+] 		return setPattern(Def_BadSkipTableSize, codec, p, size, flags);
[-] 	setPattern (
[+] 	setPattern(
[-] 		return setPattern (Def_BadSkipTableSize, codecKind, p, size, flags);
[+] 		return setPattern(Def_BadSkipTableSize, codecKind, p, size, flags);
[-] 	setPattern (
[+] 	setPattern(
[-] 		return setPattern (
[+] 		return setPattern(
[-] 			pattern.cp (),
[+] 			pattern.cp(),
[-] 			pattern.getLength (),
[+] 			pattern.getLength(),
[-] 	find (
[+] 	find(
[-] 	find (
[+] 	find(
[-] 		return find (enc::getCharCodec (codecKind), p, size);
[+] 		return find(enc::getCharCodec(codecKind), p, size);
[-] 	find (const sl::StringRef& string)
[+] 	find(const sl::StringRef& string)
[-] 		return find (enc::CharCodecKind_Utf8, string.cp (), string.getLength ());
[+] 		return find(enc::CharCodecKind_Utf8, string.cp(), string.getLength());
[-] 	find (
[+] 	find(
[-] 	find (
[+] 	find(
[-] 		return find (incrementalContext, enc::getCharCodec (codecKind), offset, p, size);
[+] 		return find(incrementalContext, enc::getCharCodec(codecKind), offset, p, size);
[-] 	find (
[+] 	find(
[-] 		return find (incrementalContext, enc::CharCodecKind_Utf8, offset, string.cp (), string.getLength ());
[+] 		return find(incrementalContext, enc::CharCodecKind_Utf8, offset, string.cp(), string.getLength());
[-] 	buildBadSkipTable (size_t tableSize);
[+] 	buildBadSkipTable(size_t tableSize);
[-] 	findImpl (
[+] 	findImpl(
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_BuddyAllocMap.h
----------------------
[-] 		AuxList <Page> m_availablePageList;
[+] 		AuxList<Page> m_availablePageList;
[-] 		getFirstPage ()
[+] 		getFirstPage()
[-] 		getFirstAvailablePage ()
[+] 		getFirstAvailablePage()
[-] 			return *m_availablePageList.getHead ();
[+] 			return *m_availablePageList.getHead();
[-] 		format (
[+] 		format(
[-] 		setPageMap (
[+] 		setPageMap(
[-] 		setBit (
[+] 		setBit(
[-] 		setBitRange (
[+] 		setBitRange(
[-] 	Array <Page> m_pageArray;
[+] 	Array<Page> m_pageArray;
[-] 	Array <Level> m_levelArray;
[+] 	Array<Level> m_levelArray;
[-] 	BuddyAllocMap ();
[+] 	BuddyAllocMap();
[-] 	create (
[+] 	create(
[-] 	close ();
[+] 	close();
[-] 	clear ();
[+] 	clear();
[-] 	getFreeSizeTop ()
[+] 	getFreeSizeTop()
[-] 	getFreeSizeBottom ()
[+] 	getFreeSizeBottom()
[-] 	getTotalSize ()
[+] 	getTotalSize()
[-] 	isEmpty ()
[+] 	isEmpty()
[-] 	allocate (size_t size);
[+] 	allocate(size_t size);
[-] 	mark (
[+] 	mark(
[-] 	free (
[+] 	free(
[-] 	getBit (size_t address)
[+] 	getBit(size_t address)
[-] 		return address < m_totalSize ? getBit (m_pageArray, address) : false;
[+] 		return address < m_totalSize ? getBit(m_pageArray, address) : false;
[-] 	getBit (
[+] 	getBit(
[-] 		return (page [pageIdx].m_map & mask) != 0;
[+] 		return (page[pageIdx].m_map & mask) != 0;
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_ByteOrder.h
----------------------
[-] swapByteOrder16 (uint16_t value)
[+] swapByteOrder16(uint16_t value)
[-] 	return _byteswap_ushort (value);
[+] 	return _byteswap_ushort(value);
[-] 	return __DARWIN_OSSwapInt16 (value);
[+] 	return __DARWIN_OSSwapInt16(value);
[-] 	return bswap_16 (value);
[+] 	return bswap_16(value);
[-] swapByteOrder32 (uint32_t value)
[+] swapByteOrder32(uint32_t value)
[-] 	return _byteswap_ulong (value);
[+] 	return _byteswap_ulong(value);
[-] 	return __DARWIN_OSSwapInt32 (value);
[+] 	return __DARWIN_OSSwapInt32(value);
[-] 	return bswap_32 (value);
[+] 	return bswap_32(value);
[-] swapByteOrder64 (uint64_t value)
[+] swapByteOrder64(uint64_t value)
[-] 	return _byteswap_uint64 (value);
[+] 	return _byteswap_uint64(value);
[-] 	return __DARWIN_OSSwapInt64 (value);
[+] 	return __DARWIN_OSSwapInt64(value);
[-] 	return bswap_64 (value);
[+] 	return bswap_64(value);
[-] swapByteOrder (
[+] swapByteOrder(
[-] 	switch (size)
[+] 	switch(size)
[-] 		*(uint16_t*) dst = swapByteOrder16 (*(uint16_t*)  src);
[+] 		*(uint16_t*)dst = swapByteOrder16(*(uint16_t*)  src);
[-] 		*(uint32_t*) dst = swapByteOrder32 (*(uint32_t*)  src);
[+] 		*(uint32_t*)dst = swapByteOrder32(*(uint32_t*)  src);
[-] 		*(uint64_t*) dst = swapByteOrder64 (*(uint64_t*)  src);
[+] 		*(uint64_t*)dst = swapByteOrder64(*(uint64_t*)  src);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_CallOnce.h
----------------------
[-] callOnce (
[+] callOnce(
[-] 		sys::atomicCmpXchg (flag, OnceFlag_Uninitialized, OnceFlag_Initializing) == OnceFlag_Uninitialized)
[+] 		sys::atomicCmpXchg(flag, OnceFlag_Uninitialized, OnceFlag_Initializing) == OnceFlag_Uninitialized)
[-] 		functor (argument);
[+] 		functor(argument);
[-] 		sys::atomicXchg (flag, OnceFlag_Initialized);
[+] 		sys::atomicXchg(flag, OnceFlag_Initialized);
[-] 		sys::yieldProcessor ();
[+] 		sys::yieldProcessor();
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_CharLiteral.h
----------------------
[-] 	operator () (char literalTable [] [4]) const
[+] 	operator () (char literalTable[] [4]) const
[-] 			_snprintf (literalTable [i], 4, "%c", i);
[+] 			_snprintf(literalTable[i], 4, "%c", i);
[-] getCharLiteral (uchar_t c)
[+] getCharLiteral(uchar_t c)
[-] 	static char literalTable [256] [4];
[+] 	static char literalTable[256] [4];
[-] 	sl::callOnce (InitCharLiteralTable (), literalTable);
[+] 	sl::callOnce(InitCharLiteralTable(), literalTable);
[-] 	return literalTable [c];
[+] 	return literalTable[c];
[-] 	operator () (char literalTable [] [4]) const
[+] 	operator () (char literalTable[] [4]) const
[-] 			_snprintf (literalTable [i], 4, "\\%02x", i);
[+] 			_snprintf(literalTable[i], 4, "\\%02x", i);
[-] getCharCodeLiteral (uchar_t c)
[+] getCharCodeLiteral(uchar_t c)
[-] 	static char literalTable [256] [4];
[+] 	static char literalTable[256] [4];
[-] 	sl::callOnce (InitCharCodeTable (), literalTable);
[+] 	sl::callOnce(InitCharCodeTable(), literalTable);
[-] 	return literalTable [c];
[+] 	return literalTable[c];
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_CircularBuffer.h
----------------------
[-] 	sl::Array <char> m_buffer;
[+] 	sl::Array<char> m_buffer;
[-] 	CircularBuffer ();
[+] 	CircularBuffer();
[-] 	isValid () const;
[+] 	isValid() const;
[-] 	isEmpty () const
[+] 	isEmpty() const
[-] 	isFull () const
[+] 	isFull() const
[-] 		ASSERT (isValid ());
[+] 		ASSERT(isValid());
[-] 		return m_dataSize == m_buffer.getCount ();
[+] 		return m_dataSize == m_buffer.getCount();
[-] 	getBufferSize () const
[+] 	getBufferSize() const
[-] 		return m_buffer.getCount ();
[+] 		return m_buffer.getCount();
[-] 	setBufferSize (size_t size);
[+] 	setBufferSize(size_t size);
[-] 	getDataSize () const
[+] 	getDataSize() const
[-] 	clear ();
[+] 	clear();
[-] 	readAll (sl::Array <char>* buffer);
[+] 	readAll(sl::Array<char>* buffer);
[-] 	sl::Array <char>
[+] 	sl::Array<char>
[-] 	readAll ()
[+] 	readAll()
[-] 		sl::Array <char> buffer;
[+] 		sl::Array<char> buffer;
[-] 		readAll (&buffer);
[+] 		readAll(&buffer);
[-] 	read (
[+] 	read(
[-] 	write (
[+] 	write(
[-] 	drop (size_t size);
[+] 	drop(size_t size);
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_Closure.h
----------------------
[-] 	BinClosure_1 (Arg a)
[+] 	BinClosure_1(Arg a)
[-] 		return Func () (m_a, b);
[+] 		return Func() (m_a, b);
[-] 	BinClosure_2 (Arg b)
[+] 	BinClosure_2(Arg b)
[-] 		return Func () (a, m_b);
[+] 		return Func() (a, m_b);
[-] 	AssignClosure_L (T& a)
[+] 	AssignClosure_L(T& a)
[-] 	AssignClosure_R (Arg b)
[+] 	AssignClosure_R(Arg b)
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_CmdLineParser.h
----------------------
[-] 	const char* m_nameTable [4]; // up to 4 alternative names
[+] 	const char* m_nameTable[4]; // up to 4 alternative names
[-] getCmdLineHelpString (const ConstList <SwitchInfo>& switchInfoList);
[+] getCmdLineHelpString(const ConstList<SwitchInfo>& switchInfoList);
[-] 	CmdLineParserRoot ()
[+] 	CmdLineParserRoot()
[-] 	getArgKind (const sl::StringRef& arg)
[+] 	getArgKind(const sl::StringRef& arg)
[-] 			arg.getLength () < 2 || arg [0] != '-' ? ArgKind_Value :
[+] 			arg.getLength() < 2 || arg[0] != '-' ? ArgKind_Value :
[-] 			arg [1] != '-' ? ArgKind_CharSwitch :
[+] 			arg[1] != '-' ? ArgKind_CharSwitch :
[-] 	extractArg (
[+] 	extractArg(
[-] 	parseSwitch (
[+] 	parseSwitch(
[-] 	parse (const sl::StringRef& cmdLine0)
[+] 	parse(const sl::StringRef& cmdLine0)
[-] 		sl::StringRef cmdLine (cmdLine0.cp (), cmdLine0.getLength ());
[+] 		sl::StringRef cmdLine(cmdLine0.cp(), cmdLine0.getLength());
[-] 		for (m_argIdx = 0; !cmdLine.isEmpty (); m_argIdx++)
[+] 		for (m_argIdx = 0; !cmdLine.isEmpty(); m_argIdx++)
[-] 			size_t length = extractArg (cmdLine, &arg);
[+] 			size_t length = extractArg(cmdLine, &arg);
[-] 			if (arg.isEmpty ())
[+] 			if (arg.isEmpty())
[-] 			result = processArg (arg);
[+] 			result = processArg(arg);
[-] 			cmdLine.offset (length);
[+] 			cmdLine.offset(length);
[-] 			checkMissingValue () &&
[+] 			checkMissingValue() &&
[-] 			static_cast <T*> (this)->finalize ();
[+] 			static_cast<T*> (this)->finalize();
[-] 	parse (
[+] 	parse(
[-] 			result = processArg (argv [i]);
[+] 			result = processArg(argv[i]);
[-] 			checkMissingValue () &&
[+] 			checkMissingValue() &&
[-] 			static_cast <T*> (this)->finalize ();
[+] 			static_cast<T*> (this)->finalize();
[-] 	parse (
[+] 	parse(
[-] 			result = processArg (sl::String (argv [i]));
[+] 			result = processArg(sl::String(argv[i]));
[-] 			checkMissingValue () &&
[+] 			checkMissingValue() &&
[-] 			static_cast <T*> (this)->finalize ();
[+] 			static_cast<T*> (this)->finalize();
[-] 	onValue0 (const sl::StringRef& value)
[+] 	onValue0(const sl::StringRef& value)
[-] 	onValue (const sl::StringRef& value)
[+] 	onValue(const sl::StringRef& value)
[-] 	onSwitch (
[+] 	onSwitch(
[-] 	finalize ()
[+] 	finalize()
[-] 	checkMissingValue ()
[+] 	checkMissingValue()
[-] 		err::setFormatStringError ("missing value for switch '%s'", m_valueSwitchName.sz ());
[+] 		err::setFormatStringError("missing value for switch '%s'", m_valueSwitchName.sz ());
[-] 	processArg (const sl::StringRef& arg)
[+] 	processArg(const sl::StringRef& arg)
[-] 		T* self = static_cast <T*> (this);
[+] 		T* self = static_cast<T*> (this);
[-] 			return self->onValue (arg);
[+] 			return self->onValue(arg);
[-] 		ArgKind argKind = getArgKind (arg);
[+] 		ArgKind argKind = getArgKind(arg);
[-] 		switch (argKind)
[+] 		switch(argKind)
[-] 			return processValue (arg);
[+] 			return processValue(arg);
[-] 			result = parseSwitch (argKind, arg.getSubString (2), &switchName, &value);
[+] 			result = parseSwitch(argKind, arg.getSubString(2), &switchName, &value);
[-] 			const SwitchInfo* switchInfo = SwitchTable::findSwitch (switchName);
[+] 			const SwitchInfo* switchInfo = SwitchTable::findSwitch(switchName);
[-] 				err::setFormatStringError ("unknown switch --%s", switchName.sz ());
[+] 				err::setFormatStringError("unknown switch --%s", switchName.sz ());
[-] 			return processSwitch (switchInfo, switchName, value);
[+] 			return processSwitch(switchInfo, switchName, value);
[-] 		ASSERT (argKind == ArgKind_CharSwitch);
[+] 		ASSERT(argKind == ArgKind_CharSwitch);
[-] 		size_t length = arg.getLength ();
[+] 		size_t length = arg.getLength();
[-] 			const SwitchInfo* switchInfo = SwitchTable::findSwitch (arg [i]);
[+] 			const SwitchInfo* switchInfo = SwitchTable::findSwitch(arg[i]);
[-] 				err::setFormatStringError ("unknown switch -%c", (uchar_t) arg [i]);
[+] 				err::setFormatStringError("unknown switch -%c", (uchar_t) arg [i]);
[-] 					parseSwitch (argKind, arg.getSubString (i), &switchName, &value) &&
[+] 					parseSwitch(argKind, arg.getSubString(i), &switchName, &value) &&
[-] 					processSwitch (switchInfo, switchName, value);
[+] 					processSwitch(switchInfo, switchName, value);
[-] 			result = self->onSwitch ((SwitchKind) switchInfo->m_switchKind, NULL);
[+] 			result = self->onSwitch((SwitchKind)switchInfo->m_switchKind, NULL);
[-] 	processValue (const sl::StringRef& value)
[+] 	processValue(const sl::StringRef& value)
[-] 		T* self = static_cast <T*> (this);
[+] 		T* self = static_cast<T*> (this);
[-] 			return m_argIdx == 0 ? self->onValue0 (value) : self->onValue (value);
[+] 			return m_argIdx == 0 ? self->onValue0(value) : self->onValue(value);
[-] 		bool result = self->onSwitch ((SwitchKind) m_valueSwitchKind, value);
[+] 		bool result = self->onSwitch((SwitchKind)m_valueSwitchKind, value);
[-] 	processSwitch (
[+] 	processSwitch(
[-] 		T* self = static_cast <T*> (this);
[+] 		T* self = static_cast<T*> (this);
[-] 		result = checkMissingValue ();
[+] 		result = checkMissingValue();
[-] 		if (switchInfo->m_value && value.isEmpty ())
[+] 		if (switchInfo->m_value && value.isEmpty())
[-] 		return self->onSwitch ((SwitchKind) switchInfo->m_switchKind, value);
[+] 		return self->onSwitch((SwitchKind)switchInfo->m_switchKind, value);
[-] 	typedef axl::sl::SimpleHashTable <char, SwitchInfo*> CharMap; \
[+] 	typedef axl::sl::SimpleHashTable<char, SwitchInfo*> CharMap; \
[-] 	typedef axl::sl::StringHashTable <SwitchInfo*> StringMap; \
[+] 	typedef axl::sl::StringHashTable<SwitchInfo*> StringMap; \
[-] 	axl::sl::AuxList <axl::sl::SwitchInfo> m_switchInfoList; \
[+] 	axl::sl::AuxList<axl::sl::SwitchInfo> m_switchInfoList; \
[-] 	getSingleton () \
[+] 	getSingleton() \
[-] 		return axl::sl::getSingleton <Class> (); \
[+] 		return axl::sl::getSingleton<Class> (); \
[-] 	axl::sl::ConstList <axl::sl::SwitchInfo> \
[+] 	axl::sl::ConstList<axl::sl::SwitchInfo> \
[-] 	getSwitchInfoList () \
[+] 	getSwitchInfoList() \
[-] 		return getSingleton ()->m_switchInfoList; \
[+] 		return getSingleton()->m_switchInfoList; \
[-] 	findSwitch (char c) \
[+] 	findSwitch(char c) \
[-] 		CharMap::Iterator it = getSingleton ()->m_charMap.find (c); \
[+] 		CharMap::Iterator it = getSingleton()->m_charMap.find(c); \
[-] 	findSwitch (const sl::StringRef& name) \
[+] 	findSwitch(const sl::StringRef& name) \
[-] 		StringMap::Iterator it = getSingleton ()->m_nameMap.find (name); \
[+] 		StringMap::Iterator it = getSingleton()->m_nameMap.find(name); \
[-] 	getHelpString () \
[+] 	getHelpString() \
[-] 		return axl::sl::getCmdLineHelpString (getSingleton ()->m_switchInfoList); \
[+] 		return axl::sl::getCmdLineHelpString(getSingleton()->m_switchInfoList); \
[-] 	Class () \
[+] 	Class() \
[-] 			switchInfo.m_nameTable [0] = name0; \
[+] 			switchInfo.m_nameTable[0] = name0; \
[-] 			switchInfo.m_nameTable [1] = name1; \
[+] 			switchInfo.m_nameTable[1] = name1; \
[-] 			switchInfo.m_nameTable [2] = name2; \
[+] 			switchInfo.m_nameTable[2] = name2; \
[-] 			switchInfo.m_nameTable [3] = name3; \
[+] 			switchInfo.m_nameTable[3] = name3; \
[-] 			m_switchInfoList.insertTail (&switchInfo); \
[+] 			m_switchInfoList.insertTail(&switchInfo); \
[-] 		ASSERT (name); \
[+] 		ASSERT(name); \
[-] 		if (name [1]) \
[+] 		if (name[1]) \
[-] 			m_nameMap [name] = lastSwitchInfo; \
[+] 			m_nameMap[name] = lastSwitchInfo; \
[-] 			m_charMap [name [0]] = lastSwitchInfo; \
[+] 			m_charMap[name[0]] = lastSwitchInfo; \
[-] 		AXL_SL_CMD_LINE_ADD_SWITCH_INFO (0, NULL, NULL, NULL, NULL, NULL, description)
[+] 		AXL_SL_CMD_LINE_ADD_SWITCH_INFO(0, NULL, NULL, NULL, NULL, NULL, description)
[-] 		AXL_SL_CMD_LINE_ADD_SWITCH_INFO (switchKind, name, NULL, NULL, NULL, value, description) \
[+] 		AXL_SL_CMD_LINE_ADD_SWITCH_INFO(switchKind, name, NULL, NULL, NULL, value, description) \
[-] 		AXL_SL_CMD_LINE_MAP_SWITCH (name)
[+] 		AXL_SL_CMD_LINE_MAP_SWITCH(name)
[-] 		AXL_SL_CMD_LINE_ADD_SWITCH_INFO (switchKind, name0, name1, NULL, NULL, value, description) \
[+] 		AXL_SL_CMD_LINE_ADD_SWITCH_INFO(switchKind, name0, name1, NULL, NULL, value, description) \
[-] 		AXL_SL_CMD_LINE_MAP_SWITCH (name0) \
[+] 		AXL_SL_CMD_LINE_MAP_SWITCH(name0) \
[-] 		AXL_SL_CMD_LINE_MAP_SWITCH (name1) \
[+] 		AXL_SL_CMD_LINE_MAP_SWITCH(name1) \
[-] 		AXL_SL_CMD_LINE_ADD_SWITCH_INFO (switchKind, name0, name1, name2, NULL, value, description) \
[+] 		AXL_SL_CMD_LINE_ADD_SWITCH_INFO(switchKind, name0, name1, name2, NULL, value, description) \
[-] 		AXL_SL_CMD_LINE_MAP_SWITCH (name0) \
[+] 		AXL_SL_CMD_LINE_MAP_SWITCH(name0) \
[-] 		AXL_SL_CMD_LINE_MAP_SWITCH (name1) \
[+] 		AXL_SL_CMD_LINE_MAP_SWITCH(name1) \
[-] 		AXL_SL_CMD_LINE_MAP_SWITCH (name2) \
[+] 		AXL_SL_CMD_LINE_MAP_SWITCH(name2) \
[-] 		AXL_SL_CMD_LINE_ADD_SWITCH_INFO (switchKind, name0, name1, name2, name3, value, description) \
[+] 		AXL_SL_CMD_LINE_ADD_SWITCH_INFO(switchKind, name0, name1, name2, name3, value, description) \
[-] 		AXL_SL_CMD_LINE_MAP_SWITCH (name0) \
[+] 		AXL_SL_CMD_LINE_MAP_SWITCH(name0) \
[-] 		AXL_SL_CMD_LINE_MAP_SWITCH (name1) \
[+] 		AXL_SL_CMD_LINE_MAP_SWITCH(name1) \
[-] 		AXL_SL_CMD_LINE_MAP_SWITCH (name2) \
[+] 		AXL_SL_CMD_LINE_MAP_SWITCH(name2) \
[-] 		AXL_SL_CMD_LINE_MAP_SWITCH (name3)
[+] 		AXL_SL_CMD_LINE_MAP_SWITCH(name3)
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_Cmp.h
----------------------
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 		return memcmp (&a, &b, sizeof (T));
[+] 		return memcmp(&a, &b, sizeof(T));
[-] 		return C () (*a, *b);
[+] 		return C() (*a, *b);
[-] class CmpSzBase <char>
[+] class CmpSzBase<char>
[-] 		return p1 ? p2 ? strcmp (p1, p2) : 1 : p2 ? -1 : 0;
[+] 		return p1 ? p2 ? strcmp(p1, p2) : 1 : p2 ? -1 : 0;
[-] class CmpSzBase_i <char>
[+] class CmpSzBase_i<char>
[-] 		return p1 ? p2 ? _stricmp (p1, p2) : 1 : p2 ? -1 : 0;
[+] 		return p1 ? p2 ? _stricmp(p1, p2) : 1 : p2 ? -1 : 0;
[-] class CmpSzBase <wchar_t>
[+] class CmpSzBase<wchar_t>
[-] 		return p1 ? p2 ? wcscmp (p1, p2) : 1 : p2 ? -1 : 0;
[+] 		return p1 ? p2 ? wcscmp(p1, p2) : 1 : p2 ? -1 : 0;
[-] class CmpSzBase_i <wchar_t>
[+] class CmpSzBase_i<wchar_t>
[-] 		return p1 ? p2 ? _wcsicmp (p1, p2) : 1 : p2 ? -1 : 0;
[+] 		return p1 ? p2 ? _wcsicmp(p1, p2) : 1 : p2 ? -1 : 0;
[-] typedef CmpSzBase <char>      CmpSz;
[+] typedef CmpSzBase<char>      CmpSz;
[-] typedef CmpSzBase <wchar_t>   CmpSz_w;
[+] typedef CmpSzBase<wchar_t>   CmpSz_w;
[-] typedef CmpSzBase_i <char>    CmpSz_i;
[+] typedef CmpSzBase_i<char>    CmpSz_i;
[-] typedef CmpSzBase_i <wchar_t> CmpSz_wi;
[+] typedef CmpSzBase_i<wchar_t> CmpSz_wi;
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 		return a.cmp (b);
[+] 		return a.cmp(b);
[-] 		return a->cmp (*b);
[+] 		return a->cmp(*b);
[-] 		return a.cmp (&b);
[+] 		return a.cmp(&b);
[-] 		return a->cmp (b);
[+] 		return a->cmp(b);
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_Construct.h
----------------------
[-] construct (T* p)
[+] construct(T* p)
[-] 	new (p) T;
[+] 	new(p)T;
[-] construct (
[+] construct(
[-] 	new (p) T (arg);
[+] 	new(p)T(arg);
[-] construct (
[+] construct(
[-] 	new (p) T (arg1, arg2);
[+] 	new(p)T(arg1, arg2);
[-] construct (
[+] construct(
[-] 	new (p) T (arg1, arg2, arg3);
[+] 	new(p)T(arg1, arg2, arg3);
[-] construct (
[+] construct(
[-] 	new (p) T (arg1, arg2, arg3, arg4);
[+] 	new(p)T(arg1, arg2, arg3, arg4);
[-] destruct (T* p)
[+] destruct(T* p)
[-] 	p->~T ();
[+] 	p->~T();
[-] takeOver (
[+] takeOver(
[-] 	dst->~T ();
[+] 	dst->~T();
[-] 	memcpy (dst, src, sizeof (T));
[+] 	memcpy(dst, src, sizeof(T));
[-] 	new (src) T;
[+] 	new(src)T;
[-] 		new (p) T;
[+] 		new(p)T;
[-] 		p->~T ();
[+] 		p->~T();
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_ForEach.h
----------------------
[-] loopArray (
[+] loopArray(
[-] 		action (*p);
[+] 		action(*p);
[-] loopIterator (
[+] loopIterator(
[-] 		action (*it);
[+] 		action(*it);
[-] filteredLoopArray (
[+] filteredLoopArray(
[-] 		if (filter (*p))
[+] 		if (filter(*p))
[-] 			action (*p);
[+] 			action(*p);
[-] filteredLoopIterator (
[+] filteredLoopIterator(
[-] 		if (filter (*it))
[+] 		if (filter(*it))
[-] 			action (*it);
[+] 			action(*it);
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_Guid.h
----------------------
[-] 			uint8_t m_data4 [8];
[+] 			uint8_t m_data4[8];
[-] 		return isEqual (guid);
[+] 		return isEqual(guid);
[-] 		return !isEqual (guid);
[+] 		return !isEqual(guid);
[-] 	cmp (const Guid& guid) const
[+] 	cmp(const Guid& guid) const
[-] 		return memcmp (this, &guid, sizeof (Guid));
[+] 		return memcmp(this, &guid, sizeof(Guid));
[-] 	hash () const
[+] 	hash() const
[-] 		return djb2 (this, sizeof (Guid));
[+] 		return djb2(this, sizeof(Guid));
[-] 	isNull () const
[+] 	isNull() const
[-] 	isEqual (const Guid& guid) const
[+] 	isEqual(const Guid& guid) const
[-] 	getString (uint_t flags = 0) const;
[+] 	getString(uint_t flags = 0) const;
[-] 	setup (
[+] 	setup(
[-] 		m_data4 [0] = b1;
[+] 		m_data4[0] = b1;
[-] 		m_data4 [1] = b2;
[+] 		m_data4[1] = b2;
[-] 		m_data4 [2] = b3;
[+] 		m_data4[2] = b3;
[-] 		m_data4 [3] = b4;
[+] 		m_data4[3] = b4;
[-] 		m_data4 [4] = b5;
[+] 		m_data4[4] = b5;
[-] 		m_data4 [5] = b6;
[+] 		m_data4[5] = b6;
[-] 		m_data4 [6] = b7;
[+] 		m_data4[6] = b7;
[-] 		m_data4 [7] = b8;
[+] 		m_data4[7] = b8;
[-] 	parse (const sl::StringRef& string);
[+] 	parse(const sl::StringRef& string);
[-] 	generate ();
[+] 	generate();
[-] buildGuid (
[+] buildGuid(
[-] 	guid.setup (l, s1, s2, b1, b2, b3, b4, b5, b6, b7, b8);
[+] 	guid.setup(l, s1, s2, b1, b2, b3, b4, b5, b6, b7, b8);
[-] parseGuid (const sl::StringRef& string)
[+] parseGuid(const sl::StringRef& string)
[-] 	guid.parse (string);
[+] 	guid.parse(string);
[-] generateGuid ()
[+] generateGuid()
[-] 	guid.generate ();
[+] 	guid.generate();
[-] 		AXL_SL_GUID_INITIALIZER (l, s1, s2, b1, b2,  b3,  b4,  b5,  b6,  b7,  b8)
[+] 		AXL_SL_GUID_INITIALIZER(l, s1, s2, b1, b2,  b3,  b4,  b5,  b6,  b7,  b8)
[-] AXL_SL_DEFINE_GUID (g_nullGuid, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);
[+] AXL_SL_DEFINE_GUID(g_nullGuid, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_Handle.h
----------------------
[-] 	typename Close = Void <T>,
[+] 	typename Close = Void<T>,
[-] 	typename GetInvalidHandle = Zero <T>
[+] 	typename GetInvalidHandle = Zero<T>
[-] 	Handle ()
[+] 	Handle()
[-] 		m_h = GetInvalidHandle () ();
[+] 		m_h = GetInvalidHandle() ();
[-] 	Handle (T h)
[+] 	Handle(T h)
[-] 	~Handle ()
[+] 	~Handle()
[-] 		close ();
[+] 		close();
[-] 	getInvalidHandle ()
[+] 	getInvalidHandle()
[-] 		return GetInvalidHandle () ();
[+] 		return GetInvalidHandle() ();
[-] 	operator T () const
[+] 	operator T() const
[-] 		attach (h);
[+] 		attach(h);
[-] 	isOpen () const
[+] 	isOpen() const
[-] 		return m_h != GetInvalidHandle () ();
[+] 		return m_h != GetInvalidHandle() ();
[-] 	close ()
[+] 	close()
[-] 		if (isOpen ())
[+] 		if (isOpen())
[-] 			Close () (m_h);
[+] 			Close() (m_h);
[-] 			m_h = GetInvalidHandle () ();
[+] 			m_h = GetInvalidHandle() ();
[-] 	attach (T h)
[+] 	attach(T h)
[-] 		close ();
[+] 		close();
[-] 	detach ()
[+] 	detach()
[-] 		m_h = GetInvalidHandle () ();
[+] 		m_h = GetInvalidHandle() ();
[-] 	p ()
[+] 	p()
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_HandleTable.h
----------------------
[-] class HandleTableIteratorBase: public Iterator <HashTableEntry <Key, Value> >
[+] class HandleTableIteratorBase: public Iterator<HashTableEntry<Key, Value> >
[-] 	HandleTableIteratorBase ()
[+] 	HandleTableIteratorBase()
[-] 	HandleTableIteratorBase (const Iterator <HashTableEntry <Key, Value> >& src)
[+] 	HandleTableIteratorBase(const Iterator<HashTableEntry<Key, Value> >& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] class ConstHandleTableIteratorBase: public ConstIterator <HashTableEntry <Key, Value> >
[+] class ConstHandleTableIteratorBase: public ConstIterator<HashTableEntry<Key, Value> >
[-] 	ConstHandleTableIteratorBase ()
[+] 	ConstHandleTableIteratorBase()
[-] 	ConstHandleTableIteratorBase (const ConstIterator <HashTableEntry <Key, Value> >& src)
[+] 	ConstHandleTableIteratorBase(const ConstIterator<HashTableEntry<Key, Value> >& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] class HandleTableIterator: public HandleTableIteratorBase <uintptr_t, T>
[+] class HandleTableIterator: public HandleTableIteratorBase<uintptr_t, T>
[-] 	HandleTableIterator ()
[+] 	HandleTableIterator()
[-] 	HandleTableIterator (const Iterator <HashTableEntry <uintptr_t, T> >& src)
[+] 	HandleTableIterator(const Iterator<HashTableEntry<uintptr_t, T> >& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] class ConstHandleTableIterator: public ConstHandleTableIteratorBase <uintptr_t, T>
[+] class ConstHandleTableIterator: public ConstHandleTableIteratorBase<uintptr_t, T>
[-] 	ConstHandleTableIterator ()
[+] 	ConstHandleTableIterator()
[-] 	ConstHandleTableIterator (const ConstIterator <HashTableEntry <uintptr_t, T> >& src)
[+] 	ConstHandleTableIterator(const ConstIterator<HashTableEntry<uintptr_t, T> >& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] 	typename ValueArg = typename ArgType <Value>::Type
[+] 	typename ValueArg = typename ArgType<Value>::Type
[-] class HandleTableBase: public HashTable <
[+] class HandleTableBase: public HashTable<
[-] 	HashId <Key>,
[+] 	HashId<Key>,
[-] 	Eq <Key>,
[+] 	Eq<Key>,
[-] 	HandleTableBase (Key seed = 1)
[+] 	HandleTableBase(Key seed = 1)
[-] 	reset (Key seed = 1)
[+] 	reset(Key seed = 1)
[-] 		this->clear ();
[+] 		this->clear();
[-] 	add (ValueArg value)
[+] 	add(ValueArg value)
[-] 		return add (m_seed, value);
[+] 		return add(m_seed, value);
[-] 	add (
[+] 	add(
[-] 			if (!this->find (key))
[+] 			if (!this->find(key))
[-] 		ASSERT (key);
[+] 		ASSERT(key);
[-] 		typename HandleTableBase::Iterator it = this->visit (key);
[+] 		typename HandleTableBase::Iterator it = this->visit(key);
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] class HandleTable: public HandleTableBase <uintptr_t, T, Arg>
[+] class HandleTable: public HandleTableBase<uintptr_t, T, Arg>
[-] 	HandleTable (uintptr_t seed = 1):
[+] 	HandleTable(uintptr_t seed = 1):
[-] 		HandleTableBase <uintptr_t, T, Arg> (seed)
[+] 		HandleTableBase<uintptr_t, T, Arg> (seed)
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_Hash.h
----------------------
[-] djb2 ()
[+] djb2()
[-] djb2 (
[+] djb2(
[-] djb2 (
[+] djb2(
[-] 	return djb2 (5381, p, size);
[+] 	return djb2(5381, p, size);
[-] djb2_op (
[+] djb2_op(
[-] 		utf8_t c = op (*p);
[+] 		utf8_t c = op(*p);
[-] djb2_op (
[+] djb2_op(
[-] 		utf16_t c = op (*p);
[+] 		utf16_t c = op(*p);
[-] djb2_op (
[+] djb2_op(
[-] 		utf32_t c = op (*p);
[+] 		utf32_t c = op(*p);
[-] djb2_op (
[+] djb2_op(
[-] 		T c = op (*p);
[+] 		T c = op(*p);
[-] 		hash = djb2 (hash, &c, sizeof (c));
[+] 		hash = djb2(hash, &c, sizeof(c));
[-] djb2_op (
[+] djb2_op(
[-] 	return djb2_op (op, 5381, p, length);
[+] 	return djb2_op(op, 5381, p, length);
[-] checksum16 (
[+] checksum16(
[-] 		return djb2 (key, sizeof (T));
[+] 		return djb2(key, sizeof(T));
[-] 		return djb2 (&key, sizeof (T));
[+] 		return djb2(&key, sizeof(T));
[-] 		return checksum16 (key, sizeof (T));
[+] 		return checksum16(key, sizeof(T));
[-] 		return checksum16 (&key, sizeof (T));
[+] 		return checksum16(&key, sizeof(T));
[-] 		return (size_t) key;
[+] 		return (size_t)key;
[-] 		return H () (*a, *b);
[+] 		return H() (*a, *b);
[-] class HashSzBase <char>
[+] class HashSzBase<char>
[-] 		return djb2 (p, strlen_s (p));
[+] 		return djb2(p, strlen_s(p));
[-] class HashSzBase <wchar_t>
[+] class HashSzBase<wchar_t>
[-] 		return djb2 (p, wcslen_s (p) * sizeof (wchar_t));
[+] 		return djb2(p, wcslen_s(p)* sizeof(wchar_t));
[-] typedef HashSzBase <char>    HashSz;
[+] typedef HashSzBase<char>    HashSz;
[-] typedef HashSzBase <wchar_t> HashSz_w;
[+] typedef HashSzBase<wchar_t> HashSz_w;
[-] typedef HashSzBase <utf8_t>  HashSz_utf8;
[+] typedef HashSzBase<utf8_t>  HashSz_utf8;
[-] typedef HashSzBase <utf16_t> HashSz_utf16;
[+] typedef HashSzBase<utf16_t> HashSz_utf16;
[-] typedef HashSzBase <utf32_t> HashSz_utf32;
[+] typedef HashSzBase<utf32_t> HashSz_utf32;
[-] class HashSzBase_i <char>
[+] class HashSzBase_i<char>
[-] 		return djb2_op (tolower, p, strlen_s (p));
[+] 		return djb2_op(tolower, p, strlen_s(p));
[-] class HashSzBase_i <wchar_t>
[+] class HashSzBase_i<wchar_t>
[-] 		return djb2_op (towlower, p, wcslen_s (p) * sizeof (wchar_t));
[+] 		return djb2_op(towlower, p, wcslen_s(p)* sizeof(wchar_t));
[-] typedef HashSzBase_i <char>    HashSz_i;
[+] typedef HashSzBase_i<char>    HashSz_i;
[-] typedef HashSzBase_i <wchar_t> HashSz_i_w;
[+] typedef HashSzBase_i<wchar_t> HashSz_i_w;
[-] typedef HashSzBase_i <utf8_t>  HashSz_i_utf8;
[+] typedef HashSzBase_i<utf8_t>  HashSz_i_utf8;
[-] typedef HashSzBase_i <utf16_t> HashSz_i_utf16;
[+] typedef HashSzBase_i<utf16_t> HashSz_i_utf16;
[-] typedef HashSzBase_i <utf32_t> HashSz_i_utf32;
[+] typedef HashSzBase_i<utf32_t> HashSz_i_utf32;
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 		return a.hash ();
[+] 		return a.hash();
[-] 		return a->hash ();
[+] 		return a->hash();
----------------------
27/02/2019 18:01:43 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_HashTable.h
----------------------
[-] struct HashTableEntry: MapEntry <Key, Value>
[+] struct HashTableEntry: MapEntry<Key, Value>
[-] 	typedef AuxList <HashTableEntry, BucketLink> Bucket;
[+] 	typedef AuxList<HashTableEntry, BucketLink> Bucket;
[-] class HashTableIterator: public Iterator <HashTableEntry <Key, Value> >
[+] class HashTableIterator: public Iterator<HashTableEntry<Key, Value> >
[-] 	HashTableIterator ()
[+] 	HashTableIterator()
[-] 	HashTableIterator (const Iterator <HashTableEntry <Key, Value> >& src)
[+] 	HashTableIterator(const Iterator<HashTableEntry<Key, Value> >& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] class ConstHashTableIterator: public ConstIterator <HashTableEntry <Key, Value> >
[+] class ConstHashTableIterator: public ConstIterator<HashTableEntry<Key, Value> >
[-] 	ConstHashTableIterator ()
[+] 	ConstHashTableIterator()
[-] 	ConstHashTableIterator (const ConstIterator <HashTableEntry <Key, Value> >& src)
[+] 	ConstHashTableIterator(const ConstIterator<HashTableEntry<Key, Value> >& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] 	typename Eq = Eq <Key>,
[+] 	typename Eq = Eq<Key>,
[-] 	typename KeyArg = typename ArgType <Key>::Type,
[+] 	typename KeyArg = typename ArgType<Key>::Type,
[-] 	typename ValueArg = typename ArgType <Value>::Type
[+] 	typename ValueArg = typename ArgType<Value>::Type
[-] 	typedef HashTableEntry <Key, Value> Entry;
[+] 	typedef HashTableEntry<Key, Value> Entry;
[-] 	typedef sl::Iterator <Entry> Iterator;
[+] 	typedef sl::Iterator<Entry> Iterator;
[-] 	typedef sl::ConstIterator <Entry> ConstIterator;
[+] 	typedef sl::ConstIterator<Entry> ConstIterator;
[-] 	List <Entry> m_list;
[+] 	List<Entry> m_list;
[-] 	Array <Bucket> m_table;
[+] 	Array<Bucket> m_table;
[-] 	explicit HashTable (
[+] 	explicit HashTable(
[-] 		const Hash& hash = Hash (),
[+] 		const Hash& hash = Hash(),
[-] 		const Eq& eq = Eq ()
[+] 		const Eq& eq = Eq()
[-] 		return this->visit (key)->m_value;
[+] 		return this->visit(key)->m_value;
[-] 	clear ()
[+] 	clear()
[-] 		m_table.clear ();
[+] 		m_table.clear();
[-] 		m_list.clear ();
[+] 		m_list.clear();
[-] 	isEmpty () const
[+] 	isEmpty() const
[-] 		return m_list.isEmpty ();
[+] 		return m_list.isEmpty();
[-] 	getHead ()
[+] 	getHead()
[-] 		return m_list.getHead ();
[+] 		return m_list.getHead();
[-] 	getHead () const
[+] 	getHead() const
[-] 		return m_list.getHead ();
[+] 		return m_list.getHead();
[-] 	getTail ()
[+] 	getTail()
[-] 		return m_list.getHead ();
[+] 		return m_list.getHead();
[-] 	getTail () const
[+] 	getTail() const
[-] 		return m_list.getHead ();
[+] 		return m_list.getHead();
[-] 	getCount () const
[+] 	getCount() const
[-] 		return m_list.getCount ();
[+] 		return m_list.getCount();
[-] 	getBucketCount () const
[+] 	getBucketCount() const
[-] 		return m_table.getCount ();
[+] 		return m_table.getCount();
[-] 	setBucketCount (size_t bucketCount)
[+] 	setBucketCount(size_t bucketCount)
[-] 		Array <Bucket> newTable;
[+] 		Array<Bucket> newTable;
[-] 		bool result = newTable.setCount (bucketCount);
[+] 		bool result = newTable.setCount(bucketCount);
[-] 		size_t oldBucketCount = m_table.getCount ();
[+] 		size_t oldBucketCount = m_table.getCount();
[-] 			Bucket* oldBucket = &m_table [i];
[+] 			Bucket* oldBucket = &m_table[i];
[-] 			while (!oldBucket->isEmpty ())
[+] 			while (!oldBucket->isEmpty())
[-] 				Entry* entry = oldBucket->removeHead ();
[+] 				Entry* entry = oldBucket->removeHead();
[-] 				size_t hash = m_hash (entry->m_key);
[+] 				size_t hash = m_hash(entry->m_key);
[-] 				Bucket* newBucket = &newTable [hash % bucketCount];
[+] 				Bucket* newBucket = &newTable[hash % bucketCount];
[-] 				newBucket->insertTail (entry);
[+] 				newBucket->insertTail(entry);
[-] 	getResizeThreshold () const
[+] 	getResizeThreshold() const
[-] 	setResizeThreshold (size_t resizeThreshold)
[+] 	setResizeThreshold(size_t resizeThreshold)
[-] 	find (KeyArg key)
[+] 	find(KeyArg key)
[-] 		size_t bucketCount = m_table.getCount ();
[+] 		size_t bucketCount = m_table.getCount();
[-] 		size_t hash = m_hash (key);
[+] 		size_t hash = m_hash(key);
[-] 		Bucket* bucket = &m_table [hash % bucketCount];
[+] 		Bucket* bucket = &m_table[hash % bucketCount];
[-] 		typename Bucket::Iterator it = bucket->getHead ();
[+] 		typename Bucket::Iterator it = bucket->getHead();
[-] 			bool isEqual = m_eq (key, it->m_key);
[+] 			bool isEqual = m_eq(key, it->m_key);
[-] 	find (KeyArg key) const
[+] 	find(KeyArg key) const
[-] 		return ((HashTable*) this)->find (key); // a simple const-cast
[+] 		return ((HashTable*)this)->find(key); // a simple const-cast
[-] 	findValue (
[+] 	findValue(
[-] 		ConstIterator it = this->find (key);
[+] 		ConstIterator it = this->find(key);
[-] 	visit (KeyArg key)
[+] 	visit(KeyArg key)
[-] 		size_t bucketCount = m_table.getCount ();
[+] 		size_t bucketCount = m_table.getCount();
[-] 			bool result = m_table.setCount (bucketCount);
[+] 			bool result = m_table.setCount(bucketCount);
[-] 		size_t hash = m_hash (key);
[+] 		size_t hash = m_hash(key);
[-] 		Bucket* bucket = &m_table [hash % bucketCount];
[+] 		Bucket* bucket = &m_table[hash % bucketCount];
[-] 		typename Bucket::Iterator it = bucket->getHead ();
[+] 		typename Bucket::Iterator it = bucket->getHead();
[-] 			bool isEqual = m_eq (key, it->m_key);
[+] 			bool isEqual = m_eq(key, it->m_key);
[-] 		Entry* entry = AXL_MEM_ZERO_NEW (Entry);
[+] 		Entry* entry = AXL_MEM_ZERO_NEW(Entry);
[-] 		m_list.insertTail (entry);
[+] 		m_list.insertTail(entry);
[-] 		bucket->insertTail (entry);
[+] 		bucket->insertTail(entry);
[-] 		size_t loadFactor = getCount () * 100 / bucketCount;
[+] 		size_t loadFactor = getCount() * 100 / bucketCount;
[-] 		size_t loadFactor = (size_t) ((uint64_t) getCount () * 100 / bucketCount);
[+] 		size_t loadFactor = (size_t)((uint64_t)getCount() * 100 / bucketCount);
[-] 			setBucketCount (bucketCount * 2);
[+] 			setBucketCount(bucketCount * 2);
[-] 	add (
[+] 	add(
[-] 		size_t prevCount = this->getCount ();
[+] 		size_t prevCount = this->getCount();
[-] 		Iterator it = this->visit (key);
[+] 		Iterator it = this->visit(key);
[-] 			*isNew = this->getCount () > prevCount;
[+] 			*isNew = this->getCount() > prevCount;
[-] 	addIfNotExists (
[+] 	addIfNotExists(
[-] 		size_t prevCount = this->getCount ();
[+] 		size_t prevCount = this->getCount();
[-] 		Iterator it = this->visit (key);
[+] 		Iterator it = this->visit(key);
[-] 		if (this->getCount () == prevCount)
[+] 		if (this->getCount() == prevCount)
[-] 	erase (Iterator it)
[+] 	erase(Iterator it)
[-] 		entry->m_bucket->remove (entry);
[+] 		entry->m_bucket->remove(entry);
[-] 		m_list.remove (entry);
[+] 		m_list.remove(entry);
[-] 		AXL_MEM_DELETE (entry);
[+] 		AXL_MEM_DELETE(entry);
[-] 	eraseKey (KeyArg key)
[+] 	eraseKey(KeyArg key)
[-] 		Iterator it = find (key);
[+] 		Iterator it = find(key);
[-] 		erase (it);
[+] 		erase(it);
[-] 	typename KeyArg = typename ArgType <Key>::Type,
[+] 	typename KeyArg = typename ArgType<Key>::Type,
[-] 	typename ValueArg = typename ArgType <Value>::Type
[+] 	typename ValueArg = typename ArgType<Value>::Type
[-] class SimpleHashTable: public HashTable <
[+] class SimpleHashTable: public HashTable<
[-] 	sl::HashId <Key>,
[+] 	sl::HashId<Key>,
[-] 	sl::Eq <Key>,
[+] 	sl::Eq<Key>,
[-] 	typename KeyArg = typename ArgType <Key>::Type,
[+] 	typename KeyArg = typename ArgType<Key>::Type,
[-] 	typename ValueArg = typename ArgType <Value>::Type
[+] 	typename ValueArg = typename ArgType<Value>::Type
[-] class DuckTypeHashTable: public HashTable <
[+] class DuckTypeHashTable: public HashTable<
[-] 	sl::HashDuckType <Key>,
[+] 	sl::HashDuckType<Key>,
[-] 	sl::EqDuckType <Key>,
[+] 	sl::EqDuckType<Key>,
[-] 	typename ValueArg = typename ArgType <Value>::Type
[+] 	typename ValueArg = typename ArgType<Value>::Type
[-] class DuckTypePtrHashTable: public HashTable <
[+] class DuckTypePtrHashTable: public HashTable<
[-] 	sl::HashDuckType <Key>,
[+] 	sl::HashDuckType<Key>,
[-] 	sl::EqDuckType <Key>,
[+] 	sl::EqDuckType<Key>,
[-] 	typedef axl::sl::HashTable <Key, Value, Hash, Eq, KeyArg, ValueArg> MapBase; \
[+] 	typedef axl::sl::HashTable<Key, Value, Hash, Eq, KeyArg, ValueArg> MapBase; \
[-] 	find (KeyArg key) \
[+] 	find(KeyArg key) \
[-] 		return axl::sl::getSingleton <Map> ()->find (key); \
[+] 		return axl::sl::getSingleton<Map> ()->find(key); \
[-] 		return axl::sl::getSingleton <Map> ()->findValue (key, undefinedValue); \
[+] 		return axl::sl::getSingleton<Map> ()->findValue(key, undefinedValue); \
[-] 		Map () \
[+] 		Map() \
[-] 			visit (key)->m_value = value;
[+] 			visit(key)->m_value = value;
[-] 		axl::sl::Eq <Key>, \
[+] 		axl::sl::Eq<Key>, \
[-] 		axl::sl::ArgType <Key>::Type, \
[+] 		axl::sl::ArgType<Key>::Type, \
[-] 		axl::sl::ArgType <Value>::Type \
[+] 		axl::sl::ArgType<Value>::Type \
[-] 		axl::sl::HashId <Key> \
[+] 		axl::sl::HashId<Key> \
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 		axl::sl::HashDuckType <Key>, \
[+] 		axl::sl::HashDuckType<Key>, \
[-] 		axl::sl::EqDuckType <Key>, \
[+] 		axl::sl::EqDuckType<Key>, \
[-] 		axl::sl::ArgType <Key>::Type, \
[+] 		axl::sl::ArgType<Key>::Type, \
[-] 		axl::sl::ArgType <Value>::Type \
[+] 		axl::sl::ArgType<Value>::Type \
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_Iterator.h
----------------------
[-] 	getNext ()
[+] 	getNext()
[-] 	getPrev ()
[+] 	getPrev()
[-] 	IteratorBase ()
[+] 	IteratorBase()
[-] 		return next ();
[+] 		return next();
[-] 		return prev ();
[+] 		return prev();
[-] 		T old = *(T*) this;
[+] 		T old = *(T*)this;
[-] 		next ();
[+] 		next();
[-] 		T old = *(T*) this;
[+] 		T old = *(T*)this;
[-] 		prev ();
[+] 		prev();
[-] 		return inc (count);
[+] 		return inc(count);
[-] 		return inc (-count);
[+] 		return inc(-count);
[-] 		return getInc (count);
[+] 		return getInc(count);
[-] 		return getInc (-count);
[+] 		return getInc(-count);
[-] 	next ()
[+] 	next()
[-] 			m_p = getEntryFromLink (getLink ()->m_next);
[+] 			m_p = getEntryFromLink(getLink()->m_next);
[-] 		return *(T*) this;
[+] 		return *(T*)this;
[-] 	prev ()
[+] 	prev()
[-] 			m_p = getEntryFromLink (getLink ()->m_prev);
[+] 			m_p = getEntryFromLink(getLink()->m_prev);
[-] 		return *(T*) this;
[+] 		return *(T*)this;
[-] 	inc (intptr_t count)
[+] 	inc(intptr_t count)
[-] 		Link* link = getLink ();
[+] 		Link* link = getLink();
[-] 		m_p = getEntryFromLink (link);
[+] 		m_p = getEntryFromLink(link);
[-] 		return *(T*) this;
[+] 		return *(T*)this;
[-] 	getNext () const
[+] 	getNext() const
[-] 		return IteratorBase (*this).next ();
[+] 		return IteratorBase(*this).next();
[-] 	getPrev () const
[+] 	getPrev() const
[-] 		return IteratorBase (*this).prev ();
[+] 		return IteratorBase(*this).prev();
[-] 	getInc (intptr_t count) const
[+] 	getInc(intptr_t count) const
[-] 		return IteratorBase (*this).inc (count);
[+] 		return IteratorBase(*this).inc(count);
[-] 	getEntry () const
[+] 	getEntry() const
[-] 	getLink () const
[+] 	getLink() const
[-] 		return m_p ? GetLink () (m_p) : NULL;
[+] 		return m_p ? GetLink() (m_p) : NULL;
[-] 	getEntryFromLink (Link* p)
[+] 	getEntryFromLink(Link* p)
[-] 		return p ? (Entry*) ((char*) p  + 1 - (size_t) GetLink () ((Entry*) 1)) : NULL;
[+] 		return p ? (Entry*)((char*)p  + 1 - (size_t)GetLink() ((Entry*) 1)) : NULL;
[-] 	getLinkFromEntry (Entry* p)
[+] 	getLinkFromEntry(Entry* p)
[-] 		return p ? GetLink () (p) : NULL;
[+] 		return p ? GetLink() (p) : NULL;
[-] 	fromLink (Link* p)
[+] 	fromLink(Link* p)
[-] 		it.m_p = getEntryFromLink (p);
[+] 		it.m_p = getEntryFromLink(p);
[-] 	typename GetLink = ImplicitPtrCast <T, ListLink>
[+] 	typename GetLink = ImplicitPtrCast<T, ListLink>
[-] class IteratorImpl: public IteratorBase <
[+] class IteratorImpl: public IteratorBase<
[-] 	Entry* p () const
[+] 	Entry* p() const
[-] 	typename GetLink = ImplicitPtrCast <T, ListLink>
[+] 	typename GetLink = ImplicitPtrCast<T, ListLink>
[-] class Iterator: public IteratorImpl <
[+] class Iterator: public IteratorImpl<
[-] 	Iterator <T, GetLink>,
[+] 	Iterator<T, GetLink>,
[-] 	Iterator ()
[+] 	Iterator()
[-] 	Iterator (const Iterator <T2, GetLink2>& src)
[+] 	Iterator(const Iterator<T2, GetLink2>& src)
[-] 	Iterator (T* p)
[+] 	Iterator(T* p)
[-] 	typename GetLink = ImplicitPtrCast <T, ListLink>
[+] 	typename GetLink = ImplicitPtrCast<T, ListLink>
[-] class ConstIterator: public IteratorImpl <
[+] class ConstIterator: public IteratorImpl<
[-] 	ConstIterator <T, GetLink>,
[+] 	ConstIterator<T, GetLink>,
[-] 	ConstIterator ()
[+] 	ConstIterator()
[-] 	ConstIterator (const Iterator <T2, GetLink2>& src)
[+] 	ConstIterator(const Iterator<T2, GetLink2>& src)
[-] 	ConstIterator (const ConstIterator <T2, GetLink2>& src)
[+] 	ConstIterator(const ConstIterator<T2, GetLink2>& src)
[-] 	ConstIterator (const T* p)
[+] 	ConstIterator(const T* p)
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_List.h
----------------------
[-] class ListBase: protected ListData <T>
[+] class ListBase: protected ListData<T>
[-] 	typedef sl::ListData <T> ListData;
[+] 	typedef sl::ListData<T> ListData;
[-] 	ListBase ()
[+] 	ListBase()
[-] 		construct ();
[+] 		construct();
[-] 	~ListBase ()
[+] 	~ListBase()
[-] 		clear ();
[+] 		clear();
[-] 	isEmpty () const
[+] 	isEmpty() const
[-] 	getListData () const
[+] 	getListData() const
[-] 	getCount () const
[+] 	getCount() const
[-] 	getHead ()
[+] 	getHead()
[-] 	getHead () const
[+] 	getHead() const
[-] 	getTail ()
[+] 	getTail()
[-] 	getTail () const
[+] 	getTail() const
[-] 	remove (Iterator it)
[+] 	remove(Iterator it)
[-] 		ListLink* link = it.getLink ();
[+] 		ListLink* link = it.getLink();
[-] 			this->m_head = Iterator::getEntryFromLink (next);
[+] 			this->m_head = Iterator::getEntryFromLink(next);
[-] 			this->m_tail = Iterator::getEntryFromLink (prev);
[+] 			this->m_tail = Iterator::getEntryFromLink(prev);
[-] 		return it.getEntry ();
[+] 		return it.getEntry();
[-] 	removeHead ()
[+] 	removeHead()
[-] 		return this->m_head ? remove (this->m_head) : NULL;
[+] 		return this->m_head ? remove(this->m_head) : NULL;
[-] 	removeTail ()
[+] 	removeTail()
[-] 		return this->m_tail ? remove (this->m_tail) : NULL;
[+] 		return this->m_tail ? remove(this->m_tail) : NULL;
[-] 	clear ()
[+] 	clear()
[-] 		ListLink* link = GetLink () (this->m_head);
[+] 		ListLink* link = GetLink() (this->m_head);
[-] 			T* p = Iterator::getEntryFromLink (link);
[+] 			T* p = Iterator::getEntryFromLink(link);
[-] 			Delete () (p);
[+] 			Delete() (p);
[-] 		construct ();
[+] 		construct();
[-] 	clearButHead ()
[+] 	clearButHead()
[-] 		if (isEmpty ())
[+] 		if (isEmpty())
[-] 		T* p = removeHead ();
[+] 		T* p = removeHead();
[-] 		clear ();
[+] 		clear();
[-] 		insertHead (p);
[+] 		insertHead(p);
[-] 	clearButTail ()
[+] 	clearButTail()
[-] 		if (isEmpty ())
[+] 		if (isEmpty())
[-] 		T* p = removeTail ();
[+] 		T* p = removeTail();
[-] 		clear ();
[+] 		clear();
[-] 		insertTail (p);
[+] 		insertTail(p);
[-] 	insertHead (T* p)
[+] 	insertHead(T* p)
[-] 		ListLink* link = GetLink () (p);
[+] 		ListLink* link = GetLink() (p);
[-] 		ListLink* headLink = Iterator::getLinkFromEntry (this->m_head);
[+] 		ListLink* headLink = Iterator::getLinkFromEntry(this->m_head);
[-] 	insertTail (T* p)
[+] 	insertTail(T* p)
[-] 		ListLink* link = GetLink () (p);
[+] 		ListLink* link = GetLink() (p);
[-] 		ListLink* tailLink = Iterator::getLinkFromEntry (this->m_tail);
[+] 		ListLink* tailLink = Iterator::getLinkFromEntry(this->m_tail);
[-] 	insertBefore (
[+] 	insertBefore(
[-] 			return insertTail (p);
[+] 			return insertTail(p);
[-] 		ListLink* link = GetLink () (p);
[+] 		ListLink* link = GetLink() (p);
[-] 		ListLink* beforeLink = before.getLink ();
[+] 		ListLink* beforeLink = before.getLink();
[-] 		return Iterator::fromLink (link);
[+] 		return Iterator::fromLink(link);
[-] 	insertAfter (
[+] 	insertAfter(
[-] 			return insertHead (p);
[+] 			return insertHead(p);
[-] 		ListLink* link = GetLink () (p);
[+] 		ListLink* link = GetLink() (p);
[-] 		ListLink* afterLink = after.getLink ();
[+] 		ListLink* afterLink = after.getLink();
[-] 		return Iterator::fromLink (link);
[+] 		return Iterator::fromLink(link);
[-] 	insertListHead (ListBase* src)
[+] 	insertListHead(ListBase* src)
[-] 		if (src->isEmpty ())
[+] 		if (src->isEmpty())
[-] 		if (isEmpty ())
[+] 		if (isEmpty())
[-] 			sl::takeOver (this, src);
[+] 			sl::takeOver(this, src);
[-] 		ListLink* headLink = GetLink () (this->m_head);
[+] 		ListLink* headLink = GetLink() (this->m_head);
[-] 		ListLink* srcTailLink = GetLink () (src->m_tail);
[+] 		ListLink* srcTailLink = GetLink() (src->m_tail);
[-] 	insertListTail (ListBase* src)
[+] 	insertListTail(ListBase* src)
[-] 		if (src->isEmpty ())
[+] 		if (src->isEmpty())
[-] 		if (isEmpty ())
[+] 		if (isEmpty())
[-] 			sl::takeOver (this, src);
[+] 			sl::takeOver(this, src);
[-] 		ListLink* tailLink = GetLink () (this->m_tail);
[+] 		ListLink* tailLink = GetLink() (this->m_tail);
[-] 		ListLink* srcHeadLink = GetLink () (src->m_head);
[+] 		ListLink* srcHeadLink = GetLink() (src->m_head);
[-] 	moveBefore (
[+] 	moveBefore(
[-] 		T* p = it.getEntry ();
[+] 		T* p = it.getEntry();
[-] 		remove (it);
[+] 		remove(it);
[-] 		insertBefore (p, before);
[+] 		insertBefore(p, before);
[-] 	moveAfter (
[+] 	moveAfter(
[-] 		T* p = it.getEntry ();
[+] 		T* p = it.getEntry();
[-] 		remove (it);
[+] 		remove(it);
[-] 		insertAfter (p, after);
[+] 		insertAfter(p, after);
[-] 	moveToHead (Iterator it)
[+] 	moveToHead(Iterator it)
[-] 		T* p = it.getEntry ();
[+] 		T* p = it.getEntry();
[-] 		remove (it);
[+] 		remove(it);
[-] 		insertHead (p);
[+] 		insertHead(p);
[-] 	moveToTail (Iterator it)
[+] 	moveToTail(Iterator it)
[-] 		T* p = it.getEntry ();
[+] 		T* p = it.getEntry();
[-] 		remove (it);
[+] 		remove(it);
[-] 		insertTail (p);
[+] 		insertTail(p);
[-] 	construct ()
[+] 	construct()
[-] 	typedef sl::ListData <T> ListData;
[+] 	typedef sl::ListData<T> ListData;
[-] 	ConstListBase ()
[+] 	ConstListBase()
[-] 	isEmpty () const
[+] 	isEmpty() const
[-] 	getCount () const
[+] 	getCount() const
[-] 	getHead () const
[+] 	getHead() const
[-] 	getTail () const
[+] 	getTail() const
[-] 	typename GetLink = ImplicitPtrCast <T, ListLink>,
[+] 	typename GetLink = ImplicitPtrCast<T, ListLink>,
[-] 	typename Delete = mem::StdDelete <T>
[+] 	typename Delete = mem::StdDelete<T>
[-] class List: public ListBase <
[+] class List: public ListBase<
[-] 	Iterator <T, GetLink>,
[+] 	Iterator<T, GetLink>,
[-] 	ConstIterator <T, GetLink>,
[+] 	ConstIterator<T, GetLink>,
[-] 	erase (typename List::Iterator it)
[+] 	erase(typename List::Iterator it)
[-] 		T* p = this->remove (it);
[+] 		T* p = this->remove(it);
[-] 		typename List::Delete () (p);
[+] 		typename List::Delete() (p);
[-] 	eraseHead ()
[+] 	eraseHead()
[-] 		T* p = this->removeHead ();
[+] 		T* p = this->removeHead();
[-] 		p ? typename List::Delete () (p) : (void) 0;
[+] 		p ? typename List::Delete() (p) : (void) 0;
[-] 	eraseTail ()
[+] 	eraseTail()
[-] 		T* p = this->removeTail ();
[+] 		T* p = this->removeTail();
[-] 		p ? typename List::Delete () (p) : (void) 0;
[+] 		p ? typename List::Delete() (p) : (void) 0;
[-] 	typename GetLink = ImplicitPtrCast <T, ListLink>
[+] 	typename GetLink = ImplicitPtrCast<T, ListLink>
[-] class CppList: public List <T, GetLink, mem::CppDelete <T> >
[+] class CppList: public List<T, GetLink, mem::CppDelete<T> >
[-] 	typename GetLink = ImplicitPtrCast <T, ListLink>
[+] 	typename GetLink = ImplicitPtrCast<T, ListLink>
[-] class AuxList: public List <T, GetLink, sl::Void <T*> >
[+] class AuxList: public List<T, GetLink, sl::Void<T*> >
[-] 	clear ()
[+] 	clear()
[-] 		this->construct ();
[+] 		this->construct();
[-] 	typename GetLink = ImplicitPtrCast <T, ListLink>
[+] 	typename GetLink = ImplicitPtrCast<T, ListLink>
[-] class ConstList: public ConstListBase <
[+] class ConstList: public ConstListBase<
[-] 	ConstIterator <T, GetLink>
[+] 	ConstIterator<T, GetLink>
[-] 	ConstList ()
[+] 	ConstList()
[-] 	ConstList (const List <T, GetLink, Delete>& list)
[+] 	ConstList(const List<T, GetLink, Delete>& list)
[-] 		this->m_listData = list.getListData ();
[+] 		this->m_listData = list.getListData();
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_MapEntry.h
----------------------
[-] 	getKey () const
[+] 	getKey() const
[-] class MapIterator: public Iterator <MapEntry <Key, Value> >
[+] class MapIterator: public Iterator<MapEntry<Key, Value> >
[-] 	MapIterator ()
[+] 	MapIterator()
[-] 	MapIterator (const Iterator <T>& src)
[+] 	MapIterator(const Iterator<T>& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] class ConstMapIterator: public ConstIterator <MapEntry <Key, Value> >
[+] class ConstMapIterator: public ConstIterator<MapEntry<Key, Value> >
[-] 	ConstMapIterator ()
[+] 	ConstMapIterator()
[-] 	ConstMapIterator (const ConstIterator <T>& src)
[+] 	ConstMapIterator(const ConstIterator<T>& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_MemMem.h
----------------------
[-] memMem (
[+] memMem(
[-] memMem (
[+] memMem(
[-] 	return (void*) memMem ((const void*) p1, size1, p2, size2);
[+] 	return (void*)memMem((const void*) p1, size1, p2, size2);
[-] reverseMemMem (
[+] reverseMemMem(
[-] reverseMemMem (
[+] reverseMemMem(
[-] 	return (void*) reverseMemMem ((const void*) p1, size1, p2, size2);
[+] 	return (void*)reverseMemMem((const void*) p1, size1, p2, size2);
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_Operator.h
----------------------
[-] 		return (B) x;
[+] 		return (B)x;
[-] 		return (B*) x;
[+] 		return (B*)x;
[-] 		return sizeof (T);
[+] 		return sizeof(T);
[-] 		return sizeof (T);
[+] 		return sizeof(T);
[-] 		return (size_t) p - 1;
[+] 		return (size_t)p - 1;
[-] 		return (B*) ((uchar_t*) p + offset);
[+] 		return (B*)((uchar_t*)p + offset);
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 		return a.isEqual (b);
[+] 		return a.isEqual(b);
[-] 		return a->isEqual (*b);
[+] 		return a->isEqual(*b);
[-] 		return a.isEqual (b);
[+] 		return a.isEqual(b);
[-] 		return a->isEqual (b);
[+] 		return a->isEqual(b);
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 	typename Arg = typename ArgType <T>::Type
[+] 	typename Arg = typename ArgType<T>::Type
[-] 		a = Func () (a, b);
[+] 		a = Func() (a, b);
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_Pack.h
----------------------
[-] 		T a = va.arg <T> ();
[+] 		T a = va.arg<T> ();
[-] 		*size = sizeof (T);
[+] 		*size = sizeof(T);
[-] 			*(T*) p = a;
[+] 			*(T*)p = a;
[-] 		int n = va.arg <int> ();
[+] 		int n = va.arg<int> ();
[-] 		*size = sizeof (T);
[+] 		*size = sizeof(T);
[-] 			*(T*) p = (T) n;
[+] 			*(T*)p = (T)n;
[-] class Pack <char>: public PackIntTrunc <char>
[+] class Pack<char>: public PackIntTrunc<char>
[-] class Pack <wchar_t>: public PackIntTrunc <wchar_t>
[+] class Pack<wchar_t>: public PackIntTrunc<wchar_t>
[-] class Pack <int8_t>: public PackIntTrunc <int8_t>
[+] class Pack<int8_t>: public PackIntTrunc<int8_t>
[-] class Pack <uint8_t>: public PackIntTrunc <uint8_t>
[+] class Pack<uint8_t>: public PackIntTrunc<uint8_t>
[-] class Pack <int16_t>: public PackIntTrunc <int16_t>
[+] class Pack<int16_t>: public PackIntTrunc<int16_t>
[-] class Pack <uint16_t>: public PackIntTrunc <uint16_t>
[+] class Pack<uint16_t>: public PackIntTrunc<uint16_t>
[-] 		T* string = va.arg <T*> ();
[+] 		T* string = va.arg<T*> ();
[-] 		size_t length = StringDetailsBase <T>::calcLength (string);
[+] 		size_t length = StringDetailsBase<T>::calcLength(string);
[-] 		size_t stringSize = (length + 1) * sizeof (T);
[+] 		size_t stringSize = (length + 1) * sizeof(T);
[-] 				memcpy (p, string, stringSize);
[+] 				memcpy(p, string, stringSize);
[-] typedef PackStringBase <char>    PackString;
[+] typedef PackStringBase<char>    PackString;
[-] typedef PackStringBase <wchar_t> PackString_w;
[+] typedef PackStringBase<wchar_t> PackString_w;
[-] typedef PackStringBase <utf8_t>  PackString_utf8;
[+] typedef PackStringBase<utf8_t>  PackString_utf8;
[-] typedef PackStringBase <utf16_t> PackString_utf16;
[+] typedef PackStringBase<utf16_t> PackString_utf16;
[-] typedef PackStringBase <utf32_t> PackString_utf32;
[+] typedef PackStringBase<utf32_t> PackString_utf32;
[-] class Pack <const char*>: public PackStringBase <char>
[+] class Pack<const char*>: public PackStringBase<char>
[-] class Pack <char*>: public PackStringBase <char>
[+] class Pack<char*>: public PackStringBase<char>
[-] class Pack <const wchar_t*>: public PackStringBase <wchar_t>
[+] class Pack<const wchar_t*>: public PackStringBase<wchar_t>
[-] class Pack <wchar_t*>: public PackStringBase <wchar_t>
[+] class Pack<wchar_t*>: public PackStringBase<wchar_t>
[-] class Pack <T*>
[+] class Pack<T*>
[-] 		T* obj = va.arg <T*> ();
[+] 		T* obj = va.arg<T*> ();
[-] 		*size = sizeof (T);
[+] 		*size = sizeof(T);
[-] 				memcpy (p, obj, sizeof (T));
[+] 				memcpy(p, obj, sizeof(T));
[-] 				memset (p, 0, sizeof (T));
[+] 				memset(p, 0, sizeof(T));
[-] 	typename SizeOf = sl::SizeOf <T>
[+] 	typename SizeOf = sl::SizeOf<T>
[-] 		T* obj = va.arg <T*> ();
[+] 		T* obj = va.arg<T*> ();
[-] 		size_t objSize = obj ? SizeOf () (obj) : sizeof (T);
[+] 		size_t objSize = obj ? SizeOf() (obj) : sizeof(T);
[-] 				memcpy (p, obj, objSize);
[+] 				memcpy(p, obj, objSize);
[-] 				memset (p, 0, objSize);
[+] 				memset(p, 0, objSize);
[-] 		err::Error error = err::getLastError ();
[+] 		err::Error error = err::getLastError();
[-] 			memcpy (p, error, error->m_size);
[+] 			memcpy(p, error, error->m_size);
[-] class Pack <err::ErrorHdr*>: public PackSelfSizedPtr <
[+] class Pack<err::ErrorHdr*>: public PackSelfSizedPtr<
[-] class Pack <const err::ErrorHdr*>: public PackSelfSizedPtr <
[+] class Pack<const err::ErrorHdr*>: public PackSelfSizedPtr<
[-] 		void* obj = va.arg <void*> ();
[+] 		void* obj = va.arg<void*> ();
[-] 		size_t objSize = va.arg <size_t> ();
[+] 		size_t objSize = va.arg<size_t> ();
[-] 				memcpy (p, obj, objSize);
[+] 				memcpy(p, obj, objSize);
[-] 				memset (p, 0, objSize);
[+] 				memset(p, 0, objSize);
[-] 			va = Pack1 () (NULL, &size1, va);
[+] 			va = Pack1() (NULL, &size1, va);
[-] 			va = Pack2 () (NULL, &size2, va);
[+] 			va = Pack2() (NULL, &size2, va);
[-] 			va = Pack1 () (p, &size1, va);
[+] 			va = Pack1() (p, &size1, va);
[-] 			va = Pack2 () ((uchar_t*) p + size1, &size2, va);
[+] 			va = Pack2() ((uchar_t*)p + size1, &size2, va);
[-] class PackSeqEx_2: public PackSeqEx <Pack1, Pack2>
[+] class PackSeqEx_2: public PackSeqEx<Pack1, Pack2>
[-] class PackSeqEx_3: public PackSeqEx <PackSeqEx <Pack1, Pack2>, Pack3>
[+] class PackSeqEx_3: public PackSeqEx<PackSeqEx<Pack1, Pack2>, Pack3>
[-] class PackSeqEx_4: public PackSeqEx <PackSeqEx_3 <Pack1, Pack2, Pack3>, Pack4>
[+] class PackSeqEx_4: public PackSeqEx<PackSeqEx_3<Pack1, Pack2, Pack3>, Pack4>
[-] class PackSeqEx_5: public PackSeqEx <PackSeqEx_4 <Pack1, Pack2, Pack3, Pack4>, Pack5>
[+] class PackSeqEx_5: public PackSeqEx<PackSeqEx_4<Pack1, Pack2, Pack3, Pack4>, Pack5>
[-] class PackSeqEx_6: public PackSeqEx <PackSeqEx_5 <Pack1, Pack2, Pack3, Pack4, Pack5>, Pack6>
[+] class PackSeqEx_6: public PackSeqEx<PackSeqEx_5<Pack1, Pack2, Pack3, Pack4, Pack5>, Pack6>
[-] class PackSeq_2: public PackSeqEx <
[+] class PackSeq_2: public PackSeqEx<
[-] 	Pack <T1>,
[+] 	Pack<T1>,
[-] 	Pack <T2>
[+] 	Pack<T2>
[-] class PackSeq_3: public PackSeqEx_3 <
[+] class PackSeq_3: public PackSeqEx_3<
[-] 	Pack <T1>,
[+] 	Pack<T1>,
[-] 	Pack <T2>,
[+] 	Pack<T2>,
[-] 	Pack <T3>
[+] 	Pack<T3>
[-] class PackSeq_4: public PackSeqEx_4 <
[+] class PackSeq_4: public PackSeqEx_4<
[-] 	Pack <T1>,
[+] 	Pack<T1>,
[-] 	Pack <T2>,
[+] 	Pack<T2>,
[-] 	Pack <T3>,
[+] 	Pack<T3>,
[-] 	Pack <T4>
[+] 	Pack<T4>
[-] class PackSeq_5: public PackSeqEx_5 <
[+] class PackSeq_5: public PackSeqEx_5<
[-] 	Pack <T1>,
[+] 	Pack<T1>,
[-] 	Pack <T2>,
[+] 	Pack<T2>,
[-] 	Pack <T3>,
[+] 	Pack<T3>,
[-] 	Pack <T4>,
[+] 	Pack<T4>,
[-] 	Pack <T5>
[+] 	Pack<T5>
[-] class PackSeq_6: public PackSeqEx_6 <
[+] class PackSeq_6: public PackSeqEx_6<
[-] 	Pack <T1>,
[+] 	Pack<T1>,
[-] 	Pack <T2>,
[+] 	Pack<T2>,
[-] 	Pack <T3>,
[+] 	Pack<T3>,
[-] 	Pack <T4>,
[+] 	Pack<T4>,
[-] 	Pack <T5>,
[+] 	Pack<T5>,
[-] 	Pack <T6>
[+] 	Pack<T6>
[-] ref::Ptr <mem::Block>
[+] ref::Ptr<mem::Block>
[-] createPackage_va (axl_va_list va)
[+] createPackage_va(axl_va_list va)
[-] 	T () (NULL, &size, va);
[+] 	T() (NULL, &size, va);
[-] 	typedef ref::Box <mem::Block> Package;
[+] 	typedef ref::Box<mem::Block> Package;
[-] 	ref::Ptr <Package> package = AXL_REF_NEW_EXTRA (Package, size);
[+] 	ref::Ptr<Package> package = AXL_REF_NEW_EXTRA(Package, size);
[-] 	T () (package + 1, &size, va);
[+] 	T() (package + 1, &size, va);
[-] ref::Ptr <mem::Block>
[+] ref::Ptr<mem::Block>
[-] createPackage (
[+] createPackage(
[-] 	AXL_VA_DECL (va, unused);
[+] 	AXL_VA_DECL(va, unused);
[-] 	return createPackage_va <T> (va);
[+] 	return createPackage_va<T> (va);
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_Packer.h
----------------------
[-] 	pack_va (
[+] 	pack_va(
[-] 	pack (
[+] 	pack(
[-] 		AXL_VA_DECL (va, size);
[+] 		AXL_VA_DECL(va, size);
[-] 		pack_va (p, size, va);
[+] 		pack_va(p, size, va);
[-] 	count_va (axl_va_list va)
[+] 	count_va(axl_va_list va)
[-] 		pack_va (NULL, &size, va);
[+] 		pack_va(NULL, &size, va);
[-] 	count (
[+] 	count(
[-] 		AXL_VA_DECL (va, unused);
[+] 		AXL_VA_DECL(va, unused);
[-] 		return count_va (va);
[+] 		return count_va(va);
[-] 	ref::Ptr <mem::Block>
[+] 	ref::Ptr<mem::Block>
[-] 	createPackage_va (axl_va_list va)
[+] 	createPackage_va(axl_va_list va)
[-] 		pack_va (NULL, &size, va);
[+] 		pack_va(NULL, &size, va);
[-] 		typedef ref::Box <mem::Block> Package;
[+] 		typedef ref::Box<mem::Block> Package;
[-] 		ref::Ptr <Package> package = AXL_REF_NEW_EXTRA (Package, size);
[+] 		ref::Ptr<Package> package = AXL_REF_NEW_EXTRA(Package, size);
[-] 		pack_va (package + 1, &size, va);
[+] 		pack_va(package + 1, &size, va);
[-] 	ref::Ptr <mem::Block>
[+] 	ref::Ptr<mem::Block>
[-] 	createPackage (
[+] 	createPackage(
[-] 		AXL_VA_DECL (va, unused);
[+] 		AXL_VA_DECL(va, unused);
[-] 		return createPackage_va (va);
[+] 		return createPackage_va(va);
[-] 	pack_va (
[+] 	pack_va(
[-] 		return Pack () (p, size, va);
[+] 		return Pack() (p, size, va);
[-] 	getSingleton ()
[+] 	getSingleton()
[-] 		return sl::getSimpleSingleton <PackerImpl> ();
[+] 		return sl::getSimpleSingleton<PackerImpl> ();
[-] 	sl::Array <Packer*> m_sequence;
[+] 	sl::Array<Packer*> m_sequence;
[-] 	pack_va (
[+] 	pack_va(
[-] 	clear ()
[+] 	clear()
[-] 		m_sequence.clear ();
[+] 		m_sequence.clear();
[-] 	append (Packer* packer)
[+] 	append(Packer* packer)
[-] 		m_sequence.append (packer);
[+] 		m_sequence.append(packer);
[-] 		return m_sequence.getCount ();
[+] 		return m_sequence.getCount();
[-] 	append ()
[+] 	append()
[-] 		return append (PackerImpl <T>::getSingleton ());
[+] 		return append(PackerImpl<T>::getSingleton());
[-] 	appendFormat (const char* formatString);
[+] 	appendFormat(const char* formatString);
[-] 	format (const char* formatString)
[+] 	format(const char* formatString)
[-] 		clear ();
[+] 		clear();
[-] 		return appendFormat (formatString);
[+] 		return appendFormat(formatString);
[-] ref::Ptr <mem::Block>
[+] ref::Ptr<mem::Block>
[-] formatPackage_va (
[+] formatPackage_va(
[-] 	packer.format (formatString);
[+] 	packer.format(formatString);
[-] 	return packer.createPackage_va (va);
[+] 	return packer.createPackage_va(va);
[-] ref::Ptr <mem::Block>
[+] ref::Ptr<mem::Block>
[-] formatPackage (
[+] formatPackage(
[-] 	AXL_VA_DECL (va, formatString);
[+] 	AXL_VA_DECL(va, formatString);
[-] 	return formatPackage_va (formatString, va);
[+] 	return formatPackage_va(formatString, va);
[-] 	axl::sl::Array <uchar_t> m_buffer;
[+] 	axl::sl::Array<uchar_t> m_buffer;
[-] 	clear ()
[+] 	clear()
[-] 		m_buffer.clear ();
[+] 		m_buffer.clear();
[-] 	getBuffer ()
[+] 	getBuffer()
[-] 	getSize ()
[+] 	getSize()
[-] 		return m_buffer.getCount ();
[+] 		return m_buffer.getCount();
[-] 	append_va (
[+] 	append_va(
[-] 	append_va (axl_va_list va)
[+] 	append_va(axl_va_list va)
[-] 		Packer* pack = PackerImpl <Pack>::getSingleton ();
[+] 		Packer* pack = PackerImpl<Pack>::getSingleton();
[-] 		return append_va (pack, va);
[+] 		return append_va(pack, va);
[-] 	append (
[+] 	append(
[-] 	append (const T& data)
[+] 	append(const T& data)
[-] 		Packer* pack = PackerImpl <Pack <T> >::getSingleton ();
[+] 		Packer* pack = PackerImpl<Pack<T> >::getSingleton();
[-] 		return pack (&data, sizeof (data));
[+] 		return pack(&data, sizeof(data));
[-] 	appendFormat_va (
[+] 	appendFormat_va(
[-] 		packer.format (formatString);
[+] 		packer.format(formatString);
[-] 		return append_va (&packer, va);
[+] 		return append_va(&packer, va);
[-] 	appendFormat (
[+] 	appendFormat(
[-] 		AXL_VA_DECL (va, formatString);
[+] 		AXL_VA_DECL(va, formatString);
[-] 		return appendFormat_va (formatString, va);
[+] 		return appendFormat_va(formatString, va);
[-] 	format_va (
[+] 	format_va(
[-] 		clear ();
[+] 		clear();
[-] 		return appendFormat_va (formatString, va);
[+] 		return appendFormat_va(formatString, va);
[-] 	format (
[+] 	format(
[-] 		AXL_VA_DECL (va, formatString);
[+] 		AXL_VA_DECL(va, formatString);
[-] 		return format_va (formatString, va);
[+] 		return format_va(formatString, va);
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_Packetizer.h
----------------------
[-] 	sl::Array <char> m_buffer;
[+] 	sl::Array<char> m_buffer;
[-] 	reset ()
[+] 	reset()
[-] 		m_buffer.clear ();
[+] 		m_buffer.clear();
[-] 	createHdr (size_t size)
[+] 	createHdr(size_t size)
[-] 		return ((uint64_t) size << 32) | PacketHdrSignature;
[+] 		return ((uint64_t)size << 32) | PacketHdrSignature;
[-] 	writeImpl (
[+] 	writeImpl(
[-] 	write (
[+] 	write(
[-] 			size_t taken = writeImpl (p, size);
[+] 			size_t taken = writeImpl(p, size);
[-] 			ASSERT (m_buffer.getCount () >= sizeof (uint64_t));
[+] 			ASSERT(m_buffer.getCount() >= sizeof(uint64_t));
[-] 			size_t dataSize = m_buffer.getCount () - sizeof (uint64_t);
[+] 			size_t dataSize = m_buffer.getCount() - sizeof(uint64_t);
[-] 				static_cast <T*> (this)->onPacket (m_buffer.p () + sizeof (uint64_t), dataSize);
[+] 				static_cast<T*> (this)->onPacket(m_buffer.p() + sizeof(uint64_t), dataSize);
[-] 			reset ();
[+] 			reset();
[-] 			p = (char*) p + taken;
[+] 			p = (char*)p + taken;
[-] 	sl::Array <char> m_buffer;
[+] 	sl::Array<char> m_buffer;
[-] 	reset ()
[+] 	reset()
[-] 		m_buffer.clear ();
[+] 		m_buffer.clear();
[-] 	createHdr (size_t size);
[+] 	createHdr(size_t size);
[-] 	writeImpl (
[+] 	writeImpl(
[-] 	write (
[+] 	write(
[-] 			size_t taken = writeImpl (p, size);
[+] 			size_t taken = writeImpl(p, size);
[-] 			ASSERT (m_buffer.getCount () >= sizeof (uint64_t));
[+] 			ASSERT(m_buffer.getCount() >= sizeof(uint64_t));
[-] 			size_t dataSize = m_buffer.getCount () - sizeof (uint64_t);
[+] 			size_t dataSize = m_buffer.getCount() - sizeof(uint64_t);
[-] 				static_cast <T*> (this)->onPacket (m_buffer.p () + sizeof (uint64_t), dataSize);
[+] 				static_cast<T*> (this)->onPacket(m_buffer.p() + sizeof(uint64_t), dataSize);
[-] 			reset ();
[+] 			reset();
[-] 			p = (char*) p + taken;
[+] 			p = (char*)p + taken;
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_Protocol.h
----------------------
[-] 	sendMsg (
[+] 	sendMsg(
[-] 		static_cast <T*> (this)->sendMsgEx (&p, &size, 1);
[+] 		static_cast<T*> (this)->sendMsgEx(&p, &size, 1);
[-] 	sendMsg (
[+] 	sendMsg(
[-] 		const void* blockArray [] = { p, extra };
[+] 		const void* blockArray[] = { p, extra };
[-] 		size_t sizeArray [] = { size, extraSize };
[+] 		size_t sizeArray[] = { size, extraSize };
[-] 		static_cast <T*> (this)->sendMsgEx (blockArray, sizeArray, 2);
[+] 		static_cast<T*> (this)->sendMsgEx(blockArray, sizeArray, 2);
[-] class AbstractProtoPeer: public ProtoPeer <AbstractProtoPeer>
[+] class AbstractProtoPeer: public ProtoPeer<AbstractProtoPeer>
[-] 	sendMsgEx (
[+] 	sendMsgEx(
[-] 	sender () \
[+] 	sender() \
[-] 		sendMsg (&msg, sizeof (msg)); \
[+] 		sendMsg(&msg, sizeof(msg)); \
[-] 	sender (const axl::sl::StringRef& strArg) \
[+] 	sender(const axl::sl::StringRef& strArg) \
[-] 		sendMsg (&msg, sizeof (msg), strArg.cp (), strArg.getLength ()); \
[+] 		sendMsg(&msg, sizeof(msg), strArg.cp(), strArg.getLength()); \
[-] 		sendMsg (&msg, sizeof (msg), ptrArg, sizeArg); \
[+] 		sendMsg(&msg, sizeof(msg), ptrArg, sizeArg); \
[-] 	sender (const axl::err::ErrorHdr* errArg) \
[+] 	sender(const axl::err::ErrorHdr* errArg) \
[-] 		sendMsg (&msg, sizeof (msg), errArg, errArg->m_size); \
[+] 		sendMsg(&msg, sizeof(msg), errArg, errArg->m_size); \
[-] 	sender (T1 arg1) \
[+] 	sender(T1 arg1) \
[-] 		axl::sl::ProtoMsg_1 <T1> msg; \
[+] 		axl::sl::ProtoMsg_1<T1> msg; \
[-] 		sendMsg (&msg, sizeof (msg)); \
[+] 		sendMsg(&msg, sizeof(msg)); \
[-] 		axl::sl::ProtoMsg_1 <T1> msg; \
[+] 		axl::sl::ProtoMsg_1<T1> msg; \
[-] 		sendMsg (&msg, sizeof (msg), strArg.cp (), strArg.getLength ()); \
[+] 		sendMsg(&msg, sizeof(msg), strArg.cp(), strArg.getLength()); \
[-] 		axl::sl::ProtoMsg_1 <T1> msg; \
[+] 		axl::sl::ProtoMsg_1<T1> msg; \
[-] 		sendMsg (&msg, sizeof (msg), ptrArg, sizeArg); \
[+] 		sendMsg(&msg, sizeof(msg), ptrArg, sizeArg); \
[-] 		axl::sl::ProtoMsg_1 <T1> msg; \
[+] 		axl::sl::ProtoMsg_1<T1> msg; \
[-] 		sendMsg (&msg, sizeof (msg), errArg, errArg->m_size); \
[+] 		sendMsg(&msg, sizeof(msg), errArg, errArg->m_size); \
[-] 		axl::sl::ProtoMsg_2 <T1, T2> msg; \
[+] 		axl::sl::ProtoMsg_2<T1, T2> msg; \
[-] 		sendMsg (&msg, sizeof (msg)); \
[+] 		sendMsg(&msg, sizeof(msg)); \
[-] 		axl::sl::ProtoMsg_2 <T1, T2> msg; \
[+] 		axl::sl::ProtoMsg_2<T1, T2> msg; \
[-] 		sendMsg (&msg, sizeof (msg), strArg.cp (), strArg.getLength ()); \
[+] 		sendMsg(&msg, sizeof(msg), strArg.cp(), strArg.getLength()); \
[-] 		axl::sl::ProtoMsg_2 <T1, T2> msg; \
[+] 		axl::sl::ProtoMsg_2<T1, T2> msg; \
[-] 		sendMsg (&msg, sizeof (msg), ptrArg, sizeArg); \
[+] 		sendMsg(&msg, sizeof(msg), ptrArg, sizeArg); \
[-] 		axl::sl::ProtoMsg_2 <T1, T2> msg; \
[+] 		axl::sl::ProtoMsg_2<T1, T2> msg; \
[-] 		sendMsg (&msg, sizeof (msg), errArg, errArg->m_size); \
[+] 		sendMsg(&msg, sizeof(msg), errArg, errArg->m_size); \
[-] 		axl::sl::ProtoMsg_3 <T1, T2, T3> msg; \
[+] 		axl::sl::ProtoMsg_3<T1, T2, T3> msg; \
[-] 		sendMsg (&msg, sizeof (msg)); \
[+] 		sendMsg(&msg, sizeof(msg)); \
[-] 		axl::sl::ProtoMsg_3 <T1, T2, T3> msg; \
[+] 		axl::sl::ProtoMsg_3<T1, T2, T3> msg; \
[-] 		sendMsg (&msg, sizeof (msg), strArg.cp (), strArg.getLength ()); \
[+] 		sendMsg(&msg, sizeof(msg), strArg.cp(), strArg.getLength()); \
[-] 		axl::sl::ProtoMsg_3 <T1, T2, T3> msg; \
[+] 		axl::sl::ProtoMsg_3<T1, T2, T3> msg; \
[-] 		sendMsg (&msg, sizeof (msg), ptrArg, sizeArg); \
[+] 		sendMsg(&msg, sizeof(msg), ptrArg, sizeArg); \
[-] 		axl::sl::ProtoMsg_3 <T1, T2, T3> msg; \
[+] 		axl::sl::ProtoMsg_3<T1, T2, T3> msg; \
[-] 		sendMsg (&msg, sizeof (msg), errArg, errArg->m_size); \
[+] 		sendMsg(&msg, sizeof(msg), errArg, errArg->m_size); \
[-] 		axl::sl::ProtoMsg_4 <T1, T2, T3, T4> msg; \
[+] 		axl::sl::ProtoMsg_4<T1, T2, T3, T4> msg; \
[-] 		sendMsg (&msg, sizeof (msg)); \
[+] 		sendMsg(&msg, sizeof(msg)); \
[-] 		axl::sl::ProtoMsg_4 <T1, T2, T3, T4> msg; \
[+] 		axl::sl::ProtoMsg_4<T1, T2, T3, T4> msg; \
[-] 		sendMsg (&msg, sizeof (msg), strArg.cp (), strArg.getLength ()); \
[+] 		sendMsg(&msg, sizeof(msg), strArg.cp(), strArg.getLength()); \
[-] 		axl::sl::ProtoMsg_4 <T1, T2, T3, T4> msg; \
[+] 		axl::sl::ProtoMsg_4<T1, T2, T3, T4> msg; \
[-] 		sendMsg (&msg, sizeof (msg), ptrArg, sizeArg); \
[+] 		sendMsg(&msg, sizeof(msg), ptrArg, sizeArg); \
[-] 		axl::sl::ProtoMsg_4 <T1, T2, T3, T4> msg; \
[+] 		axl::sl::ProtoMsg_4<T1, T2, T3, T4> msg; \
[-] 		sendMsg (&msg, sizeof (msg), errArg, errArg->m_size); \
[+] 		sendMsg(&msg, sizeof(msg), errArg, errArg->m_size); \
[-] 		if (size < sizeof (axl::sl::ProtoMsg)) \
[+] 		if (size < sizeof(axl::sl::ProtoMsg)) \
[-] 		axl::sl::ProtoMsg* hdr = (axl::sl::ProtoMsg*) p; \
[+] 		axl::sl::ProtoMsg* hdr = (axl::sl::ProtoMsg*)p; \
[-] 		switch (hdr->m_code) \
[+] 		switch(hdr->m_code) \
[-] 		handler (); \
[+] 		handler(); \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		size_t length = size - sizeof (Msg); \
[+] 		size_t length = size - sizeof(Msg); \
[-] 		axl::sl::StringRef string ((char*) (msg + 1), length); \
[+] 		axl::sl::StringRef string((char*)(msg + 1), length); \
[-] 		handler (string); \
[+] 		handler(string); \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		size_t extraSize = size - sizeof (Msg); \
[+] 		size_t extraSize = size - sizeof(Msg); \
[-] 		handler (msg + 1, extraSize); \
[+] 		handler(msg + 1, extraSize); \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		handler ((const axl::err::ErrorHdr*) (msg + 1)); \
[+] 		handler((const axl::err::ErrorHdr*) (msg + 1)); \
[-] 		typedef axl::sl::ProtoMsg_1 <T1> Msg; \
[+] 		typedef axl::sl::ProtoMsg_1<T1> Msg; \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		handler (msg->m_arg1); \
[+] 		handler(msg->m_arg1); \
[-] 		typedef axl::sl::ProtoMsg_1 <T1> Msg; \
[+] 		typedef axl::sl::ProtoMsg_1<T1> Msg; \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		size_t length = size - sizeof (Msg); \
[+] 		size_t length = size - sizeof(Msg); \
[-] 		axl::sl::StringRef string ((char*) (msg + 1), length); \
[+] 		axl::sl::StringRef string((char*)(msg + 1), length); \
[-] 		handler (msg->m_arg1, string); \
[+] 		handler(msg->m_arg1, string); \
[-] 		typedef axl::sl::ProtoMsg_1 <T1> Msg; \
[+] 		typedef axl::sl::ProtoMsg_1<T1> Msg; \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		size_t extraSize = size - sizeof (Msg); \
[+] 		size_t extraSize = size - sizeof(Msg); \
[-] 		handler (msg->m_arg1, msg + 1, extraSize); \
[+] 		handler(msg->m_arg1, msg + 1, extraSize); \
[-] 		typedef axl::sl::ProtoMsg_1 <T1> Msg; \
[+] 		typedef axl::sl::ProtoMsg_1<T1> Msg; \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		handler (msg->m_arg1, (const axl::err::ErrorHdr*) (msg + 1)); \
[+] 		handler(msg->m_arg1, (const axl::err::ErrorHdr*) (msg + 1)); \
[-] 		typedef axl::sl::ProtoMsg_2 <T1, T2> Msg; \
[+] 		typedef axl::sl::ProtoMsg_2<T1, T2> Msg; \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		handler (msg->m_arg1, msg->m_arg2); \
[+] 		handler(msg->m_arg1, msg->m_arg2); \
[-] 		typedef axl::sl::ProtoMsg_2 <T1, T2> Msg; \
[+] 		typedef axl::sl::ProtoMsg_2<T1, T2> Msg; \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		size_t length = size - sizeof (Msg); \
[+] 		size_t length = size - sizeof(Msg); \
[-] 		axl::sl::StringRef string ((char*) (msg + 1), length); \
[+] 		axl::sl::StringRef string((char*)(msg + 1), length); \
[-] 		handler (msg->m_arg1, msg->m_arg2, string); \
[+] 		handler(msg->m_arg1, msg->m_arg2, string); \
[-] 		typedef axl::sl::ProtoMsg_2 <T1, T2> Msg; \
[+] 		typedef axl::sl::ProtoMsg_2<T1, T2> Msg; \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		size_t extraSize = size - sizeof (Msg); \
[+] 		size_t extraSize = size - sizeof(Msg); \
[-] 		handler (msg->m_arg1, msg->m_arg2, msg + 1, extraSize); \
[+] 		handler(msg->m_arg1, msg->m_arg2, msg + 1, extraSize); \
[-] 		typedef axl::sl::ProtoMsg_2 <T1, T2> Msg; \
[+] 		typedef axl::sl::ProtoMsg_2<T1, T2> Msg; \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		handler (msg->m_arg1, msg->m_arg2, (const axl::err::ErrorHdr*) (msg + 1)); \
[+] 		handler(msg->m_arg1, msg->m_arg2, (const axl::err::ErrorHdr*) (msg + 1)); \
[-] 		typedef axl::sl::ProtoMsg_3 <T1, T2, T3> Msg; \
[+] 		typedef axl::sl::ProtoMsg_3<T1, T2, T3> Msg; \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		handler (msg->m_arg1, msg->m_arg2, msg->m_arg3); \
[+] 		handler(msg->m_arg1, msg->m_arg2, msg->m_arg3); \
[-] 		typedef axl::sl::ProtoMsg_3 <T1, T2, T3> Msg; \
[+] 		typedef axl::sl::ProtoMsg_3<T1, T2, T3> Msg; \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		size_t length = size - sizeof (Msg); \
[+] 		size_t length = size - sizeof(Msg); \
[-] 		axl::sl::StringRef string ((char*) (msg + 1), length); \
[+] 		axl::sl::StringRef string((char*)(msg + 1), length); \
[-] 		handler (msg->m_arg1, msg->m_arg2, msg->m_arg3, string); \
[+] 		handler(msg->m_arg1, msg->m_arg2, msg->m_arg3, string); \
[-] 		typedef axl::sl::ProtoMsg_3 <T1, T2, T3> Msg; \
[+] 		typedef axl::sl::ProtoMsg_3<T1, T2, T3> Msg; \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		size_t extraSize = size - sizeof (Msg); \
[+] 		size_t extraSize = size - sizeof(Msg); \
[-] 		handler (msg->m_arg1, msg->m_arg2, msg->m_arg3, msg + 1, extraSize); \
[+] 		handler(msg->m_arg1, msg->m_arg2, msg->m_arg3, msg + 1, extraSize); \
[-] 		typedef axl::sl::ProtoMsg_3 <T1, T2, T3> Msg; \
[+] 		typedef axl::sl::ProtoMsg_3<T1, T2, T3> Msg; \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		size_t extraSize = size - sizeof (Msg); \
[+] 		size_t extraSize = size - sizeof(Msg); \
[-] 		handler (msg->m_arg1, msg->m_arg2, msg->m_arg3, (const axl::err::ErrorHdr*) (msg + 1)); \
[+] 		handler(msg->m_arg1, msg->m_arg2, msg->m_arg3, (const axl::err::ErrorHdr*) (msg + 1)); \
[-] 		typedef axl::sl::ProtoMsg_4 <T1, T2, T3, T4> Msg; \
[+] 		typedef axl::sl::ProtoMsg_4<T1, T2, T3, T4> Msg; \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		handler (msg->m_arg1, msg->m_arg2, msg->m_arg3, msg->m_arg4); \
[+] 		handler(msg->m_arg1, msg->m_arg2, msg->m_arg3, msg->m_arg4); \
[-] 		typedef axl::sl::ProtoMsg_4 <T1, T2, T3, T4> Msg; \
[+] 		typedef axl::sl::ProtoMsg_4<T1, T2, T3, T4> Msg; \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		size_t length = size - sizeof (Msg); \
[+] 		size_t length = size - sizeof(Msg); \
[-] 		axl::sl::StringRef string ((char*) (msg + 1), length); \
[+] 		axl::sl::StringRef string((char*)(msg + 1), length); \
[-] 		handler (msg->m_arg1, msg->m_arg2, msg->m_arg3, msg->m_arg4, string); \
[+] 		handler(msg->m_arg1, msg->m_arg2, msg->m_arg3, msg->m_arg4, string); \
[-] 		typedef axl::sl::ProtoMsg_4 <T1, T2, T3, T4> Msg; \
[+] 		typedef axl::sl::ProtoMsg_4<T1, T2, T3, T4> Msg; \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		size_t extraSize = size - sizeof (Msg); \
[+] 		size_t extraSize = size - sizeof(Msg); \
[-] 		handler (msg->m_arg1, msg->m_arg2, msg->m_arg3, msg->m_arg4, msg + 1, extraSize); \
[+] 		handler(msg->m_arg1, msg->m_arg2, msg->m_arg3, msg->m_arg4, msg + 1, extraSize); \
[-] 		typedef axl::sl::ProtoMsg_4 <T1, T2, T3, T4> Msg; \
[+] 		typedef axl::sl::ProtoMsg_4<T1, T2, T3, T4> Msg; \
[-] 		Msg* msg = (Msg*) p; \
[+] 		Msg* msg = (Msg*)p; \
[-] 		if (size < sizeof (Msg)) \
[+] 		if (size < sizeof(Msg)) \
[-] 		handler (msg->m_arg1, msg->m_arg2, msg->m_arg3, msg->m_arg4, (const axl::err::ErrorHdr*) (msg + 1)); \
[+] 		handler(msg->m_arg1, msg->m_arg2, msg->m_arg3, msg->m_arg4, (const axl::err::ErrorHdr*) (msg + 1)); \
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_RbTree.h
----------------------
[-] class RbTreeNode: public BinTreeNodeBase <
[+] class RbTreeNode: public BinTreeNodeBase<
[-] 	RbTreeNode <Key, Value>,
[+] 	RbTreeNode<Key, Value>,
[-] 	onXcg (
[+] 	onXcg(
[-] 	getColor (RbTreeNode* node)
[+] 	getColor(RbTreeNode* node)
[-] 	assertValid (RbTreeNode* node)
[+] 	assertValid(RbTreeNode* node)
[-] 		size_t leftCount = assertValid (node->m_left);
[+] 		size_t leftCount = assertValid(node->m_left);
[-] 		size_t rightCount = assertValid (node->m_right);
[+] 		size_t rightCount = assertValid(node->m_right);
[-] 		ASSERT (leftCount == rightCount);
[+] 		ASSERT(leftCount == rightCount);
[-] 			ASSERT (getColor (node->m_left) == RbColor_Black);
[+] 			ASSERT(getColor(node->m_left) == RbColor_Black);
[-] 			ASSERT (getColor (node->m_right) == RbColor_Black);
[+] 			ASSERT(getColor(node->m_right) == RbColor_Black);
[-] class RbTreeIterator: public Iterator <RbTreeNode <Key, Value> >
[+] class RbTreeIterator: public Iterator<RbTreeNode<Key, Value> >
[-] 	RbTreeIterator ()
[+] 	RbTreeIterator()
[-] 	RbTreeIterator (const Iterator <RbTreeNode <Key, Value> >& src)
[+] 	RbTreeIterator(const Iterator<RbTreeNode<Key, Value> >& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] 	typename Cmp = Cmp <Key>,
[+] 	typename Cmp = Cmp<Key>,
[-] 	typename KeyArg = typename ArgType <Key>::Type,
[+] 	typename KeyArg = typename ArgType<Key>::Type,
[-] 	typename ValueArg = typename ArgType <Value>::Type
[+] 	typename ValueArg = typename ArgType<Value>::Type
[-] class RbTree: public BinTreeBase <
[+] class RbTree: public BinTreeBase<
[-] 	RbTree <Key, Value, Cmp, KeyArg, ValueArg>,
[+] 	RbTree<Key, Value, Cmp, KeyArg, ValueArg>,
[-] 	RbTreeNode <Key, Value>,
[+] 	RbTreeNode<Key, Value>,
[-] 	friend class BinTreeBase <
[+] 	friend class BinTreeBase<
[-] 		RbTree <Key, Value, Cmp, KeyArg, ValueArg>,
[+] 		RbTree<Key, Value, Cmp, KeyArg, ValueArg>,
[-] 		RbTreeNode <Key, Value>,
[+] 		RbTreeNode<Key, Value>,
[-] 	typedef BinTreeBase <
[+] 	typedef BinTreeBase<
[-] 		RbTree <Key, Value, Cmp, KeyArg, ValueArg>,
[+] 		RbTree<Key, Value, Cmp, KeyArg, ValueArg>,
[-] 		RbTreeNode <Key, Value>,
[+] 		RbTreeNode<Key, Value>,
[-] 	typedef RbTreeNode <Key, Value> Node;
[+] 	typedef RbTreeNode<Key, Value> Node;
[-] 	RbTree (const Cmp& cmp = Cmp ()):
[+] 	RbTree(const Cmp& cmp = Cmp()):
[-] 		BaseType (cmp)
[+] 		BaseType(cmp)
[-] 	onInsert (Node* x)
[+] 	onInsert(Node* x)
[-] 				if (Node::getColor (y) == RbColor_Red)
[+] 				if (Node::getColor(y) == RbColor_Red)
[-] 						this->rotateLeft (x);
[+] 						this->rotateLeft(x);
[-] 					this->rotateRight (x->m_parent->m_parent);
[+] 					this->rotateRight(x->m_parent->m_parent);
[-] 				if (Node::getColor (y) == RbColor_Red)
[+] 				if (Node::getColor(y) == RbColor_Red)
[-] 						this->rotateRight (x);
[+] 						this->rotateRight(x);
[-] 					this->rotateLeft (x->m_parent->m_parent);
[+] 					this->rotateLeft(x->m_parent->m_parent);
[-] 		assertValid ();
[+] 		assertValid();
[-] 	onErase (Node* node)
[+] 	onErase(Node* node)
[-] 		Node* x = this->replaceWithChild (node);
[+] 		Node* x = this->replaceWithChild(node);
[-] 		while (x != this->m_root && Node::getColor (x) == RbColor_Black)
[+] 		while (x != this->m_root && Node::getColor(x) == RbColor_Black)
[-] 					this->rotateLeft (p);
[+] 					this->rotateLeft(p);
[-] 				if (Node::getColor (w->m_left) == RbColor_Black &&
[+] 				if (Node::getColor(w->m_left) == RbColor_Black &&
[-] 					Node::getColor (w->m_right) == RbColor_Black)
[+] 					Node::getColor(w->m_right) == RbColor_Black)
[-] 					if (Node::getColor (w->m_right) == RbColor_Black)
[+] 					if (Node::getColor(w->m_right) == RbColor_Black)
[-] 						this->rotateRight (w);
[+] 						this->rotateRight(w);
[-] 					this->rotateLeft (p);
[+] 					this->rotateLeft(p);
[-] 					this->rotateRight (p);
[+] 					this->rotateRight(p);
[-] 				if (Node::getColor (w->m_left) == RbColor_Black &&
[+] 				if (Node::getColor(w->m_left) == RbColor_Black &&
[-] 					Node::getColor (w->m_right) == RbColor_Black)
[+] 					Node::getColor(w->m_right) == RbColor_Black)
[-] 					if (Node::getColor (w->m_left) == RbColor_Black)
[+] 					if (Node::getColor(w->m_left) == RbColor_Black)
[-] 						this->rotateLeft (w);
[+] 						this->rotateLeft(w);
[-] 					this->rotateRight (p);
[+] 					this->rotateRight(p);
[-] 		assertValid ();
[+] 		assertValid();
[-] 	assertValid ()
[+] 	assertValid()
[-] 		Node::assertValid (this->m_root);
[+] 		Node::assertValid(this->m_root);
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_SimpleSingleton.h
----------------------
[-] 		new (p) T;
[+] 		new(p)T;
[-] getSimpleSingleton (volatile int32_t* flag = NULL)
[+] getSimpleSingleton(volatile int32_t* flag = NULL)
[-] 	static uchar_t buffer [sizeof (T)] = { 0 };
[+] 	static uchar_t buffer[sizeof(T)] = { 0 };
[-] 	callOnce (ConstructSimpleSingleton <T> (), buffer, flag);
[+] 	callOnce(ConstructSimpleSingleton<T> (), buffer, flag);
[-] 	return (T*) buffer;
[+] 	return (T*)buffer;
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_Singleton.h
----------------------
[-] 	finalize ()
[+] 	finalize()
[-] 		m_p->~T ();
[+] 		m_p->~T();
[-] 	typedef DestructSingleton <T> Destruct;
[+] 	typedef DestructSingleton<T> Destruct;
[-] 		new (p) T;
[+] 		new(p)T;
[-] 		ref::Ptr <Destruct> destruct = AXL_REF_NEW (Destruct);
[+] 		ref::Ptr<Destruct> destruct = AXL_REF_NEW(Destruct);
[-] 		destruct->m_p = (T*) p;
[+] 		destruct->m_p = (T*)p;
[-] 		g::getModule ()->addFinalizer (destruct);
[+] 		g::getModule()->addFinalizer(destruct);
[-] getSingleton (volatile int32_t* flag = NULL)
[+] getSingleton(volatile int32_t* flag = NULL)
[-] 	static uchar_t buffer [sizeof (T)] = { 0 };
[+] 	static uchar_t buffer[sizeof(T)] = { 0 };
[-] 	callOnce (ConstructSingleton <T> (), buffer, flag);
[+] 	callOnce(ConstructSingleton<T> (), buffer, flag);
[-] 	return (T*) buffer;
[+] 	return (T*)buffer;
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_String.h
----------------------
[-] 	typename Details0 = StringDetailsBase <T>
[+] 	typename Details0 = StringDetailsBase<T>
[-] 	typedef StringRefBase <C, Details> StringRef;
[+] 	typedef StringRefBase<C, Details> StringRef;
[-] 	typedef StringRefBase <C2, Details2> StringRef2;
[+] 	typedef StringRefBase<C2, Details2> StringRef2;
[-] 	typedef StringRefBase <C3, Details3> StringRef3;
[+] 	typedef StringRefBase<C3, Details3> StringRef3;
[-] 	typedef StringBase <C, Details> String;
[+] 	typedef StringBase<C, Details> String;
[-] 	typedef StringBase <C2, Details2> String2;
[+] 	typedef StringBase<C2, Details2> String2;
[-] 	typedef StringBase <C3, Details3> String3;
[+] 	typedef StringBase<C3, Details3> String3;
[-] 	StringRefBase ()
[+] 	StringRefBase()
[-] 		initialize ();
[+] 		initialize();
[-] 	StringRefBase (StringRef&& src)
[+] 	StringRefBase(StringRef&& src)
[-] 		initialize ();
[+] 		initialize();
[-] 		move (std::move (src));
[+] 		move(std::move(src));
[-] 	StringRefBase (const StringRef& src)
[+] 	StringRefBase(const StringRef& src)
[-] 		initialize ();
[+] 		initialize();
[-] 		attach (src);
[+] 		attach(src);
[-] 	StringRefBase (const C* p)
[+] 	StringRefBase(const C* p)
[-] 		initialize ();
[+] 		initialize();
[-] 		attach (NULL, p, Details::calcLength (p), p != NULL);
[+] 		attach(NULL, p, Details::calcLength(p), p != NULL);
[-] 	StringRefBase (
[+] 	StringRefBase(
[-] 		initialize ();
[+] 		initialize();
[-] 		attach (NULL, p, length, isNullTerminated);
[+] 		attach(NULL, p, length, isNullTerminated);
[-] 	StringRefBase (
[+] 	StringRefBase(
[-] 		initialize ();
[+] 		initialize();
[-] 		attach (NULL, p, (C*) end - p, isNullTerminated);
[+] 		attach(NULL, p, (C*)end - p, isNullTerminated);
[-] 	StringRefBase (
[+] 	StringRefBase(
[-] 		initialize ();
[+] 		initialize();
[-] 		attach (hdr, p, Details::calcLength (p), p != NULL);
[+] 		attach(hdr, p, Details::calcLength(p), p != NULL);
[-] 	StringRefBase (
[+] 	StringRefBase(
[-] 		initialize ();
[+] 		initialize();
[-] 		attach (hdr, p, length, isNullTerminated);
[+] 		attach(hdr, p, length, isNullTerminated);
[-] 	StringRefBase (
[+] 	StringRefBase(
[-] 		initialize ();
[+] 		initialize();
[-] 		attach (hdr, p, (C*) end - p, isNullTerminated);
[+] 		attach(hdr, p, (C*)end - p, isNullTerminated);
[-] 	~StringRefBase ()
[+] 	~StringRefBase()
[-] 		release ();
[+] 		release();
[-] 		move (std::move (src));
[+] 		move(std::move(src));
[-] 		attach (src);
[+] 		attach(src);
[-] 		return cmp (string) == 0;
[+] 		return cmp(string) == 0;
[-] 		return cmp (string) != 0;
[+] 		return cmp(string) != 0;
[-] 		return cmp (string) < 0;
[+] 		return cmp(string) < 0;
[-] 		return cmp (string) <= 0;
[+] 		return cmp(string) <= 0;
[-] 		return cmp (string) > 0;
[+] 		return cmp(string) > 0;
[-] 		return cmp (string) >= 0;
[+] 		return cmp(string) >= 0;
[-] 		return cmp (p) == 0;
[+] 		return cmp(p) == 0;
[-] 		return cmp (p) != 0;
[+] 		return cmp(p) != 0;
[-] 		return cmp (p) < 0;
[+] 		return cmp(p) < 0;
[-] 		return cmp (p) <= 0;
[+] 		return cmp(p) <= 0;
[-] 		return cmp (p) > 0;
[+] 		return cmp(p) > 0;
[-] 		return cmp (p) >= 0;
[+] 		return cmp(p) >= 0;
[-] 		result.append (string);
[+] 		result.append(string);
[-] 		result.append (string);
[+] 		result.append(string);
[-] 		result.append (string);
[+] 		result.append(string);
[-] 		result.append (p);
[+] 		result.append(p);
[-] 		result.append (p);
[+] 		result.append(p);
[-] 		result.append (p);
[+] 		result.append(p);
[-] 		ASSERT ((size_t) i < m_length);
[+] 		ASSERT((size_t)i < m_length);
[-] 		return m_p [(size_t) i];
[+] 		return m_p[(size_t)i];
[-] 	cp () const
[+] 	cp() const
[-] 	sz () const
[+] 	sz() const
[-] 		return m_length ? ensureNullTerminated () : Details::getEmptyString ();
[+] 		return m_length ? ensureNullTerminated() : Details::getEmptyString();
[-] 	szn () const
[+] 	szn() const
[-] 		return m_length ? ensureNullTerminated () : NULL;
[+] 		return m_length ? ensureNullTerminated() : NULL;
[-] 	s2 () const
[+] 	s2() const
[-] 		return String2 (m_p, m_length);
[+] 		return String2(m_p, m_length);
[-] 	s3 () const
[+] 	s3() const
[-] 		return String3 (m_p, m_length);
[+] 		return String3(m_p, m_length);
[-] 	getLength () const
[+] 	getLength() const
[-] 	getHdr () const
[+] 	getHdr() const
[-] 	getEnd () const
[+] 	getEnd() const
[-] 	isEmpty () const
[+] 	isEmpty() const
[-] 	isNullTerminated () const
[+] 	isNullTerminated() const
[-] 	clear ()
[+] 	clear()
[-] 		release ();
[+] 		release();
[-] 	release ()
[+] 	release()
[-] 			m_hdr->release ();
[+] 			m_hdr->release();
[-] 		initialize ();
[+] 		initialize();
[-] 	offset (size_t length)
[+] 	offset(size_t length)
[-] 	cmp (const StringRef& string) const
[+] 	cmp(const StringRef& string) const
[-] 		int result = Details::cmp (m_p, string.m_p, AXL_MIN (m_length, string.m_length));
[+] 		int result = Details::cmp(m_p, string.m_p, AXL_MIN(m_length, string.m_length));
[-] 	cmpIgnoreCase (
[+] 	cmpIgnoreCase(
[-] 			cmpIgnoreCase_pcu (string) :
[+] 			cmpIgnoreCase_pcu(string) :
[-] 			cmpIgnoreCase_pcp (string);
[+] 			cmpIgnoreCase_pcp(string);
[-] 	hash () const
[+] 	hash() const
[-] 		return djb2 (m_p, m_length * sizeof (C));
[+] 		return djb2(m_p, m_length * sizeof(C));
[-] 	hashIgnoreCase (CaseConvertMethod method = CaseConvertMethod_Default) const
[+] 	hashIgnoreCase(CaseConvertMethod method = CaseConvertMethod_Default) const
[-] 			hashIgnoreCase_pcu () :
[+] 			hashIgnoreCase_pcu() :
[-] 			hashIgnoreCase_pcp ();
[+] 			hashIgnoreCase_pcp();
[-] 	isEqual (const StringRef& string) const
[+] 	isEqual(const StringRef& string) const
[-] 			Details::cmp (m_p, string.m_p, m_length) == 0;
[+] 			Details::cmp(m_p, string.m_p, m_length) == 0;
[-] 	isEqualIgnoreCase (
[+] 	isEqualIgnoreCase(
[-] 		return cmpIgnoreCase (string, method) == 0;
[+] 		return cmpIgnoreCase(string, method) == 0;
[-] 	isPrefix (const StringRef& string) const
[+] 	isPrefix(const StringRef& string) const
[-] 			Details::cmp (m_p, string.m_p, string.m_length) == 0;
[+] 			Details::cmp(m_p, string.m_p, string.m_length) == 0;
[-] 	isPrefixIgnoreCase (
[+] 	isPrefixIgnoreCase(
[-] 			getLeftSubString (string.m_length).isEqualIgnoreCase (string, method);
[+] 			getLeftSubString(string.m_length).isEqualIgnoreCase(string, method);
[-] 	isSuffix (const StringRef& string) const
[+] 	isSuffix(const StringRef& string) const
[-] 			Details::cmp (m_p + m_length - string.m_length, string.m_p, string.m_length) == 0;
[+] 			Details::cmp(m_p + m_length - string.m_length, string.m_p, string.m_length) == 0;
[-] 	isSuffixIgnoreCase (
[+] 	isSuffixIgnoreCase(
[-] 			getRightSubString (string.m_length).isEqualIgnoreCase (string, method);
[+] 			getRightSubString(string.m_length).isEqualIgnoreCase(string, method);
[-] 	find (C c) const
[+] 	find(C c) const
[-] 		return Details::find (m_p, m_length, c);
[+] 		return Details::find(m_p, m_length, c);
[-] 	find (const StringRef& subString) const
[+] 	find(const StringRef& subString) const
[-] 		return Details::find (m_p, m_length, subString.m_p, subString.m_length);
[+] 		return Details::find(m_p, m_length, subString.m_p, subString.m_length);
[-] 	findOneOf (const StringRef& charSet) const
[+] 	findOneOf(const StringRef& charSet) const
[-] 		return Details::findOneOf (m_p, m_length, charSet.m_p, charSet.m_length);
[+] 		return Details::findOneOf(m_p, m_length, charSet.m_p, charSet.m_length);
[-] 	findNotOneOf (const StringRef& charSet) const
[+] 	findNotOneOf(const StringRef& charSet) const
[-] 		return Details::findNotOneOf (m_p, m_length, charSet.m_p, charSet.m_length);
[+] 		return Details::findNotOneOf(m_p, m_length, charSet.m_p, charSet.m_length);
[-] 	reverseFind (C c) const
[+] 	reverseFind(C c) const
[-] 		return Details::reverseFind (m_p, m_length, c);
[+] 		return Details::reverseFind(m_p, m_length, c);
[-] 	reverseFind (const StringRef& subString) const
[+] 	reverseFind(const StringRef& subString) const
[-] 		return Details::reverseFind (m_p, m_length, subString.m_p, subString.m_length);
[+] 		return Details::reverseFind(m_p, m_length, subString.m_p, subString.m_length);
[-] 	reverseFindOneOf (const StringRef& charSet) const
[+] 	reverseFindOneOf(const StringRef& charSet) const
[-] 		return Details::reverseFindOneOf (m_p, m_length, charSet.m_p, charSet.m_length);
[+] 		return Details::reverseFindOneOf(m_p, m_length, charSet.m_p, charSet.m_length);
[-] 	reverseFindNotOneOf (const StringRef& charSet) const
[+] 	reverseFindNotOneOf(const StringRef& charSet) const
[-] 		return Details::reverseFindNotOneOf (m_p, m_length, charSet.m_p, charSet.m_length);
[+] 		return Details::reverseFindNotOneOf(m_p, m_length, charSet.m_p, charSet.m_length);
[-] 	getSubString (
[+] 	getSubString(
[-] 			return StringRef ();
[+] 			return StringRef();
[-] 		return StringRef (m_hdr, m_p + first, end - first);
[+] 		return StringRef(m_hdr, m_p + first, end - first);
[-] 	getLeftSubString (size_t length) const
[+] 	getLeftSubString(size_t length) const
[-] 		return StringRef (m_hdr, m_p, length);
[+] 		return StringRef(m_hdr, m_p, length);
[-] 	getRightSubString (size_t length) const
[+] 	getRightSubString(size_t length) const
[-] 		return StringRef (m_hdr, m_p + m_length - length, length);
[+] 		return StringRef(m_hdr, m_p + m_length - length, length);
[-] 	getLeftTrimmedString () const
[+] 	getLeftTrimmedString() const
[-] 		static StringRef whitespace (Details::getWhitespace (), 4);
[+] 		static StringRef whitespace(Details::getWhitespace(), 4);
[-] 		size_t i = findNotOneOf (whitespace);
[+] 		size_t i = findNotOneOf(whitespace);
[-] 			return StringRef ();
[+] 			return StringRef();
[-] 		string.attach (m_hdr, m_p + i, m_length - i, m_isNullTerminated);
[+] 		string.attach(m_hdr, m_p + i, m_length - i, m_isNullTerminated);
[-] 	getRightTimmedString () const
[+] 	getRightTimmedString() const
[-] 		static StringRef whitespace (Details::getWhitespace (), 4);
[+] 		static StringRef whitespace(Details::getWhitespace(), 4);
[-] 		size_t i = reverseFindNotOneOf (whitespace);
[+] 		size_t i = reverseFindNotOneOf(whitespace);
[-] 			return StringRef ();
[+] 			return StringRef();
[-] 		string.attach (m_hdr, m_p, i + 1, false);
[+] 		string.attach(m_hdr, m_p, i + 1, false);
[-] 	getTrimmedString () const
[+] 	getTrimmedString() const
[-] 		static StringRef whitespace (Details::getWhitespace (), 4);
[+] 		static StringRef whitespace(Details::getWhitespace(), 4);
[-] 		size_t i = findNotOneOf (whitespace);
[+] 		size_t i = findNotOneOf(whitespace);
[-] 			return StringRef ();
[+] 			return StringRef();
[-] 		size_t j = reverseFindNotOneOf (whitespace);
[+] 		size_t j = reverseFindNotOneOf(whitespace);
[-] 		ASSERT (j != -1);
[+] 		ASSERT(j != -1);
[-] 			string.attach (m_hdr, m_p + i, j + 1 - i, false);
[+] 			string.attach(m_hdr, m_p + i, j + 1 - i, false);
[-] 			string.attach (m_hdr, m_p + i, m_length - i, m_isNullTerminated);
[+] 			string.attach(m_hdr, m_p + i, m_length - i, m_isNullTerminated);
[-] 	getLowerCaseString (CaseConvertMethod method = CaseConvertMethod_Default)
[+] 	getLowerCaseString(CaseConvertMethod method = CaseConvertMethod_Default)
[-] 		string.makeLowerCase (method);
[+] 		string.makeLowerCase(method);
[-] 	getUpperCaseString (CaseConvertMethod method = CaseConvertMethod_Default)
[+] 	getUpperCaseString(CaseConvertMethod method = CaseConvertMethod_Default)
[-] 		string.makeUpperCase (method);
[+] 		string.makeUpperCase(method);
[-] 	getCaseFoldedString (CaseConvertMethod method = CaseConvertMethod_Default)
[+] 	getCaseFoldedString(CaseConvertMethod method = CaseConvertMethod_Default)
[-] 		string.makeCaseFolded (method);
[+] 		string.makeCaseFolded(method);
[-] 	ensureNullTerminated () const
[+] 	ensureNullTerminated() const
[-] 		if (m_hdr && m_hdr->isInsideBuffer (m_p + m_length) && !m_p [m_length])
[+] 		if (m_hdr && m_hdr->isInsideBuffer(m_p + m_length) && !m_p[m_length])
[-] 		String string (*this);
[+] 		String string(*this);
[-] 		attachBufHdr (string.getHdr ());
[+] 		attachBufHdr(string.getHdr());
[-] 		m_p = (C*) string.sz ();
[+] 		m_p = (C*)string.sz();
[-] 	initialize ()
[+] 	initialize()
[-] 	move (StringRefBase&& src)
[+] 	move(StringRefBase&& src)
[-] 			m_hdr->release ();
[+] 			m_hdr->release();
[-] 		src.initialize ();
[+] 		src.initialize();
[-] 	attachBufHdr (ref::BufHdr* hdr) const
[+] 	attachBufHdr(ref::BufHdr* hdr) const
[-] 			hdr->addRef ();
[+] 			hdr->addRef();
[-] 			m_hdr->release ();
[+] 			m_hdr->release();
[-] 	attach (const StringRef& src)
[+] 	attach(const StringRef& src)
[-] 			attach (src.m_hdr, src.m_p, src.m_length, src.m_isNullTerminated);
[+] 			attach(src.m_hdr, src.m_p, src.m_length, src.m_isNullTerminated);
[-] 	attach (
[+] 	attach(
[-] 		ASSERT (length != -1 && (!isNullTerminated || !p [length]));
[+] 		ASSERT(length != -1 && (!isNullTerminated || !p[length]));
[-] 		attachBufHdr (hdr);
[+] 		attachBufHdr(hdr);
[-] 		m_p = (C*) p;
[+] 		m_p = (C*)p;
[-] 	cmpIgnoreCase_pcu (const StringRef& string) const
[+] 	cmpIgnoreCase_pcu(const StringRef& string) const
[-] 		size_t length = AXL_MIN (m_length, string.m_length);
[+] 		size_t length = AXL_MIN(m_length, string.m_length);
[-] 			C c1 = Details::toLower (*p1);
[+] 			C c1 = Details::toLower(*p1);
[-] 			C c2 = Details::toLower (*p2);
[+] 			C c2 = Details::toLower(*p2);
[-] 	cmpIgnoreCase_pcp (const StringRef& string) const
[+] 	cmpIgnoreCase_pcp(const StringRef& string) const
[-] 			size_t codePointLength1 = Encoding::getDecodeCodePointLength (*p1);
[+] 			size_t codePointLength1 = Encoding::getDecodeCodePointLength(*p1);
[-] 			size_t codePointLength2 = Encoding::getDecodeCodePointLength (*p2);
[+] 			size_t codePointLength2 = Encoding::getDecodeCodePointLength(*p2);
[-] 			utf32_t c1 = Encoding::decodeCodePoint (p1);
[+] 			utf32_t c1 = Encoding::decodeCodePoint(p1);
[-] 			utf32_t c2 = Encoding::decodeCodePoint (p2);
[+] 			utf32_t c2 = Encoding::decodeCodePoint(p2);
[-] 			c1 = enc::UtfToCaseFolded () (c1);
[+] 			c1 = enc::UtfToCaseFolded() (c1);
[-] 			c2 = enc::UtfToCaseFolded () (c2);
[+] 			c2 = enc::UtfToCaseFolded() (c2);
[-] 	hashIgnoreCase_pcu () const
[+] 	hashIgnoreCase_pcu() const
[-] 		size_t h = djb2 ();
[+] 		size_t h = djb2();
[-] 			C c = Details::toLower (*p);
[+] 			C c = Details::toLower(*p);
[-] 			h = djb2 (h, &c, sizeof (c));
[+] 			h = djb2(h, &c, sizeof(c));
[-] 	hashIgnoreCase_pcp () const
[+] 	hashIgnoreCase_pcp() const
[-] 		size_t h = djb2 ();
[+] 		size_t h = djb2();
[-] 			size_t codePointLength = Encoding::getDecodeCodePointLength (*p);
[+] 			size_t codePointLength = Encoding::getDecodeCodePointLength(*p);
[-] 			utf32_t c = Encoding::decodeCodePoint (p);
[+] 			utf32_t c = Encoding::decodeCodePoint(p);
[-] 			c = enc::UtfToCaseFolded () (c);
[+] 			c = enc::UtfToCaseFolded() (c);
[-] 			h = djb2 (h, &c, sizeof (c));
[+] 			h = djb2(h, &c, sizeof(c));
[-] 	typename Details0 = StringDetailsBase <T>
[+] 	typename Details0 = StringDetailsBase<T>
[-] class StringBase: public StringRefBase <T, Details0>
[+] class StringBase: public StringRefBase<T, Details0>
[-] 	typedef StringRefBase <T, Details0> StringRef;
[+] 	typedef StringRefBase<T, Details0> StringRef;
[-] 	StringBase ()
[+] 	StringBase()
[-] 	StringBase (StringBase&& src)
[+] 	StringBase(StringBase&& src)
[-] 		copy (std::move (src));
[+] 		copy(std::move(src));
[-] 	StringBase (StringRef&& src)
[+] 	StringBase(StringRef&& src)
[-] 		copy (std::move (src));
[+] 		copy(std::move(src));
[-] 	StringBase (const StringBase& src)
[+] 	StringBase(const StringBase& src)
[-] 		copy (src);
[+] 		copy(src);
[-] 	StringBase (const StringRef& src)
[+] 	StringBase(const StringRef& src)
[-] 		copy (src);
[+] 		copy(src);
[-] 	StringBase (const StringRef2& src)
[+] 	StringBase(const StringRef2& src)
[-] 		copy (src);
[+] 		copy(src);
[-] 	StringBase (const StringRef3& src)
[+] 	StringBase(const StringRef3& src)
[-] 		copy (src);
[+] 		copy(src);
[-] 	StringBase (
[+] 	StringBase(
[-] 		copy (p, length);
[+] 		copy(p, length);
[-] 	StringBase (
[+] 	StringBase(
[-] 		copy (p, (C*) end - p);
[+] 		copy(p, (C*)end - p);
[-] 	StringBase (
[+] 	StringBase(
[-] 		copy (p, length);
[+] 		copy(p, length);
[-] 	StringBase (
[+] 	StringBase(
[-] 		copy (p, (C2*) end - p);
[+] 		copy(p, (C2*)end - p);
[-] 	StringBase (
[+] 	StringBase(
[-] 		copy (p, length);
[+] 		copy(p, length);
[-] 	StringBase (
[+] 	StringBase(
[-] 		copy (p, (C3*) end - p);
[+] 		copy(p, (C3*)end - p);
[-] 	StringBase (utf32_t x)
[+] 	StringBase(utf32_t x)
[-] 		copy (x);
[+] 		copy(x);
[-] 	StringBase (
[+] 	StringBase(
[-] 		copy (x, count);
[+] 		copy(x, count);
[-] 	StringBase (
[+] 	StringBase(
[-] 		setBuffer (kind, p, size);
[+] 		setBuffer(kind, p, size);
[-] 		return sz ();
[+] 		return sz();
[-] 		copy (std::move (src));
[+] 		copy(std::move(src));
[-] 		copy (std::move (src));
[+] 		copy(std::move(src));
[-] 		copy (src);
[+] 		copy(src);
[-] 		copy (src);
[+] 		copy(src);
[-] 		copy (src);
[+] 		copy(src);
[-] 		copy (src);
[+] 		copy(src);
[-] 		copy (p, -1);
[+] 		copy(p, -1);
[-] 		copy (p, -1);
[+] 		copy(p, -1);
[-] 		copy (p, -1);
[+] 		copy(p, -1);
[-] 		copy (x);
[+] 		copy(x);
[-] 		append (string);
[+] 		append(string);
[-] 		append (string);
[+] 		append(string);
[-] 		append (string);
[+] 		append(string);
[-] 		append (p, -1);
[+] 		append(p, -1);
[-] 		append (p, -1);
[+] 		append(p, -1);
[-] 		append (p, -1);
[+] 		append(p, -1);
[-] 		append (x);
[+] 		append(x);
[-] 		ASSERT ((size_t) i < this->m_length);
[+] 		ASSERT((size_t)i < this->m_length);
[-] 		return this->m_p [(size_t) i];
[+] 		return this->m_p[(size_t)i];
[-] 		ASSERT ((size_t) i < this->m_length);
[+] 		ASSERT((size_t)i < this->m_length);
[-] 		return this->m_p [(size_t) i];
[+] 		return this->m_p[(size_t)i];
[-] 	p ()
[+] 	p()
[-] 	sz () const
[+] 	sz() const
[-] 		ASSERT (!this->m_length || this->m_isNullTerminated);
[+] 		ASSERT(!this->m_length || this->m_isNullTerminated);
[-] 		return this->m_length ? this->m_p : Details::getEmptyString ();
[+] 		return this->m_length ? this->m_p : Details::getEmptyString();
[-] 	szn () const
[+] 	szn() const
[-] 		ASSERT (!this->m_length || this->m_isNullTerminated);
[+] 		ASSERT(!this->m_length || this->m_isNullTerminated);
[-] 	clear ()
[+] 	clear()
[-] 			ASSERT (!this->m_length);
[+] 			ASSERT(!this->m_length);
[-] 		if (this->m_hdr->getRefCount () != 1)
[+] 		if (this->m_hdr->getRefCount() != 1)
[-] 			this->release ();
[+] 			this->release();
[-] 		this->m_p = (C*) (this->m_hdr + 1);
[+] 		this->m_p = (C*)(this->m_hdr + 1);
[-] 		this->m_p [0] = 0;
[+] 		this->m_p[0] = 0;
[-] 	forceCopy (const StringRef& src)
[+] 	forceCopy(const StringRef& src)
[-] 		return copy (src.cp (), src.getLength ());
[+] 		return copy(src.cp(), src.getLength());
[-] 	copy (StringRef&& src)
[+] 	copy(StringRef&& src)
[-] 		if (src.isEmpty ())
[+] 		if (src.isEmpty())
[-] 			clear ();
[+] 			clear();
[-] 			src.release ();
[+] 			src.release();
[-] 		ref::BufHdr* hdr = src.getHdr ();
[+] 		ref::BufHdr* hdr = src.getHdr();
[-] 		if (!hdr || (hdr->getFlags () & ref::BufHdrFlag_Exclusive) || !src.isNullTerminated ())
[+] 		if (!hdr || (hdr->getFlags() & ref::BufHdrFlag_Exclusive) || !src.isNullTerminated())
[-] 			copy (src.cp (), src.getLength ());
[+] 			copy(src.cp(), src.getLength());
[-] 			src.release ();
[+] 			src.release();
[-] 		this->move (std::move (src));
[+] 		this->move(std::move(src));
[-] 	copy (const StringRef& src)
[+] 	copy(const StringRef& src)
[-] 		if (src.isEmpty ())
[+] 		if (src.isEmpty())
[-] 			clear ();
[+] 			clear();
[-] 		ref::BufHdr* hdr = src.getHdr ();
[+] 		ref::BufHdr* hdr = src.getHdr();
[-] 		if (!hdr || (hdr->getFlags () & ref::BufHdrFlag_Exclusive) || !src.isNullTerminated ())
[+] 		if (!hdr || (hdr->getFlags() & ref::BufHdrFlag_Exclusive) || !src.isNullTerminated())
[-] 			return copy (src.cp (), src.getLength ());
[+] 			return copy(src.cp(), src.getLength());
[-] 		this->attach (src);
[+] 		this->attach(src);
[-] 	copy (const StringRef2& src)
[+] 	copy(const StringRef2& src)
[-] 		return copy (src.cp (), src.getLength ());
[+] 		return copy(src.cp(), src.getLength());
[-] 	copy (const StringRef3& src)
[+] 	copy(const StringRef3& src)
[-] 		return copy (src.cp (), src.getLength ());
[+] 		return copy(src.cp(), src.getLength());
[-] 	copy (
[+] 	copy(
[-] 			length = Details::calcLength (p);
[+] 			length = Details::calcLength(p);
[-] 			clear ();
[+] 			clear();
[-] 		if (this->m_hdr && this->m_hdr->isInsideBuffer (p))
[+] 		if (this->m_hdr && this->m_hdr->isInsideBuffer(p))
[-] 			C* end = (C*) this->m_hdr->getEnd ();
[+] 			C* end = (C*)this->m_hdr->getEnd();
[-] 			ASSERT (p + length <= end);
[+] 			ASSERT(p + length <= end);
[-] 			this->m_p = (C*) p;
[+] 			this->m_p = (C*)p;
[-] 			this->m_isNullTerminated = p + length < end && !p [length];
[+] 			this->m_isNullTerminated = p + length < end && !p[length];
[-] 		if (!createBuffer (length, false))
[+] 		if (!createBuffer(length, false))
[-] 		Details::copy (this->m_p, p, length);
[+] 		Details::copy(this->m_p, p, length);
[-] 	copy (
[+] 	copy(
[-] 			length = Details2::calcLength (p);
[+] 			length = Details2::calcLength(p);
[-] 			clear ();
[+] 			clear();
[-] 		size_t newLength = enc::UtfConvert <Encoding, Encoding2>::calcRequiredLength (p, length);
[+] 		size_t newLength = enc::UtfConvert<Encoding, Encoding2>::calcRequiredLength(p, length);
[-] 		if (!createBuffer (newLength, false))
[+] 		if (!createBuffer(newLength, false))
[-] 		enc::UtfConvert <Encoding, Encoding2>::convert (this->m_p, newLength, p, length);
[+] 		enc::UtfConvert<Encoding, Encoding2>::convert(this->m_p, newLength, p, length);
[-] 	copy (
[+] 	copy(
[-] 			length = Details3::calcLength (p);
[+] 			length = Details3::calcLength(p);
[-] 			clear ();
[+] 			clear();
[-] 		size_t newLength = enc::UtfConvert <Encoding, Encoding3>::calcRequiredLength (p, length);
[+] 		size_t newLength = enc::UtfConvert<Encoding, Encoding3>::calcRequiredLength(p, length);
[-] 		if (!createBuffer (newLength, false))
[+] 		if (!createBuffer(newLength, false))
[-] 		enc::UtfConvert <Encoding, Encoding3>::convert (this->m_p, newLength, p, length);
[+] 		enc::UtfConvert<Encoding, Encoding3>::convert(this->m_p, newLength, p, length);
[-] 	copy (utf32_t x)
[+] 	copy(utf32_t x)
[-] 			clear ();
[+] 			clear();
[-] 		return copy (x, 1);
[+] 		return copy(x, 1);
[-] 	copy (
[+] 	copy(
[-] 			clear ();
[+] 			clear();
[-] 		size_t codePointLength = Encoding::getEncodeCodePointLength (x);
[+] 		size_t codePointLength = Encoding::getEncodeCodePointLength(x);
[-] 		ASSERT (codePointLength <= 4);
[+] 		ASSERT(codePointLength <= 4);
[-] 		if (!createBuffer (newLength, false))
[+] 		if (!createBuffer(newLength, false))
[-] 		C pattern [sizeof (utf32_t) / sizeof (C)];
[+] 		C pattern[sizeof(utf32_t) / sizeof(C)];
[-] 		Encoding::encodeCodePoint (pattern, x);
[+] 		Encoding::encodeCodePoint(pattern, x);
[-] 		fillWithPattern (this->m_p, pattern, codePointLength, count);
[+] 		fillWithPattern(this->m_p, pattern, codePointLength, count);
[-] 	append (const StringRef& src)
[+] 	append(const StringRef& src)
[-] 		return insert (-1, src);
[+] 		return insert(-1, src);
[-] 	append (const StringRef2& src)
[+] 	append(const StringRef2& src)
[-] 		return insert (-1, src);
[+] 		return insert(-1, src);
[-] 	append (const StringRef3& src)
[+] 	append(const StringRef3& src)
[-] 		return insert (-1, src);
[+] 		return insert(-1, src);
[-] 	append (
[+] 	append(
[-] 		return insert (-1, p, length);
[+] 		return insert(-1, p, length);
[-] 	append (
[+] 	append(
[-] 		return insert (-1, p, length);
[+] 		return insert(-1, p, length);
[-] 	append (
[+] 	append(
[-] 		return insert (-1, p, length);
[+] 		return insert(-1, p, length);
[-] 	append (utf32_t x)
[+] 	append(utf32_t x)
[-] 		return x ? append (x, 1) : this->m_length;
[+] 		return x ? append(x, 1) : this->m_length;
[-] 	append (
[+] 	append(
[-] 		return insert (-1, x, count);
[+] 		return insert(-1, x, count);
[-] 	appendNewLine ()
[+] 	appendNewLine()
[-] 		return insertNewLine (-1);
[+] 		return insertNewLine(-1);
[-] 	insert (
[+] 	insert(
[-] 		return !this->m_length ? copy (src) : insert (index, src.cp (), src.getLength ());
[+] 		return !this->m_length ? copy(src) : insert(index, src.cp(), src.getLength());
[-] 	insert (
[+] 	insert(
[-] 		return insert (index, src.cp (), src.getLength ());
[+] 		return insert(index, src.cp(), src.getLength());
[-] 	insert (
[+] 	insert(
[-] 		return insert (index, src.cp (), src.getLength ());
[+] 		return insert(index, src.cp(), src.getLength());
[-] 	insert (
[+] 	insert(
[-] 			length = Details::calcLength (p);
[+] 			length = Details::calcLength(p);
[-] 		ref::Ptr <void> shadow;
[+] 		ref::Ptr<void> shadow;
[-] 		if (this->m_hdr && this->m_hdr->isInsideBuffer (p))
[+] 		if (this->m_hdr && this->m_hdr->isInsideBuffer(p))
[-] 		C* dst = insertSpace (index, length);
[+] 		C* dst = insertSpace(index, length);
[-] 		Details::copy (dst, p, length);
[+] 		Details::copy(dst, p, length);
[-] 	insert (
[+] 	insert(
[-] 			length = Details2::calcLength (p);
[+] 			length = Details2::calcLength(p);
[-] 		size_t insertLength = enc::UtfConvert <Encoding, Encoding2>::calcRequiredLength (p, length);
[+] 		size_t insertLength = enc::UtfConvert<Encoding, Encoding2>::calcRequiredLength(p, length);
[-] 		C* dst = insertSpace (index, insertLength);
[+] 		C* dst = insertSpace(index, insertLength);
[-] 		enc::UtfConvert <Encoding, Encoding2>::convert (dst, insertLength, p, length);
[+] 		enc::UtfConvert<Encoding, Encoding2>::convert(dst, insertLength, p, length);
[-] 	insert (
[+] 	insert(
[-] 			length = Details3::calcLength (p);
[+] 			length = Details3::calcLength(p);
[-] 		size_t insertLength = enc::UtfConvert <Encoding, Encoding3>::calcRequiredLength (p, length);
[+] 		size_t insertLength = enc::UtfConvert<Encoding, Encoding3>::calcRequiredLength(p, length);
[-] 		C* dst = insertSpace (index, insertLength);
[+] 		C* dst = insertSpace(index, insertLength);
[-] 		enc::UtfConvert <Encoding, Encoding3>::convert (dst, insertLength, p, length);
[+] 		enc::UtfConvert<Encoding, Encoding3>::convert(dst, insertLength, p, length);
[-] 	insert (
[+] 	insert(
[-] 		return x ? insert (index, x, 1) : this->m_length;
[+] 		return x ? insert(index, x, 1) : this->m_length;
[-] 	insert (
[+] 	insert(
[-] 		size_t codePointLength = Encoding::getEncodeCodePointLength (x);
[+] 		size_t codePointLength = Encoding::getEncodeCodePointLength(x);
[-] 		ASSERT (codePointLength <= 4);
[+] 		ASSERT(codePointLength <= 4);
[-] 		C* dst = insertSpace (index, count * codePointLength);
[+] 		C* dst = insertSpace(index, count * codePointLength);
[-] 		C pattern [sizeof (utf32_t) / sizeof (C)];
[+] 		C pattern[sizeof(utf32_t) / sizeof(C)];
[-] 		Encoding::encodeCodePoint (pattern, x);
[+] 		Encoding::encodeCodePoint(pattern, x);
[-] 		fillWithPattern (dst, pattern, codePointLength, count);
[+] 		fillWithPattern(dst, pattern, codePointLength, count);
[-] 	insertNewLine (size_t index)
[+] 	insertNewLine(size_t index)
[-] 		return insert (index, Details::getCrLf (), 2);
[+] 		return insert(index, Details::getCrLf(), 2);
[-] 		return insert (index, '\n');
[+] 		return insert(index, '\n');
[-] 	remove (
[+] 	remove(
[-] 			result = setReducedLength (index);
[+] 			result = setReducedLength(index);
[-] 		result = ensureExclusive ();
[+] 		result = ensureExclusive();
[-] 		Details::copy (dst, dst + count, newLength - index);
[+] 		Details::copy(dst, dst + count, newLength - index);
[-] 		result = setReducedLength (newLength);
[+] 		result = setReducedLength(newLength);
[-] 	trimLeft ()
[+] 	trimLeft()
[-] 		static StringRef whitespace (Details::getWhitespace (), 4);
[+] 		static StringRef whitespace(Details::getWhitespace(), 4);
[-] 		size_t i = this->findNotOneOf (whitespace);
[+] 		size_t i = this->findNotOneOf(whitespace);
[-] 			clear ();
[+] 			clear();
[-] 	trimRight ()
[+] 	trimRight()
[-] 		static StringRef whitespace (Details::getWhitespace (), 4);
[+] 		static StringRef whitespace(Details::getWhitespace(), 4);
[-] 		size_t i = this->reverseFindNotOneOf (whitespace);
[+] 		size_t i = this->reverseFindNotOneOf(whitespace);
[-] 			clear ();
[+] 			clear();
[-] 		setReducedLength (i + 1);
[+] 		setReducedLength(i + 1);
[-] 	trim ()
[+] 	trim()
[-] 		trimLeft ();
[+] 		trimLeft();
[-] 		return trimRight ();
[+] 		return trimRight();
[-] 	replace (
[+] 	replace(
[-] 		return replace (from, from.getLength (), to, to.getLength ());
[+] 		return replace(from, from.getLength(), to, to.getLength());
[-] 	replace (
[+] 	replace(
[-] 		return replace (from, Details::calcLength (from), to, Details::calcLength (to));
[+] 		return replace(from, Details::calcLength(from), to, Details::calcLength(to));
[-] 	replace (
[+] 	replace(
[-] 		bool result = ensureExclusive ();
[+] 		bool result = ensureExclusive();
[-] 			size_t i = Details::find (this->m_p + offset, this->m_length - offset, from, fromLength);
[+] 			size_t i = Details::find(this->m_p + offset, this->m_length - offset, from, fromLength);
[-] 				fromLength < toLength ?	insertSpace (i, toLength - fromLength) != NULL :
[+] 				fromLength < toLength ?	insertSpace(i, toLength - fromLength) != NULL :
[-] 				fromLength > toLength ?	remove (i, fromLength - toLength) != -1 :
[+] 				fromLength > toLength ?	remove(i, fromLength - toLength) != -1 :
[-] 			Details::copy (this->m_p + i, to, toLength);
[+] 			Details::copy(this->m_p + i, to, toLength);
[-] 	replace (
[+] 	replace(
[-] 		bool result = ensureExclusive ();
[+] 		bool result = ensureExclusive();
[-] 	makeLowerCase (CaseConvertMethod method = CaseConvertMethod_Default)
[+] 	makeLowerCase(CaseConvertMethod method = CaseConvertMethod_Default)
[-] 			convertCase_pcu (Details::toLower) :
[+] 			convertCase_pcu(Details::toLower) :
[-] 			convertCase_pcp <enc::UtfToLowerCase> ();
[+] 			convertCase_pcp<enc::UtfToLowerCase> ();
[-] 	makeUpperCase (CaseConvertMethod method = CaseConvertMethod_Default)
[+] 	makeUpperCase(CaseConvertMethod method = CaseConvertMethod_Default)
[-] 			convertCase_pcu (Details::toUpper) :
[+] 			convertCase_pcu(Details::toUpper) :
[-] 			convertCase_pcp <enc::UtfToUpperCase> ();
[+] 			convertCase_pcp<enc::UtfToUpperCase> ();
[-] 	makeCaseFolded (CaseConvertMethod method = CaseConvertMethod_Default)
[+] 	makeCaseFolded(CaseConvertMethod method = CaseConvertMethod_Default)
[-] 			convertCase_pcu (Details::toLower) :
[+] 			convertCase_pcu(Details::toLower) :
[-] 			convertCase_pcp <enc::UtfToCaseFolded> ();
[+] 			convertCase_pcp<enc::UtfToCaseFolded> ();
[-] 	format_va (
[+] 	format_va(
[-] 		size_t length = Details::calcFormatLength_va (formatString, va);
[+] 		size_t length = Details::calcFormatLength_va(formatString, va);
[-] 		if (!createBuffer (length, false))
[+] 		if (!createBuffer(length, false))
[-] 		Details::format_va (this->m_p, length + 1, formatString, va);
[+] 		Details::format_va(this->m_p, length + 1, formatString, va);
[-] 	format (
[+] 	format(
[-] 		AXL_VA_DECL (va, formatString);
[+] 		AXL_VA_DECL(va, formatString);
[-] 		return format_va (formatString, va);
[+] 		return format_va(formatString, va);
[-] 	appendFormat_va (
[+] 	appendFormat_va(
[-] 		size_t appendLength = Details::calcFormatLength_va (formatString, va);
[+] 		size_t appendLength = Details::calcFormatLength_va(formatString, va);
[-] 		if (!createBuffer (newLength, true))
[+] 		if (!createBuffer(newLength, true))
[-] 		Details::format_va (this->m_p + oldLength, appendLength + 1, formatString, va);
[+] 		Details::format_va(this->m_p + oldLength, appendLength + 1, formatString, va);
[-] 	appendFormat (
[+] 	appendFormat(
[-] 		AXL_VA_DECL (va, formatString);
[+] 		AXL_VA_DECL(va, formatString);
[-] 		return appendFormat_va (formatString, va);
[+] 		return appendFormat_va(formatString, va);
[-] 	chop (size_t delta)
[+] 	chop(size_t delta)
[-] 			clear ();
[+] 			clear();
[-] 			bool result = setReducedLength (this->m_length - delta);
[+] 			bool result = setReducedLength(this->m_length - delta);
[-] 	setReducedLength (size_t length)
[+] 	setReducedLength(size_t length)
[-] 			clear ();
[+] 			clear();
[-] 		ASSERT (this->m_p && this->m_hdr);
[+] 		ASSERT(this->m_p && this->m_hdr);
[-] 		ASSERT (length < this->m_hdr->getLeftoverBufferSize (this->m_p) / sizeof (C)); // misuse otherwise
[+] 		ASSERT(length < this->m_hdr->getLeftoverBufferSize(this->m_p) / sizeof(C)); // misuse otherwise
[-] 		bool isNullTerminated = !this->m_p [length];
[+] 		bool isNullTerminated = !this->m_p[length];
[-] 		if (!isNullTerminated && this->m_hdr->getRefCount () == 1)
[+] 		if (!isNullTerminated && this->m_hdr->getRefCount() == 1)
[-] 			this->m_p [length] = 0;
[+] 			this->m_p[length] = 0;
[-] 		return isNullTerminated || createBuffer (length, true) != NULL;
[+] 		return isNullTerminated || createBuffer(length, true) != NULL;
[-] 	isExclusive ()
[+] 	isExclusive()
[-] 		return !this->m_length || this->m_hdr && this->m_hdr->getRefCount () == 1;
[+] 		return !this->m_length || this->m_hdr && this->m_hdr->getRefCount() == 1;
[-] 	ensureExclusive ()
[+] 	ensureExclusive()
[-] 		return this->m_length ? createBuffer (this->m_length, true) != NULL : true;
[+] 		return this->m_length ? createBuffer(this->m_length, true) != NULL : true;
[-] 	getBuffer (size_t* length = NULL)
[+] 	getBuffer(size_t* length = NULL)
[-] 		C* p = createBuffer (this->m_length, true);
[+] 		C* p = createBuffer(this->m_length, true);
[-] 			size_t bufferLength = this->m_hdr->getLeftoverBufferSize (this->m_p) / sizeof (C);
[+] 			size_t bufferLength = this->m_hdr->getLeftoverBufferSize(this->m_p) / sizeof(C);
[-] 			ASSERT (bufferLength);
[+] 			ASSERT(bufferLength);
[-] 	createBuffer (
[+] 	createBuffer(
[-] 		size_t size = (length + 1) * sizeof (C);
[+] 		size_t size = (length + 1) * sizeof(C);
[-] 			this->m_hdr->getRefCount () == 1)
[+] 			this->m_hdr->getRefCount() == 1)
[-] 				this->m_p = (C*) (this->m_hdr + 1);
[+] 				this->m_p = (C*)(this->m_hdr + 1);
[-] 			if (this->m_hdr->getLeftoverBufferSize (this->m_p) >= size)
[+] 			if (this->m_hdr->getLeftoverBufferSize(this->m_p) >= size)
[-] 				this->m_p [length] = 0;
[+] 				this->m_p[length] = 0;
[-] 		size_t bufferSize = getAllocSize (size);
[+] 		size_t bufferSize = getAllocSize(size);
[-] 		ref::Ptr <ref::BufHdr> hdr = AXL_REF_NEW_EXTRA (ref::BufHdr, bufferSize);
[+] 		ref::Ptr<ref::BufHdr> hdr = AXL_REF_NEW_EXTRA(ref::BufHdr, bufferSize);
[-] 		C* p = (C*) (hdr + 1);
[+] 		C* p = (C*)(hdr + 1);
[-] 			size_t copyLength = AXL_MIN (length, this->m_length);
[+] 			size_t copyLength = AXL_MIN(length, this->m_length);
[-] 			Details::copy (p, this->m_p, copyLength);
[+] 			Details::copy(p, this->m_p, copyLength);
[-] 			this->m_hdr->release ();
[+] 			this->m_hdr->release();
[-] 		p [length] = 0; // ensure zero termination
[+] 		p[length] = 0; // ensure zero termination
[-] 		this->m_hdr = hdr.detach ();
[+] 		this->m_hdr = hdr.detach();
[-] 	setBuffer (
[+] 	setBuffer(
[-] 		ASSERT (size >= sizeof (ref::BufHdr) + sizeof (C));
[+] 		ASSERT(size >= sizeof(ref::BufHdr) + sizeof(C));
[-] 		size_t bufferSize = size - sizeof (ref::BufHdr);
[+] 		size_t bufferSize = size - sizeof(ref::BufHdr);
[-] 		ref::Ptr <ref::BufHdr> hdr = AXL_REF_NEW_INPLACE (ref::BufHdr, p, NULL, flags);
[+] 		ref::Ptr<ref::BufHdr> hdr = AXL_REF_NEW_INPLACE(ref::BufHdr, p, NULL, flags);
[-] 			this->m_hdr->release ();
[+] 			this->m_hdr->release();
[-] 		this->m_p = (C*) (hdr + 1);
[+] 		this->m_p = (C*)(hdr + 1);
[-] 		this->m_p [0] = 0;
[+] 		this->m_p[0] = 0;
[-] 		this->m_hdr = hdr.detach ();
[+] 		this->m_hdr = hdr.detach();
[-] 		return bufferSize / sizeof (C) - 1;
[+] 		return bufferSize / sizeof(C) - 1;
[-] 	reserve (
[+] 	reserve(
[-] 		if (!createBuffer (length, saveContents))
[+] 		if (!createBuffer(length, saveContents))
[-] 		this->m_p [oldLength] = 0;
[+] 		this->m_p[oldLength] = 0;
[-] 	updateLength ()
[+] 	updateLength()
[-] 		size_t fullLength = this->m_hdr->getLeftoverBufferSize (this->m_p) / sizeof (C);
[+] 		size_t fullLength = this->m_hdr->getLeftoverBufferSize(this->m_p) / sizeof(C);
[-] 		ASSERT (fullLength);
[+] 		ASSERT(fullLength);
[-] 		this->m_length = Details::calcLength (this->m_p, fullLength - 1);
[+] 		this->m_length = Details::calcLength(this->m_p, fullLength - 1);
[-] 	insertSpace (
[+] 	insertSpace(
[-] 		if (!createBuffer (oldLength + length, true))
[+] 		if (!createBuffer(oldLength + length, true))
[-] 			Details::move (dst + length, dst, oldLength - index);
[+] 			Details::move(dst + length, dst, oldLength - index);
[-] 	fillWithPattern (
[+] 	fillWithPattern(
[-] 			Details::fill (p, *pattern, count);
[+] 			Details::fill(p, *pattern, count);
[-] 			Details::copy (p, pattern, patternLength);
[+] 			Details::copy(p, pattern, patternLength);
[-] 	convertCase_pcu (CaseOp op)
[+] 	convertCase_pcu(CaseOp op)
[-] 		bool result = ensureExclusive ();
[+] 		bool result = ensureExclusive();
[-] 			*p = op (*p);
[+] 			*p = op(*p);
[-] 	convertCase_pcp ()
[+] 	convertCase_pcp()
[-] 		size_t length = enc::UtfConvert <Encoding, Encoding, CaseOp>::calcRequiredLength (this->m_p, this->m_length);
[+] 		size_t length = enc::UtfConvert<Encoding, Encoding, CaseOp>::calcRequiredLength(this->m_p, this->m_length);
[-] 		C* p = createBuffer (length);
[+] 		C* p = createBuffer(length);
[-] 		enc::UtfConvert <Encoding, Encoding, CaseOp>::convert (p, length, src.cp (), src.getLength ());
[+] 		enc::UtfConvert<Encoding, Encoding, CaseOp>::convert(p, length, src.cp(), src.getLength());
[-] typedef StringRefBase <char>    StringRef;
[+] typedef StringRefBase<char>    StringRef;
[-] typedef StringRefBase <wchar_t> StringRef_w;
[+] typedef StringRefBase<wchar_t> StringRef_w;
[-] typedef StringRefBase <utf8_t>  StringRef_utf8;
[+] typedef StringRefBase<utf8_t>  StringRef_utf8;
[-] typedef StringRefBase <utf16_t> StringRef_utf16;
[+] typedef StringRefBase<utf16_t> StringRef_utf16;
[-] typedef StringRefBase <utf32_t> StringRef_utf32;
[+] typedef StringRefBase<utf32_t> StringRef_utf32;
[-] typedef StringBase <char>    String;
[+] typedef StringBase<char>    String;
[-] typedef StringBase <wchar_t> String_w;
[+] typedef StringBase<wchar_t> String_w;
[-] typedef StringBase <utf8_t>  String_utf8;
[+] typedef StringBase<utf8_t>  String_utf8;
[-] typedef StringBase <utf16_t> String_utf16;
[+] typedef StringBase<utf16_t> String_utf16;
[-] typedef StringBase <utf32_t> String_utf32;
[+] typedef StringBase<utf32_t> String_utf32;
[-] class ArgType <String_utf8>
[+] class ArgType<String_utf8>
[-] class ArgType <String_utf16>
[+] class ArgType<String_utf16>
[-] class ArgType <String_utf32>
[+] class ArgType<String_utf32>
[-] formatString_va (
[+] formatString_va(
[-] 	string.format_va (formatString, va);
[+] 	string.format_va(formatString, va);
[-] formatString (
[+] formatString(
[-] 	AXL_VA_DECL (va, formatString);
[+] 	AXL_VA_DECL(va, formatString);
[-] 	return formatString_va (formatString, va);
[+] 	return formatString_va(formatString, va);
[-] formatString_w_va (
[+] formatString_w_va(
[-] 	string.format_va (formatString, va);
[+] 	string.format_va(formatString, va);
[-] formatString_w (
[+] formatString_w(
[-] 	AXL_VA_DECL (va, formatString);
[+] 	AXL_VA_DECL(va, formatString);
[-] 	return formatString_w_va (formatString, va);
[+] 	return formatString_w_va(formatString, va);
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_StringDetails.h
----------------------
[-] 	getEmptyString ()
[+] 	getEmptyString()
[-] 		static T emptyString [] = { 0 };
[+] 		static T emptyString[] = { 0 };
[-] 	getCrLf ()
[+] 	getCrLf()
[-] 		static T crLf [] = { '\r', '\n', 0 };
[+] 		static T crLf[] = { '\r', '\n', 0 };
[-] 	getWhitespace ()
[+] 	getWhitespace()
[-] 		static T whitespace [] = { ' ', '\t', '\r', '\n', 0 };
[+] 		static T whitespace[] = { ' ', '\t', '\r', '\n', 0 };
[-] 	calcLength (const T* p)
[+] 	calcLength(const T* p)
[-] 	calcLength (
[+] 	calcLength(
[-] 	cmp (
[+] 	cmp(
[-] 	find (
[+] 	find(
[-] 	find (
[+] 	find(
[-] 		const T* f = (const T*) memMem (p, length * sizeof (T), subString, subStringLength * sizeof (T));
[+] 		const T* f = (const T*) memMem(p, length * sizeof(T), subString, subStringLength * sizeof(T));
[-] 	findOneOf (
[+] 	findOneOf(
[-] 			size_t f = find (charSet, charCount, *p);
[+] 			size_t f = find(charSet, charCount, *p);
[-] 	findNotOneOf (
[+] 	findNotOneOf(
[-] 			size_t f = find (charSet, charCount, *p);
[+] 			size_t f = find(charSet, charCount, *p);
[-] 	reverseFind (
[+] 	reverseFind(
[-] 	reverseFind (
[+] 	reverseFind(
[-] 		const T* f = reverseMemMem (p, length * sizeof (T), subString, subStringLength * sizeof (T));
[+] 		const T* f = reverseMemMem(p, length * sizeof(T), subString, subStringLength * sizeof(T));
[-] 	reverseFindOneOf (
[+] 	reverseFindOneOf(
[-] 			size_t f = find (charSet, charCount, *p);
[+] 			size_t f = find(charSet, charCount, *p);
[-] 	reverseFindNotOneOf (
[+] 	reverseFindNotOneOf(
[-] 			size_t f = find (charSet, charCount, *p);
[+] 			size_t f = find(charSet, charCount, *p);
[-] 	fill (
[+] 	fill(
[-] 	copy (
[+] 	copy(
[-] 		memcpy (dst, src, length * sizeof (T));
[+] 		memcpy(dst, src, length * sizeof(T));
[-] 	move (
[+] 	move(
[-] 		memmove (dst, src, length * sizeof (T));
[+] 		memmove(dst, src, length * sizeof(T));
[-] class StringDetailsBase <utf8_t>: public StringDetailsImpl <utf8_t>
[+] class StringDetailsBase<utf8_t>: public StringDetailsImpl<utf8_t>
[-] 	typedef StringDetailsBase <C2> Details2;
[+] 	typedef StringDetailsBase<C2> Details2;
[-] 	typedef StringDetailsBase <C3> Details3;
[+] 	typedef StringDetailsBase<C3> Details3;
[-] 	calcLength (const C* p)
[+] 	calcLength(const C* p)
[-] 		return p ? strlen (p) : 0;
[+] 		return p ? strlen(p) : 0;
[-] 	calcLength (
[+] 	calcLength(
[-] 		return p ? strnlen (p, maxLength) : 0;
[+] 		return p ? strnlen(p, maxLength) : 0;
[-] 	toLower (C c)
[+] 	toLower(C c)
[-] 		return (C) tolower ((uint8_t) c);
[+] 		return (C)tolower((uint8_t)c);
[-] 	toUpper (C c)
[+] 	toUpper(C c)
[-] 		return (C) toupper ((uint8_t) c);
[+] 		return (C)toupper((uint8_t)c);
[-] 	cmp (
[+] 	cmp(
[-] 		return memcmp (p1, p2, length);
[+] 		return memcmp(p1, p2, length);
[-] 	find (
[+] 	find(
[-] 		const C* f = (const C*) memchr (p, c, length);
[+] 		const C* f = (const C*) memchr(p, c, length);
[-] 	find (
[+] 	find(
[-] 		return StringDetailsImpl <utf8_t>::find (p, length, subString, subStringLength);
[+] 		return StringDetailsImpl<utf8_t>::find(p, length, subString, subStringLength);
[-] 	fill (
[+] 	fill(
[-] 		memset (p, c, count);
[+] 		memset(p, c, count);
[-] 	calcFormatLength_va (
[+] 	calcFormatLength_va(
[-] 		return _vscprintf (formatString, va);
[+] 		return _vscprintf(formatString, va);
[-] 	format_va (
[+] 	format_va(
[-] 		_vsnprintf (buffer, bufferLength, formatString, va);
[+] 		_vsnprintf(buffer, bufferLength, formatString, va);
[-] 			buffer [bufferLength - 1] = 0; // not really necessary, just to make it identical to C++11 vsnprintf
[+] 			buffer[bufferLength - 1] = 0; // not really necessary, just to make it identical to C++11 vsnprintf
[-] 	calcFormatLength_va (
[+] 	calcFormatLength_va(
[-] 		return vsnprintf (NULL, 0, formatString, va);
[+] 		return vsnprintf(NULL, 0, formatString, va);
[-] 	format_va (
[+] 	format_va(
[-] 		return vsnprintf (buffer, bufferLength, formatString, va);
[+] 		return vsnprintf(buffer, bufferLength, formatString, va);
[-] class StringDetailsBase <utf16_t>: public StringDetailsImpl <utf16_t>
[+] class StringDetailsBase<utf16_t>: public StringDetailsImpl<utf16_t>
[-] 	typedef StringDetailsBase <C2> Details2;
[+] 	typedef StringDetailsBase<C2> Details2;
[-] 	typedef StringDetailsBase <C3> Details3;
[+] 	typedef StringDetailsBase<C3> Details3;
[-] 	toLower (C c)
[+] 	toLower(C c)
[-] 		return (C) towlower ((uint16_t) c);
[+] 		return (C)towlower((uint16_t)c);
[-] 	toUpper (C c)
[+] 	toUpper(C c)
[-] 		return (C) towupper ((uint16_t) c);
[+] 		return (C)towupper((uint16_t)c);
[-] 	calcFormatLength_va (
[+] 	calcFormatLength_va(
[-] 		return _vscwprintf (formatString, va);
[+] 		return _vscwprintf(formatString, va);
[-] 	format_va (
[+] 	format_va(
[-] 		_vsnwprintf (buffer, bufferLength, formatString, va);
[+] 		_vsnwprintf(buffer, bufferLength, formatString, va);
[-] 			buffer [bufferLength - 1] = 0; // not really necessary, just to make it identical to C++11 vsnprintf
[+] 			buffer[bufferLength - 1] = 0; // not really necessary, just to make it identical to C++11 vsnprintf
[-] 	calcFormatLength_va (
[+] 	calcFormatLength_va(
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	format_va (
[+] 	format_va(
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] class StringDetailsBase <utf32_t>: public StringDetailsImpl <utf32_t>
[+] class StringDetailsBase<utf32_t>: public StringDetailsImpl<utf32_t>
[-] 	typedef StringDetailsBase <C2> Details2;
[+] 	typedef StringDetailsBase<C2> Details2;
[-] 	typedef StringDetailsBase <C3> Details3;
[+] 	typedef StringDetailsBase<C3> Details3;
[-] 	toLower (C c)
[+] 	toLower(C c)
[-] 		return (C) towlower ((uint32_t) c);
[+] 		return (C)towlower((uint32_t)c);
[-] 	toUpper (C c)
[+] 	toUpper(C c)
[-] 		return (C) towupper ((uint32_t) c);
[+] 		return (C)towupper((uint32_t)c);
[-] 	calcFormatLength_va (
[+] 	calcFormatLength_va(
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	format_va (
[+] 	format_va(
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] typedef StringDetailsBase <char>    StringDetails;
[+] typedef StringDetailsBase<char>    StringDetails;
[-] typedef StringDetailsBase <wchar_t> StringDetails_w;
[+] typedef StringDetailsBase<wchar_t> StringDetails_w;
[-] typedef StringDetailsBase <utf8_t>  StringDetails_utf8;
[+] typedef StringDetailsBase<utf8_t>  StringDetails_utf8;
[-] typedef StringDetailsBase <utf16_t> StringDetails_utf16;
[+] typedef StringDetailsBase<utf16_t> StringDetails_utf16;
[-] typedef StringDetailsBase <utf32_t> StringDetails_utf32;
[+] typedef StringDetailsBase<utf32_t> StringDetails_utf32;
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_StringHashTable.h
----------------------
[-] 		const sl::StringRefBase <T>& string1,
[+] 		const sl::StringRefBase<T>& string1,
[-] 		const sl::StringRefBase <T>& string2
[+] 		const sl::StringRefBase<T>& string2
[-] 		return string1.isEqualIgnoreCase (string2, CaseConvertMethod_PerCodeUnit);
[+] 		return string1.isEqualIgnoreCase(string2, CaseConvertMethod_PerCodeUnit);
[-] 		const sl::StringRefBase <T>& string1,
[+] 		const sl::StringRefBase<T>& string1,
[-] 		const sl::StringRefBase <T>& string2
[+] 		const sl::StringRefBase<T>& string2
[-] 		return string1.isEqualIgnoreCase (string2, CaseConvertMethod_PerCodePoint);
[+] 		return string1.isEqualIgnoreCase(string2, CaseConvertMethod_PerCodePoint);
[-] typedef EqStringIgnoreCaseBase_pcu <char>    EqStringIgnoreCase_pcu;
[+] typedef EqStringIgnoreCaseBase_pcu<char>    EqStringIgnoreCase_pcu;
[-] typedef EqStringIgnoreCaseBase_pcu <wchar_t> EqStringIgnoreCase_pcu_w;
[+] typedef EqStringIgnoreCaseBase_pcu<wchar_t> EqStringIgnoreCase_pcu_w;
[-] typedef EqStringIgnoreCaseBase_pcu <utf8_t>  EqStringIgnoreCase_pcu_utf8;
[+] typedef EqStringIgnoreCaseBase_pcu<utf8_t>  EqStringIgnoreCase_pcu_utf8;
[-] typedef EqStringIgnoreCaseBase_pcu <utf16_t> EqStringIgnoreCase_pcu_utf16;
[+] typedef EqStringIgnoreCaseBase_pcu<utf16_t> EqStringIgnoreCase_pcu_utf16;
[-] typedef EqStringIgnoreCaseBase_pcu <utf32_t> EqStringIgnoreCase_pcu_utf32;
[+] typedef EqStringIgnoreCaseBase_pcu<utf32_t> EqStringIgnoreCase_pcu_utf32;
[-] typedef EqStringIgnoreCaseBase_pcp <char>    EqStringIgnoreCase_pcp;
[+] typedef EqStringIgnoreCaseBase_pcp<char>    EqStringIgnoreCase_pcp;
[-] typedef EqStringIgnoreCaseBase_pcp <wchar_t> EqStringIgnoreCase_pcp_w;
[+] typedef EqStringIgnoreCaseBase_pcp<wchar_t> EqStringIgnoreCase_pcp_w;
[-] typedef EqStringIgnoreCaseBase_pcp <utf8_t>  EqStringIgnoreCase_pcp_utf8;
[+] typedef EqStringIgnoreCaseBase_pcp<utf8_t>  EqStringIgnoreCase_pcp_utf8;
[-] typedef EqStringIgnoreCaseBase_pcp <utf16_t> EqStringIgnoreCase_pcp_utf16;
[+] typedef EqStringIgnoreCaseBase_pcp<utf16_t> EqStringIgnoreCase_pcp_utf16;
[-] typedef EqStringIgnoreCaseBase_pcp <utf32_t> EqStringIgnoreCase_pcp_utf32;
[+] typedef EqStringIgnoreCaseBase_pcp<utf32_t> EqStringIgnoreCase_pcp_utf32;
[-] 	operator () (const sl::StringRefBase <T>& string) const
[+] 	operator () (const sl::StringRefBase<T>& string) const
[-] 		return string.hashIgnoreCase (CaseConvertMethod_PerCodeUnit);
[+] 		return string.hashIgnoreCase(CaseConvertMethod_PerCodeUnit);
[-] 	operator () (const sl::StringRefBase <T>& string) const
[+] 	operator () (const sl::StringRefBase<T>& string) const
[-] 		return string.hashIgnoreCase (CaseConvertMethod_PerCodePoint);
[+] 		return string.hashIgnoreCase(CaseConvertMethod_PerCodePoint);
[-] typedef HashStringIgnoreCaseBase_pcu <char>    HashStringIgnoreCase_pcu;
[+] typedef HashStringIgnoreCaseBase_pcu<char>    HashStringIgnoreCase_pcu;
[-] typedef HashStringIgnoreCaseBase_pcu <wchar_t> HashStringIgnoreCase_pcu_w;
[+] typedef HashStringIgnoreCaseBase_pcu<wchar_t> HashStringIgnoreCase_pcu_w;
[-] typedef HashStringIgnoreCaseBase_pcu <utf8_t>  HashStringIgnoreCase_pcu_utf8;
[+] typedef HashStringIgnoreCaseBase_pcu<utf8_t>  HashStringIgnoreCase_pcu_utf8;
[-] typedef HashStringIgnoreCaseBase_pcu <utf16_t> HashStringIgnoreCase_pcu_utf16;
[+] typedef HashStringIgnoreCaseBase_pcu<utf16_t> HashStringIgnoreCase_pcu_utf16;
[-] typedef HashStringIgnoreCaseBase_pcu <utf32_t> HashStringIgnoreCase_pcu_utf32;
[+] typedef HashStringIgnoreCaseBase_pcu<utf32_t> HashStringIgnoreCase_pcu_utf32;
[-] typedef HashStringIgnoreCaseBase_pcp <char>    HashStringIgnoreCase_pcp;
[+] typedef HashStringIgnoreCaseBase_pcp<char>    HashStringIgnoreCase_pcp;
[-] typedef HashStringIgnoreCaseBase_pcp <wchar_t> HashStringIgnoreCase_pcp_w;
[+] typedef HashStringIgnoreCaseBase_pcp<wchar_t> HashStringIgnoreCase_pcp_w;
[-] typedef HashStringIgnoreCaseBase_pcp <utf8_t>  HashStringIgnoreCase_pcp_utf8;
[+] typedef HashStringIgnoreCaseBase_pcp<utf8_t>  HashStringIgnoreCase_pcp_utf8;
[-] typedef HashStringIgnoreCaseBase_pcp <utf16_t> HashStringIgnoreCase_pcp_utf16;
[+] typedef HashStringIgnoreCaseBase_pcp<utf16_t> HashStringIgnoreCase_pcp_utf16;
[-] typedef HashStringIgnoreCaseBase_pcp <utf32_t> HashStringIgnoreCase_pcp_utf32;
[+] typedef HashStringIgnoreCaseBase_pcp<utf32_t> HashStringIgnoreCase_pcp_utf32;
[-] class StringHashTable: public DuckTypeHashTable <String, Value>
[+] class StringHashTable: public DuckTypeHashTable<String, Value>
[-] class StringHashTable_w: public DuckTypeHashTable <String_w, Value>
[+] class StringHashTable_w: public DuckTypeHashTable<String_w, Value>
[-] class StringHashTable_utf8: public DuckTypeHashTable <String_utf8, Value>
[+] class StringHashTable_utf8: public DuckTypeHashTable<String_utf8, Value>
[-] class StringHashTable_utf16: public DuckTypeHashTable <String_utf16, Value>
[+] class StringHashTable_utf16: public DuckTypeHashTable<String_utf16, Value>
[-] class StringHashTable_utf32: public DuckTypeHashTable <String_utf32, Value>
[+] class StringHashTable_utf32: public DuckTypeHashTable<String_utf32, Value>
[-] class StringHashTableIgnoreCase_pcu: public HashTable <
[+] class StringHashTableIgnoreCase_pcu: public HashTable<
[-] class StringHashTableIgnoreCase_pcu_w: public HashTable <
[+] class StringHashTableIgnoreCase_pcu_w: public HashTable<
[-] class StringHashTableIgnoreCase_pcu_utf8: public HashTable <
[+] class StringHashTableIgnoreCase_pcu_utf8: public HashTable<
[-] class StringHashTableIgnoreCase_pcu_utf16: public HashTable <
[+] class StringHashTableIgnoreCase_pcu_utf16: public HashTable<
[-] class StringHashTableIgnoreCase_pcu_utf32: public HashTable <
[+] class StringHashTableIgnoreCase_pcu_utf32: public HashTable<
[-] class StringHashTableIgnoreCase_pcp: public HashTable <
[+] class StringHashTableIgnoreCase_pcp: public HashTable<
[-] class StringHashTableIgnoreCase_pcp_w: public HashTable <
[+] class StringHashTableIgnoreCase_pcp_w: public HashTable<
[-] class StringHashTableIgnoreCase_pcp_utf8: public HashTable <
[+] class StringHashTableIgnoreCase_pcp_utf8: public HashTable<
[-] class StringHashTableIgnoreCase_pcp_utf16: public HashTable <
[+] class StringHashTableIgnoreCase_pcp_utf16: public HashTable<
[-] class StringHashTableIgnoreCase_pcp_utf32: public HashTable <
[+] class StringHashTableIgnoreCase_pcp_utf32: public HashTable<
[-] class StringHashTableIterator: public Iterator <HashTableEntry <String, Value> >
[+] class StringHashTableIterator: public Iterator<HashTableEntry<String, Value> >
[-] 	StringHashTableIterator ()
[+] 	StringHashTableIterator()
[-] 	StringHashTableIterator (const Iterator <HashTableEntry <String, Value> >& src)
[+] 	StringHashTableIterator(const Iterator<HashTableEntry<String, Value> >& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] class ConstStringHashTableIterator: public ConstIterator <HashTableEntry <String, Value> >
[+] class ConstStringHashTableIterator: public ConstIterator<HashTableEntry<String, Value> >
[-] 	ConstStringHashTableIterator ()
[+] 	ConstStringHashTableIterator()
[-] 	ConstStringHashTableIterator (const ConstIterator <HashTableEntry <String, Value> >& src)
[+] 	ConstStringHashTableIterator(const ConstIterator<HashTableEntry<String, Value> >& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] class StringHashTableIterator_w: public Iterator <HashTableEntry <String_w, Value> >
[+] class StringHashTableIterator_w: public Iterator<HashTableEntry<String_w, Value> >
[-] 	StringHashTableIterator_w ()
[+] 	StringHashTableIterator_w()
[-] 	StringHashTableIterator_w (const Iterator <HashTableEntry <String_w, Value> >& src)
[+] 	StringHashTableIterator_w(const Iterator<HashTableEntry<String_w, Value> >& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] class ConstStringHashTableIterator_w: public ConstIterator <HashTableEntry <String_w, Value> >
[+] class ConstStringHashTableIterator_w: public ConstIterator<HashTableEntry<String_w, Value> >
[-] 	ConstStringHashTableIterator_w ()
[+] 	ConstStringHashTableIterator_w()
[-] 	ConstStringHashTableIterator_w (const ConstIterator <HashTableEntry <String_w, Value> >& src)
[+] 	ConstStringHashTableIterator_w(const ConstIterator<HashTableEntry<String_w, Value> >& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] class StringHashTableIterator_utf8: public Iterator <HashTableEntry <String_utf8, Value> >
[+] class StringHashTableIterator_utf8: public Iterator<HashTableEntry<String_utf8, Value> >
[-] 	StringHashTableIterator_utf8 ()
[+] 	StringHashTableIterator_utf8()
[-] 	StringHashTableIterator_utf8 (const Iterator <HashTableEntry <String_utf8, Value> >& src)
[+] 	StringHashTableIterator_utf8(const Iterator<HashTableEntry<String_utf8, Value> >& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] class ConstStringHashTableIterator_utf8: public ConstIterator <HashTableEntry <String_utf8, Value> >
[+] class ConstStringHashTableIterator_utf8: public ConstIterator<HashTableEntry<String_utf8, Value> >
[-] 	ConstStringHashTableIterator_utf8 ()
[+] 	ConstStringHashTableIterator_utf8()
[-] 	ConstStringHashTableIterator_utf8 (const ConstIterator <HashTableEntry <String_utf8, Value> >& src)
[+] 	ConstStringHashTableIterator_utf8(const ConstIterator<HashTableEntry<String_utf8, Value> >& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] class StringHashTableIterator_utf16: public Iterator <HashTableEntry <String_utf16, Value> >
[+] class StringHashTableIterator_utf16: public Iterator<HashTableEntry<String_utf16, Value> >
[-] 	StringHashTableIterator_utf16 ()
[+] 	StringHashTableIterator_utf16()
[-] 	StringHashTableIterator_utf16 (const Iterator <HashTableEntry <String_utf16, Value> >& src)
[+] 	StringHashTableIterator_utf16(const Iterator<HashTableEntry<String_utf16, Value> >& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] class ConstStringHashTableIterator_utf16: public ConstIterator <HashTableEntry <String_utf16, Value> >
[+] class ConstStringHashTableIterator_utf16: public ConstIterator<HashTableEntry<String_utf16, Value> >
[-] 	ConstStringHashTableIterator_utf16 ()
[+] 	ConstStringHashTableIterator_utf16()
[-] 	ConstStringHashTableIterator_utf16 (const ConstIterator <HashTableEntry <String_utf16, Value> >& src)
[+] 	ConstStringHashTableIterator_utf16(const ConstIterator<HashTableEntry<String_utf16, Value> >& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] class StringHashTableIterator_utf32: public Iterator <HashTableEntry <String_utf32, Value> >
[+] class StringHashTableIterator_utf32: public Iterator<HashTableEntry<String_utf32, Value> >
[-] 	StringHashTableIterator_utf32 ()
[+] 	StringHashTableIterator_utf32()
[-] 	StringHashTableIterator_utf32 (const Iterator <HashTableEntry <String_utf32, Value> >& src)
[+] 	StringHashTableIterator_utf32(const Iterator<HashTableEntry<String_utf32, Value> >& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] class ConstStringHashTableIterator_utf32: public ConstIterator <HashTableEntry <String_utf32, Value> >
[+] class ConstStringHashTableIterator_utf32: public ConstIterator<HashTableEntry<String_utf32, Value> >
[-] 	ConstStringHashTableIterator_utf32 ()
[+] 	ConstStringHashTableIterator_utf32()
[-] 	ConstStringHashTableIterator_utf32 (const ConstIterator <HashTableEntry <String_utf32, Value> >& src)
[+] 	ConstStringHashTableIterator_utf32(const ConstIterator<HashTableEntry<String_utf32, Value> >& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] 	AXL_SL_BEGIN_DUCK_TYPE_HASH_TABLE (Class, axl::sl::String, Value)
[+] 	AXL_SL_BEGIN_DUCK_TYPE_HASH_TABLE(Class, axl::sl::String, Value)
[-] 	AXL_SL_END_DUCK_TYPE_HASH_TABLE ()
[+] 	AXL_SL_END_DUCK_TYPE_HASH_TABLE()
[-] 		axl::sl::ArgType <Value>::Type \
[+] 		axl::sl::ArgType<Value>::Type \
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 		axl::sl::ArgType <Value>::Type \
[+] 		axl::sl::ArgType<Value>::Type \
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_Swap.h
----------------------
[-] swap (
[+] swap(
[-] 		swap (a, b);
[+] 		swap(a, b);
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sl\axl_sl_Unpacker.h
----------------------
[-] 		size_t length = StringDetailsBase <T>::calcLength ((T*) p);
[+] 		size_t length = StringDetailsBase<T>::calcLength((T*)p);
[-] 		size_t stringSize = (length + 1) * sizeof (T);
[+] 		size_t stringSize = (length + 1) * sizeof(T);
[-] 		*value = (T*) p;
[+] 		*value = (T*)p;
[-] 		return (length + 1) * sizeof (T);
[+] 		return (length + 1) * sizeof(T);
[-] 		if (size < sizeof (T))
[+] 		if (size < sizeof(T))
[-] 		*value = (T*) p;
[+] 		*value = (T*)p;
[-] 		return sizeof (T);
[+] 		return sizeof(T);
[-] 	typename SizeOf = sl::SizeOf <T>
[+] 	typename SizeOf = sl::SizeOf<T>
[-] 		if (size < sizeof (T))
[+] 		if (size < sizeof(T))
[-] 		size_t objectSize = SizeOf () ((T*) p);
[+] 		size_t objectSize = SizeOf() ((T*)p);
[-] 		ASSERT (objectSize >= sizeof (T)); // otherwise wrong SizeOf impl
[+] 		ASSERT(objectSize >= sizeof(T)); // otherwise wrong SizeOf impl
[-] 		*value = (T*) p;
[+] 		*value = (T*)p;
[-] typedef UnpackStringBase <char>    UnpackString;
[+] typedef UnpackStringBase<char>    UnpackString;
[-] typedef UnpackStringBase <wchar_t> UnpackString_w;
[+] typedef UnpackStringBase<wchar_t> UnpackString_w;
[-] typedef UnpackStringBase <utf8_t>  UnpackString_utf8;
[+] typedef UnpackStringBase<utf8_t>  UnpackString_utf8;
[-] typedef UnpackStringBase <utf16_t> UnpackString_utf16;
[+] typedef UnpackStringBase<utf16_t> UnpackString_utf16;
[-] typedef UnpackStringBase <utf32_t> UnpackString_utf32;
[+] typedef UnpackStringBase<utf32_t> UnpackString_utf32;
[-] 		if (size < sizeof (T))
[+] 		if (size < sizeof(T))
[-] 		*value = *(T*) p;
[+] 		*value = *(T*)p;
[-] 		return sizeof (T);
[+] 		return sizeof(T);
[-] class Unpack <char*>: public UnpackStringBase <char>
[+] class Unpack<char*>: public UnpackStringBase<char>
[-] class Unpack <const char*>: public UnpackStringBase <char>
[+] class Unpack<const char*>: public UnpackStringBase<char>
[-] class Unpack <wchar_t*>: public UnpackStringBase <wchar_t>
[+] class Unpack<wchar_t*>: public UnpackStringBase<wchar_t>
[-] class Unpack <const wchar_t*>: public UnpackStringBase <wchar_t>
[+] class Unpack<const wchar_t*>: public UnpackStringBase<wchar_t>
[-] class Unpack <T*>: public UnpackPtr <T>
[+] class Unpack<T*>: public UnpackPtr<T>
[-] class Unpack <err::ErrorHdr*>: public UnpackSelfSizedPtr <
[+] class Unpack<err::ErrorHdr*>: public UnpackSelfSizedPtr<
[-] class Unpack <const err::ErrorHdr*>: public UnpackSelfSizedPtr <
[+] class Unpack<const err::ErrorHdr*>: public UnpackSelfSizedPtr<
[-] 	Unpacker ()
[+] 	Unpacker()
[-] 		setup (NULL, 0);
[+] 		setup(NULL, 0);
[-] 	Unpacker (
[+] 	Unpacker(
[-] 		setup (p, size);
[+] 		setup(p, size);
[-] 	setup (
[+] 	setup(
[-] 	clear ()
[+] 	clear()
[-] 		setup (NULL, 0);
[+] 		setup(NULL, 0);
[-] 	rewind ()
[+] 	rewind()
[-] 	getLeftoverSize ()
[+] 	getLeftoverSize()
[-] 		return m_size - ((uchar_t*) m_current - (uchar_t*) m_begin);
[+] 		return m_size - ((uchar_t*)m_current - (uchar_t*)m_begin);
[-] 	unpack (
[+] 	unpack(
[-] 	unpack (T* value)
[+] 	unpack(T* value)
[-] 		size_t leftoverSize = getLeftoverSize ();
[+] 		size_t leftoverSize = getLeftoverSize();
[-] 		size_t size = Unpack () (m_current, leftoverSize, value);
[+] 		size_t size = Unpack() (m_current, leftoverSize, value);
[-] 		m_current = (uchar_t*) m_current + size;
[+] 		m_current = (uchar_t*)m_current + size;
[-] 	unpack (T* value)
[+] 	unpack(T* value)
[-] 		return unpack <T, Unpack <T> > (value);
[+] 		return unpack<T, Unpack<T> > (value);
[-] 	scan_va (
[+] 	scan_va(
[-] 	scan (
[+] 	scan(
[-] 		AXL_VA_DECL (va, formatString);
[+] 		AXL_VA_DECL(va, formatString);
[-] 		return scan_va (formatString, va);
[+] 		return scan_va(formatString, va);
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_st\axl_st_LuaStringTemplate.h
----------------------
[-] class LuaStringTemplate: public StringTemplate <LuaStringTemplate>
[+] class LuaStringTemplate: public StringTemplate<LuaStringTemplate>
[-] 	friend class StringTemplate <LuaStringTemplate>;
[+] 	friend class StringTemplate<LuaStringTemplate>;
[-] 	LuaStringTemplate ()
[+] 	LuaStringTemplate()
[-] 	close ();
[+] 	close();
[-] 	create ();
[+] 	create();
[-] 	getArgCount ()
[+] 	getArgCount()
[-] 	setArgCount (size_t count);
[+] 	setArgCount(size_t count);
[-] 	runScript (
[+] 	runScript(
[-] 	createPassthroughCall (
[+] 	createPassthroughCall(
[-] 		script->appendFormat ("passthrough (%d, %d);", offset, length);
[+] 		script->appendFormat("passthrough (%d, %d);", offset, length);
[-] 	createEmitCall (
[+] 	createEmitCall(
[-] 	getLine_lua (lua_State* h);
[+] 	getLine_lua(lua_State* h);
[-] 	getCol_lua (lua_State* h);
[+] 	getCol_lua(lua_State* h);
[-] 	emit_lua (lua_State* h);
[+] 	emit_lua(lua_State* h);
[-] 	passthrough_lua (lua_State* h);
[+] 	passthrough_lua(lua_State* h);
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_st\axl_st_StringTemplate.h
----------------------
[-] gotoEndOfScriptSnippet (
[+] gotoEndOfScriptSnippet(
[-] 	sl::AuxList <EmitContext> m_emitContextStack;
[+] 	sl::AuxList<EmitContext> m_emitContextStack;
[-] 	clear ()
[+] 	clear()
[-] 		m_emitContextStack.clear ();
[+] 		m_emitContextStack.clear();
[-] 	process (
[+] 	process(
[-] 			output->clear ();
[+] 			output->clear();
[-] 			output->reserve (frame.getLength ());
[+] 			output->reserve(frame.getLength());
[-] 		else if (!m_emitContextStack.isEmpty ())
[+] 		else if (!m_emitContextStack.isEmpty())
[-] 			output = m_emitContextStack.getTail ()->m_output; // append to the last output buffer
[+] 			output = m_emitContextStack.getTail()->m_output; // append to the last output buffer
[-] 			err::setError (err::SystemErrorCode_InvalidParameter);
[+] 			err::setError(err::SystemErrorCode_InvalidParameter);
[-] 		result = createScript (&scriptSource, fileName, frame);
[+] 		result = createScript(&scriptSource, fileName, frame);
[-] 		if (scriptSource.isEmpty ())
[+] 		if (scriptSource.isEmpty())
[-] 			output->copy (frame);
[+] 			output->copy(frame);
[-] 		m_emitContextStack.insertTail (&emitContext);
[+] 		m_emitContextStack.insertTail(&emitContext);
[-] 		result = static_cast <T*> (this)->runScript (fileName, scriptSource);
[+] 		result = static_cast<T*> (this)->runScript(fileName, scriptSource);
[-] 		ASSERT (*m_emitContextStack.getTail () == &emitContext);
[+] 		ASSERT(*m_emitContextStack.getTail() == &emitContext);
[-] 		m_emitContextStack.removeTail ();
[+] 		m_emitContextStack.removeTail();
[-] 	processFile (
[+] 	processFile(
[-] 			file.open (fileName, io::FileFlag_ReadOnly) &&
[+] 			file.open(fileName, io::FileFlag_ReadOnly) &&
[-] 			process (
[+] 			process(
[-] 				sl::StringRef ((const char*) file.p (), file.getMappingSize ())
[+] 				sl::StringRef((const char*) file.p(), file.getMappingSize())
[-] 	processFileToFile (
[+] 	processFileToFile(
[-] 		result = processFile (&stringBuffer, frameFileName);
[+] 		result = processFile(&stringBuffer, frameFileName);
[-] 		result = targetFile.open (targetFileName);
[+] 		result = targetFile.open(targetFileName);
[-] 		size_t size = stringBuffer.getLength ();
[+] 		size_t size = stringBuffer.getLength();
[-] 		result = targetFile.write (stringBuffer, size) != -1;
[+] 		result = targetFile.write(stringBuffer, size) != -1;
[-] 		targetFile.setSize (size);
[+] 		targetFile.setSize(size);
[-] 	createScript (
[+] 	createScript(
[-] 		lexer.create (fileName, frame);
[+] 		lexer.create(fileName, frame);
[-] 		scriptSource->clear ();
[+] 		scriptSource->clear();
[-] 			const Token* token = lexer.getToken ();
[+] 			const Token* token = lexer.getToken();
[-] 				err::setFormatStringError ("invalid character '\\x%02x'", (uchar_t) token->m_data.m_integer);
[+] 				err::setFormatStringError("invalid character '\\x%02x'", (uchar_t) token->m_data.m_integer);
[-] 				static_cast <T*> (this)->createPassthroughCall (
[+] 				static_cast<T*> (this)->createPassthroughCall(
[-] 				scriptSource->append ('\n', token->m_pos.m_line - line);
[+] 				scriptSource->append('\n', token->m_pos.m_line - line);
[-] 			switch (token->m_token)
[+] 			switch(token->m_token)
[-] 				static_cast <T*> (this)->createEmitCall (scriptSource, token->m_data.m_string);
[+] 				static_cast<T*> (this)->createEmitCall(scriptSource, token->m_data.m_string);
[-] 				lexer.nextToken ();
[+] 				lexer.nextToken();
[-] 				result = gotoEndOfScriptSnippet (&lexer, &pos);
[+] 				result = gotoEndOfScriptSnippet(&lexer, &pos);
[-] 				scriptSource->append (frame.getSubString (offset, pos.m_offset - offset));
[+] 				scriptSource->append(frame.getSubString(offset, pos.m_offset - offset));
[-] 				scriptSource->append (";");
[+] 				scriptSource->append(";");
[-] 				result = gotoEndOfScriptSnippet (&lexer, &pos);
[+] 				result = gotoEndOfScriptSnippet(&lexer, &pos);
[-] 				static_cast <T*> (this)->createEmitCall (
[+] 				static_cast<T*> (this)->createEmitCall(
[-] 					frame.getSubString (offset, pos.m_offset - offset)
[+] 					frame.getSubString(offset, pos.m_offset - offset)
[-] 				ASSERT (false);
[+] 				ASSERT(false);
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_st\axl_st_StringTemplateLexer.h
----------------------
[-] AXL_LEX_BEGIN_TOKEN_NAME_MAP (TokenName)
[+] AXL_LEX_BEGIN_TOKEN_NAME_MAP(TokenName)
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Eof,        "eof")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Eof,        "eof")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Error,      "error")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Error,      "error")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_OpenCode,   "%{")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_OpenCode,   "%{")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_OpenData_r, "%(")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_OpenData_r, "%(")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_OpenData_c, "%{")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_OpenData_c, "%{")
[-] 	AXL_LEX_TOKEN_NAME (TokenKind_Data,       "user-data")
[+] 	AXL_LEX_TOKEN_NAME(TokenKind_Data,       "user-data")
[-] AXL_LEX_END_TOKEN_NAME_MAP ();
[+] AXL_LEX_END_TOKEN_NAME_MAP();
[-] typedef lex::RagelToken <TokenKind, TokenName> Token;
[+] typedef lex::RagelToken<TokenKind, TokenName> Token;
[-] class Lexer: public lex::RagelLexer <Lexer, Token>
[+] class Lexer: public lex::RagelLexer<Lexer, Token>
[-] 	friend class lex::RagelLexer <Lexer, Token>;
[+] 	friend class lex::RagelLexer<Lexer, Token>;
[-] 	getMachineState (LexerMachineKind machine);
[+] 	getMachineState(LexerMachineKind machine);
[-] 	createStringToken (
[+] 	createStringToken(
[-] 		Token* token = createToken (tokenKind);
[+] 		Token* token = createToken(tokenKind);
[-] 		token->m_data.m_string = sl::StringRef (ts + left, token->m_pos.m_length - (left + right));
[+] 		token->m_data.m_string = sl::StringRef(ts + left, token->m_pos.m_length - (left + right));
[-] 	init ();
[+] 	init();
[-] 	exec ();
[+] 	exec();
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sys\axl_sys_Atomic.h
----------------------
[-] #	pragma intrinsic (_InterlockedExchange)
[+] #	pragma intrinsic(_InterlockedExchange)
[-] #	pragma intrinsic (_InterlockedCompareExchange)
[+] #	pragma intrinsic(_InterlockedCompareExchange)
[-] #	pragma intrinsic (_InterlockedIncrement)
[+] #	pragma intrinsic(_InterlockedIncrement)
[-] #	pragma intrinsic (_InterlockedDecrement)
[+] #	pragma intrinsic(_InterlockedDecrement)
[-] #		pragma intrinsic (_InterlockedExchange64)
[+] #		pragma intrinsic(_InterlockedExchange64)
[-] #		pragma intrinsic (_InterlockedCompareExchange64)
[+] #		pragma intrinsic(_InterlockedCompareExchange64)
[-] #		pragma intrinsic (_InterlockedIncrement64)
[+] #		pragma intrinsic(_InterlockedIncrement64)
[-] #		pragma intrinsic (_InterlockedDecrement64)
[+] #		pragma intrinsic(_InterlockedDecrement64)
[-] atomicLoad (volatile int32_t* p)
[+] atomicLoad(volatile int32_t* p)
[-] atomicXchg (
[+] atomicXchg(
[-] 	return AXL_INTERLOCKED_FUNC32 (Exchange) ((long*) p, value);
[+] 	return AXL_INTERLOCKED_FUNC32(Exchange)((long*)p, value);
[-] atomicXchg (
[+] atomicXchg(
[-] 	return AXL_INTERLOCKED_FUNC64 (Exchange64) (p, value);
[+] 	return AXL_INTERLOCKED_FUNC64(Exchange64)(p, value);
[-] atomicCmpXchg (
[+] atomicCmpXchg(
[-] 	return AXL_INTERLOCKED_FUNC32 (CompareExchange) ((long*) p, newValue, cmpValue); // inverse order!
[+] 	return AXL_INTERLOCKED_FUNC32(CompareExchange)((long*)p, newValue, cmpValue); // inverse order!
[-] atomicCmpXchg (
[+] atomicCmpXchg(
[-] 	return AXL_INTERLOCKED_FUNC64 (CompareExchange64) (p, newValue, cmpValue); // inverse order!
[+] 	return AXL_INTERLOCKED_FUNC64(CompareExchange64)(p, newValue, cmpValue); // inverse order!
[-] atomicInc (volatile int32_t* p)
[+] atomicInc(volatile int32_t* p)
[-] 	return AXL_INTERLOCKED_FUNC32 (Increment) ((long*) p);
[+] 	return AXL_INTERLOCKED_FUNC32(Increment)((long*)p);
[-] atomicInc (volatile int64_t* p)
[+] atomicInc(volatile int64_t* p)
[-] 	return AXL_INTERLOCKED_FUNC64 (Increment64) (p);
[+] 	return AXL_INTERLOCKED_FUNC64(Increment64)(p);
[-] atomicDec (volatile int32_t* p)
[+] atomicDec(volatile int32_t* p)
[-] 	return AXL_INTERLOCKED_FUNC32 (Decrement) ((long*) p);
[+] 	return AXL_INTERLOCKED_FUNC32(Decrement)((long*)p);
[-] atomicDec (volatile int64_t* p)
[+] atomicDec(volatile int64_t* p)
[-] 	return AXL_INTERLOCKED_FUNC64 (Decrement64) (p);
[+] 	return AXL_INTERLOCKED_FUNC64(Decrement64)(p);
[-] atomicLoad (volatile int64_t* p)
[+] atomicLoad(volatile int64_t* p)
[-] atomicLoad (volatile size_t* p)
[+] atomicLoad(volatile size_t* p)
[-] atomicXchg (
[+] atomicXchg(
[-] 	return AXL_INTERLOCKED_FUNC64 (Exchange64) ((int64_t*) p, value);
[+] 	return AXL_INTERLOCKED_FUNC64(Exchange64)((int64_t*)p, value);
[-] atomicCmpXchg (
[+] atomicCmpXchg(
[-] 	return AXL_INTERLOCKED_FUNC64 (CompareExchange64) ((int64_t*) p, newValue, cmpValue); // inverse order!
[+] 	return AXL_INTERLOCKED_FUNC64(CompareExchange64)((int64_t*)p, newValue, cmpValue); // inverse order!
[-] atomicInc (volatile size_t* p)
[+] atomicInc(volatile size_t* p)
[-] 	return AXL_INTERLOCKED_FUNC64 (Increment64) ((int64_t*) p);
[+] 	return AXL_INTERLOCKED_FUNC64(Increment64)((int64_t*)p);
[-] atomicDec (volatile size_t* p)
[+] atomicDec(volatile size_t* p)
[-] 	return AXL_INTERLOCKED_FUNC64 (Decrement64) ((int64_t*) p);
[+] 	return AXL_INTERLOCKED_FUNC64(Decrement64)((int64_t*)p);
[-] atomicLoad (volatile int64_t* p)
[+] atomicLoad(volatile int64_t* p)
[-] 	return AXL_INTERLOCKED_FUNC64 (CompareExchange64) (p, 0, 0); // any value will do
[+] 	return AXL_INTERLOCKED_FUNC64(CompareExchange64)(p, 0, 0); // any value will do
[-] atomicLoad (volatile size_t* p)
[+] atomicLoad(volatile size_t* p)
[-] atomicXchg (
[+] atomicXchg(
[-] 	return AXL_INTERLOCKED_FUNC32 (Exchange) ((long*) p, value);
[+] 	return AXL_INTERLOCKED_FUNC32(Exchange)((long*)p, value);
[-] atomicCmpXchg (
[+] atomicCmpXchg(
[-] 	return AXL_INTERLOCKED_FUNC32 (CompareExchange) ((long*) p, newValue, cmpValue); // inverse order!
[+] 	return AXL_INTERLOCKED_FUNC32(CompareExchange)((long*)p, newValue, cmpValue); // inverse order!
[-] atomicInc (volatile size_t* p)
[+] atomicInc(volatile size_t* p)
[-] 	return AXL_INTERLOCKED_FUNC32 (Increment) ((long*) p);
[+] 	return AXL_INTERLOCKED_FUNC32(Increment)((long*)p);
[-] atomicDec (volatile size_t* p)
[+] atomicDec(volatile size_t* p)
[-] 	return AXL_INTERLOCKED_FUNC32 (Decrement) ((long*) p);
[+] 	return AXL_INTERLOCKED_FUNC32(Decrement)((long*)p);
[-] atomicLoad (volatile int32_t* p)
[+] atomicLoad(volatile int32_t* p)
[-] atomicXchg (
[+] atomicXchg(
[-] 	return __sync_lock_test_and_set (p, value);
[+] 	return __sync_lock_test_and_set(p, value);
[-] atomicXchg (
[+] atomicXchg(
[-] 	return __sync_lock_test_and_set (p, value);
[+] 	return __sync_lock_test_and_set(p, value);
[-] atomicXchg (
[+] atomicXchg(
[-] 	return __sync_lock_test_and_set (p, value);
[+] 	return __sync_lock_test_and_set(p, value);
[-] atomicCmpXchg (
[+] atomicCmpXchg(
[-] 	return __sync_val_compare_and_swap (p, cmpValue, newValue);
[+] 	return __sync_val_compare_and_swap(p, cmpValue, newValue);
[-] atomicCmpXchg (
[+] atomicCmpXchg(
[-] 	return __sync_val_compare_and_swap (p, cmpValue, newValue);
[+] 	return __sync_val_compare_and_swap(p, cmpValue, newValue);
[-] atomicCmpXchg (
[+] atomicCmpXchg(
[-] 	return __sync_val_compare_and_swap (p, cmpValue, newValue);
[+] 	return __sync_val_compare_and_swap(p, cmpValue, newValue);
[-] atomicInc (volatile int32_t* p)
[+] atomicInc(volatile int32_t* p)
[-] 	return __sync_add_and_fetch (p, 1);
[+] 	return __sync_add_and_fetch(p, 1);
[-] atomicInc (volatile int64_t* p)
[+] atomicInc(volatile int64_t* p)
[-] 	return __sync_add_and_fetch (p, 1);
[+] 	return __sync_add_and_fetch(p, 1);
[-] atomicInc (volatile size_t* p)
[+] atomicInc(volatile size_t* p)
[-] 	return __sync_add_and_fetch (p, 1);
[+] 	return __sync_add_and_fetch(p, 1);
[-] atomicDec (volatile int32_t* p)
[+] atomicDec(volatile int32_t* p)
[-] 	return __sync_sub_and_fetch (p, 1);
[+] 	return __sync_sub_and_fetch(p, 1);
[-] atomicDec (volatile int64_t* p)
[+] atomicDec(volatile int64_t* p)
[-] 	return __sync_sub_and_fetch (p, 1);
[+] 	return __sync_sub_and_fetch(p, 1);
[-] atomicDec (volatile size_t* p)
[+] atomicDec(volatile size_t* p)
[-] 	return __sync_sub_and_fetch (p, 1);
[+] 	return __sync_sub_and_fetch(p, 1);
[-] atomicXchg (
[+] atomicXchg(
[-] 	return __sync_lock_test_and_set (p, value);
[+] 	return __sync_lock_test_and_set(p, value);
[-] atomicCmpXchg (
[+] atomicCmpXchg(
[-] 	return __sync_val_compare_and_swap (p, cmpValue, newValue);
[+] 	return __sync_val_compare_and_swap(p, cmpValue, newValue);
[-] atomicInc (volatile intptr_t* p)
[+] atomicInc(volatile intptr_t* p)
[-] 	return __sync_add_and_fetch (p, 1);
[+] 	return __sync_add_and_fetch(p, 1);
[-] atomicDec (volatile intptr_t* p)
[+] atomicDec(volatile intptr_t* p)
[-] 	return __sync_sub_and_fetch (p, 1);
[+] 	return __sync_sub_and_fetch(p, 1);
[-] atomicLoad (volatile int64_t* p)
[+] atomicLoad(volatile int64_t* p)
[-] atomicLoad (volatile int128_t* p)
[+] atomicLoad(volatile int128_t* p)
[-] 	return __sync_val_compare_and_swap (p, 0, 0); // any value will do
[+] 	return __sync_val_compare_and_swap(p, 0, 0); // any value will do
[-] atomicXchg (
[+] atomicXchg(
[-] 	return __sync_lock_test_and_set (p, value);
[+] 	return __sync_lock_test_and_set(p, value);
[-] atomicCmpXchg (
[+] atomicCmpXchg(
[-] 	return __sync_val_compare_and_swap (p, cmpValue, newValue);
[+] 	return __sync_val_compare_and_swap(p, cmpValue, newValue);
[-] atomicInc (volatile int128_t* p)
[+] atomicInc(volatile int128_t* p)
[-] 	return __sync_add_and_fetch (p, 1);
[+] 	return __sync_add_and_fetch(p, 1);
[-] atomicDec (volatile int128_t* p)
[+] atomicDec(volatile int128_t* p)
[-] 	return __sync_sub_and_fetch (p, 1);
[+] 	return __sync_sub_and_fetch(p, 1);
[-] atomicLoad (volatile int64_t* p)
[+] atomicLoad(volatile int64_t* p)
[-] 	return __sync_val_compare_and_swap (p, 0, 0); // any value will do
[+] 	return __sync_val_compare_and_swap(p, 0, 0); // any value will do
[-] atomicUpdatePeak (
[+] atomicUpdatePeak(
[-] 		if (atomicCmpXchg (peak, old, current) == old)
[+] 		if (atomicCmpXchg(peak, old, current) == old)
[-] yieldProcessor ()
[+] yieldProcessor()
[-] 	::YieldProcessor ();
[+] 	::YieldProcessor();
[-] 	sched_yield ();
[+] 	sched_yield();
[-] atomicLock (volatile int32_t* lock)
[+] atomicLock(volatile int32_t* lock)
[-] 		uint32_t result = sys::atomicCmpXchg (lock, 0, 1);
[+] 		uint32_t result = sys::atomicCmpXchg(lock, 0, 1);
[-] 		sys::yieldProcessor ();
[+] 		sys::yieldProcessor();
[-] atomicUnlock (volatile int32_t* lock)
[+] atomicUnlock(volatile int32_t* lock)
[-] 	uint32_t result = sys::atomicCmpXchg (lock, 1, 0);
[+] 	uint32_t result = sys::atomicCmpXchg(lock, 1, 0);
[-] 	ASSERT (result == 1);
[+] 	ASSERT(result == 1);
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sys\axl_sys_DynamicLibrary.h
----------------------
[-] 	isOpen () const
[+] 	isOpen() const
[-] 		return m_library.isOpen ();
[+] 		return m_library.isOpen();
[-] 	open (const sl::StringRef& fileName)
[+] 	open(const sl::StringRef& fileName)
[-] 		char buffer [256];
[+] 		char buffer[256];
[-] 		sl::String_w fileName_w (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 		sl::String_w fileName_w(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 		return m_library.loadLibrary (fileName_w);
[+] 		return m_library.loadLibrary(fileName_w);
[-] 	close ()
[+] 	close()
[-] 		m_library.close ();
[+] 		m_library.close();
[-] 	detach ()
[+] 	detach()
[-] 		m_library.detach ();
[+] 		m_library.detach();
[-] 	getFunction (const sl::StringRef& name)
[+] 	getFunction(const sl::StringRef& name)
[-] 		return m_library.getProcAddress (name);
[+] 		return m_library.getProcAddress(name);
[-] 	isOpen () const
[+] 	isOpen() const
[-] 		return m_library.isOpen ();
[+] 		return m_library.isOpen();
[-] 	open (const sl::StringRef& fileName)
[+] 	open(const sl::StringRef& fileName)
[-] 		return m_library.open (fileName);
[+] 		return m_library.open(fileName);
[-] 	close ()
[+] 	close()
[-] 		m_library.close ();
[+] 		m_library.close();
[-] 	detach ()
[+] 	detach()
[-] 		m_library.detach ();
[+] 		m_library.detach();
[-] 	getFunction (const sl::StringRef& name)
[+] 	getFunction(const sl::StringRef& name)
[-] 		return m_library.getSymbol (name);
[+] 		return m_library.getSymbol(name);
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sys\axl_sys_Event.h
----------------------
[-] 	EventBase ()
[+] 	EventBase()
[-] 		m_event.create (NULL, IsNotificationEvent () (), false, NULL);
[+] 		m_event.create(NULL, IsNotificationEvent() (), false, NULL);
[-] 	signal ()
[+] 	signal()
[-] 		return m_event.signal ();
[+] 		return m_event.signal();
[-] 	reset ()
[+] 	reset()
[-] 		return m_event.reset ();
[+] 		return m_event.reset();
[-] 	wait (uint_t timeout = -1)
[+] 	wait(uint_t timeout = -1)
[-] 		return m_event.wait (timeout) == win::WaitResult_Object0;
[+] 		return m_event.wait(timeout) == win::WaitResult_Object0;
[-] 	EventBase ()
[+] 	EventBase()
[-] 	EventBase (
[+] 	EventBase(
[-] 		m_condMutexPair (condAttr, mutexAttr)
[+] 		m_condMutexPair(condAttr, mutexAttr)
[-] 	close ();
[+] 	close();
[-] 	reset ()
[+] 	reset()
[-] 		m_condMutexPair.lock ();
[+] 		m_condMutexPair.lock();
[-] 		m_condMutexPair.unlock ();
[+] 		m_condMutexPair.unlock();
[-] 	wait (uint_t timeout = -1)
[+] 	wait(uint_t timeout = -1)
[-] 		m_condMutexPair.lock ();
[+] 		m_condMutexPair.lock();
[-] 			if (!IsNotificationEvent () ())
[+] 			if (!IsNotificationEvent() ())
[-] 			m_condMutexPair.unlock ();
[+] 			m_condMutexPair.unlock();
[-] 		bool result = m_condMutexPair.wait (timeout);
[+] 		bool result = m_condMutexPair.wait(timeout);
[-] 			m_condMutexPair.unlock ();
[+] 			m_condMutexPair.unlock();
[-] 		if (!IsNotificationEvent () ())
[+] 		if (!IsNotificationEvent() ())
[-] 		m_condMutexPair.unlock ();
[+] 		m_condMutexPair.unlock();
[-] 	signal ()
[+] 	signal()
[-] 		m_condMutexPair.lock ();
[+] 		m_condMutexPair.lock();
[-] 			m_condMutexPair.unlock ();
[+] 			m_condMutexPair.unlock();
[-] 		bool result = IsNotificationEvent () () ?
[+] 		bool result = IsNotificationEvent() () ?
[-] 			m_condMutexPair.broadcast () :
[+] 			m_condMutexPair.broadcast() :
[-] 			m_condMutexPair.signal ();
[+] 			m_condMutexPair.signal();
[-] 			m_condMutexPair.unlock ();
[+] 			m_condMutexPair.unlock();
[-] 		m_condMutexPair.unlock ();
[+] 		m_condMutexPair.unlock();
[-] typedef EventBase <sl::False <bool> > Event;
[+] typedef EventBase<sl::False<bool> > Event;
[-] typedef EventBase <sl::True <bool> > NotificationEvent;
[+] typedef EventBase<sl::True<bool> > NotificationEvent;
[-] 	close ()
[+] 	close()
[-] 		m_event.close ();
[+] 		m_event.close();
[-] 	create ()
[+] 	create()
[-] 		return m_event.create (NULL, IsNotificationEvent () (), false);
[+] 		return m_event.create(NULL, IsNotificationEvent() (), false);
[-] 	create (const sl::StringRef& name)
[+] 	create(const sl::StringRef& name)
[-] 		return m_event.create (NULL, IsNotificationEvent () (), false, name.s2 ());
[+] 		return m_event.create(NULL, IsNotificationEvent() (), false, name.s2());
[-] 	open (const sl::StringRef& name)
[+] 	open(const sl::StringRef& name)
[-] 		return m_event.open (EVENT_ALL_ACCESS, false, name.s2 ());
[+] 		return m_event.open(EVENT_ALL_ACCESS, false, name.s2());
[-] 	wait (uint_t timeout = -1)
[+] 	wait(uint_t timeout = -1)
[-] 		return m_event.wait (timeout) == sys::win::WaitResult_Object0;
[+] 		return m_event.wait(timeout) == sys::win::WaitResult_Object0;
[-] 	signal ()
[+] 	signal()
[-] 		return m_event.signal ();
[+] 		return m_event.signal();
[-] 	reset ()
[+] 	reset()
[-] 		return m_event.reset ();
[+] 		return m_event.reset();
[-] 	typedef EventBase <IsNotificationEvent> EventImpl;
[+] 	typedef EventBase<IsNotificationEvent> EventImpl;
[-] 		char m_unnamedEventBuffer [sizeof (EventImpl)]; // avoid heap allocations
[+] 		char m_unnamedEventBuffer[sizeof(EventImpl)]; // avoid heap allocations
[-] 	NameableEventBase ()
[+] 	NameableEventBase()
[-] 		create ();
[+] 		create();
[-] 	~NameableEventBase ()
[+] 	~NameableEventBase()
[-] 		close ();
[+] 		close();
[-] 	close ()
[+] 	close()
[-] 		if (m_event == (EventImpl*) m_unnamedEventBuffer)
[+] 		if (m_event == (EventImpl*)m_unnamedEventBuffer)
[-] 			m_event->~EventImpl ();
[+] 			m_event->~EventImpl();
[-] 		else if (!m_name.isEmpty ())
[+] 		else if (!m_name.isEmpty())
[-] 			io::psx::SharedMemory::unlink (m_name);
[+] 			io::psx::SharedMemory::unlink(m_name);
[-] 			m_event->~EventImpl ();
[+] 			m_event->~EventImpl();
[-] 		m_mapping.close ();
[+] 		m_mapping.close();
[-] 		m_name.clear ();
[+] 		m_name.clear();
[-] 	create ()
[+] 	create()
[-] 		close ();
[+] 		close();
[-] 		m_event = (EventImpl*) m_unnamedEventBuffer;
[+] 		m_event = (EventImpl*)m_unnamedEventBuffer;
[-] 		new (m_event) EventImpl;
[+] 		new(m_event)EventImpl;
[-] 	create (const sl::StringRef& name)
[+] 	create(const sl::StringRef& name)
[-] 		close ();
[+] 		close();
[-] 			sharedMemory.open (name) &&
[+] 			sharedMemory.open(name) &&
[-] 			sharedMemory.setSize (sizeof (EventImpl));
[+] 			sharedMemory.setSize(sizeof(EventImpl));
[-] 		m_event = (EventImpl*) m_mapping.map (
[+] 		m_event = (EventImpl*)m_mapping.map(
[-] 			sizeof (EventImpl),
[+] 			sizeof(EventImpl),
[-] 			sharedMemory.unlink (name);
[+] 			sharedMemory.unlink(name);
[-] 		condAttr.setProcessShared (PTHREAD_PROCESS_SHARED);
[+] 		condAttr.setProcessShared(PTHREAD_PROCESS_SHARED);
[-] 		mutexAttr.setProcessShared (PTHREAD_PROCESS_SHARED);
[+] 		mutexAttr.setProcessShared(PTHREAD_PROCESS_SHARED);
[-] 		new (m_event) EventImpl (condAttr, mutexAttr);
[+] 		new(m_event)EventImpl(condAttr, mutexAttr);
[-] 	open (const sl::StringRef& name)
[+] 	open(const sl::StringRef& name)
[-] 		close ();
[+] 		close();
[-] 		bool result = sharedMemory.open (name, O_RDWR); // no O_CREAT
[+] 		bool result = sharedMemory.open(name, O_RDWR); // no O_CREAT
[-] 		m_event = (EventImpl*) m_mapping.map (
[+] 		m_event = (EventImpl*)m_mapping.map(
[-] 			sizeof (EventImpl),
[+] 			sizeof(EventImpl),
[-] 	wait (uint_t timeout = -1)
[+] 	wait(uint_t timeout = -1)
[-] 		ASSERT (m_event);
[+] 		ASSERT(m_event);
[-] 		return m_event->wait (timeout);
[+] 		return m_event->wait(timeout);
[-] 	signal ()
[+] 	signal()
[-] 		ASSERT (m_event);
[+] 		ASSERT(m_event);
[-] 		return m_event->signal ();
[+] 		return m_event->signal();
[-] 	reset ()
[+] 	reset()
[-] 		ASSERT (m_event);
[+] 		ASSERT(m_event);
[-] 		m_event->reset (); // returns void on POSIX
[+] 		m_event->reset(); // returns void on POSIX
[-] typedef NameableEventBase <sl::False <bool> > NameableEvent;
[+] typedef NameableEventBase<sl::False<bool> > NameableEvent;
[-] typedef NameableEventBase <sl::True <bool> > NameableNotificationEvent;
[+] typedef NameableEventBase<sl::True<bool> > NameableNotificationEvent;
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sys\axl_sys_InvertedSemaphore.h
----------------------
[-] 	InvertedSemaphore (intptr_t count = 0)
[+] 	InvertedSemaphore(intptr_t count = 0)
[-] 		setImpl (count);
[+] 		setImpl(count);
[-] 	set (intptr_t count)
[+] 	set(intptr_t count)
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 		setImpl (count);
[+] 		setImpl(count);
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 	add (intptr_t delta)
[+] 	add(intptr_t delta)
[-] 		m_lock.lock ();
[+] 		m_lock.lock();
[-] 		setImpl (m_count + delta);
[+] 		setImpl(m_count + delta);
[-] 		m_lock.unlock ();
[+] 		m_lock.unlock();
[-] 	setImpl (intptr_t count) // called under lock
[+] 	setImpl(intptr_t count) // called under lock
[-] 		ASSERT (count >= 0);
[+] 		ASSERT(count >= 0);
[-] 			reset ();
[+] 			reset();
[-] 			signal ();
[+] 			signal();
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sys\axl_sys_Lock.h
----------------------
[-] 	lock ()
[+] 	lock()
[-] 		m_criticalSection.enter ();
[+] 		m_criticalSection.enter();
[-] 	unlock ()
[+] 	unlock()
[-] 		m_criticalSection.leave ();
[+] 		m_criticalSection.leave();
[-] 	lock ()
[+] 	lock()
[-] 		m_mutex.lock ();
[+] 		m_mutex.lock();
[-] 	unlock ()
[+] 	unlock()
[-] 		m_mutex.unlock ();
[+] 		m_mutex.unlock();
[-] 	ScopeLock (Lock* lock)
[+] 	ScopeLock(Lock* lock)
[-] 		lock->lock ();
[+] 		lock->lock();
[-] 	~ScopeLock ()
[+] 	~ScopeLock()
[-] 		m_lock->unlock ();
[+] 		m_lock->unlock();
----------------------
27/02/2019 18:01:44 - C:\Projects\repos\ioninja\axl\include\axl_sys\axl_sys_Process.h
----------------------
[-] createProcess (const sl::StringRef& commandLine)
[+] createProcess(const sl::StringRef& commandLine)
[-] 	HINSTANCE hProcess = ::ShellExecuteW (0, L"open", sl::String_w (commandLine), 0, 0, SW_SHOWNORMAL);
[+] 	HINSTANCE hProcess = ::ShellExecuteW(0, L"open", sl::String_w (commandLine), 0, 0, SW_SHOWNORMAL);
[-] 	return err::complete (hProcess != NULL);
[+] 	return err::complete(hProcess != NULL);
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys\axl_sys_ReadWriteLock.h
----------------------
[-] 	ReadWriteLock ()
[+] 	ReadWriteLock()
[-] 	~ReadWriteLock ()
[+] 	~ReadWriteLock()
[-] 		close ();
[+] 		close();
[-] 	close ();
[+] 	close();
[-] 	create ();
[+] 	create();
[-] 	create (
[+] 	create(
[-] 	open (
[+] 	open(
[-] 	readLock (uint_t timeout = -1);
[+] 	readLock(uint_t timeout = -1);
[-] 	readUnlock ();
[+] 	readUnlock();
[-] 	writeLock (uint_t timeout = -1);
[+] 	writeLock(uint_t timeout = -1);
[-] 	writeUnlock ();
[+] 	writeUnlock();
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys\axl_sys_Semaphore.h
----------------------
[-] 	isOpen ()
[+] 	isOpen()
[-] 		return m_semaphore.isOpen ();
[+] 		return m_semaphore.isOpen();
[-] 	close ()
[+] 	close()
[-] 		m_semaphore.close ();
[+] 		m_semaphore.close();
[-] 	create (const sl::StringRef& name)
[+] 	create(const sl::StringRef& name)
[-] 		return m_semaphore.create (NULL, 0, MAXLONG, name.s2 ());
[+] 		return m_semaphore.create(NULL, 0, MAXLONG, name.s2());
[-] 	open (const sl::StringRef& name)
[+] 	open(const sl::StringRef& name)
[-] 		return m_semaphore.open (SEMAPHORE_ALL_ACCESS, false, name.s2 ());
[+] 		return m_semaphore.open(SEMAPHORE_ALL_ACCESS, false, name.s2());
[-] 	signal (size_t count = 1)
[+] 	signal(size_t count = 1)
[-] 		return m_semaphore.signal (count);
[+] 		return m_semaphore.signal(count);
[-] 	wait ()
[+] 	wait()
[-] 		return m_semaphore.wait (-1) == win::WaitResult_Object0;
[+] 		return m_semaphore.wait(-1) == win::WaitResult_Object0;
[-] 	isOpen ()
[+] 	isOpen()
[-] 		return m_sem.isOpen ();
[+] 		return m_sem.isOpen();
[-] 	close ()
[+] 	close()
[-] 		m_sem.close ();
[+] 		m_sem.close();
[-] 	create (const sl::StringRef& name)
[+] 	create(const sl::StringRef& name)
[-] 		return m_sem.open (name, O_CREAT | O_EXCL, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, 0);
[+] 		return m_sem.open(name, O_CREAT | O_EXCL, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH, 0);
[-] 	open (const sl::StringRef& name)
[+] 	open(const sl::StringRef& name)
[-] 		return m_sem.open (name, 0, 0, 0);
[+] 		return m_sem.open(name, 0, 0, 0);
[-] 	signal ()
[+] 	signal()
[-] 		return m_sem.post ();
[+] 		return m_sem.post();
[-] 	signal (size_t count)
[+] 	signal(size_t count)
[-] 			bool result = m_sem.post ();
[+] 			bool result = m_sem.post();
[-] 	tryWait ()
[+] 	tryWait()
[-] 		return m_sem.tryWait ();
[+] 		return m_sem.tryWait();
[-] 	wait ()
[+] 	wait()
[-] 		return m_sem.wait ();
[+] 		return m_sem.wait();
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys\axl_sys_SjljTry.h
----------------------
[-] sjljThrow ()
[+] sjljThrow()
[-] 	SjljFrame* sjljFrame = getTlsPtrSlotValue <SjljFrame> ();
[+] 	SjljFrame* sjljFrame = getTlsPtrSlotValue<SjljFrame> ();
[-] 	ASSERT (sjljFrame);
[+] 	ASSERT(sjljFrame);
[-] 	longjmp (sjljFrame->m_jmpBuf, -1);
[+] 	longjmp(sjljFrame->m_jmpBuf, -1);
[-] 	axl::sys::SjljFrame* __axlSjljPrevFrame = axl::sys::setTlsPtrSlotValue <axl::sys::SjljFrame> (&__axlSjljFrame); \
[+] 	axl::sys::SjljFrame* __axlSjljPrevFrame = axl::sys::setTlsPtrSlotValue<axl::sys::SjljFrame> (&__axlSjljFrame); \
[-] 	int __axlSjljBranch = setjmp (__axlSjljFrame.m_jmpBuf); \
[+] 	int __axlSjljBranch = setjmp(__axlSjljFrame.m_jmpBuf); \
[-] 			axl::sys::SjljFrame* prev = axl::sys::setTlsPtrSlotValue <axl::sys::SjljFrame> (__axlSjljPrevFrame); \
[+] 			axl::sys::SjljFrame* prev = axl::sys::setTlsPtrSlotValue<axl::sys::SjljFrame> (__axlSjljPrevFrame); \
[-] 			ASSERT (prev == &__axlSjljFrame); \
[+] 			ASSERT(prev == &__axlSjljFrame); \
[-] 			axl::sys::SjljFrame* prev = axl::sys::setTlsPtrSlotValue <axl::sys::SjljFrame> (__axlSjljPrevFrame); \
[+] 			axl::sys::SjljFrame* prev = axl::sys::setTlsPtrSlotValue<axl::sys::SjljFrame> (__axlSjljPrevFrame); \
[-] 			ASSERT (prev == &__axlSjljFrame || prev == __axlSjljPrevFrame); \
[+] 			ASSERT(prev == &__axlSjljFrame || prev == __axlSjljPrevFrame); \
[-] 		axl::sys::SjljFrame* prev = axl::sys::setTlsPtrSlotValue <axl::sys::SjljFrame> (__axlSjljPrevFrame); \
[+] 		axl::sys::SjljFrame* prev = axl::sys::setTlsPtrSlotValue<axl::sys::SjljFrame> (__axlSjljPrevFrame); \
[-] 		ASSERT (prev == &__axlSjljFrame || prev == __axlSjljPrevFrame); \
[+] 		ASSERT(prev == &__axlSjljFrame || prev == __axlSjljPrevFrame); \
[-] 	axl::sys::sjljThrow ()
[+] 	axl::sys::sjljThrow()
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys\axl_sys_Thread.h
----------------------
[-] 	~ThreadImpl ()
[+] 	~ThreadImpl()
[-] 		waitAndClose ();
[+] 		waitAndClose();
[-] 	isOpen ()
[+] 	isOpen()
[-] 		return m_thread.isOpen ();
[+] 		return m_thread.isOpen();
[-] 	getThreadId ()
[+] 	getThreadId()
[-] 		return m_thread.getThreadId ();
[+] 		return m_thread.getThreadId();
[-] 	start ()
[+] 	start()
[-] 		return m_thread.create (NULL, 0, threadFuncImpl, (T*) this, 0);
[+] 		return m_thread.create(NULL, 0, threadFuncImpl, (T*)this, 0);
[-] 	wait (uint_t timeout = -1)
[+] 	wait(uint_t timeout = -1)
[-] 		return !m_thread.isOpen () || m_thread.wait (timeout) == win::WaitResult_Object0;
[+] 		return !m_thread.isOpen() || m_thread.wait(timeout) == win::WaitResult_Object0;
[-] 	waitAndClose (uint_t timeout = -1)
[+] 	waitAndClose(uint_t timeout = -1)
[-] 		bool result = wait (timeout);
[+] 		bool result = wait(timeout);
[-] 			ASSERT (false); // terminating thread
[+] 			ASSERT(false); // terminating thread
[-] 			m_thread.terminate (err::SystemErrorCode_IoTimeout);
[+] 			m_thread.terminate(err::SystemErrorCode_IoTimeout);
[-] 		m_thread.close ();
[+] 		m_thread.close();
[-] 	terminate ()
[+] 	terminate()
[-] 		return m_thread.terminate (err::SystemErrorCode_IoTimeout);
[+] 		return m_thread.terminate(err::SystemErrorCode_IoTimeout);
[-] 	threadFuncImpl (void* context)
[+] 	threadFuncImpl(void* context)
[-] 		((T*) context)->threadFunc ();
[+] 		((T*)context)->threadFunc();
[-] getCurrentThreadId ()
[+] getCurrentThreadId()
[-] 	return ::GetCurrentThreadId ();
[+] 	return ::GetCurrentThreadId();
[-] 	isOpen ()
[+] 	isOpen()
[-] 		return m_thread.isOpen ();
[+] 		return m_thread.isOpen();
[-] 	getThreadId ()
[+] 	getThreadId()
[-] 		return (uint64_t) (pthread_t) m_thread;
[+] 		return (uint64_t)(pthread_t)m_thread;
[-] 	terminate ()
[+] 	terminate()
[-] 		return m_thread.cancel ();
[+] 		return m_thread.cancel();
[-] 	~ThreadImpl ()
[+] 	~ThreadImpl()
[-] 		waitAndClose ();
[+] 		waitAndClose();
[-] 	start ()
[+] 	start()
[-] 		ASSERT (!m_thread.isOpen ());
[+] 		ASSERT(!m_thread.isOpen());
[-] 		m_threadCompletedEvent.reset ();
[+] 		m_threadCompletedEvent.reset();
[-] 		return m_thread.create (threadFuncImpl, (T*) this);
[+] 		return m_thread.create(threadFuncImpl, (T*)this);
[-] 	wait (uint_t timeout = -1)
[+] 	wait(uint_t timeout = -1)
[-] 		return !m_thread.isOpen () || m_threadCompletedEvent.wait (timeout);
[+] 		return !m_thread.isOpen() || m_threadCompletedEvent.wait(timeout);
[-] 	waitAndClose (uint_t timeout = -1)
[+] 	waitAndClose(uint_t timeout = -1)
[-] 		if (!m_thread.isOpen ())
[+] 		if (!m_thread.isOpen())
[-] 		bool result = m_threadCompletedEvent.wait (timeout);
[+] 		bool result = m_threadCompletedEvent.wait(timeout);
[-] 			m_thread.join ();
[+] 			m_thread.join();
[-] 			ASSERT (false); // cancelling thread
[+] 			ASSERT(false); // cancelling thread
[-] 			m_thread.cancel ();
[+] 			m_thread.cancel();
[-] 		m_thread.detach ();
[+] 		m_thread.detach();
[-] 	threadFuncImpl (void* context)
[+] 	threadFuncImpl(void* context)
[-] 		T* self = (T*) context;
[+] 		T* self = (T*)context;
[-] 		self->threadFunc ();
[+] 		self->threadFunc();
[-] 		self->m_threadCompletedEvent.signal ();
[+] 		self->m_threadCompletedEvent.signal();
[-] 	~ThreadImpl ()
[+] 	~ThreadImpl()
[-] 		waitAndClose ();
[+] 		waitAndClose();
[-] 	start ()
[+] 	start()
[-] 		ASSERT (!m_thread.isOpen ());
[+] 		ASSERT(!m_thread.isOpen());
[-] 		return m_thread.create (threadFunc, (T*) this);
[+] 		return m_thread.create(threadFunc, (T*)this);
[-] 	wait (uint_t timeout = -1)
[+] 	wait(uint_t timeout = -1)
[-] 		return !m_thread.isOpen () || m_thread.join (timeout);
[+] 		return !m_thread.isOpen() || m_thread.join(timeout);
[-] 	waitAndClose (uint_t timeout = -1)
[+] 	waitAndClose(uint_t timeout = -1)
[-] 		bool result = wait (timeout);
[+] 		bool result = wait(timeout);
[-] 			ASSERT (false);
[+] 			ASSERT(false);
[-] 			m_thread.cancel ();
[+] 			m_thread.cancel();
[-] 		m_thread.detach ();
[+] 		m_thread.detach();
[-] 	threadFunc (void* context)
[+] 	threadFunc(void* context)
[-] 		((T*) context)->threadFunc ();
[+] 		((T*)context)->threadFunc();
[-] getCurrentThreadId ()
[+] getCurrentThreadId()
[-] 	return (uint64_t) ::pthread_self ();
[+] 	return (uint64_t) ::pthread_self();
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys\axl_sys_Time.h
----------------------
[-] getTimestamp ();
[+] getTimestamp();
[-] getPreciseTimestamp ();
[+] getPreciseTimestamp();
[-] sleep (uint32_t msCount);
[+] sleep(uint32_t msCount);
[-] getTimeZoneOffsetInMinutes (int timeZone)
[+] getTimeZoneOffsetInMinutes(int timeZone)
[-] 	Time ()
[+] 	Time()
[-] 		memset (this, 0, sizeof (Time));
[+] 		memset(this, 0, sizeof(Time));
[-] 	Time (uint64_t timestamp)
[+] 	Time(uint64_t timestamp)
[-] 		setTimestampImpl (timestamp, true, 0);
[+] 		setTimestampImpl(timestamp, true, 0);
[-] 	Time (
[+] 	Time(
[-] 		setTimestampImpl (timestamp, false, timeZone);
[+] 		setTimestampImpl(timestamp, false, timeZone);
[-] 	getTimestamp () const
[+] 	getTimestamp() const
[-] 		return getTimestampImpl (true, 0);
[+] 		return getTimestampImpl(true, 0);
[-] 	getTimestamp (int timeZone) const
[+] 	getTimestamp(int timeZone) const
[-] 		return getTimestampImpl (false, timeZone);
[+] 		return getTimestampImpl(false, timeZone);
[-] 	setTimestamp (uint64_t timestamp)
[+] 	setTimestamp(uint64_t timestamp)
[-] 		setTimestampImpl (timestamp, true, 0);
[+] 		setTimestampImpl(timestamp, true, 0);
[-] 	setTimestamp (
[+] 	setTimestamp(
[-] 		setTimestampImpl (timestamp, false, timeZone);
[+] 		setTimestampImpl(timestamp, false, timeZone);
[-] 	format (
[+] 	format(
[-] 	format (const sl::StringRef& formatString = "%W %D %N %Y %h:%m:%s") const
[+] 	format(const sl::StringRef& formatString = "%W %D %N %Y %h:%m:%s") const
[-] 		format (&string, formatString);
[+] 		format(&string, formatString);
[-] 	getTimestampImpl (
[+] 	getTimestampImpl(
[-] 	setTimestampImpl (
[+] 	setTimestampImpl(
[-] getTimespecFromTimeout (
[+] getTimespecFromTimeout(
[-] 	tspec->tv_nsec = (uint64_t) (timeout % 1000) * 1000000;
[+] 	tspec->tv_nsec = (uint64_t)(timeout % 1000) * 1000000;
[-] getAbsTimespecFromTimeout (
[+] getAbsTimespecFromTimeout(
[-] getTimestampFromTimeval (const timeval* tval)
[+] getTimestampFromTimeval(const timeval* tval)
[-] 	return ((uint64_t) tval->tv_sec + AXL_SYS_EPOCH_DIFF) * 10000000 + (uint64_t) tval->tv_usec * 10;
[+] 	return ((uint64_t)tval->tv_sec + AXL_SYS_EPOCH_DIFF) * 10000000 + (uint64_t)tval->tv_usec * 10;
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys\axl_sys_TlsMgr.h
----------------------
[-] typedef ref::Ptr <void> TlsValue;
[+] typedef ref::Ptr<void> TlsValue;
[-] 		sl::Array <sl::BoxListEntry <TlsValue>*> m_array;
[+] 		sl::Array<sl::BoxListEntry<TlsValue>*> m_array;
[-] 		sl::BoxList <TlsValue> m_valueList;
[+] 		sl::BoxList<TlsValue> m_valueList;
[-] 	TlsMgr ();
[+] 	TlsMgr();
[-] 	~TlsMgr ();
[+] 	~TlsMgr();
[-] 	createSlot ()
[+] 	createSlot()
[-] 		return sys::atomicInc (&m_slotCount) - 1;
[+] 		return sys::atomicInc(&m_slotCount) - 1;
[-] 	getSlotValue (size_t slot);
[+] 	getSlotValue(size_t slot);
[-] 	setSlotValue (
[+] 	setSlotValue(
[-] 	tlsCallback (
[+] 	tlsCallback(
[-] 	getCurrentThreadPage ();
[+] 	getCurrentThreadPage();
[-] 	findCurrentThreadPage ()
[+] 	findCurrentThreadPage()
[-] 		return (Page*) ::TlsGetValue (m_tlsIdx);
[+] 		return (Page*) ::TlsGetValue(m_tlsIdx);
[-] 	setCurrentThreadPage (Page* page)
[+] 	setCurrentThreadPage(Page* page)
[-] 		::TlsSetValue (m_tlsIdx, page);
[+] 		::TlsSetValue(m_tlsIdx, page);
[-] 	findCurrentThreadPage ()
[+] 	findCurrentThreadPage()
[-] 		return (Page*) ::pthread_getspecific (m_tlsKey);
[+] 		return (Page*) ::pthread_getspecific(m_tlsKey);
[-] 	setCurrentThreadPage (Page* page)
[+] 	setCurrentThreadPage(Page* page)
[-] 		::pthread_setspecific (m_tlsKey, page);
[+] 		::pthread_setspecific(m_tlsKey, page);
[-] 	tlsDestructor (void* p)
[+] 	tlsDestructor(void* p)
[-] 		ASSERT (p);
[+] 		ASSERT(p);
[-] 		AXL_MEM_DELETE ((Page*) p);
[+] 		AXL_MEM_DELETE((Page*)p);
[-] getTlsMgr ()
[+] getTlsMgr()
[-] 	return sl::getSingleton <TlsMgr> ();
[+] 	return sl::getSingleton<TlsMgr> ();
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys\axl_sys_TlsSlot.h
----------------------
[-] 	TlsSlot ()
[+] 	TlsSlot()
[-] 		m_slot = getTlsMgr ()->createSlot ();
[+] 		m_slot = getTlsMgr()->createSlot();
[-] 	getSlot ()
[+] 	getSlot()
[-] 	operator size_t ()
[+] 	operator size_t()
[-] 	getValue ()
[+] 	getValue()
[-] 		return (T*) getTlsMgr ()->getSlotValue (m_slot).p ();
[+] 		return (T*)getTlsMgr()->getSlotValue(m_slot).p();
[-] 	setValue (T* p)
[+] 	setValue(T* p)
[-] 		return (T*) getTlsMgr ()->setSlotValue (m_slot, sys::TlsValue (p, NULL)).p ();
[+] 		return (T*)getTlsMgr()->setSlotValue(m_slot, sys::TlsValue(p, NULL)).p();
[-] getTlsPtrSlotValue ()
[+] getTlsPtrSlotValue()
[-] 	return sl::getSimpleSingleton <TlsPtrSlot <T> > ()->getValue ();
[+] 	return sl::getSimpleSingleton<TlsPtrSlot<T> > ()->getValue();
[-] setTlsPtrSlotValue (T* p)
[+] setTlsPtrSlotValue(T* p)
[-] 	return sl::getSimpleSingleton <TlsPtrSlot <T> > ()->setValue (p);
[+] 	return sl::getSimpleSingleton<TlsPtrSlot<T> > ()->setValue(p);
[-] 	ScopedTlsPtrSlot (T* p)
[+] 	ScopedTlsPtrSlot(T* p)
[-] 		m_prevValue = setTlsPtrSlotValue <T> (p);
[+] 		m_prevValue = setTlsPtrSlotValue<T> (p);
[-] 	~ScopedTlsPtrSlot ()
[+] 	~ScopedTlsPtrSlot()
[-] 		setTlsPtrSlotValue <T> (m_prevValue);
[+] 		setTlsPtrSlotValue<T> (m_prevValue);
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_drw\axl_sys_drw_MachError.h
----------------------
[-] AXL_SL_DEFINE_GUID (
[+] AXL_SL_DEFINE_GUID(
[-] 	getErrorDescription (mach_error_t code)
[+] 	getErrorDescription(mach_error_t code)
[-] 		return ::mach_error_string (code);
[+] 		return ::mach_error_string(code);
[-] 	getErrorDescription (const err::ErrorRef& error)
[+] 	getErrorDescription(const err::ErrorRef& error)
[-] 		return getErrorDescription (error->m_code);
[+] 		return getErrorDescription(error->m_code);
[-] 	MachError ()
[+] 	MachError()
[-] 	MachError (mach_error_t code)
[+] 	MachError(mach_error_t code)
[-] 		create (code);
[+] 		create(code);
[-] 	create (mach_error_t code);
[+] 	create(mach_error_t code);
[-] setMachError (mach_error_t code)
[+] setMachError(mach_error_t code)
[-] 	return err::setError (MachError (code));
[+] 	return err::setError(MachError(code));
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_drw\axl_sys_drw_Semaphore.h
----------------------
[-] 	Semaphore ()
[+] 	Semaphore()
[-] 		mach_error_t result = ::semaphore_create (mach_task_self (), &m_semaphore, SYNC_POLICY_FIFO, 0);
[+] 		mach_error_t result = ::semaphore_create(mach_task_self(), &m_semaphore, SYNC_POLICY_FIFO, 0);
[-] 		ASSERT (result == 0);
[+] 		ASSERT(result == 0);
[-] 	~Semaphore ()
[+] 	~Semaphore()
[-] 		mach_error_t result = ::semaphore_destroy (mach_task_self (), m_semaphore);
[+] 		mach_error_t result = ::semaphore_destroy(mach_task_self(), m_semaphore);
[-] 		ASSERT (result == 0);
[+] 		ASSERT(result == 0);
[-] 	signal ()
[+] 	signal()
[-] 		mach_error_t result = ::semaphore_signal (m_semaphore);
[+] 		mach_error_t result = ::semaphore_signal(m_semaphore);
[-] 		return result == 0 ? true : err::fail (sys::drw::MachError (result));
[+] 		return result == 0 ? true : err::fail(sys::drw::MachError(result));
[-] 	signalAll ()
[+] 	signalAll()
[-] 		mach_error_t result = ::semaphore_signal_all (m_semaphore);
[+] 		mach_error_t result = ::semaphore_signal_all(m_semaphore);
[-] 		return result == 0 ? true : err::fail (sys::drw::MachError (result));
[+] 		return result == 0 ? true : err::fail(sys::drw::MachError(result));
[-] 	wait ()
[+] 	wait()
[-] 		mach_error_t result = ::semaphore_wait (m_semaphore);
[+] 		mach_error_t result = ::semaphore_wait(m_semaphore);
[-] 		return result == 0 ? true : err::fail (sys::drw::MachError (result));
[+] 		return result == 0 ? true : err::fail(sys::drw::MachError(result));
[-] 	wait (uint_t timeout);
[+] 	wait(uint_t timeout);
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_lnx\axl_sys_lnx_Udev.h
----------------------
[-] completeUdev (
[+] completeUdev(
[-] 		err::setFormatStringError ("'%s' failed", functionName);
[+] 		err::setFormatStringError("'%s' failed", functionName);
[-] completeUdevErrno (int result)
[+] completeUdevErrno(int result)
[-] 		err::setError (-result);
[+] 		err::setError(-result);
[-] 		::udev_unref (h);
[+] 		::udev_unref(h);
[-] 		::udev_device_unref (h);
[+] 		::udev_device_unref(h);
[-] 		::udev_enumerate_unref (h);
[+] 		::udev_enumerate_unref(h);
[-] 		::udev_monitor_unref (h);
[+] 		::udev_monitor_unref(h);
[-] class UdevContext: public sl::Handle <udev*, UnrefUdevContext>
[+] class UdevContext: public sl::Handle<udev*, UnrefUdevContext>
[-] 	UdevContext ()
[+] 	UdevContext()
[-] 		create ();
[+] 		create();
[-] 	UdevContext (udev* h)
[+] 	UdevContext(udev* h)
[-] 	create ();
[+] 	create();
[-] 	addRef ()
[+] 	addRef()
[-] 		::udev_ref (m_h);
[+] 		::udev_ref(m_h);
[-] 	getDeviceFromSysPath (const sl::StringRef& sysPath)
[+] 	getDeviceFromSysPath(const sl::StringRef& sysPath)
[-] 		udev_device* device = ::udev_device_new_from_syspath (m_h, sysPath.sz ());
[+] 		udev_device* device = ::udev_device_new_from_syspath(m_h, sysPath.sz());
[-] 		return completeUdev (device, "udev_device_new_from_syspath");
[+] 		return completeUdev(device, "udev_device_new_from_syspath");
[-] 	getDeviceFromDevNum (
[+] 	getDeviceFromDevNum(
[-] 		udev_device* device = ::udev_device_new_from_devnum (m_h, type, devNum);
[+] 		udev_device* device = ::udev_device_new_from_devnum(m_h, type, devNum);
[-] 		return completeUdev (device, "udev_device_new_from_devnum");
[+] 		return completeUdev(device, "udev_device_new_from_devnum");
[-] 	getDeviceFromSubsytemSysName (
[+] 	getDeviceFromSubsytemSysName(
[-] 		udev_device* device = ::udev_device_new_from_subsystem_sysname (m_h, subsystem.sz (), sysName.sz ());
[+] 		udev_device* device = ::udev_device_new_from_subsystem_sysname(m_h, subsystem.sz(), sysName.sz());
[-] 		return completeUdev (device, "udev_device_new_from_subsystem_sysname");
[+] 		return completeUdev(device, "udev_device_new_from_subsystem_sysname");
[-] 	getDeviceFromDeviceId (const sl::StringRef& deviceId)
[+] 	getDeviceFromDeviceId(const sl::StringRef& deviceId)
[-] 		udev_device* device = ::udev_device_new_from_device_id (m_h, (char*) deviceId.sz ());
[+] 		udev_device* device = ::udev_device_new_from_device_id(m_h, (char*)deviceId.sz());
[-] 		return completeUdev (device, "udev_device_new_from_device_id");
[+] 		return completeUdev(device, "udev_device_new_from_device_id");
[-] 	getDeviceFromEnvironment ()
[+] 	getDeviceFromEnvironment()
[-] 		udev_device* device = ::udev_device_new_from_environment (m_h);
[+] 		udev_device* device = ::udev_device_new_from_environment(m_h);
[-] 		return completeUdev (device, "udev_device_new_from_environment");
[+] 		return completeUdev(device, "udev_device_new_from_environment");
[-] 	createEnumerator ()
[+] 	createEnumerator()
[-] 		udev_enumerate* enumerator = ::udev_enumerate_new (m_h);
[+] 		udev_enumerate* enumerator = ::udev_enumerate_new(m_h);
[-] 		return completeUdev (enumerator, "udev_device_new_from_environment");
[+] 		return completeUdev(enumerator, "udev_device_new_from_environment");
[-] 	createMonitor (const sl::StringRef& name)
[+] 	createMonitor(const sl::StringRef& name)
[-] 		udev_monitor* monitor = ::udev_monitor_new_from_netlink (m_h, name.sz ());
[+] 		udev_monitor* monitor = ::udev_monitor_new_from_netlink(m_h, name.sz());
[-] 		return completeUdev (monitor, "udev_monitor_new_from_netlink");
[+] 		return completeUdev(monitor, "udev_monitor_new_from_netlink");
[-] class UdevDevice: public sl::Handle <udev_device*, UnrefUdevDevice>
[+] class UdevDevice: public sl::Handle<udev_device*, UnrefUdevDevice>
[-] 	UdevDevice ()
[+] 	UdevDevice()
[-] 	UdevDevice (udev_device* h)
[+] 	UdevDevice(udev_device* h)
[-] 	addRef ()
[+] 	addRef()
[-] 		::udev_device_ref (m_h);
[+] 		::udev_device_ref(m_h);
[-] 	getUdev ()
[+] 	getUdev()
[-] 		return ::udev_device_get_udev (m_h);
[+] 		return ::udev_device_get_udev(m_h);
[-] 	getSysPath ()
[+] 	getSysPath()
[-] 		return ::udev_device_get_syspath (m_h);
[+] 		return ::udev_device_get_syspath(m_h);
[-] 	getSysName ()
[+] 	getSysName()
[-] 	getSysNum ()
[+] 	getSysNum()
[-] 		return ::udev_device_get_sysnum (m_h);
[+] 		return ::udev_device_get_sysnum(m_h);
[-] 	getDevPath ()
[+] 	getDevPath()
[-] 		return ::udev_device_get_devpath (m_h);
[+] 		return ::udev_device_get_devpath(m_h);
[-] 	getDevNode ()
[+] 	getDevNode()
[-] 		return ::udev_device_get_devnode (m_h);
[+] 		return ::udev_device_get_devnode(m_h);
[-] 	getDevNum ()
[+] 	getDevNum()
[-] 		return ::udev_device_get_devnum (m_h);
[+] 		return ::udev_device_get_devnum(m_h);
[-] 	getDevType ()
[+] 	getDevType()
[-] 		return ::udev_device_get_devtype (m_h);
[+] 		return ::udev_device_get_devtype(m_h);
[-] 	getSubsystem ()
[+] 	getSubsystem()
[-] 		return ::udev_device_get_subsystem (m_h);
[+] 		return ::udev_device_get_subsystem(m_h);
[-] 	getDriver ()
[+] 	getDriver()
[-] 		return ::udev_device_get_driver (m_h);
[+] 		return ::udev_device_get_driver(m_h);
[-] 	getParent ()
[+] 	getParent()
[-] 		return ::udev_device_get_parent (m_h);
[+] 		return ::udev_device_get_parent(m_h);
[-] 	getParentWithSubsystemDevType (
[+] 	getParentWithSubsystemDevType(
[-] 		return ::udev_device_get_parent_with_subsystem_devtype (m_h, subSystem.sz (), devType.sz ());
[+] 		return ::udev_device_get_parent_with_subsystem_devtype(m_h, subSystem.sz(), devType.sz());
[-] 	isInitialized ()
[+] 	isInitialized()
[-] 		return ::udev_device_get_is_initialized (m_h) != 0;
[+] 		return ::udev_device_get_is_initialized(m_h) != 0;
[-] 	getAction ()
[+] 	getAction()
[-] 		return ::udev_device_get_action (m_h);
[+] 		return ::udev_device_get_action(m_h);
[-] 	getDevLinkList ()
[+] 	getDevLinkList()
[-] 		return ::udev_device_get_devlinks_list_entry (m_h);
[+] 		return ::udev_device_get_devlinks_list_entry(m_h);
[-] 	getPropertyList ()
[+] 	getPropertyList()
[-] 		return ::udev_device_get_properties_list_entry (m_h);
[+] 		return ::udev_device_get_properties_list_entry(m_h);
[-] 	getTagList ()
[+] 	getTagList()
[-] 		return ::udev_device_get_tags_list_entry (m_h);
[+] 		return ::udev_device_get_tags_list_entry(m_h);
[-] 	getSysAttrList ()
[+] 	getSysAttrList()
[-] 		return ::udev_device_get_sysattr_list_entry (m_h);
[+] 		return ::udev_device_get_sysattr_list_entry(m_h);
[-] 	getPropertyValue (const sl::StringRef& key)
[+] 	getPropertyValue(const sl::StringRef& key)
[-] 		return ::udev_device_get_property_value (m_h, key.sz ());
[+] 		return ::udev_device_get_property_value(m_h, key.sz());
[-] 	hasTag (const sl::StringRef& tag)
[+] 	hasTag(const sl::StringRef& tag)
[-] 		return ::udev_device_has_tag (m_h, tag.sz ());
[+] 		return ::udev_device_has_tag(m_h, tag.sz());
[-] 	getSysAttrValue (const sl::StringRef& sysAttr)
[+] 	getSysAttrValue(const sl::StringRef& sysAttr)
[-] 		return ::udev_device_get_sysattr_value (m_h, sysAttr.sz ());
[+] 		return ::udev_device_get_sysattr_value(m_h, sysAttr.sz());
[-] 	setSysAttrValue (
[+] 	setSysAttrValue(
[-] 		return ::udev_device_set_sysattr_value (m_h, sysAttr.sz (), (char*) value.sz ());
[+] 		return ::udev_device_set_sysattr_value(m_h, sysAttr.sz(), (char*)value.sz());
[-] class UdevEnumerator: public sl::Handle <udev_enumerate*, UnrefUdevEnumerator>
[+] class UdevEnumerator: public sl::Handle<udev_enumerate*, UnrefUdevEnumerator>
[-] 	UdevEnumerator ()
[+] 	UdevEnumerator()
[-] 	UdevEnumerator (udev_enumerate* h)
[+] 	UdevEnumerator(udev_enumerate* h)
[-] 	addRef ()
[+] 	addRef()
[-] 		::udev_enumerate_ref (m_h);
[+] 		::udev_enumerate_ref(m_h);
[-] 	getUdev ()
[+] 	getUdev()
[-] 		return ::udev_enumerate_get_udev (m_h);
[+] 		return ::udev_enumerate_get_udev(m_h);
[-] 	addMatchSubsystem (const sl::StringRef& subsystem)
[+] 	addMatchSubsystem(const sl::StringRef& subsystem)
[-] 		int result = ::udev_enumerate_add_match_subsystem (m_h, subsystem.sz ());
[+] 		int result = ::udev_enumerate_add_match_subsystem(m_h, subsystem.sz());
[-] 		return completeUdevErrno (result);
[+] 		return completeUdevErrno(result);
[-] 	addNoMatchSubsystem (const sl::StringRef& subsystem)
[+] 	addNoMatchSubsystem(const sl::StringRef& subsystem)
[-] 		int result = ::udev_enumerate_add_nomatch_subsystem (m_h, subsystem.sz ());
[+] 		int result = ::udev_enumerate_add_nomatch_subsystem(m_h, subsystem.sz());
[-] 		return completeUdevErrno (result);
[+] 		return completeUdevErrno(result);
[-] 	addMatchSysAttr (
[+] 	addMatchSysAttr(
[-] 		int result = ::udev_enumerate_add_match_sysattr (m_h, sysAttr.sz (), value.sz ());
[+] 		int result = ::udev_enumerate_add_match_sysattr(m_h, sysAttr.sz(), value.sz());
[-] 		return completeUdevErrno (result);
[+] 		return completeUdevErrno(result);
[-] 	addNoMatchSysAttr (
[+] 	addNoMatchSysAttr(
[-] 		int result = ::udev_enumerate_add_match_sysattr (m_h, sysAttr.sz (), value.sz ());
[+] 		int result = ::udev_enumerate_add_match_sysattr(m_h, sysAttr.sz(), value.sz());
[-] 		return completeUdevErrno (result);
[+] 		return completeUdevErrno(result);
[-] 	addMatchProperty (
[+] 	addMatchProperty(
[-] 		int result = ::udev_enumerate_add_match_property (m_h, prop.sz (), value.sz ());
[+] 		int result = ::udev_enumerate_add_match_property(m_h, prop.sz(), value.sz());
[-] 		return completeUdevErrno (result);
[+] 		return completeUdevErrno(result);
[-] 	addMatchSysName (const sl::StringRef& sysName)
[+] 	addMatchSysName(const sl::StringRef& sysName)
[-] 		int result = ::udev_enumerate_add_match_sysname (m_h, sysName.sz ());
[+] 		int result = ::udev_enumerate_add_match_sysname(m_h, sysName.sz());
[-] 		return completeUdevErrno (result);
[+] 		return completeUdevErrno(result);
[-] 	addMatchTag (const sl::StringRef& tag)
[+] 	addMatchTag(const sl::StringRef& tag)
[-] 		int result = ::udev_enumerate_add_match_tag (m_h, tag.sz ());
[+] 		int result = ::udev_enumerate_add_match_tag(m_h, tag.sz());
[-] 		return completeUdevErrno (result);
[+] 		return completeUdevErrno(result);
[-] 	addMatchParentDevice (udev_device* parentDevice)
[+] 	addMatchParentDevice(udev_device* parentDevice)
[-] 		int result = ::udev_enumerate_add_match_parent (m_h, parentDevice);
[+] 		int result = ::udev_enumerate_add_match_parent(m_h, parentDevice);
[-] 		return completeUdevErrno (result);
[+] 		return completeUdevErrno(result);
[-] 	addMatchIsInitialized ()
[+] 	addMatchIsInitialized()
[-] 		int result = ::udev_enumerate_add_match_is_initialized (m_h);
[+] 		int result = ::udev_enumerate_add_match_is_initialized(m_h);
[-] 		return completeUdevErrno (result);
[+] 		return completeUdevErrno(result);
[-] 	scanDevices ()
[+] 	scanDevices()
[-] 		int result = ::udev_enumerate_scan_devices (m_h);
[+] 		int result = ::udev_enumerate_scan_devices(m_h);
[-] 		return completeUdevErrno (result);
[+] 		return completeUdevErrno(result);
[-] 	scanSubsystems ()
[+] 	scanSubsystems()
[-] 		int result = ::udev_enumerate_scan_subsystems (m_h);
[+] 		int result = ::udev_enumerate_scan_subsystems(m_h);
[-] 		return completeUdevErrno (result);
[+] 		return completeUdevErrno(result);
[-] 	addSysPath (const sl::StringRef& sysPath)
[+] 	addSysPath(const sl::StringRef& sysPath)
[-] 		int result = ::udev_enumerate_add_syspath (m_h, sysPath.sz ());
[+] 		int result = ::udev_enumerate_add_syspath(m_h, sysPath.sz());
[-] 		return completeUdevErrno (result);
[+] 		return completeUdevErrno(result);
[-] 	getListEntry ()
[+] 	getListEntry()
[-] 		return ::udev_enumerate_get_list_entry (m_h);
[+] 		return ::udev_enumerate_get_list_entry(m_h);
[-] class UdevMonitor: public sl::Handle <udev_monitor*, UnrefUdevMonitor>
[+] class UdevMonitor: public sl::Handle<udev_monitor*, UnrefUdevMonitor>
[-] 	UdevMonitor ()
[+] 	UdevMonitor()
[-] 	UdevMonitor (udev_monitor* h)
[+] 	UdevMonitor(udev_monitor* h)
[-] 	addRef ()
[+] 	addRef()
[-] 		::udev_monitor_ref (m_h);
[+] 		::udev_monitor_ref(m_h);
[-] 	getUdev ()
[+] 	getUdev()
[-] 		return ::udev_monitor_get_udev (m_h);
[+] 		return ::udev_monitor_get_udev(m_h);
[-] 	getFd ()
[+] 	getFd()
[-] 		return ::udev_monitor_get_fd (m_h);
[+] 		return ::udev_monitor_get_fd(m_h);
[-] 	updateFilter ()
[+] 	updateFilter()
[-] 		int result = ::udev_monitor_filter_update (m_h);
[+] 		int result = ::udev_monitor_filter_update(m_h);
[-] 		return completeUdevErrno (result);
[+] 		return completeUdevErrno(result);
[-] 	removeFilter ()
[+] 	removeFilter()
[-] 		int result = ::udev_monitor_filter_remove (m_h);
[+] 		int result = ::udev_monitor_filter_remove(m_h);
[-] 		return completeUdevErrno (result);
[+] 		return completeUdevErrno(result);
[-] 	addMatchSubsystemDevTypeFilter (
[+] 	addMatchSubsystemDevTypeFilter(
[-] 		int result = ::udev_monitor_filter_add_match_subsystem_devtype (m_h, subsystem.sz (), devType.sz ());
[+] 		int result = ::udev_monitor_filter_add_match_subsystem_devtype(m_h, subsystem.sz(), devType.sz());
[-] 		return completeUdevErrno (result);
[+] 		return completeUdevErrno(result);
[-] 	addMatchTagFilter (const char *tag)
[+] 	addMatchTagFilter(const char *tag)
[-] 		int result = ::udev_monitor_filter_add_match_tag (m_h, tag);
[+] 		int result = ::udev_monitor_filter_add_match_tag(m_h, tag);
[-] 		return completeUdevErrno (result);
[+] 		return completeUdevErrno(result);
[-] 	setReceiveBufferSize (size_t size)
[+] 	setReceiveBufferSize(size_t size)
[-] 		int result = ::udev_monitor_set_receive_buffer_size (m_h, size);
[+] 		int result = ::udev_monitor_set_receive_buffer_size(m_h, size);
[-] 		return completeUdevErrno (result);
[+] 		return completeUdevErrno(result);
[-] 	enableReceiving ()
[+] 	enableReceiving()
[-] 		int result = ::udev_monitor_enable_receiving (m_h);
[+] 		int result = ::udev_monitor_enable_receiving(m_h);
[-] 		return completeUdevErrno (result);
[+] 		return completeUdevErrno(result);
[-] 	receiveDevice ()
[+] 	receiveDevice()
[-] 		udev_device* device = ::udev_monitor_receive_device (m_h);
[+] 		udev_device* device = ::udev_monitor_receive_device(m_h);
[-] 		return completeUdev (device, "udev_monitor_receive_device ");
[+] 		return completeUdev(device, "udev_monitor_receive_device ");
[-] class UdevListEntry: public sl::Handle <udev_list_entry*>
[+] class UdevListEntry: public sl::Handle<udev_list_entry*>
[-] 	UdevListEntry ()
[+] 	UdevListEntry()
[-] 	UdevListEntry (udev_list_entry* h)
[+] 	UdevListEntry(udev_list_entry* h)
[-] 		next ();
[+] 		next();
[-] 		next ();
[+] 		next();
[-] 	getNext ()
[+] 	getNext()
[-] 		return ::udev_list_entry_get_next (m_h);
[+] 		return ::udev_list_entry_get_next(m_h);
[-] 	next ()
[+] 	next()
[-] 		m_h = ::udev_list_entry_get_next (m_h);
[+] 		m_h = ::udev_list_entry_get_next(m_h);
[-] 	findByName (const char *name)
[+] 	findByName(const char *name)
[-] 		return ::udev_list_entry_get_by_name (m_h, name);
[+] 		return ::udev_list_entry_get_by_name(m_h, name);
[-] 	getName ()
[+] 	getName()
[-] 		return ::udev_list_entry_get_name (m_h);
[+] 		return ::udev_list_entry_get_name(m_h);
[-] 	getValue ()
[+] 	getValue()
[-] 		return ::udev_list_entry_get_value (m_h);
[+] 		return ::udev_list_entry_get_value(m_h);
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_psx\axl_sys_psx_Cond.h
----------------------
[-] 	CondAttr ()
[+] 	CondAttr()
[-] 		::pthread_condattr_init (&m_attr);
[+] 		::pthread_condattr_init(&m_attr);
[-] 	~CondAttr ()
[+] 	~CondAttr()
[-] 		::pthread_condattr_destroy (&m_attr);
[+] 		::pthread_condattr_destroy(&m_attr);
[-] 	getProcessShared (int* value) const
[+] 	getProcessShared(int* value) const
[-] 		int result = ::pthread_condattr_getpshared (&m_attr, value);
[+] 		int result = ::pthread_condattr_getpshared(&m_attr, value);
[-] 		return result == 0 ? true : err::fail (result);
[+] 		return result == 0 ? true : err::fail(result);
[-] 	setProcessShared (int value)
[+] 	setProcessShared(int value)
[-] 		int result = ::pthread_condattr_setpshared (&m_attr, value);
[+] 		int result = ::pthread_condattr_setpshared(&m_attr, value);
[-] 		return result == 0 ? true : err::fail (result);
[+] 		return result == 0 ? true : err::fail(result);
[-] 	Cond (const pthread_condattr_t* attr = NULL)
[+] 	Cond(const pthread_condattr_t* attr = NULL)
[-] 		::pthread_cond_init (&m_cond, attr);
[+] 		::pthread_cond_init(&m_cond, attr);
[-] 	~Cond ()
[+] 	~Cond()
[-] 		::pthread_cond_destroy (&m_cond);
[+] 		::pthread_cond_destroy(&m_cond);
[-] 	signal ()
[+] 	signal()
[-] 		int result = ::pthread_cond_signal (&m_cond);
[+] 		int result = ::pthread_cond_signal(&m_cond);
[-] 		return result == 0 ? true : err::fail (result);
[+] 		return result == 0 ? true : err::fail(result);
[-] 	broadcast ()
[+] 	broadcast()
[-] 		int result = ::pthread_cond_broadcast (&m_cond);
[+] 		int result = ::pthread_cond_broadcast(&m_cond);
[-] 		return result == 0 ? true : err::fail (result);
[+] 		return result == 0 ? true : err::fail(result);
[-] 	wait (pthread_mutex_t* mutex)
[+] 	wait(pthread_mutex_t* mutex)
[-] 		int result = ::pthread_cond_wait (&m_cond, mutex);
[+] 		int result = ::pthread_cond_wait(&m_cond, mutex);
[-] 		return result == 0 ? true : err::fail (result);
[+] 		return result == 0 ? true : err::fail(result);
[-] 	wait (
[+] 	wait(
[-] 	CondMutexPair ()
[+] 	CondMutexPair()
[-] 	CondMutexPair (
[+] 	CondMutexPair(
[-] 		m_cond (condAttr),
[+] 		m_cond(condAttr),
[-] 		m_mutex (mutexAttr)
[+] 		m_mutex(mutexAttr)
[-] 	tryLock ()
[+] 	tryLock()
[-] 		return m_mutex.tryLock ();
[+] 		return m_mutex.tryLock();
[-] 	lock ()
[+] 	lock()
[-] 		m_mutex.lock ();
[+] 		m_mutex.lock();
[-] 	unlock ()
[+] 	unlock()
[-] 		m_mutex.unlock ();
[+] 		m_mutex.unlock();
[-] 	signal ()
[+] 	signal()
[-] 		return m_cond.signal ();
[+] 		return m_cond.signal();
[-] 	broadcast ()
[+] 	broadcast()
[-] 		return m_cond.broadcast ();
[+] 		return m_cond.broadcast();
[-] 	wait ()
[+] 	wait()
[-] 		return m_cond.wait (m_mutex);
[+] 		return m_cond.wait(m_mutex);
[-] 	wait (uint_t timeout)
[+] 	wait(uint_t timeout)
[-] 		return m_cond.wait (m_mutex, timeout);
[+] 		return m_cond.wait(m_mutex, timeout);
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_psx\axl_sys_psx_DynamicLibrary.h
----------------------
[-] 		::dlclose (h);
[+] 		::dlclose(h);
[-] class DynamicLibrary: public sl::Handle <void*, CloseDynamicLibrary>
[+] class DynamicLibrary: public sl::Handle<void*, CloseDynamicLibrary>
[-] 	open (
[+] 	open(
[-] 	getSymbol (const sl::StringRef& name);
[+] 	getSymbol(const sl::StringRef& name);
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_psx\axl_sys_psx_Mutex.h
----------------------
[-] 	MutexAttr ()
[+] 	MutexAttr()
[-] 		::pthread_mutexattr_init (&m_attr);
[+] 		::pthread_mutexattr_init(&m_attr);
[-] 	~MutexAttr ()
[+] 	~MutexAttr()
[-] 		::pthread_mutexattr_destroy (&m_attr);
[+] 		::pthread_mutexattr_destroy(&m_attr);
[-] 	getProcessShared (int* value) const;
[+] 	getProcessShared(int* value) const;
[-] 	setProcessShared (int value);
[+] 	setProcessShared(int value);
[-] 	getType (int* value) const;
[+] 	getType(int* value) const;
[-] 	setType (int value);
[+] 	setType(int value);
[-] 	Mutex (const pthread_mutexattr_t* attr = NULL)
[+] 	Mutex(const pthread_mutexattr_t* attr = NULL)
[-] 		::pthread_mutex_init (&m_mutex, attr);
[+] 		::pthread_mutex_init(&m_mutex, attr);
[-] 	~Mutex ()
[+] 	~Mutex()
[-] 		::pthread_mutex_destroy (&m_mutex);
[+] 		::pthread_mutex_destroy(&m_mutex);
[-] 	tryLock ();
[+] 	tryLock();
[-] 	lock ()
[+] 	lock()
[-] 		int result = ::pthread_mutex_lock (&m_mutex);
[+] 		int result = ::pthread_mutex_lock(&m_mutex);
[-] 		ASSERT (result == 0);
[+] 		ASSERT(result == 0);
[-] 	lock (uint_t timeout);
[+] 	lock(uint_t timeout);
[-] 	unlock ()
[+] 	unlock()
[-] 		::pthread_mutex_unlock (&m_mutex);
[+] 		::pthread_mutex_unlock(&m_mutex);
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_psx\axl_sys_psx_Sem.h
----------------------
[-] 	Sem (
[+] 	Sem(
[-] 		int result = sem_init (&m_sem, isShared, value);
[+] 		int result = sem_init(&m_sem, isShared, value);
[-] 		ASSERT (result == 0);
[+] 		ASSERT(result == 0);
[-] 	~Sem ()
[+] 	~Sem()
[-] 		int result = ::sem_destroy (&m_sem);
[+] 		int result = ::sem_destroy(&m_sem);
[-] 		ASSERT (result == 0);
[+] 		ASSERT(result == 0);
[-] 	post ()
[+] 	post()
[-] 		int result = ::sem_post (&m_sem);
[+] 		int result = ::sem_post(&m_sem);
[-] 		return err::complete (result == 0);
[+] 		return err::complete(result == 0);
[-] 	signal ()
[+] 	signal()
[-] 		return post ();
[+] 		return post();
[-] 	tryWait ()
[+] 	tryWait()
[-] 		int result = ::sem_trywait (&m_sem);
[+] 		int result = ::sem_trywait(&m_sem);
[-] 		return err::complete (result == 0);
[+] 		return err::complete(result == 0);
[-] 	wait ()
[+] 	wait()
[-] 		int result = ::sem_wait (&m_sem);
[+] 		int result = ::sem_wait(&m_sem);
[-] 		return err::complete (result == 0);
[+] 		return err::complete(result == 0);
[-] 	wait (uint_t timeout);
[+] 	wait(uint_t timeout);
[-] 	getValue (int* value)
[+] 	getValue(int* value)
[-] 		int result = ::sem_getvalue (&m_sem, value);
[+] 		int result = ::sem_getvalue(&m_sem, value);
[-] 		return err::complete (result == 0);
[+] 		return err::complete(result == 0);
[-] 		::sem_close (h);
[+] 		::sem_close(h);
[-] class NamedSem: public sl::Handle <sem_t*, CloseNamedSem>
[+] class NamedSem: public sl::Handle<sem_t*, CloseNamedSem>
[-] 	open (
[+] 	open(
[-] 	unlink (const sl::StringRef& name)
[+] 	unlink(const sl::StringRef& name)
[-] 		int result = ::sem_unlink (name.sz ());
[+] 		int result = ::sem_unlink(name.sz());
[-] 		return err::complete (result == 0);
[+] 		return err::complete(result == 0);
[-] 	post ()
[+] 	post()
[-] 		int result = ::sem_post (m_h);
[+] 		int result = ::sem_post(m_h);
[-] 		return err::complete (result == 0);
[+] 		return err::complete(result == 0);
[-] 	signal ()
[+] 	signal()
[-] 		return post ();
[+] 		return post();
[-] 	tryWait ()
[+] 	tryWait()
[-] 		int result = ::sem_trywait (m_h);
[+] 		int result = ::sem_trywait(m_h);
[-] 		return err::complete (result == 0);
[+] 		return err::complete(result == 0);
[-] 	wait ()
[+] 	wait()
[-] 		int result = ::sem_wait (m_h);
[+] 		int result = ::sem_wait(m_h);
[-] 		return err::complete (result == 0);
[+] 		return err::complete(result == 0);
[-] 	wait (uint_t timeout);
[+] 	wait(uint_t timeout);
[-] 	getValue (int* value)
[+] 	getValue(int* value)
[-] 		int result = ::sem_getvalue (m_h, value);
[+] 		int result = ::sem_getvalue(m_h, value);
[-] 		return err::complete (result == 0);
[+] 		return err::complete(result == 0);
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_psx\axl_sys_psx_Thread.h
----------------------
[-] 	ThreadAttr ()
[+] 	ThreadAttr()
[-] 		::pthread_attr_init (&m_attr);
[+] 		::pthread_attr_init(&m_attr);
[-] 	~ThreadAttr ()
[+] 	~ThreadAttr()
[-] 		::pthread_attr_destroy (&m_attr);
[+] 		::pthread_attr_destroy(&m_attr);
[-] 	getAffinity () const
[+] 	getAffinity() const
[-] 		::pthread_attr_getaffinity_np (&m_attr, sizeof (cpu_set_t), &cpuSet);
[+] 		::pthread_attr_getaffinity_np(&m_attr, sizeof(cpu_set_t), &cpuSet);
[-] 	setAffinity (cpu_set_t cpuSet)
[+] 	setAffinity(cpu_set_t cpuSet)
[-] 		int result = ::pthread_attr_setaffinity_np (&m_attr, sizeof (cpu_set_t), &cpuSet);
[+] 		int result = ::pthread_attr_setaffinity_np(&m_attr, sizeof(cpu_set_t), &cpuSet);
[-] 		return result == 0 ? true : err::fail (result);
[+] 		return result == 0 ? true : err::fail(result);
[-] 	getStackSize () const
[+] 	getStackSize() const
[-] 		::pthread_attr_getstacksize (&m_attr, &size);
[+] 		::pthread_attr_getstacksize(&m_attr, &size);
[-] 	setStackSize (size_t size)
[+] 	setStackSize(size_t size)
[-] 		int result = ::pthread_attr_setstacksize (&m_attr, size);
[+] 		int result = ::pthread_attr_setstacksize(&m_attr, size);
[-] 		return result == 0 ? true : err::fail (result);
[+] 		return result == 0 ? true : err::fail(result);
[-] ThreadFunc (void* context);
[+] ThreadFunc(void* context);
[-] 	Thread ()
[+] 	Thread()
[-] 	~Thread ()
[+] 	~Thread()
[-] 		detach ();
[+] 		detach();
[-] 	operator pthread_t ()
[+] 	operator pthread_t()
[-] 	isOpen ()
[+] 	isOpen()
[-] 	create (
[+] 	create(
[-] 	create (
[+] 	create(
[-] 		return create (NULL, threadFunc, context);
[+] 		return create(NULL, threadFunc, context);
[-] 	cancel ()
[+] 	cancel()
[-] 		int result = ::pthread_cancel (m_threadId);
[+] 		int result = ::pthread_cancel(m_threadId);
[-] 		return result != 0 ? true : err::fail (result);
[+] 		return result != 0 ? true : err::fail(result);
[-] 	join (void** retVal = NULL);
[+] 	join(void** retVal = NULL);
[-] 	tryJoin (void** retVal = NULL);
[+] 	tryJoin(void** retVal = NULL);
[-] 	join (
[+] 	join(
[-] 	detach ();
[+] 	detach();
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_AccessToken.h
----------------------
[-] 	openProcessToken (
[+] 	openProcessToken(
[-] 	openProcessToken (dword_t access = TOKEN_ALL_ACCESS)
[+] 	openProcessToken(dword_t access = TOKEN_ALL_ACCESS)
[-] 		return openProcessToken (::GetCurrentProcess (), access);
[+] 		return openProcessToken(::GetCurrentProcess(), access);
[-] 	openThreadToken (
[+] 	openThreadToken(
[-] 	openThreadToken (
[+] 	openThreadToken(
[-] 		return openThreadToken (::GetCurrentThread (), access);
[+] 		return openThreadToken(::GetCurrentThread(), access);
[-] 	getTokenInformation (
[+] 	getTokenInformation(
[-] 		bool_t result = ::GetTokenInformation (m_h, infoClass, p, size, actualSize);
[+] 		bool_t result = ::GetTokenInformation(m_h, infoClass, p, size, actualSize);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	getTokenInformation (
[+] 	getTokenInformation(
[-] 		sl::Array <char>* buffer
[+] 		sl::Array<char>* buffer
[-] 	sl::Array <char>
[+] 	sl::Array<char>
[-] 	getTokenInformation (TOKEN_INFORMATION_CLASS infoClass)
[+] 	getTokenInformation(TOKEN_INFORMATION_CLASS infoClass)
[-] 		sl::Array <char> buffer;
[+] 		sl::Array<char> buffer;
[-] 		getTokenInformation (infoClass, &buffer);
[+] 		getTokenInformation(infoClass, &buffer);
[-] 	setTokenInformation (
[+] 	setTokenInformation(
[-] 		bool_t result = ::SetTokenInformation (m_h, infoClass, p, size);
[+] 		bool_t result = ::SetTokenInformation(m_h, infoClass, p, size);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	isMemberOf (PSID group);
[+] 	isMemberOf(PSID group);
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_Bstr.h
----------------------
[-] 		::SysFreeString (h);
[+] 		::SysFreeString(h);
[-] class Bstr: public sl::Handle <BSTR, FreeBstr>
[+] class Bstr: public sl::Handle<BSTR, FreeBstr>
[-] 	Bstr ()
[+] 	Bstr()
[-] 	Bstr (const Bstr& src)
[+] 	Bstr(const Bstr& src)
[-] 		copy (src.m_h);
[+] 		copy(src.m_h);
[-] 	Bstr (const sl::StringRef& string)
[+] 	Bstr(const sl::StringRef& string)
[-] 		copy (string);
[+] 		copy(string);
[-] 	Bstr (const sl::StringRef_w& string)
[+] 	Bstr(const sl::StringRef_w& string)
[-] 		copy (string);
[+] 		copy(string);
[-] 		copy (src.m_h);
[+] 		copy(src.m_h);
[-] 		copy (string);
[+] 		copy(string);
[-] 		copy (string);
[+] 		copy(string);
[-] 	getLength () const
[+] 	getLength() const
[-] 		return ::SysStringLen (m_h);
[+] 		return ::SysStringLen(m_h);
[-] 	getByteLength () const
[+] 	getByteLength() const
[-] 		return ::SysStringByteLen (m_h);
[+] 		return ::SysStringByteLen(m_h);
[-] 	copy (
[+] 	copy(
[-] 	copy (const sl::StringRef& string)
[+] 	copy(const sl::StringRef& string)
[-] 		return copy (sl::String_w (string));
[+] 		return copy(sl::String_w(string));
[-] 	copy (const sl::StringRef_w& string)
[+] 	copy(const sl::StringRef_w& string)
[-] 		return copy ((BSTR) string.cp (), string.getLength ());
[+] 		return copy((BSTR)string.cp(), string.getLength());
[-] createBstrFromString (
[+] createBstrFromString(
[-] 	const sl::StringRefBase <T>& string
[+] 	const sl::StringRefBase<T>& string
[-] 	ASSERT (p);
[+] 	ASSERT(p);
[-] 	bool result = bstr.copy (string);
[+] 	bool result = bstr.copy(string);
[-] 	*p = bstr.detach ();
[+] 	*p = bstr.detach();
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_CriticalSection.h
----------------------
[-] 	CriticalSection ()
[+] 	CriticalSection()
[-] 		::InitializeCriticalSection (this);
[+] 		::InitializeCriticalSection(this);
[-] 	~CriticalSection ()
[+] 	~CriticalSection()
[-] 		::DeleteCriticalSection (this);
[+] 		::DeleteCriticalSection(this);
[-] 	enter ()
[+] 	enter()
[-] 		::EnterCriticalSection (this);
[+] 		::EnterCriticalSection(this);
[-] 	leave ()
[+] 	leave()
[-] 		::LeaveCriticalSection (this);
[+] 		::LeaveCriticalSection(this);
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_DeviceInfo.h
----------------------
[-] AXL_SELECT_ANY SP_DEVINFO_DATA g_nullDevInfoData = { sizeof (SP_DEVINFO_DATA) };
[+] AXL_SELECT_ANY SP_DEVINFO_DATA g_nullDevInfoData = { sizeof(SP_DEVINFO_DATA) };
[-] 	DeviceInfo ()
[+] 	DeviceInfo()
[-] 	DeviceInfo (
[+] 	DeviceInfo(
[-] 	getDevInfoSet ()
[+] 	getDevInfoSet()
[-] 	getDevInfoData ()
[+] 	getDevInfoData()
[-] 	getDeviceRegistryProperty (
[+] 	getDeviceRegistryProperty(
[-] 		bool_t result = ::SetupDiGetDeviceRegistryPropertyW (m_devInfoSet, &m_devInfoData, propId, NULL, (byte_t*) buffer, (dword_t) size, requiredSize);
[+] 		bool_t result = ::SetupDiGetDeviceRegistryPropertyW(m_devInfoSet, &m_devInfoData, propId, NULL, (byte_t*)buffer, (dword_t)size, requiredSize);
[-] 		return err::complete (result != 0);
[+] 		return err::complete(result != 0);
[-] 	getDeviceRegistryProperty (
[+] 	getDeviceRegistryProperty(
[-] 		sl::Array <char>* buffer
[+] 		sl::Array<char>* buffer
[-] 	getDeviceRegistryProperty (
[+] 	getDeviceRegistryProperty(
[-] 	getDeviceRegistryProperty (
[+] 	getDeviceRegistryProperty(
[-] 	setDeviceRegistryProperty (
[+] 	setDeviceRegistryProperty(
[-] 		bool_t result = ::SetupDiSetDeviceRegistryPropertyW (m_devInfoSet, &m_devInfoData, propId, (const byte_t*) buffer, (dword_t) size);
[+] 		bool_t result = ::SetupDiSetDeviceRegistryPropertyW(m_devInfoSet, &m_devInfoData, propId, (const byte_t*) buffer, (dword_t)size);
[-] 		return err::complete (result != 0);
[+] 		return err::complete(result != 0);
[-] 	openDeviceRegistryKey (REGSAM keyAccess); // KEY_ALL_ACCESS, KEY_QUERY_VALUE, KEY_SET_VALUE etc
[+] 	openDeviceRegistryKey(REGSAM keyAccess); // KEY_ALL_ACCESS, KEY_QUERY_VALUE, KEY_SET_VALUE etc
[-] 	getDeviceInstallParams (SP_DEVINSTALL_PARAMS_W* params)
[+] 	getDeviceInstallParams(SP_DEVINSTALL_PARAMS_W* params)
[-] 		bool_t result = ::SetupDiGetDeviceInstallParamsW (m_devInfoSet, &m_devInfoData, params);
[+] 		bool_t result = ::SetupDiGetDeviceInstallParamsW(m_devInfoSet, &m_devInfoData, params);
[-] 		return err::complete (result != 0);
[+] 		return err::complete(result != 0);
[-] 	setDeviceInstallParams (const SP_DEVINSTALL_PARAMS_W* params)
[+] 	setDeviceInstallParams(const SP_DEVINSTALL_PARAMS_W* params)
[-] 		bool_t result = ::SetupDiSetDeviceInstallParamsW (m_devInfoSet, &m_devInfoData, (SP_DEVINSTALL_PARAMS_W*) params);
[+] 		bool_t result = ::SetupDiSetDeviceInstallParamsW(m_devInfoSet, &m_devInfoData, (SP_DEVINSTALL_PARAMS_W*)params);
[-] 		return err::complete (result != 0);
[+] 		return err::complete(result != 0);
[-] 	getClassInstallParams (
[+] 	getClassInstallParams(
[-] 		bool_t result = ::SetupDiGetClassInstallParamsW (m_devInfoSet, &m_devInfoData, (SP_CLASSINSTALL_HEADER*) buffer, (dword_t) size, requiredSize);
[+] 		bool_t result = ::SetupDiGetClassInstallParamsW(m_devInfoSet, &m_devInfoData, (SP_CLASSINSTALL_HEADER*)buffer, (dword_t)size, requiredSize);
[-] 		return err::complete (result != 0);
[+] 		return err::complete(result != 0);
[-] 	getClassInstallParams (sl::Array <char>* buffer);
[+] 	getClassInstallParams(sl::Array<char>* buffer);
[-] 	setClassInstallParams (
[+] 	setClassInstallParams(
[-] 		bool_t result = ::SetupDiSetClassInstallParamsW (m_devInfoSet, &m_devInfoData, (SP_CLASSINSTALL_HEADER*) params, size);
[+] 		bool_t result = ::SetupDiSetClassInstallParamsW(m_devInfoSet, &m_devInfoData, (SP_CLASSINSTALL_HEADER*)params, size);
[-] 		return err::complete (result != 0);
[+] 		return err::complete(result != 0);
[-] 	callClassInstaller (DI_FUNCTION function)
[+] 	callClassInstaller(DI_FUNCTION function)
[-] 		bool_t result = ::SetupDiCallClassInstaller (function, m_devInfoSet, &m_devInfoData);
[+] 		bool_t result = ::SetupDiCallClassInstaller(function, m_devInfoSet, &m_devInfoData);
[-] 		return err::complete (result != 0);
[+] 		return err::complete(result != 0);
[-] 	restartDevice (bool* isRebootRequired);
[+] 	restartDevice(bool* isRebootRequired);
[-] 		::SetupDiDestroyDeviceInfoList (h);
[+] 		::SetupDiDestroyDeviceInfoList(h);
[-] class DeviceInfoSet: public sl::Handle <HDEVINFO, DestroyDeviceInfoSet, sl::MinusOne <HDEVINFO> >
[+] class DeviceInfoSet: public sl::Handle<HDEVINFO, DestroyDeviceInfoSet, sl::MinusOne<HDEVINFO> >
[-] 	create (uint_t flags = DIGCF_PRESENT);
[+] 	create(uint_t flags = DIGCF_PRESENT);
[-] 	create (
[+] 	create(
[-] 	create (
[+] 	create(
[-] 	getDeviceInfo (
[+] 	getDeviceInfo(
[-] 	getDeviceClassGuids (
[+] 	getDeviceClassGuids(
[-] 		bool_t result = ::SetupDiClassGuidsFromNameW (name.sz (), buffer, (dword_t) count, requiredCount);
[+] 		bool_t result = ::SetupDiClassGuidsFromNameW(name.sz(), buffer, (dword_t)count, requiredCount);
[-] 		return err::complete (result != 0);
[+] 		return err::complete(result != 0);
[-] 	getDeviceClassGuids (
[+] 	getDeviceClassGuids(
[-] 		sl::Array <GUID>* buffer
[+] 		sl::Array<GUID>* buffer
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_Event.h
----------------------
[-] 	create (
[+] 	create(
[-] 		close ();
[+] 		close();
[-] 		m_h = ::CreateEventW (secAttr, isManualReset, isSignalled, name.szn ());
[+] 		m_h = ::CreateEventW(secAttr, isManualReset, isSignalled, name.szn());
[-] 		return err::complete (m_h != NULL);
[+] 		return err::complete(m_h != NULL);
[-] 	open (
[+] 	open(
[-] 		close ();
[+] 		close();
[-] 		m_h = ::OpenEventW (access, doInheritHandle, name.szn ());
[+] 		m_h = ::OpenEventW(access, doInheritHandle, name.szn());
[-] 		return err::complete (m_h != NULL);
[+] 		return err::complete(m_h != NULL);
[-] 	signal ()
[+] 	signal()
[-] 		bool_t result = ::SetEvent (m_h);
[+] 		bool_t result = ::SetEvent(m_h);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	reset ()
[+] 	reset()
[-] 		bool_t result = ::ResetEvent (m_h);
[+] 		bool_t result = ::ResetEvent(m_h);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	pulse ()
[+] 	pulse()
[-] 		bool_t result = ::PulseEvent (m_h);
[+] 		bool_t result = ::PulseEvent(m_h);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_Handle.h
----------------------
[-] 		::CloseHandle (h);
[+] 		::CloseHandle(h);
[-] typedef sl::Handle <HANDLE, CloseHandle> Handle;
[+] typedef sl::Handle<HANDLE, CloseHandle> Handle;
[-] 		::RegCloseKey (h);
[+] 		::RegCloseKey(h);
[-] typedef sl::Handle <HKEY, CloseRegKey, sl::MinusOne <HKEY> > RegKeyHandle;
[+] typedef sl::Handle<HKEY, CloseRegKey, sl::MinusOne<HKEY> > RegKeyHandle;
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_JobObject.h
----------------------
[-] class JobObject: public sl::Handle <HANDLE, CloseHandle, sl::Zero <HANDLE> >
[+] class JobObject: public sl::Handle<HANDLE, CloseHandle, sl::Zero<HANDLE> >
[-] 	create (
[+] 	create(
[-] 		close ();
[+] 		close();
[-] 		m_h = ::CreateJobObjectW (secAttr, name.szn ());
[+] 		m_h = ::CreateJobObjectW(secAttr, name.szn());
[-] 		return err::complete (m_h != NULL);
[+] 		return err::complete(m_h != NULL);
[-] 	open (
[+] 	open(
[-] 		close ();
[+] 		close();
[-] 		m_h = ::OpenJobObjectW (access, doInheritHandle, name.szn ());
[+] 		m_h = ::OpenJobObjectW(access, doInheritHandle, name.szn());
[-] 		return err::complete (m_h != NULL);
[+] 		return err::complete(m_h != NULL);
[-] 	assignProcess (HANDLE process)
[+] 	assignProcess(HANDLE process)
[-] 		bool_t result = ::AssignProcessToJobObject (m_h, process);
[+] 		bool_t result = ::AssignProcessToJobObject(m_h, process);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	setInformation (
[+] 	setInformation(
[-] 		bool_t result = ::SetInformationJobObject (m_h, infoClass, (void*) p,  (dword_t) size);
[+] 		bool_t result = ::SetInformationJobObject(m_h, infoClass, (void*)p,  (dword_t)size);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	queryInformation (
[+] 	queryInformation(
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_Library.h
----------------------
[-] 		::FreeLibrary (h);
[+] 		::FreeLibrary(h);
[-] class Library: public sl::Handle <HMODULE, FreeLibrary>
[+] class Library: public sl::Handle<HMODULE, FreeLibrary>
[-] 	loadLibrary (const sl::StringRef_w& fileName);
[+] 	loadLibrary(const sl::StringRef_w& fileName);
[-] 	getProcAddress (const sl::StringRef& name)
[+] 	getProcAddress(const sl::StringRef& name)
[-] 		void* p = ::GetProcAddress (m_h, name.sz ());
[+] 		void* p = ::GetProcAddress(m_h, name.sz());
[-] 		return err::complete <void*> (p, NULL);
[+] 		return err::complete<void*> (p, NULL);
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_NtDll.h
----------------------
[-] 	WCHAR FileName [1];
[+] 	WCHAR FileName[1];
[-] 	WCHAR NameBuffer [1];
[+] 	WCHAR NameBuffer[1];
[-] NtQueryDirectoryFileFunc (
[+] NtQueryDirectoryFileFunc(
[-] NtOpenDirectoryObjectFunc (
[+] NtOpenDirectoryObjectFunc(
[-] NtQueryDirectoryObjectFunc (
[+] NtQueryDirectoryObjectFunc(
[-] NtOpenSymbolicLinkObjectFunc (
[+] NtOpenSymbolicLinkObjectFunc(
[-] NtQuerySymbolicLinkObjectFunc (
[+] NtQuerySymbolicLinkObjectFunc(
[-] NtQueryInformationFileFunc (
[+] NtQueryInformationFileFunc(
[-] NtQueryObjectFunc (
[+] NtQueryObjectFunc(
[-] initNtDllFunctions ();
[+] initNtDllFunctions();
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_NtStatus.h
----------------------
[-] AXL_SL_DEFINE_GUID (
[+] AXL_SL_DEFINE_GUID(
[-] 	getErrorDescription (long status);
[+] 	getErrorDescription(long status);
[-] 	getErrorDescription (const err::ErrorRef& error)
[+] 	getErrorDescription(const err::ErrorRef& error)
[-] 		return getErrorDescription (error->m_code);
[+] 		return getErrorDescription(error->m_code);
[-] 	NtStatus ()
[+] 	NtStatus()
[-] 	NtStatus (long status)
[+] 	NtStatus(long status)
[-] 		create (status);
[+] 		create(status);
[-] 	create (long status);
[+] 	create(long status);
[-] setNtStatus (long status)
[+] setNtStatus(long status)
[-] 	return setError (NtStatus (status));
[+] 	return setError(NtStatus(status));
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_PerfCounter.h
----------------------
[-] 	PerfCounter ()
[+] 	PerfCounter()
[-] 		start ();
[+] 		start();
[-] 	start ()
[+] 	start()
[-] 			::QueryPerformanceFrequency (&m_frequency) &&
[+] 			::QueryPerformanceFrequency(&m_frequency) &&
[-] 			::QueryPerformanceCounter (&m_startTime);
[+] 			::QueryPerformanceCounter(&m_startTime);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	getElapsedTime ()
[+] 	getElapsedTime()
[-] 		::QueryPerformanceCounter (&time);
[+] 		::QueryPerformanceCounter(&time);
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_Process.h
----------------------
[-] 	createProcess (
[+] 	createProcess(
[-] 	createProcess (
[+] 	createProcess(
[-] 		return createProcess (
[+] 		return createProcess(
[-] 	getProcessId ()
[+] 	getProcessId()
[-] 		dword_t id = ::GetProcessId (m_h);
[+] 		dword_t id = ::GetProcessId(m_h);
[-] 		return err::complete <dword_t> (id, -1);
[+] 		return err::complete<dword_t> (id, -1);
[-] 	getExitCode (dword_t* exitCode)
[+] 	getExitCode(dword_t* exitCode)
[-] 		bool_t result = ::GetExitCodeProcess (m_h, exitCode);
[+] 		bool_t result = ::GetExitCodeProcess(m_h, exitCode);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] syncExec (
[+] syncExec(
[-] 	sl::Array <char>* output,
[+] 	sl::Array<char>* output,
----------------------
27/02/2019 18:01:45 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_Semaphore.h
----------------------
[-] 	create (
[+] 	create(
[-] 		close ();
[+] 		close();
[-] 		m_h = ::CreateSemaphore (secAttr, initialCount, maxCount, name.sz ());
[+] 		m_h = ::CreateSemaphore(secAttr, initialCount, maxCount, name.sz());
[-] 		return err::complete (m_h != NULL);
[+] 		return err::complete(m_h != NULL);
[-] 	open (
[+] 	open(
[-] 		close ();
[+] 		close();
[-] 		m_h = ::OpenSemaphore (access, doInheritHandle, name.sz ());
[+] 		m_h = ::OpenSemaphore(access, doInheritHandle, name.sz());
[-] 		return err::complete (m_h != NULL);
[+] 		return err::complete(m_h != NULL);
[-] 	signal (uint_t count = 1)
[+] 	signal(uint_t count = 1)
[-] 		bool_t result = ::ReleaseSemaphore (m_h, count, NULL);
[+] 		bool_t result = ::ReleaseSemaphore(m_h, count, NULL);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_Service.h
----------------------
[-] 		::CloseServiceHandle (h);
[+] 		::CloseServiceHandle(h);
[-] typedef sl::Handle <SC_HANDLE, CloseServiceHandle> ServiceHandle;
[+] typedef sl::Handle<SC_HANDLE, CloseServiceHandle> ServiceHandle;
[-] 	start (
[+] 	start(
[-] 		const wchar_t* argv [],
[+] 		const wchar_t* argv[],
[-] 		bool_t result = ::StartServiceW (m_h, argc, argv);
[+] 		bool_t result = ::StartServiceW(m_h, argc, argv);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	start ()
[+] 	start()
[-] 		return start (NULL, 0);
[+] 		return start(NULL, 0);
[-] 	stop ()
[+] 	stop()
[-] 		return control (SERVICE_CONTROL_STOP, &serviceStatus);
[+] 		return control(SERVICE_CONTROL_STOP, &serviceStatus);
[-] 	control (
[+] 	control(
[-] 		bool_t result = ::ControlService (m_h, code, serviceStatus);
[+] 		bool_t result = ::ControlService(m_h, code, serviceStatus);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	remove ()
[+] 	remove()
[-] 		bool_t result = ::DeleteService (m_h);
[+] 		bool_t result = ::DeleteService(m_h);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	setServiceType (dword_t serviceType)
[+] 	setServiceType(dword_t serviceType)
[-] 		return changeServiceConfig (serviceType, SERVICE_NO_CHANGE, SERVICE_NO_CHANGE);
[+] 		return changeServiceConfig(serviceType, SERVICE_NO_CHANGE, SERVICE_NO_CHANGE);
[-] 	setStartType (dword_t startType)
[+] 	setStartType(dword_t startType)
[-] 		return changeServiceConfig (SERVICE_NO_CHANGE, startType, SERVICE_NO_CHANGE);
[+] 		return changeServiceConfig(SERVICE_NO_CHANGE, startType, SERVICE_NO_CHANGE);
[-] 	setErrorControl (dword_t errorControl)
[+] 	setErrorControl(dword_t errorControl)
[-] 		return changeServiceConfig (SERVICE_NO_CHANGE, SERVICE_NO_CHANGE, errorControl);
[+] 		return changeServiceConfig(SERVICE_NO_CHANGE, SERVICE_NO_CHANGE, errorControl);
[-] 	setDescription (const sl::StringRef_w& description);
[+] 	setDescription(const sl::StringRef_w& description);
[-] 	queryServiceStatus (SERVICE_STATUS* serviceStatus)
[+] 	queryServiceStatus(SERVICE_STATUS* serviceStatus)
[-] 		bool_t result = ::QueryServiceStatus (m_h, serviceStatus);
[+] 		bool_t result = ::QueryServiceStatus(m_h, serviceStatus);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	changeServiceConfig (
[+] 	changeServiceConfig(
[-] 		bool_t result = ::ChangeServiceConfigW (
[+] 		bool_t result = ::ChangeServiceConfigW(
[-] 			binaryFilePath.szn (),
[+] 			binaryFilePath.szn(),
[-] 			loadOrderGroup.szn (),
[+] 			loadOrderGroup.szn(),
[-] 			dependencies.szn (),
[+] 			dependencies.szn(),
[-] 			serviceStartName.szn (),
[+] 			serviceStartName.szn(),
[-] 			password.szn (),
[+] 			password.szn(),
[-] 			displayName.szn ()
[+] 			displayName.szn()
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	changeServiceConfig2 (
[+] 	changeServiceConfig2(
[-] 		bool_t result = ::ChangeServiceConfig2W (m_h, infoLevel, (void*) info);
[+] 		bool_t result = ::ChangeServiceConfig2W(m_h, infoLevel, (void*)info);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_ServiceMgr.h
----------------------
[-] 	open (
[+] 	open(
[-] 	createService (
[+] 	createService(
[-] 	openService (
[+] 	openService(
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_Sid.h
----------------------
[-] 		return ::GetLengthSid ((PSID) sid);
[+] 		return ::GetLengthSid((PSID)sid);
[-] class Sid: public ref::Buf <SID, SizeOfSid>
[+] class Sid: public ref::Buf<SID, SizeOfSid>
[-] 	Sid ()
[+] 	Sid()
[-] 	Sid (const SID* sid)
[+] 	Sid(const SID* sid)
[-] 		copy (sid);
[+] 		copy(sid);
[-] 	Sid (
[+] 	Sid(
[-] 		AXL_VA_DECL (va, subAuthorityCount);
[+] 		AXL_VA_DECL(va, subAuthorityCount);
[-] 		create_va (identifierAuthority, subAuthorityCount, va);
[+] 		create_va(identifierAuthority, subAuthorityCount, va);
[-] 		copy (src);
[+] 		copy(src);
[-] 		copy (sid);
[+] 		copy(sid);
[-] 	create (
[+] 	create(
[-] 		AXL_VA_DECL (va, subAuthorityCount);
[+] 		AXL_VA_DECL(va, subAuthorityCount);
[-] 		return create_va (identifierAuthority, subAuthorityCount, va);
[+] 		return create_va(identifierAuthority, subAuthorityCount, va);
[-] 	create_va (
[+] 	create_va(
[-] 	parse (const sl::StringRef& string);
[+] 	parse(const sl::StringRef& string);
[-] 	parse (const sl::StringRef_w& string);
[+] 	parse(const sl::StringRef_w& string);
[-] 	getString (sl::String* string) const;
[+] 	getString(sl::String* string) const;
[-] 	getString () const
[+] 	getString() const
[-] 		getString (&string);
[+] 		getString(&string);
[-] 	lookupAccountName (
[+] 	lookupAccountName(
[-] 	lookupAccountName (
[+] 	lookupAccountName(
[-] 	lookupAccountName (
[+] 	lookupAccountName(
[-] 		return lookupAccountName (NULL, accountName, sidType);
[+] 		return lookupAccountName(NULL, accountName, sidType);
[-] 	lookupAccountName (
[+] 	lookupAccountName(
[-] 		return lookupAccountName (NULL, accountName, sidType);
[+] 		return lookupAccountName(NULL, accountName, sidType);
[-] 	lookupAccountSid (
[+] 	lookupAccountSid(
[-] 		return lookupAccountSid (systemName, m_p, accountName, sidType);
[+] 		return lookupAccountSid(systemName, m_p, accountName, sidType);
[-] 	lookupAccountSid (
[+] 	lookupAccountSid(
[-] 		return lookupAccountSid (NULL, m_p, accountName, sidType);
[+] 		return lookupAccountSid(NULL, m_p, accountName, sidType);
[-] 	lookupAccountSid (
[+] 	lookupAccountSid(
[-] 		lookupAccountSid (systemName, m_p, &accountName, sidType);
[+] 		lookupAccountSid(systemName, m_p, &accountName, sidType);
[-] 	lookupAccountSid (SID_NAME_USE* sidType = NULL)
[+] 	lookupAccountSid(SID_NAME_USE* sidType = NULL)
[-] 		lookupAccountSid (NULL, m_p, &accountName, sidType);
[+] 		lookupAccountSid(NULL, m_p, &accountName, sidType);
[-] 	lookupAccountSid (
[+] 	lookupAccountSid(
[-] 	lookupAccountSid (
[+] 	lookupAccountSid(
[-] 		return lookupAccountSid (NULL, sid, accountName, sidType);
[+] 		return lookupAccountSid(NULL, sid, accountName, sidType);
[-] 	lookupAccountSid (
[+] 	lookupAccountSid(
[-] 		lookupAccountSid (systemName, sid, &accountName, sidType);
[+] 		lookupAccountSid(systemName, sid, &accountName, sidType);
[-] 	lookupAccountSid (
[+] 	lookupAccountSid(
[-] 		return lookupAccountSid (NULL, sid, sidType);
[+] 		return lookupAccountSid(NULL, sid, sidType);
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_Thread.h
----------------------
[-] 	Thread ()
[+] 	Thread()
[-] 	getThreadId ()
[+] 	getThreadId()
[-] 	close ()
[+] 	close()
[-] 		WaitableHandle::close ();
[+] 		WaitableHandle::close();
[-] 	create (
[+] 	create(
[-] 	setPriority (int priority)
[+] 	setPriority(int priority)
[-] 		bool_t result = ::SetThreadPriority (m_h, priority);
[+] 		bool_t result = ::SetThreadPriority(m_h, priority);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	terminate (dword_t exitCode)
[+] 	terminate(dword_t exitCode)
[-] 		bool_t result = ::TerminateThread (m_h, exitCode);
[+] 		bool_t result = ::TerminateThread(m_h, exitCode);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	getExitCode (dword_t* exitCode)
[+] 	getExitCode(dword_t* exitCode)
[-] 		bool_t result = ::GetExitCodeThread (m_h, exitCode);
[+] 		bool_t result = ::GetExitCodeThread(m_h, exitCode);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_VirtualMemory.h
----------------------
[-] 	VirtualMemory ()
[+] 	VirtualMemory()
[-] 	~VirtualMemory ()
[+] 	~VirtualMemory()
[-] 		release ();
[+] 		release();
[-] 	void* p () const
[+] 	void* p() const
[-] 	getSize () const
[+] 	getSize() const
[-] 	alloc (
[+] 	alloc(
[-] 	alloc (
[+] 	alloc(
[-] 		return alloc (NULL, size, allocationFlags, protectionFlags);
[+] 		return alloc(NULL, size, allocationFlags, protectionFlags);
[-] 	commit (
[+] 	commit(
[-] 		void* result = ::VirtualAlloc (p, size, MEM_COMMIT, protectionFlags);
[+] 		void* result = ::VirtualAlloc(p, size, MEM_COMMIT, protectionFlags);
[-] 		return err::complete (result != NULL);
[+] 		return err::complete(result != NULL);
[-] 	commit (uint_t protectionFlags = PAGE_READWRITE)
[+] 	commit(uint_t protectionFlags = PAGE_READWRITE)
[-] 		return commit (m_p, m_size, protectionFlags);
[+] 		return commit(m_p, m_size, protectionFlags);
[-] 	decommit (
[+] 	decommit(
[-] 		bool_t result = ::VirtualFree (p, size, MEM_DECOMMIT);
[+] 		bool_t result = ::VirtualFree(p, size, MEM_DECOMMIT);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	decommit ()
[+] 	decommit()
[-] 		return decommit (m_p, m_size);
[+] 		return decommit(m_p, m_size);
[-] 	release ();
[+] 	release();
[-] 	protect (
[+] 	protect(
[-] 	lock (
[+] 	lock(
[-] 		bool_t result = ::VirtualLock (p, size);
[+] 		bool_t result = ::VirtualLock(p, size);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	lock ()
[+] 	lock()
[-] 		return lock (m_p, m_size);
[+] 		return lock(m_p, m_size);
[-] 	unlock (
[+] 	unlock(
[-] 		bool_t result = ::VirtualUnlock (p, size);
[+] 		bool_t result = ::VirtualUnlock(p, size);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	unlock ()
[+] 	unlock()
[-] 		return unlock (m_p, m_size);
[+] 		return unlock(m_p, m_size);
[-] 	query (
[+] 	query(
[-] 		size_t result = ::VirtualQuery (p, information, sizeof (MEMORY_BASIC_INFORMATION));
[+] 		size_t result = ::VirtualQuery(p, information, sizeof(MEMORY_BASIC_INFORMATION));
[-] 		return err::complete (result != 0);
[+] 		return err::complete(result != 0);
[-] 	query (MEMORY_BASIC_INFORMATION* information)
[+] 	query(MEMORY_BASIC_INFORMATION* information)
[-] 		return query (m_p, information);
[+] 		return query(m_p, information);
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_WaitableHandle.h
----------------------
[-] 	wait (
[+] 	wait(
[-] 		dword_t result = ::WaitForSingleObjectEx (m_h, timeout, isAlertable);
[+] 		dword_t result = ::WaitForSingleObjectEx(m_h, timeout, isAlertable);
[-] 		return completeWait (result);
[+] 		return completeWait(result);
[-] 	multiWait (
[+] 	multiWait(
[-] 		dword_t result = ::WaitForMultipleObjectsEx (count, waitArray, doWaitAll, timeout, isAlertable);
[+] 		dword_t result = ::WaitForMultipleObjectsEx(count, waitArray, doWaitAll, timeout, isAlertable);
[-] 		return completeWait (result);
[+] 		return completeWait(result);
[-] 	completeWait (dword_t result);
[+] 	completeWait(dword_t result);
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_WaitableTimer.h
----------------------
[-] 	create (
[+] 	create(
[-] 		close ();
[+] 		close();
[-] 		m_h = ::CreateWaitableTimerW (secAttr, isManualReset, name);
[+] 		m_h = ::CreateWaitableTimerW(secAttr, isManualReset, name);
[-] 		return err::complete (m_h != NULL);
[+] 		return err::complete(m_h != NULL);
[-] 	open (
[+] 	open(
[-] 		close ();
[+] 		close();
[-] 		m_h = ::OpenWaitableTimerW (access, doInheritHandle, name);
[+] 		m_h = ::OpenWaitableTimerW(access, doInheritHandle, name);
[-] 		return err::complete (m_h != NULL);
[+] 		return err::complete(m_h != NULL);
[-] 	setTimer (
[+] 	setTimer(
[-] 		bool_t result = ::SetWaitableTimer (m_h, (LARGE_INTEGER*) &dueTime, period, completionRoutine, completionContext, resume);
[+] 		bool_t result = ::SetWaitableTimer(m_h, (LARGE_INTEGER*) &dueTime, period, completionRoutine, completionContext, resume);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	setRelativeTimer (
[+] 	setRelativeTimer(
[-] 		return setTimer (dueTime, period, completionRoutine, completionContext, resume);
[+] 		return setTimer(dueTime, period, completionRoutine, completionContext, resume);
[-] 	cancel ()
[+] 	cancel()
[-] 		bool_t result = ::CancelWaitableTimer (m_h);
[+] 		bool_t result = ::CancelWaitableTimer(m_h);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\include\axl_sys_win\axl_sys_win_WinError.h
----------------------
[-] AXL_SL_DEFINE_GUID (
[+] AXL_SL_DEFINE_GUID(
[-] 	getErrorDescription (dword_t code);
[+] 	getErrorDescription(dword_t code);
[-] 	getErrorDescription (const err::ErrorRef& error)
[+] 	getErrorDescription(const err::ErrorRef& error)
[-] 		return getErrorDescription (error->m_code);
[+] 		return getErrorDescription(error->m_code);
[-] 	WinError ()
[+] 	WinError()
[-] 	WinError (dword_t code)
[+] 	WinError(dword_t code)
[-] 		create (code);
[+] 		create(code);
[-] 	create (dword_t code);
[+] 	create(dword_t code);
[-] setWinError (dword_t code)
[+] setWinError(dword_t code)
[-] 	return err::setError (WinError (code));
[+] 	return err::setError(WinError(code));
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\include\axl_xml\axl_xml_ExpatError.h
----------------------
[-] AXL_SL_DEFINE_GUID (
[+] AXL_SL_DEFINE_GUID(
[-] 	getErrorDescription (XML_Error code)
[+] 	getErrorDescription(XML_Error code)
[-] 		const XML_LChar* string = XML_ErrorString (code);
[+] 		const XML_LChar* string = XML_ErrorString(code);
[-] 	getErrorDescription (const err::ErrorRef& error)
[+] 	getErrorDescription(const err::ErrorRef& error)
[-] 		return getErrorDescription ((XML_Error) error->m_code);
[+] 		return getErrorDescription((XML_Error)error->m_code);
[-] registerExpatErrorProvider ()
[+] registerExpatErrorProvider()
[-] 	err::getErrorMgr ()->registerProvider (
[+] 	err::getErrorMgr()->registerProvider(
[-] 		sl::getSimpleSingleton <ExpatErrorProvider> ()
[+] 		sl::getSimpleSingleton<ExpatErrorProvider> ()
[-] 	ExpatError ()
[+] 	ExpatError()
[-] 	ExpatError (XML_Error code)
[+] 	ExpatError(XML_Error code)
[-] 		create (code);
[+] 		create(code);
[-] 	create (XML_Error code);
[+] 	create(XML_Error code);
[-] setExpatError (XML_Error code)
[+] setExpatError(XML_Error code)
[-] 	return setError (ExpatError (code));
[+] 	return setError(ExpatError(code));
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\include\axl_xml\axl_xml_ExpatParser.h
----------------------
[-] 		::XML_ParserFree (h);
[+] 		::XML_ParserFree(h);
[-] class ExpatParserRoot: public sl::Handle <XML_Parser, FreeExpatParser>
[+] class ExpatParserRoot: public sl::Handle<XML_Parser, FreeExpatParser>
[-] 	create (const sl::StringRef& encoding = NULL);
[+] 	create(const sl::StringRef& encoding = NULL);
[-] 	createNs (
[+] 	createNs(
[-] 	createNs (char separator)
[+] 	createNs(char separator)
[-] 		return createNs (NULL, separator);
[+] 		return createNs(NULL, separator);
[-] 	getLastErrorCode () const
[+] 	getLastErrorCode() const
[-] 		return ::XML_GetErrorCode (m_h);
[+] 		return ::XML_GetErrorCode(m_h);
[-] 	getLastError () const
[+] 	getLastError() const
[-] 		XML_Error errorCode = getLastErrorCode ();
[+] 		XML_Error errorCode = getLastErrorCode();
[-] 		return errorCode ? (err::Error) ExpatError (errorCode) : (err::Error) &err::g_noError;
[+] 		return errorCode ? (err::Error)ExpatError(errorCode) : (err::Error) &err::g_noError;
[-] 	getLineNumber () const
[+] 	getLineNumber() const
[-] 		return ::XML_GetCurrentLineNumber (m_h);
[+] 		return ::XML_GetCurrentLineNumber(m_h);
[-] 	getColumnNumber () const
[+] 	getColumnNumber() const
[-] 		return ::XML_GetCurrentColumnNumber (m_h);
[+] 		return ::XML_GetCurrentColumnNumber(m_h);
[-] 	getByteOffset () const
[+] 	getByteOffset() const
[-] 		return ::XML_GetCurrentByteIndex (m_h);
[+] 		return ::XML_GetCurrentByteIndex(m_h);
[-] 	getUserData ()
[+] 	getUserData()
[-] 		return XML_GetUserData (m_h);
[+] 		return XML_GetUserData(m_h);
[-] 	setUserData (void* userData)
[+] 	setUserData(void* userData)
[-] 		::XML_SetUserData (m_h, userData);
[+] 		::XML_SetUserData(m_h, userData);
[-] 	setElementHandler (
[+] 	setElementHandler(
[-] 		::XML_SetElementHandler (m_h, startHandler, endHandler);
[+] 		::XML_SetElementHandler(m_h, startHandler, endHandler);
[-] 	setStartElementHandler (XML_StartElementHandler handler)
[+] 	setStartElementHandler(XML_StartElementHandler handler)
[-] 		::XML_SetStartElementHandler (m_h, handler);
[+] 		::XML_SetStartElementHandler(m_h, handler);
[-] 	setEndElementHandler (XML_EndElementHandler handler)
[+] 	setEndElementHandler(XML_EndElementHandler handler)
[-] 		::XML_SetEndElementHandler (m_h, handler);
[+] 		::XML_SetEndElementHandler(m_h, handler);
[-] 	setCharacterDataHandler (XML_CharacterDataHandler handler)
[+] 	setCharacterDataHandler(XML_CharacterDataHandler handler)
[-] 		::XML_SetCharacterDataHandler (m_h, handler);
[+] 		::XML_SetCharacterDataHandler(m_h, handler);
[-] 	setProcessingInstructionHandler (XML_ProcessingInstructionHandler handler)
[+] 	setProcessingInstructionHandler(XML_ProcessingInstructionHandler handler)
[-] 		::XML_SetProcessingInstructionHandler (m_h, handler);
[+] 		::XML_SetProcessingInstructionHandler(m_h, handler);
[-] 	setCommentHandler (XML_CommentHandler handler)
[+] 	setCommentHandler(XML_CommentHandler handler)
[-] 		::XML_SetCommentHandler (m_h, handler);
[+] 		::XML_SetCommentHandler(m_h, handler);
[-] 	setCdataSectionHandler (
[+] 	setCdataSectionHandler(
[-] 		::XML_SetCdataSectionHandler (m_h, startHandler, endHandler);
[+] 		::XML_SetCdataSectionHandler(m_h, startHandler, endHandler);
[-] 	setStartCdataSectionHandler (XML_StartCdataSectionHandler handler)
[+] 	setStartCdataSectionHandler(XML_StartCdataSectionHandler handler)
[-] 		::XML_SetStartCdataSectionHandler (m_h, handler);
[+] 		::XML_SetStartCdataSectionHandler(m_h, handler);
[-] 	setEndCdataSectionHandler (XML_EndCdataSectionHandler handler)
[+] 	setEndCdataSectionHandler(XML_EndCdataSectionHandler handler)
[-] 		::XML_SetEndCdataSectionHandler (m_h, handler);
[+] 		::XML_SetEndCdataSectionHandler(m_h, handler);
[-] 	setDefaultHandler (XML_DefaultHandler handler)
[+] 	setDefaultHandler(XML_DefaultHandler handler)
[-] 		::XML_SetDefaultHandler (m_h, handler);
[+] 		::XML_SetDefaultHandler(m_h, handler);
[-] 	setDefaultHandlerExpand (XML_DefaultHandler handler)
[+] 	setDefaultHandlerExpand(XML_DefaultHandler handler)
[-] 		::XML_SetDefaultHandlerExpand (m_h, handler);
[+] 		::XML_SetDefaultHandlerExpand(m_h, handler);
[-] 	setDoctypeDeclHandler (
[+] 	setDoctypeDeclHandler(
[-] 		::XML_SetDoctypeDeclHandler (m_h, startHandler, endHandler);
[+] 		::XML_SetDoctypeDeclHandler(m_h, startHandler, endHandler);
[-] 	setStartDoctypeDeclHandler (XML_StartDoctypeDeclHandler handler)
[+] 	setStartDoctypeDeclHandler(XML_StartDoctypeDeclHandler handler)
[-] 		::XML_SetStartDoctypeDeclHandler (m_h, handler);
[+] 		::XML_SetStartDoctypeDeclHandler(m_h, handler);
[-] 	setEndDoctypeDeclHandler (XML_EndDoctypeDeclHandler handler)
[+] 	setEndDoctypeDeclHandler(XML_EndDoctypeDeclHandler handler)
[-] 		::XML_SetEndDoctypeDeclHandler (m_h, handler);
[+] 		::XML_SetEndDoctypeDeclHandler(m_h, handler);
[-] 	setNotationDeclHandler (XML_NotationDeclHandler handler)
[+] 	setNotationDeclHandler(XML_NotationDeclHandler handler)
[-] 		::XML_SetNotationDeclHandler (m_h, handler);
[+] 		::XML_SetNotationDeclHandler(m_h, handler);
[-] 	setNamespaceDeclHandler (
[+] 	setNamespaceDeclHandler(
[-] 		::XML_SetNamespaceDeclHandler (m_h, startHandler, endHandler);
[+] 		::XML_SetNamespaceDeclHandler(m_h, startHandler, endHandler);
[-] 	setStartNamespaceDeclHandler (XML_StartNamespaceDeclHandler handler)
[+] 	setStartNamespaceDeclHandler(XML_StartNamespaceDeclHandler handler)
[-] 		::XML_SetStartNamespaceDeclHandler (m_h, handler);
[+] 		::XML_SetStartNamespaceDeclHandler(m_h, handler);
[-] 	setEndNamespaceDeclHandler (XML_EndNamespaceDeclHandler handler)
[+] 	setEndNamespaceDeclHandler(XML_EndNamespaceDeclHandler handler)
[-] 		::XML_SetEndNamespaceDeclHandler (m_h, handler);
[+] 		::XML_SetEndNamespaceDeclHandler(m_h, handler);
[-] 	setNotStandaloneHandler (XML_NotStandaloneHandler handler)
[+] 	setNotStandaloneHandler(XML_NotStandaloneHandler handler)
[-] 		::XML_SetNotStandaloneHandler (m_h, handler);
[+] 		::XML_SetNotStandaloneHandler(m_h, handler);
[-] 	setUnknownEncodingHandler (XML_UnknownEncodingHandler handler)
[+] 	setUnknownEncodingHandler(XML_UnknownEncodingHandler handler)
[-] 		::XML_SetUnknownEncodingHandler (m_h, handler, getUserData ());
[+] 		::XML_SetUnknownEncodingHandler(m_h, handler, getUserData());
[-] 	parse (
[+] 	parse(
[-] 		XML_Status status = ::XML_Parse (m_h, (const char*) p, size, isFinal);
[+] 		XML_Status status = ::XML_Parse(m_h, (const char*) p, size, isFinal);
[-] 		return complete (status == XML_STATUS_OK, false);
[+] 		return complete(status == XML_STATUS_OK, false);
[-] 	parseBuffer (
[+] 	parseBuffer(
[-] 		XML_Status status = ::XML_ParseBuffer (m_h, size, isFinal);
[+] 		XML_Status status = ::XML_ParseBuffer(m_h, size, isFinal);
[-] 		return complete (status == XML_STATUS_OK, false);
[+] 		return complete(status == XML_STATUS_OK, false);
[-] 	parseFile (
[+] 	parseFile(
[-] 	getBuffer (size_t size)
[+] 	getBuffer(size_t size)
[-] 		void* p = ::XML_GetBuffer (m_h, size);
[+] 		void* p = ::XML_GetBuffer(m_h, size);
[-] 		return complete <void*> (p, NULL);
[+] 		return complete<void*> (p, NULL);
[-] 	complete (
[+] 	complete(
[-] 			err::setError (getLastError ());
[+] 			err::setError(getLastError());
[-] 	ExpatParser ()
[+] 	ExpatParser()
[-] 		create ();
[+] 		create();
[-] 	create (const sl::StringRef& encoding = NULL)
[+] 	create(const sl::StringRef& encoding = NULL)
[-] 		return ExpatParserRoot::create (encoding) && setHandlers ();
[+] 		return ExpatParserRoot::create(encoding) && setHandlers();
[-] 	createNs (
[+] 	createNs(
[-] 		return ExpatParserRoot::createNs (encoding, separator) && setHandlers ();
[+] 		return ExpatParserRoot::createNs(encoding, separator) && setHandlers();
[-] 	createNs (char separator)
[+] 	createNs(char separator)
[-] 		return ExpatParserRoot::createNs (separator) && setHandlers ();
[+] 		return ExpatParserRoot::createNs(separator) && setHandlers();
[-] 	onStartElement (
[+] 	onStartElement(
[-] 	onEndElement (const char* name)
[+] 	onEndElement(const char* name)
[-] 	onCharacterData (
[+] 	onCharacterData(
[-] 	onProcessingInstruction (
[+] 	onProcessingInstruction(
[-] 	onComment (const char* data)
[+] 	onComment(const char* data)
[-] 	onStartCdataSection ()
[+] 	onStartCdataSection()
[-] 	onEndCdataSection ()
[+] 	onEndCdataSection()
[-] 	onDefault (
[+] 	onDefault(
[-] 	onDefaultExpand (
[+] 	onDefaultExpand(
[-] 	onStartDoctypeDecl (
[+] 	onStartDoctypeDecl(
[-] 	onEndDoctypeDecl ()
[+] 	onEndDoctypeDecl()
[-] 	onNotationDecl (
[+] 	onNotationDecl(
[-] 	onStartNamespaceDecl (
[+] 	onStartNamespaceDecl(
[-] 	onEndNamespaceDecl (const char* prefix)
[+] 	onEndNamespaceDecl(const char* prefix)
[-] 	onNotStandalone ()
[+] 	onNotStandalone()
[-] 	onUnknownEncoding (
[+] 	onUnknownEncoding(
[-] 	setHandlers ()
[+] 	setHandlers()
[-] 		setUserData (static_cast <T*> (this));
[+] 		setUserData(static_cast<T*> (this));
[-] 			setStartElementHandler (startElementHandler);
[+] 			setStartElementHandler(startElementHandler);
[-] 			setEndElementHandler (endElementHandler);
[+] 			setEndElementHandler(endElementHandler);
[-] 			setCharacterDataHandler (characterDataHandler);
[+] 			setCharacterDataHandler(characterDataHandler);
[-] 			setProcessingInstructionHandler (processingInstructionHandler);
[+] 			setProcessingInstructionHandler(processingInstructionHandler);
[-] 			setCommentHandler (commentHandler);
[+] 			setCommentHandler(commentHandler);
[-] 			setStartCdataSectionHandler (startCdataSectionHandler);
[+] 			setStartCdataSectionHandler(startCdataSectionHandler);
[-] 			setEndCdataSectionHandler (endCdataSectionHandler);
[+] 			setEndCdataSectionHandler(endCdataSectionHandler);
[-] 			setDefaultHandler (defaultHandler);
[+] 			setDefaultHandler(defaultHandler);
[-] 			setDefaultHandlerExpand (defaultHandlerExpand);
[+] 			setDefaultHandlerExpand(defaultHandlerExpand);
[-] 			setStartDoctypeDeclHandler (startDoctypeDeclHandler);
[+] 			setStartDoctypeDeclHandler(startDoctypeDeclHandler);
[-] 			setEndDoctypeDeclHandler (endDoctypeDeclHandler);
[+] 			setEndDoctypeDeclHandler(endDoctypeDeclHandler);
[-] 			setNotationDeclHandler (notationDeclHandler);
[+] 			setNotationDeclHandler(notationDeclHandler);
[-] 			setStartNamespaceDeclHandler (startNamespaceDeclHandler);
[+] 			setStartNamespaceDeclHandler(startNamespaceDeclHandler);
[-] 			setEndNamespaceDeclHandler (endNamespaceDeclHandler);
[+] 			setEndNamespaceDeclHandler(endNamespaceDeclHandler);
[-] 			setNotStandaloneHandler (notStandaloneHandler);
[+] 			setNotStandaloneHandler(notStandaloneHandler);
[-] 			setUnknownEncodingHandler (unknownEncodingHandler);
[+] 			setUnknownEncodingHandler(unknownEncodingHandler);
[-] 	startElementHandler (
[+] 	startElementHandler(
[-] 		((T*) userData)->onStartElement (name, attributes);
[+] 		((T*)userData)->onStartElement(name, attributes);
[-] 	endElementHandler (
[+] 	endElementHandler(
[-] 		((T*) userData)->onEndElement (name);
[+] 		((T*)userData)->onEndElement(name);
[-] 	characterDataHandler (
[+] 	characterDataHandler(
[-] 		((T*) userData)->onCharacterData (string, length);
[+] 		((T*)userData)->onCharacterData(string, length);
[-] 	processingInstructionHandler (
[+] 	processingInstructionHandler(
[-] 		((T*) userData)->onProcessingInstruction (target, data);
[+] 		((T*)userData)->onProcessingInstruction(target, data);
[-] 	commentHandler (
[+] 	commentHandler(
[-] 		((T*) userData)->onComment (data);
[+] 		((T*)userData)->onComment(data);
[-] 	startCdataSectionHandler (void* userData)
[+] 	startCdataSectionHandler(void* userData)
[-] 		((T*) userData)->onStartCdataSection ();
[+] 		((T*)userData)->onStartCdataSection();
[-] 	endCdataSectionHandler (void* userData)
[+] 	endCdataSectionHandler(void* userData)
[-] 		((T*) userData)->onEndCdataSection ();
[+] 		((T*)userData)->onEndCdataSection();
[-] 	defaultHandler (
[+] 	defaultHandler(
[-] 		((T*) userData)->onDefault (string, length);
[+] 		((T*)userData)->onDefault(string, length);
[-] 	defaultHandlerExpand (
[+] 	defaultHandlerExpand(
[-] 		((T*) userData)->onDefaultExpand (string, length);
[+] 		((T*)userData)->onDefaultExpand(string, length);
[-] 	startDoctypeDeclHandler (
[+] 	startDoctypeDeclHandler(
[-] 		((T*) userData)->onStartDoctypeDecl (doctypeName, systemId, publicId, hasInternalSubset != 0);
[+] 		((T*)userData)->onStartDoctypeDecl(doctypeName, systemId, publicId, hasInternalSubset != 0);
[-] 	endDoctypeDeclHandler (void* userData)
[+] 	endDoctypeDeclHandler(void* userData)
[-] 		((T*) userData)->onEndDoctypeDecl ();
[+] 		((T*)userData)->onEndDoctypeDecl();
[-] 	notationDeclHandler (
[+] 	notationDeclHandler(
[-] 		((T*) userData)->onNotationDecl (notationName, base, systemId, publicId);
[+] 		((T*)userData)->onNotationDecl(notationName, base, systemId, publicId);
[-] 	startNamespaceDeclHandler (
[+] 	startNamespaceDeclHandler(
[-] 		((T*) userData)->onStartNamespaceDecl (prefix, uri);
[+] 		((T*)userData)->onStartNamespaceDecl(prefix, uri);
[-] 	endNamespaceDeclHandler (
[+] 	endNamespaceDeclHandler(
[-] 		((T*) userData)->onEndNamespaceDecl (prefix);
[+] 		((T*)userData)->onEndNamespaceDecl(prefix);
[-] 	notStandaloneHandler (void* userData)
[+] 	notStandaloneHandler(void* userData)
[-] 		return ((T*) userData)->onNotStandalone ();
[+] 		return ((T*)userData)->onNotStandalone();
[-] 	unknownEncodingHandler (
[+] 	unknownEncodingHandler(
[-] 		return ((T*) userData)->onUnknownEncoding (name, encoding);
[+] 		return ((T*)userData)->onUnknownEncoding(name, encoding);
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\include\axl_zip\axl_zip_ZipReader.h
----------------------
[-] 	ZipReader ()
[+] 	ZipReader()
[-] 	~ZipReader ()
[+] 	~ZipReader()
[-] 		close ();
[+] 		close();
[-] 	isOpen ()
[+] 	isOpen()
[-] 	close ();
[+] 	close();
[-] 	openFile (const sl::StringRef& fileName);
[+] 	openFile(const sl::StringRef& fileName);
[-] 	openMem (
[+] 	openMem(
[-] 	getFileCount ();
[+] 	getFileCount();
[-] 	getFileName (size_t index);
[+] 	getFileName(size_t index);
[-] 	getFileInfo (
[+] 	getFileInfo(
[-] 	isDirectoryFile (size_t index);
[+] 	isDirectoryFile(size_t index);
[-] 	isFileEncrypted (size_t index);
[+] 	isFileEncrypted(size_t index);
[-] 	extractFileToMem (
[+] 	extractFileToMem(
[-] 	extractFileToMem (
[+] 	extractFileToMem(
[-] 		sl::Array <char>* buffer
[+] 		sl::Array<char>* buffer
[-] 	sl::Array <char>
[+] 	sl::Array<char>
[-] 	extractFileToMem (size_t index)
[+] 	extractFileToMem(size_t index)
[-] 		sl::Array <char> buffer;
[+] 		sl::Array<char> buffer;
[-] 		extractFileToMem (index, &buffer);
[+] 		extractFileToMem(index, &buffer);
[-] 	extractFileToFile (
[+] 	extractFileToFile(
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\src\axl_cf\axl_cf_Dictionary.cpp
----------------------
[-] MutableDictionaryRef::create (CFDictionaryRef src)
[+] MutableDictionaryRef::create(CFDictionaryRef src)
[-] 	CFMutableDictionaryRef newDictionary = ::CFDictionaryCreateMutableCopy (kCFAllocatorDefault, 0, src);
[+] 	CFMutableDictionaryRef newDictionary = ::CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, src);
[-] 		return err::fail (err::SystemErrorCode_InsufficientResources);
[+] 		return err::fail(err::SystemErrorCode_InsufficientResources);
[-] 	this->attach (newDictionary);
[+] 	this->attach(newDictionary);
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\src\axl_cf\axl_cf_Number.cpp
----------------------
[-] NumberRef::create (
[+] NumberRef::create(
[-] 	CFNumberRef newNumber = ::CFNumberCreate (kCFAllocatorDefault, type, p);
[+] 	CFNumberRef newNumber = ::CFNumberCreate(kCFAllocatorDefault, type, p);
[-] 		return err::fail (err::SystemErrorCode_InsufficientResources);
[+] 		return err::fail(err::SystemErrorCode_InsufficientResources);
[-] 	attach (newNumber);
[+] 	attach(newNumber);
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\src\axl_cf\axl_cf_String.cpp
----------------------
[-] StringRef::create (CFStringRef src)
[+] StringRef::create(CFStringRef src)
[-] 	CFStringRef newString = ::CFStringCreateCopy (kCFAllocatorDefault, src);
[+] 	CFStringRef newString = ::CFStringCreateCopy(kCFAllocatorDefault, src);
[-] 		return err::fail (err::SystemErrorCode_InsufficientResources);
[+] 		return err::fail(err::SystemErrorCode_InsufficientResources);
[-] 	attach (newString);
[+] 	attach(newString);
[-] StringRef::create (
[+] StringRef::create(
[-] 		length = strlen_s (p);
[+] 		length = strlen_s(p);
[-] 	CFStringRef newString = ::CFStringCreateWithBytes (
[+] 	CFStringRef newString = ::CFStringCreateWithBytes(
[-] 		return err::fail (err::SystemErrorCode_InsufficientResources);
[+] 		return err::fail(err::SystemErrorCode_InsufficientResources);
[-] 	attach (newString);
[+] 	attach(newString);
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\src\axl_cf\axl_cf_Type.cpp
----------------------
[-] getStringFromCfString (CFStringRef cfString)
[+] getStringFromCfString(CFStringRef cfString)
[-] 	size_t length = ::CFStringGetLength (cfString);
[+] 	size_t length = ::CFStringGetLength(cfString);
[-] 		return sl::String ();
[+] 		return sl::String();
[-] 	::CFStringGetBytes (
[+] 	::CFStringGetBytes(
[-] 		return sl::String ();
[+] 		return sl::String();
[-] 	char* p = string.createBuffer (bufferLength);
[+] 	char* p = string.createBuffer(bufferLength);
[-] 		::CFStringGetBytes (
[+] 		::CFStringGetBytes(
[-] 			(UInt8*) p,
[+] 			(UInt8*)p,
[-] getTypeIdDescription (CFTypeID typeId)
[+] getTypeIdDescription(CFTypeID typeId)
[-] 	CFStringRef p = ::CFCopyTypeIDDescription (typeId);
[+] 	CFStringRef p = ::CFCopyTypeIDDescription(typeId);
[-] 	sl::String string = getStringFromCfString (p);
[+] 	sl::String string = getStringFromCfString(p);
[-] 	::CFRelease (p);
[+] 	::CFRelease(p);
[-] cfTypeToString (
[+] cfTypeToString(
[-] 	CFTypeID typeId = ::CFGetTypeID (cfType);
[+] 	CFTypeID typeId = ::CFGetTypeID(cfType);
[-] 	if (typeId == getStringTypeId ())
[+] 	if (typeId == getStringTypeId())
[-] 		CFStringRef cfString = (CFStringRef) cfType;
[+] 		CFStringRef cfString = (CFStringRef)cfType;
[-] 		return getStringFromCfString (cfString);
[+] 		return getStringFromCfString(cfString);
[-] 	else if (typeId == getBooleanTypeId ())
[+] 	else if (typeId == getBooleanTypeId())
[-] 		CFBooleanRef cfBoolean = (CFBooleanRef) cfType;
[+] 		CFBooleanRef cfBoolean = (CFBooleanRef)cfType;
[-] 		bool b = ::CFBooleanGetValue (cfBoolean);
[+] 		bool b = ::CFBooleanGetValue(cfBoolean);
[-] 	else if (typeId == getNumberTypeId ())
[+] 	else if (typeId == getNumberTypeId())
[-] 		CFNumberRef cfNumber = (CFNumberRef) cfType;
[+] 		CFNumberRef cfNumber = (CFNumberRef)cfType;
[-] 			::CFNumberGetValue (cfNumber, kCFNumberDoubleType, &x);
[+] 			::CFNumberGetValue(cfNumber, kCFNumberDoubleType, &x);
[-] 			return sl::formatString ("%f", x);
[+] 			return sl::formatString("%f", x);
[-] 			::CFNumberGetValue (cfNumber, kCFNumberLongLongType, &x);
[+] 			::CFNumberGetValue(cfNumber, kCFNumberLongLongType, &x);
[-] 			return sl::formatString ("%lld", x);
[+] 			return sl::formatString("%lld", x);
[-] 		CFStringRef cfString = ::CFCopyDescription (cfType);
[+] 		CFStringRef cfString = ::CFCopyDescription(cfType);
[-] 		sl::String string = getStringFromCfString (cfString);
[+] 		sl::String string = getStringFromCfString(cfString);
[-] 		::CFRelease (cfString);
[+] 		::CFRelease(cfString);
[-] 		return getTypeIdDescription (typeId);
[+] 		return getTypeIdDescription(typeId);
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_enc_Base32Encoding.cpp
----------------------
[-] 	Base32Writer (
[+] 	Base32Writer(
[-] 	write (uchar_t x);
[+] 	write(uchar_t x);
[-] 	addPadding ();
[+] 	addPadding();
[-] Base32Writer::Base32Writer (
[+] Base32Writer::Base32Writer(
[-] Base32Writer::write (uchar_t x)
[+] Base32Writer::write(uchar_t x)
[-] 	static const char charTable [] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
[+] 	static const char charTable[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
[-] 		ASSERT (m_p < m_end);
[+] 		ASSERT(m_p < m_end);
[-] 	ASSERT (m_p < m_end);
[+] 	ASSERT(m_p < m_end);
[-] 	*m_p++ = charTable [x & 0x1f];
[+] 	*m_p++ = charTable[x & 0x1f];
[-] Base32Writer::addPadding ()
[+] Base32Writer::addPadding()
[-] 	static const char paddingTable [] = "0189";
[+] 	static const char paddingTable[] = "0189";
[-] 		*m_p++ = paddingTable [rand () % lengthof (paddingTable)];
[+] 		*m_p++ = paddingTable[rand() % lengthof(paddingTable)];
[-] Base32Encoding::encode (
[+] Base32Encoding::encode(
[-] 		string->clear ();
[+] 		string->clear();
[-] 	char* dst = string->createBuffer (length);
[+] 	char* dst = string->createBuffer(length);
[-] 	Base32Writer writer (dst, length, hyphenDistance);
[+] 	Base32Writer writer(dst, length, hyphenDistance);
[-] 		switch (i)
[+] 		switch(i)
[-] 			writer.write (y);
[+] 			writer.write(y);
[-] 			writer.write (x | (y << 4));
[+] 			writer.write(x | (y << 4));
[-] 			writer.write (y >> 1);
[+] 			writer.write(y >> 1);
[-] 			writer.write (x | (y << 3));
[+] 			writer.write(x | (y << 3));
[-] 			writer.write (y >> 2);
[+] 			writer.write(y >> 2);
[-] 			writer.write (x | (y << 2));
[+] 			writer.write(x | (y << 2));
[-] 			writer.write (y >> 3);
[+] 			writer.write(y >> 3);
[-] 			writer.write (x | (y << 1));
[+] 			writer.write(x | (y << 1));
[-] 			ASSERT (false);
[+] 			ASSERT(false);
[-] 		writer.write (x);
[+] 		writer.write(x);
[-] 	writer.addPadding ();
[+] 	writer.addPadding();
[-] Base32Encoding::decode (
[+] Base32Encoding::decode(
[-] 	sl::Array <char>* buffer,
[+] 	sl::Array<char>* buffer,
[-] 	size_t sizeGuess = (string.getLength () * 5) / 8;
[+] 	size_t sizeGuess = (string.getLength() * 5) / 8;
[-] 	buffer->reserve (sizeGuess);
[+] 	buffer->reserve(sizeGuess);
[-] 	buffer->clear ();
[+] 	buffer->clear();
[-] 	const char* p = string.cp ();
[+] 	const char* p = string.cp();
[-] 	const char* end = string.getEnd ();
[+] 	const char* end = string.getEnd();
[-] 			buffer->append (x);
[+] 			buffer->append(x);
[-] 			buffer->append (x);
[+] 			buffer->append(x);
[-] 	return buffer->getCount ();
[+] 	return buffer->getCount();
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_enc_CharCodec.cpp
----------------------
[-] getCharCodec (CharCodecKind codecKind)
[+] getCharCodec(CharCodecKind codecKind)
[-] 	static UtfCodec <Utf8>     utf8Codec;
[+] 	static UtfCodec<Utf8>     utf8Codec;
[-] 	static UtfCodec <Utf16>    utf16Codec;
[+] 	static UtfCodec<Utf16>    utf16Codec;
[-] 	static UtfCodec <Utf16_be> utf16Codec_be;
[+] 	static UtfCodec<Utf16_be> utf16Codec_be;
[-] 	static UtfCodec <Utf32>    utf32Codec;
[+] 	static UtfCodec<Utf32>    utf32Codec;
[-] 	static UtfCodec <Utf32_be> utf32Codec_be;
[+] 	static UtfCodec<Utf32_be> utf32Codec_be;
[-] 	static CharCodec* codecTable [] =
[+] 	static CharCodec* codecTable[] =
[-] 	return (size_t) codecKind < countof (codecTable) ? codecTable [codecKind] : NULL;
[+] 	return (size_t)codecKind < countof(codecTable) ? codecTable[codecKind] : NULL;
[-] CharCodec::encodeFromUtf8 (
[+] CharCodec::encodeFromUtf8(
[-] 	sl::Array <char>* buffer,
[+] 	sl::Array<char>* buffer,
[-] 	buffer->clear ();
[+] 	buffer->clear();
[-] 	bool result = buffer->reserve (length * m_unitSize);
[+] 	bool result = buffer->reserve(length * m_unitSize);
[-] 		char tmpBuffer [256];
[+] 		char tmpBuffer[256];
[-] 		size_t takenBufferSize = encodeFromUtf8 (tmpBuffer, sizeof (tmpBuffer), p, end - p, &takenLength);
[+] 		size_t takenBufferSize = encodeFromUtf8(tmpBuffer, sizeof(tmpBuffer), p, end - p, &takenLength);
[-] 		result = buffer->append (tmpBuffer, takenBufferSize) != -1;
[+] 		result = buffer->append(tmpBuffer, takenBufferSize) != -1;
[-] 	return buffer->getCount ();
[+] 	return buffer->getCount();
[-] CharCodec::encodeFromUtf16 (
[+] CharCodec::encodeFromUtf16(
[-] 	sl::Array <char>* buffer,
[+] 	sl::Array<char>* buffer,
[-] 	buffer->clear ();
[+] 	buffer->clear();
[-] 	bool result = buffer->reserve (length * m_unitSize);
[+] 	bool result = buffer->reserve(length * m_unitSize);
[-] 		char tmpBuffer [256];
[+] 		char tmpBuffer[256];
[-] 		size_t takenBufferSize = encodeFromUtf16 (tmpBuffer, sizeof (tmpBuffer), p, end - p, &takenLength);
[+] 		size_t takenBufferSize = encodeFromUtf16(tmpBuffer, sizeof(tmpBuffer), p, end - p, &takenLength);
[-] 		result = buffer->append (tmpBuffer, takenBufferSize) != -1;
[+] 		result = buffer->append(tmpBuffer, takenBufferSize) != -1;
[-] 	return buffer->getCount ();
[+] 	return buffer->getCount();
[-] CharCodec::encodeFromUtf32 (
[+] CharCodec::encodeFromUtf32(
[-] 	sl::Array <char>* buffer,
[+] 	sl::Array<char>* buffer,
[-] 	buffer->clear ();
[+] 	buffer->clear();
[-] 	bool result = buffer->reserve (length * m_unitSize);
[+] 	bool result = buffer->reserve(length * m_unitSize);
[-] 		char tmpBuffer [256];
[+] 		char tmpBuffer[256];
[-] 		size_t takenBufferSize = encodeFromUtf32 (tmpBuffer, sizeof (tmpBuffer), p, end - p, &takenLength);
[+] 		size_t takenBufferSize = encodeFromUtf32(tmpBuffer, sizeof(tmpBuffer), p, end - p, &takenLength);
[-] 		result = buffer->append (tmpBuffer, takenBufferSize) != -1;
[+] 		result = buffer->append(tmpBuffer, takenBufferSize) != -1;
[-] 	return buffer->getCount ();
[+] 	return buffer->getCount();
[-] sl::Array <char>
[+] sl::Array<char>
[-] CharCodec::encodeFromUtf8 (
[+] CharCodec::encodeFromUtf8(
[-] 	sl::Array <char> buffer;
[+] 	sl::Array<char> buffer;
[-] 	encodeFromUtf8 (&buffer, p, length);
[+] 	encodeFromUtf8(&buffer, p, length);
[-] sl::Array <char>
[+] sl::Array<char>
[-] CharCodec::encodeFromUtf16 (
[+] CharCodec::encodeFromUtf16(
[-] 	sl::Array <char> buffer;
[+] 	sl::Array<char> buffer;
[-] 	encodeFromUtf16 (&buffer, p, length);
[+] 	encodeFromUtf16(&buffer, p, length);
[-] sl::Array <char>
[+] sl::Array<char>
[-] CharCodec::encodeFromUtf32 (
[+] CharCodec::encodeFromUtf32(
[-] 	sl::Array <char> buffer;
[+] 	sl::Array<char> buffer;
[-] 	encodeFromUtf32 (&buffer, p, length);
[+] 	encodeFromUtf32(&buffer, p, length);
[-] CharCodec::decodeToUtf8 (
[+] CharCodec::decodeToUtf8(
[-] 	sl::Array <utf8_t>* buffer,
[+] 	sl::Array<utf8_t>* buffer,
[-] 	buffer->clear ();
[+] 	buffer->clear();
[-] 	bool result = buffer->reserve (length);
[+] 	bool result = buffer->reserve(length);
[-] 		utf8_t tmpBuffer [256];
[+] 		utf8_t tmpBuffer[256];
[-] 		size_t takenBufferLength = decodeToUtf8 (tmpBuffer, countof (tmpBuffer), p, end - p, &takenSize);
[+] 		size_t takenBufferLength = decodeToUtf8(tmpBuffer, countof(tmpBuffer), p, end - p, &takenSize);
[-] 		result = buffer->append (tmpBuffer, takenBufferLength) != -1;
[+] 		result = buffer->append(tmpBuffer, takenBufferLength) != -1;
[-] 	return buffer->getCount ();
[+] 	return buffer->getCount();
[-] CharCodec::decodeToUtf16 (
[+] CharCodec::decodeToUtf16(
[-] 	sl::Array <utf16_t>* buffer,
[+] 	sl::Array<utf16_t>* buffer,
[-] 	buffer->clear ();
[+] 	buffer->clear();
[-] 	bool result = buffer->reserve (length);
[+] 	bool result = buffer->reserve(length);
[-] 		utf16_t tmpBuffer [256];
[+] 		utf16_t tmpBuffer[256];
[-] 		size_t takenBufferLength = decodeToUtf16 (tmpBuffer, countof (tmpBuffer), p, end - p, &takenSize);
[+] 		size_t takenBufferLength = decodeToUtf16(tmpBuffer, countof(tmpBuffer), p, end - p, &takenSize);
[-] 		result = buffer->append (tmpBuffer, takenBufferLength) != -1;
[+] 		result = buffer->append(tmpBuffer, takenBufferLength) != -1;
[-] 	return buffer->getCount ();
[+] 	return buffer->getCount();
[-] CharCodec::decodeToUtf32 (
[+] CharCodec::decodeToUtf32(
[-] 	sl::Array <utf32_t>* buffer,
[+] 	sl::Array<utf32_t>* buffer,
[-] 	buffer->clear ();
[+] 	buffer->clear();
[-] 	bool result = buffer->reserve (length);
[+] 	bool result = buffer->reserve(length);
[-] 		utf32_t tmpBuffer [256];
[+] 		utf32_t tmpBuffer[256];
[-] 		size_t takenBufferLength = decodeToUtf32 (tmpBuffer, countof (tmpBuffer), p, end - p, &takenSize);
[+] 		size_t takenBufferLength = decodeToUtf32(tmpBuffer, countof(tmpBuffer), p, end - p, &takenSize);
[-] 		result = buffer->append (tmpBuffer, takenBufferLength) != -1;
[+] 		result = buffer->append(tmpBuffer, takenBufferLength) != -1;
[-] 	return buffer->getCount ();
[+] 	return buffer->getCount();
[-] sl::Array <utf8_t>
[+] sl::Array<utf8_t>
[-] CharCodec::decodeToUtf8 (
[+] CharCodec::decodeToUtf8(
[-] 	sl::Array <utf8_t> buffer;
[+] 	sl::Array<utf8_t> buffer;
[-] 	decodeToUtf8 (&buffer, p, size);
[+] 	decodeToUtf8(&buffer, p, size);
[-] sl::Array <utf16_t>
[+] sl::Array<utf16_t>
[-] CharCodec::decodeToUtf16 (
[+] CharCodec::decodeToUtf16(
[-] 	sl::Array <utf16_t> buffer;
[+] 	sl::Array<utf16_t> buffer;
[-] 	decodeToUtf16 (&buffer, p, size);
[+] 	decodeToUtf16(&buffer, p, size);
[-] sl::Array <utf32_t>
[+] sl::Array<utf32_t>
[-] CharCodec::decodeToUtf32 (
[+] CharCodec::decodeToUtf32(
[-] 	sl::Array <utf32_t> buffer;
[+] 	sl::Array<utf32_t> buffer;
[-] 	decodeToUtf32 (&buffer, p, size);
[+] 	decodeToUtf32(&buffer, p, size);
[-] CodePointDecoder::loadState (uint32_t state)
[+] CodePointDecoder::loadState(uint32_t state)
[-] 	*((uint32_t*) m_accumulator) = state;
[+] 	*((uint32_t*)m_accumulator) = state;
[-] CodePointDecoder::saveState ()
[+] CodePointDecoder::saveState()
[-] CodePointDecoder::decode (
[+] CodePointDecoder::decode(
[-] 		takenBufferLength = decodeImpl (buffer, bufferLength, p, size, &takenSize);
[+] 		takenBufferLength = decodeImpl(buffer, bufferLength, p, size, &takenSize);
[-] 	ASSERT (m_accumulatorCount < sizeof (m_accumulator));
[+] 	ASSERT(m_accumulatorCount < sizeof(m_accumulator));
[-] 	size_t accumulatorLeftoverSize = sizeof (m_accumulator) - m_accumulatorCount;
[+] 	size_t accumulatorLeftoverSize = sizeof(m_accumulator) - m_accumulatorCount;
[-] 	size_t copySize = AXL_MIN (size, accumulatorLeftoverSize);
[+] 	size_t copySize = AXL_MIN(size, accumulatorLeftoverSize);
[-] 	memcpy (m_accumulator + m_accumulatorCount, p, copySize);
[+] 	memcpy(m_accumulator + m_accumulatorCount, p, copySize);
[-] 	takenBufferLength = m_charCodec->decodeToUtf32 (
[+] 	takenBufferLength = m_charCodec->decodeToUtf32(
[-] 		ASSERT (takenSize == 0);
[+] 		ASSERT(takenSize == 0);
[-] 	ASSERT (takenBufferLength == 1 && takenSize > m_accumulatorCount);
[+] 	ASSERT(takenBufferLength == 1 && takenSize > m_accumulatorCount);
[-] 		takenBufferLength += decodeImpl (
[+] 		takenBufferLength += decodeImpl(
[-] 			(char*) p + takenSize,
[+] 			(char*)p + takenSize,
[-] CodePointDecoder::decode (
[+] CodePointDecoder::decode(
[-] 		takenBufferLength = decodeImpl (cplBuffer, textBuffer, bufferLength, p, size, &takenSize);
[+] 		takenBufferLength = decodeImpl(cplBuffer, textBuffer, bufferLength, p, size, &takenSize);
[-] 	ASSERT (m_accumulatorCount < sizeof (m_accumulator));
[+] 	ASSERT(m_accumulatorCount < sizeof(m_accumulator));
[-] 	size_t accumulatorLeftoverSize = sizeof (m_accumulator) - m_accumulatorCount;
[+] 	size_t accumulatorLeftoverSize = sizeof(m_accumulator) - m_accumulatorCount;
[-] 	size_t copySize = AXL_MIN (size, accumulatorLeftoverSize);
[+] 	size_t copySize = AXL_MIN(size, accumulatorLeftoverSize);
[-] 	memcpy (m_accumulator + m_accumulatorCount, p, copySize);
[+] 	memcpy(m_accumulator + m_accumulatorCount, p, copySize);
[-] 	takenBufferLength = m_charCodec->decodeToUtf32 (
[+] 	takenBufferLength = m_charCodec->decodeToUtf32(
[-] 		ASSERT (takenSize == 0);
[+] 		ASSERT(takenSize == 0);
[-] 	ASSERT (takenBufferLength == 1 && takenSize > m_accumulatorCount);
[+] 	ASSERT(takenBufferLength == 1 && takenSize > m_accumulatorCount);
[-] 		takenBufferLength += decodeImpl (
[+] 		takenBufferLength += decodeImpl(
[-] 			(char*) p + takenSize,
[+] 			(char*)p + takenSize,
[-] CodePointDecoder::decodeImpl (
[+] CodePointDecoder::decodeImpl(
[-] 	ASSERT (takenSize_o);
[+] 	ASSERT(takenSize_o);
[-] 	size_t takenBufferLength = m_charCodec->decodeToUtf32 (
[+] 	size_t takenBufferLength = m_charCodec->decodeToUtf32(
[-] 		ASSERT (size - takenSize < sizeof (m_accumulator));
[+] 		ASSERT(size - takenSize < sizeof(m_accumulator));
[-] 		memcpy (m_accumulator, (char*) p + takenSize, m_accumulatorCount);
[+] 		memcpy(m_accumulator, (char*)p + takenSize, m_accumulatorCount);
[-] CodePointDecoder::decodeImpl (
[+] CodePointDecoder::decodeImpl(
[-] 	ASSERT (takenSize_o);
[+] 	ASSERT(takenSize_o);
[-] 	size_t takenBufferLength = m_charCodec->decodeToUtf32 (
[+] 	size_t takenBufferLength = m_charCodec->decodeToUtf32(
[-] 		ASSERT (size - takenSize < sizeof (m_accumulator));
[+] 		ASSERT(size - takenSize < sizeof(m_accumulator));
[-] 		memcpy (m_accumulator, (char*) p + takenSize, m_accumulatorCount);
[+] 		memcpy(m_accumulator, (char*)p + takenSize, m_accumulatorCount);
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_enc_EscapeEncoding.cpp
----------------------
[-] EscapeEncoding::findEscapeChar (char x)
[+] EscapeEncoding::findEscapeChar(char x)
[-] 	switch (x)
[+] 	switch(x)
[-] EscapeEncoding::findEscapeReplaceChar (char x)
[+] EscapeEncoding::findEscapeReplaceChar(char x)
[-] 	switch (x)
[+] 	switch(x)
[-] EscapeEncoding::encode (
[+] EscapeEncoding::encode(
[-] 	string->clear ();
[+] 	string->clear();
[-] 	string->reserve (source.getLength ());
[+] 	string->reserve(source.getLength());
[-] 	char escapeSequence [4] = { '\\' };
[+] 	char escapeSequence[4] = { '\\' };
[-] 	const char* p = source.cp ();
[+] 	const char* p = source.cp();
[-] 	const char* end = source.getEnd ();
[+] 	const char* end = source.getEnd();
[-] 			string->append (base, p - base);
[+] 			string->append(base, p - base);
[-] 			escapeSequence [1] = '\\';
[+] 			escapeSequence[1] = '\\';
[-] 			string->append (escapeSequence, 2);
[+] 			string->append(escapeSequence, 2);
[-] 			if (isprint (*p))
[+] 			if (isprint(*p))
[-] 			string->append (base, p - base);
[+] 			string->append(base, p - base);
[-] 			char escape = findEscapeChar (*p);
[+] 			char escape = findEscapeChar(*p);
[-] 				escapeSequence [1] = escape;
[+] 				escapeSequence[1] = escape;
[-] 				string->append (escapeSequence, 2);
[+] 				string->append(escapeSequence, 2);
[-] 				escapeSequence [1] = 'x';
[+] 				escapeSequence[1] = 'x';
[-] 				escapeSequence [2] = HexEncoding::getHexChar_l (*p >> 4);
[+] 				escapeSequence[2] = HexEncoding::getHexChar_l(*p >> 4);
[-] 				escapeSequence [3] = HexEncoding::getHexChar_l (*p);
[+] 				escapeSequence[3] = HexEncoding::getHexChar_l(*p);
[-] 				string->append (escapeSequence, 4);
[+] 				string->append(escapeSequence, 4);
[-] 	string->append (base, p - base);
[+] 	string->append(base, p - base);
[-] 	return string->getLength ();
[+] 	return string->getLength();
[-] isHexChar (char c)
[+] isHexChar(char c)
[-] EscapeEncoding::decode (
[+] EscapeEncoding::decode(
[-] 	string->clear ();
[+] 	string->clear();
[-] 	string->reserve (source.getLength () / 2);
[+] 	string->reserve(source.getLength() / 2);
[-] 	char hexCodeString [16];
[+] 	char hexCodeString[16];
[-] 	const char* p = source.cp ();
[+] 	const char* p = source.cp();
[-] 	const char* end = source.getEnd ();
[+] 	const char* end = source.getEnd();
[-] 		switch (state)
[+] 		switch(state)
[-] 				string->append (base, p - base);
[+] 				string->append(base, p - base);
[-] 			switch (*p)
[+] 			switch(*p)
[-] 				replace = findEscapeReplaceChar (*p);
[+] 				replace = findEscapeReplaceChar(*p);
[-] 					string->append (replace, 1);
[+] 					string->append(replace, 1);
[-] 			if (isHexChar (*p))
[+] 			if (isHexChar(*p))
[-] 				hexCodeString [hexCodeLen++] = *p;
[+] 				hexCodeString[hexCodeLen++] = *p;
[-] 				string->append ((char const*) &hexCode, 1);
[+] 				string->append((char const*) &hexCode, 1);
[-] 				hexCodeString [hexCodeLen] = 0;
[+] 				hexCodeString[hexCodeLen] = 0;
[-] 				hexCode = strtoul (hexCodeString, NULL, 16);
[+] 				hexCode = strtoul(hexCodeString, NULL, 16);
[-] 					string->append ((char const*) &hexCode, 1);
[+] 					string->append((char const*) &hexCode, 1);
[-] 					utf8_t buffer [8];
[+] 					utf8_t buffer[8];
[-] 					size_t length = enc::Utf8::getEncodeCodePointLength (hexCode);
[+] 					size_t length = enc::Utf8::getEncodeCodePointLength(hexCode);
[-] 					enc::Utf8::encodeCodePoint (buffer, hexCode);
[+] 					enc::Utf8::encodeCodePoint(buffer, hexCode);
[-] 					string->append (buffer, length);
[+] 					string->append(buffer, length);
[-] 	string->append (base, p - base);
[+] 	string->append(base, p - base);
[-] 	return string->getLength ();
[+] 	return string->getLength();
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_enc_HexEncoding.cpp
----------------------
[-] HexEncoding::encode (
[+] HexEncoding::encode(
[-] 		string->clear ();
[+] 		string->clear();
[-] 		char* dst = string->createBuffer (length);
[+] 		char* dst = string->createBuffer(length);
[-] 			encode_nsu (dst, src, srcEnd);
[+] 			encode_nsu(dst, src, srcEnd);
[-] 			encode_nsl (dst, src, srcEnd);
[+] 			encode_nsl(dst, src, srcEnd);
[-] 		char* dst = string->createBuffer (length);
[+] 		char* dst = string->createBuffer(length);
[-] 			encode_u (dst, src, srcEnd);
[+] 			encode_u(dst, src, srcEnd);
[-] 			encode_l (dst, src, srcEnd);
[+] 			encode_l(dst, src, srcEnd);
[-] HexEncoding::encode_l (
[+] HexEncoding::encode_l(
[-] 	*dst++ = getHexChar_l (x >> 4);
[+] 	*dst++ = getHexChar_l(x >> 4);
[-] 	*dst++ = getHexChar_l (x);
[+] 	*dst++ = getHexChar_l(x);
[-] 		*dst++ = getHexChar_l (x >> 4);
[+] 		*dst++ = getHexChar_l(x >> 4);
[-] 		*dst++ = getHexChar_l (x);
[+] 		*dst++ = getHexChar_l(x);
[-] HexEncoding::encode_u (
[+] HexEncoding::encode_u(
[-] 	*dst++ = getHexChar_u (x >> 4);
[+] 	*dst++ = getHexChar_u(x >> 4);
[-] 	*dst++ = getHexChar_u (x);
[+] 	*dst++ = getHexChar_u(x);
[-] 		*dst++ = getHexChar_u (x >> 4);
[+] 		*dst++ = getHexChar_u(x >> 4);
[-] 		*dst++ = getHexChar_u (x);
[+] 		*dst++ = getHexChar_u(x);
[-] HexEncoding::encode_nsl (
[+] HexEncoding::encode_nsl(
[-] 		*dst++ = getHexChar_l (x >> 4);
[+] 		*dst++ = getHexChar_l(x >> 4);
[-] 		*dst++ = getHexChar_l (x);
[+] 		*dst++ = getHexChar_l(x);
[-] HexEncoding::encode_nsu (
[+] HexEncoding::encode_nsu(
[-] 		*dst++ = getHexChar_u (x >> 4);
[+] 		*dst++ = getHexChar_u(x >> 4);
[-] 		*dst++ = getHexChar_u (x);
[+] 		*dst++ = getHexChar_u(x);
[-] HexEncoding::decode (
[+] HexEncoding::decode(
[-] 	sl::Array <char>* buffer,
[+] 	sl::Array<char>* buffer,
[-] 	buffer->clear ();
[+] 	buffer->clear();
[-] 	buffer->reserve (source.getLength () / 2);
[+] 	buffer->reserve(source.getLength() / 2);
[-] 	char hexCodeString [4] = { 0 };
[+] 	char hexCodeString[4] = { 0 };
[-] 	const char* p = source.cp ();
[+] 	const char* p = source.cp();
[-] 	const char* end = source.getEnd ();
[+] 	const char* end = source.getEnd();
[-] 		bool_t isSpace = isspace (*p);
[+] 		bool_t isSpace = isspace(*p);
[-] 		switch (state)
[+] 		switch(state)
[-] 			hexCodeString [0] = *p;
[+] 			hexCodeString[0] = *p;
[-] 				hexCodeString [hexCodeLen++] = *p;
[+] 				hexCodeString[hexCodeLen++] = *p;
[-] 			hexCodeString [hexCodeLen] = 0;
[+] 			hexCodeString[hexCodeLen] = 0;
[-] 			x = (uchar_t) strtoul (hexCodeString, &hexCodeEnd, 16);
[+] 			x = (uchar_t)strtoul(hexCodeString, &hexCodeEnd, 16);
[-] 			if (hexCodeEnd == &hexCodeString [hexCodeLen])
[+] 			if (hexCodeEnd == &hexCodeString[hexCodeLen])
[-] 				buffer->append (x);
[+] 				buffer->append(x);
[-] 		hexCodeString [hexCodeLen] = 0;
[+] 		hexCodeString[hexCodeLen] = 0;
[-] 		x = (uchar_t) strtoul (hexCodeString, &hexCodeEnd, 16);
[+] 		x = (uchar_t)strtoul(hexCodeString, &hexCodeEnd, 16);
[-] 		if (hexCodeEnd == &hexCodeString [hexCodeLen])
[+] 		if (hexCodeEnd == &hexCodeString[hexCodeLen])
[-] 			buffer->append (x);
[+] 			buffer->append(x);
[-] 	return buffer->getCount ();
[+] 	return buffer->getCount();
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_enc_Utf.cpp
----------------------
[-] getUtfKindString (UtfKind utfKind)
[+] getUtfKindString(UtfKind utfKind)
[-] 	static const char* stringTable [] =
[+] 	static const char* stringTable[] =
[-] 	return (size_t) utfKind < countof (stringTable) ?
[+] 	return (size_t)utfKind < countof(stringTable) ?
[-] 		stringTable [utfKind] :
[+] 		stringTable[utfKind] :
[-]  * @param excWord (in) initial exceptions word
[+]  * @param excWord(in)initial exceptions word
[-]  * @param idx (in) desired slot index
[+]  * @param idx(in)desired slot index
[-]  * @param pExc16 (in/out) const uint16_t * after excWord=*pExc16++;
[+]  * @param pExc16(in/out) const uint16_t * after excWord=*pExc16++;
[-]  * @param value (out) int32_t or uint32_t output if hasSlot, otherwise not modified
[+]  * @param value(out)int32_t or uint32_t output if hasSlot, otherwise not modified
[-] utfIsPrintable (utf32_t c)
[+] utfIsPrintable(utf32_t c)
[-] utfIsPrintableNonMark (utf32_t c)
[+] utfIsPrintableNonMark(utf32_t c)
[-] utfIsSpace (utf32_t c)
[+] utfIsSpace(utf32_t c)
[-] utfIsPunctuation (utf32_t c)
[+] utfIsPunctuation(utf32_t c)
[-] utfIsLetter (utf32_t c)
[+] utfIsLetter(utf32_t c)
[-] utfIsDigit (utf32_t c)
[+] utfIsDigit(utf32_t c)
[-] utfIsNumber (utf32_t c)
[+] utfIsNumber(utf32_t c)
[-] utfIsLetterOrDigit (utf32_t c)
[+] utfIsLetterOrDigit(utf32_t c)
[-] utfIsLetterOrNumber (utf32_t c)
[+] utfIsLetterOrNumber(utf32_t c)
[-] utfIsLowerCase (utf32_t c)
[+] utfIsLowerCase(utf32_t c)
[-] utfIsUpperCase (utf32_t c)
[+] utfIsUpperCase(utf32_t c)
[-] utfToLowerCase (utf32_t c)
[+] utfToLowerCase(utf32_t c)
[-] utfToUpperCase (utf32_t c)
[+] utfToUpperCase(utf32_t c)
[-] utfToCaseFolded (utf32_t c)
[+] utfToCaseFolded(utf32_t c)
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_err_Errno.cpp
----------------------
[-] ErrnoProvider::getErrorDescription (int code)
[+] ErrnoProvider::getErrorDescription(int code)
[-] 	char buffer [512] = { 0 };
[+] 	char buffer[512] = { 0 };
[-] 	strerror_s (buffer, countof (buffer) - 1, code);
[+] 	strerror_s(buffer, countof(buffer) - 1, code);
[-] 	return strerror_r (code, buffer, countof (buffer) - 1);
[+] 	return strerror_r(code, buffer, countof(buffer) - 1);
[-] 	strerror_r (code, buffer, countof (buffer) - 1);
[+] 	strerror_r(code, buffer, countof(buffer) - 1);
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_err_Error.cpp
----------------------
[-] setOutOfMemoryError ()
[+] setOutOfMemoryError()
[-] 	setError (SystemErrorCode_InsufficientResources);
[+] 	setError(SystemErrorCode_InsufficientResources);
[-] ErrorHdr::getDescription () const
[+] ErrorHdr::getDescription() const
[-] 	ErrorProvider* provider = getErrorMgr ()->findProvider (m_guid);
[+] 	ErrorProvider* provider = getErrorMgr()->findProvider(m_guid);
[-] 		provider->getErrorDescription (this) :
[+] 		provider->getErrorDescription(this) :
[-] 		sl::formatString ("%s::%d", m_guid.getString ().sz (), m_code);
[+] 		sl::formatString("%s::%d", m_guid.getString ().sz (), m_code);
[-] ErrorRef::getDescription () const
[+] ErrorRef::getDescription() const
[-] 	return !isEmpty () ? m_p->getDescription () : g_noError.getDescription ();
[+] 	return !isEmpty() ? m_p->getDescription() : g_noError.getDescription();
[-] Error::push (const ErrorRef& error)
[+] Error::push(const ErrorRef& error)
[-] 		return copy (error);
[+] 		return copy(error);
[-] 	if (isKindOf (g_stdErrorGuid, StdErrorCode_Stack))
[+] 	if (isKindOf(g_stdErrorGuid, StdErrorCode_Stack))
[-] 		base += sizeof (ErrorHdr);
[+] 		base += sizeof(ErrorHdr);
[-] 		baseSize -= sizeof (ErrorHdr);
[+] 		baseSize -= sizeof(ErrorHdr);
[-] 	size_t size = sizeof (ErrorHdr) + error->m_size + baseSize;
[+] 	size_t size = sizeof(ErrorHdr) + error->m_size + baseSize;
[-] 	createBuffer (size, true);
[+] 	createBuffer(size, true);
[-] 	memmove (
[+] 	memmove(
[-] 		(uchar_t*) m_p + sizeof (ErrorHdr) + error->m_size,
[+] 		(uchar_t*)m_p + sizeof(ErrorHdr) + error->m_size,
[-] 		(uchar_t*) m_p + base,
[+] 		(uchar_t*)m_p + base,
[-] 	m_p->m_size = (uint32_t) size;
[+] 	m_p->m_size = (uint32_t)size;
[-] 	memcpy (m_p + 1, error, error->m_size);
[+] 	memcpy(m_p + 1, error, error->m_size);
[-] Error::createSimpleError (
[+] Error::createSimpleError(
[-] 	createBuffer (sizeof (ErrorHdr));
[+] 	createBuffer(sizeof(ErrorHdr));
[-] 	m_p->m_size = sizeof (ErrorHdr);
[+] 	m_p->m_size = sizeof(ErrorHdr);
[-] 	return sizeof (ErrorHdr);
[+] 	return sizeof(ErrorHdr);
[-] Error::format_va (
[+] Error::format_va(
[-] 	packer.format (formatString);
[+] 	packer.format(formatString);
[-] 	packer.pack_va (NULL, &packSize, va);
[+] 	packer.pack_va(NULL, &packSize, va);
[-] 	size_t size = sizeof (ErrorHdr) + packSize;
[+] 	size_t size = sizeof(ErrorHdr) + packSize;
[-] 	createBuffer (size);
[+] 	createBuffer(size);
[-] 	m_p->m_size = (uint32_t) size;
[+] 	m_p->m_size = (uint32_t)size;
[-] 	packer.pack_va (m_p + 1, &packSize, va);
[+] 	packer.pack_va(m_p + 1, &packSize, va);
[-] Error::createStringError (const sl::StringRef& string)
[+] Error::createStringError(const sl::StringRef& string)
[-] 	size_t length = string.getLength ();
[+] 	size_t length = string.getLength();
[-] 	size_t size = sizeof (ErrorHdr) + length + 1;
[+] 	size_t size = sizeof(ErrorHdr) + length + 1;
[-] 	ErrorHdr* error = createBuffer (size);
[+] 	ErrorHdr* error = createBuffer(size);
[-] 	error->m_size = (uint32_t) size;
[+] 	error->m_size = (uint32_t)size;
[-] 	char* dst = (char*) (error + 1);
[+] 	char* dst = (char*)(error + 1);
[-] 	memcpy (dst, string.cp (), length);
[+] 	memcpy(dst, string.cp(), length);
[-] 	dst [length] = 0;
[+] 	dst[length] = 0;
[-] Error::formatStringError_va (
[+] Error::formatStringError_va(
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String string (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String string(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	string.format_va (formatString, va);
[+] 	string.format_va(formatString, va);
[-] 	return createStringError (string);
[+] 	return createStringError(string);
[-] getLastError ()
[+] getLastError()
[-] 	return getErrorMgr ()->getLastError ();
[+] 	return getErrorMgr()->getLastError();
[-] setError (const ErrorRef& error)
[+] setError(const ErrorRef& error)
[-] 	getErrorMgr ()->setError (error);
[+] 	getErrorMgr()->setError(error);
[-] 	return error.getSize ();
[+] 	return error.getSize();
[-] pushError (const ErrorRef& error)
[+] pushError(const ErrorRef& error)
[-] 	Error stack = getLastError ();
[+] 	Error stack = getLastError();
[-] 	ASSERT (!stack.isKindOf (g_stdErrorGuid, StdErrorCode_NoError));
[+] 	ASSERT(!stack.isKindOf(g_stdErrorGuid, StdErrorCode_NoError));
[-] 	size_t result = stack.push (error);
[+] 	size_t result = stack.push(error);
[-] 	return result != -1 ? setError (stack) : -1;
[+] 	return result != -1 ? setError(stack) : -1;
[-] getLastErrorDescription ()
[+] getLastErrorDescription()
[-] 	return getErrorMgr ()->getLastError ().getDescription ();
[+] 	return getErrorMgr()->getLastError().getDescription();
[-] setFormatError_va (
[+] setFormatError_va(
[-] 	size_t result = error.format_va (guid, code, formatString, va);
[+] 	size_t result = error.format_va(guid, code, formatString, va);
[-] 	return result != -1 ? setError (error) : -1;
[+] 	return result != -1 ? setError(error) : -1;
[-] pushFormatError_va (
[+] pushFormatError_va(
[-] 	size_t result = error.format_va (guid, code, formatString, va);
[+] 	size_t result = error.format_va(guid, code, formatString, va);
[-] 	return result != -1 ? pushError (error) : -1;
[+] 	return result != -1 ? pushError(error) : -1;
[-] setError (const sl::StringRef& string)
[+] setError(const sl::StringRef& string)
[-] 	size_t result = error.createStringError (string);
[+] 	size_t result = error.createStringError(string);
[-] 	return result != -1 ? setError (error) : -1;
[+] 	return result != -1 ? setError(error) : -1;
[-] pushError (const sl::StringRef& string)
[+] pushError(const sl::StringRef& string)
[-] 	size_t result = error.createStringError (string);
[+] 	size_t result = error.createStringError(string);
[-] 	return result != -1 ? pushError (error) : -1;
[+] 	return result != -1 ? pushError(error) : -1;
[-] setFormatStringError_va (
[+] setFormatStringError_va(
[-] 	size_t result = error.formatStringError_va (formatString, va);
[+] 	size_t result = error.formatStringError_va(formatString, va);
[-] 	return result != -1 ? setError (error) : -1;
[+] 	return result != -1 ? setError(error) : -1;
[-] pushFormatStringError_va (
[+] pushFormatStringError_va(
[-] 	size_t result = error.formatStringError_va (formatString, va);
[+] 	size_t result = error.formatStringError_va(formatString, va);
[-] 	return result != -1 ? pushError (error) : -1;
[+] 	return result != -1 ? pushError(error) : -1;
[-] StdErrorProvider::getErrorDescription (const ErrorRef& error)
[+] StdErrorProvider::getErrorDescription(const ErrorRef& error)
[-] 	if (error->m_size < sizeof (ErrorHdr))
[+] 	if (error->m_size < sizeof(ErrorHdr))
[-] 		return sl::String ();
[+] 		return sl::String();
[-] 	switch (error->m_code)
[+] 	switch(error->m_code)
[-] 		stringSize = error->m_size - sizeof (ErrorHdr);
[+] 		stringSize = error->m_size - sizeof(ErrorHdr);
[-] 		return stringSize && !p [stringSize - 1] ?
[+] 		return stringSize && !p[stringSize - 1] ?
[-] 			sl::StringRef (error.getHdr (), p, stringSize - 1, true) :
[+] 			sl::StringRef(error.getHdr(), p, stringSize - 1, true) :
[-] 			sl::StringRef (error.getHdr (), p, stringSize, false);
[+] 			sl::StringRef(error.getHdr(), p, stringSize, false);
[-] 		return getStackErrorDescription (error);
[+] 		return getStackErrorDescription(error);
[-] 		return sl::formatString ("error #%d");
[+] 		return sl::formatString("error #%d");
[-] StdErrorProvider::getStackErrorDescription (const ErrorRef& error)
[+] StdErrorProvider::getStackErrorDescription(const ErrorRef& error)
[-] 	const void* end = error.getEnd ();
[+] 	const void* end = error.getEnd();
[-] 		ASSERT (p->m_size >= sizeof (ErrorHdr));
[+] 		ASSERT(p->m_size >= sizeof(ErrorHdr));
[-] 		if (!string.isEmpty ())
[+] 		if (!string.isEmpty())
[-] 		string += ErrorRef (p).getDescription ();
[+] 		string += ErrorRef(p).getDescription();
[-] 		p = (ErrorHdr*) ((uchar_t*) p + p->m_size);
[+] 		p = (ErrorHdr*)((uchar_t*)p + p->m_size);
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_err_ErrorMgr.cpp
----------------------
[-] ErrorMgr::ErrorMgr ()
[+] ErrorMgr::ErrorMgr()
[-] 	m_tlsSlot = sys::getTlsMgr ()->createSlot ();
[+] 	m_tlsSlot = sys::getTlsMgr()->createSlot();
[-] 	registerProvider (g_stdErrorGuid, sl::getSimpleSingleton <StdErrorProvider> ());
[+] 	registerProvider(g_stdErrorGuid, sl::getSimpleSingleton<StdErrorProvider> ());
[-] 	registerProvider (g_errnoGuid, sl::getSimpleSingleton <ErrnoProvider> ());
[+] 	registerProvider(g_errnoGuid, sl::getSimpleSingleton<ErrnoProvider> ());
[-] 	registerProvider (sys::win::g_winErrorGuid, sl::getSimpleSingleton <sys::win::WinErrorProvider> ());
[+] 	registerProvider(sys::win::g_winErrorGuid, sl::getSimpleSingleton<sys::win::WinErrorProvider> ());
[-] 	registerProvider (sys::win::g_ntStatusGuid, sl::getSimpleSingleton <sys::win::NtStatusProvider> ());
[+] 	registerProvider(sys::win::g_ntStatusGuid, sl::getSimpleSingleton<sys::win::NtStatusProvider> ());
[-] 	registerProvider (sys::drw::g_MachErrorGuid, sl::getSimpleSingleton <sys::drw::MachErrorProvider> ());
[+] 	registerProvider(sys::drw::g_MachErrorGuid, sl::getSimpleSingleton<sys::drw::MachErrorProvider> ());
[-] ErrorMgr::registerProvider (
[+] ErrorMgr::registerProvider(
[-] 	sys::ScopeLock scopeLock (&m_lock);
[+] 	sys::ScopeLock scopeLock(&m_lock);
[-] 	m_providerMap.visit (guid)->m_value = provider;
[+] 	m_providerMap.visit(guid)->m_value = provider;
[-] ErrorMgr::findProvider (const sl::Guid& guid)
[+] ErrorMgr::findProvider(const sl::Guid& guid)
[-] 	sys::ScopeLock scopeLock (&m_lock);
[+] 	sys::ScopeLock scopeLock(&m_lock);
[-] 	sl::HashTableIterator <sl::Guid, ErrorProvider*> it = m_providerMap.find (guid);
[+] 	sl::HashTableIterator<sl::Guid, ErrorProvider*> it = m_providerMap.find(guid);
[-] ErrorMgr::getLastError ()
[+] ErrorMgr::getLastError()
[-] 	ThreadEntry* entry = findThreadEntry ();
[+] 	ThreadEntry* entry = findThreadEntry();
[-] 	if (entry && !entry->m_error.isEmpty ())
[+] 	if (entry && !entry->m_error.isEmpty())
[-] ErrorMgr::setError (const ErrorRef& error)
[+] ErrorMgr::setError(const ErrorRef& error)
[-] 	ThreadEntry* entry = getThreadEntry ();
[+] 	ThreadEntry* entry = getThreadEntry();
[-] 		m_forwardRouter->routeError (error);
[+] 		m_forwardRouter->routeError(error);
[-] ErrorMgr::getThreadEntry ()
[+] ErrorMgr::getThreadEntry()
[-] 	ThreadEntry* entry = findThreadEntry ();
[+] 	ThreadEntry* entry = findThreadEntry();
[-] 	ref::Ptr <ThreadEntry> newEntry = AXL_REF_NEW (ref::Box <ThreadEntry>);
[+] 	ref::Ptr<ThreadEntry> newEntry = AXL_REF_NEW(ref::Box<ThreadEntry>);
[-] 	sys::getTlsMgr ()->setSlotValue (m_tlsSlot, newEntry);
[+] 	sys::getTlsMgr()->setSlotValue(m_tlsSlot, newEntry);
----------------------
27/02/2019 18:01:46 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_g_Module.cpp
----------------------
[-] initPreciseTimestamps ();
[+] initPreciseTimestamps();
[-] 	ModuleCreator ()
[+] 	ModuleCreator()
[-] 		getModule ();
[+] 		getModule();
[-] Module::Module ()
[+] Module::Module()
[-] 	m_hModule = ::GetModuleHandle (NULL);
[+] 	m_hModule = ::GetModuleHandle(NULL);
[-] 	::GetSystemInfo (&systemInfo);
[+] 	::GetSystemInfo(&systemInfo);
[-] 	sys::win::initNtDllFunctions ();
[+] 	sys::win::initNtDllFunctions();
[-] 	m_systemInfo.m_processorCount     = sysconf (_SC_NPROCESSORS_ONLN);
[+] 	m_systemInfo.m_processorCount     = sysconf(_SC_NPROCESSORS_ONLN);
[-] 	m_systemInfo.m_pageSize           = sysconf (_SC_PAGE_SIZE);
[+] 	m_systemInfo.m_pageSize           = sysconf(_SC_PAGE_SIZE);
[-] 	m_systemInfo.m_mappingAlignFactor = sysconf (_SC_PAGE_SIZE);
[+] 	m_systemInfo.m_mappingAlignFactor = sysconf(_SC_PAGE_SIZE);
[-] 	sys::initPreciseTimestamps ();
[+] 	sys::initPreciseTimestamps();
[-] Module::~Module ()
[+] Module::~Module()
[-] 	while (!m_finalizerList.isEmpty ())
[+] 	while (!m_finalizerList.isEmpty())
[-] 		FinalizerEntry* finalizerEntry = m_finalizerList.removeTail ();
[+] 		FinalizerEntry* finalizerEntry = m_finalizerList.removeTail();
[-] 		finalizerEntry->m_finalizer->finalize ();
[+] 		finalizerEntry->m_finalizer->finalize();
[-] 		AXL_MEM_DELETE (finalizerEntry);
[+] 		AXL_MEM_DELETE(finalizerEntry);
[-] 	m_memTracker.trace ();
[+] 	m_memTracker.trace();
[-] Module::addFinalizer (const ref::Ptr <Finalizer>& finalizer)
[+] Module::addFinalizer(const ref::Ptr<Finalizer>& finalizer)
[-] 	FinalizerEntry* finalizerEntry = AXL_MEM_NEW (FinalizerEntry);
[+] 	FinalizerEntry* finalizerEntry = AXL_MEM_NEW(FinalizerEntry);
[-] 	m_finalizerListLock.lock ();
[+] 	m_finalizerListLock.lock();
[-] 	m_finalizerList.insertTail (finalizerEntry);
[+] 	m_finalizerList.insertTail(finalizerEntry);
[-] 	m_finalizerListLock.unlock ();
[+] 	m_finalizerListLock.unlock();
[-] axl_trace_va (
[+] axl_trace_va(
[-] 	char buffer [512] = { 0 };
[+] 	char buffer[512] = { 0 };
[-] 	axl::sl::String string (axl::ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	axl::sl::String string(axl::ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	string.format_va (formatString, va);
[+] 	string.format_va(formatString, va);
[-] 	::OutputDebugStringA (string);
[+] 	::OutputDebugStringA(string);
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_mem_Tracker.cpp
----------------------
[-] addTrackerBlock (TrackerBlockHdr* hdr)
[+] addTrackerBlock(TrackerBlockHdr* hdr)
[-] 	g::getModule ()->getMemTracker ()->add (hdr);
[+] 	g::getModule()->getMemTracker()->add(hdr);
[-] removeTrackerBlock (TrackerBlockHdr* hdr)
[+] removeTrackerBlock(TrackerBlockHdr* hdr)
[-] 	g::getModule ()->getMemTracker ()->remove (hdr);
[+] 	g::getModule()->getMemTracker()->remove(hdr);
[-] Tracker::Tracker ()
[+] Tracker::Tracker()
[-] Tracker::add (TrackerBlockHdr* hdr)
[+] Tracker::add(TrackerBlockHdr* hdr)
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	m_blockList.insertTail (hdr);
[+] 	m_blockList.insertTail(hdr);
[-] 	size_t blockCount = m_blockList.getCount ();
[+] 	size_t blockCount = m_blockList.getCount();
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] Tracker::remove (TrackerBlockHdr* hdr)
[+] Tracker::remove(TrackerBlockHdr* hdr)
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	m_blockList.remove (hdr);
[+] 	m_blockList.remove(hdr);
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
[-] Tracker::trace ()
[+] Tracker::trace()
[-] 	m_lock.lock ();
[+] 	m_lock.lock();
[-] 	TRACE (
[+] 	TRACE(
[-] 		g::getModule ()->getTag (),
[+] 		g::getModule()->getTag(),
[-] 		m_blockList.getCount (),
[+] 		m_blockList.getCount(),
[-] 	if (!m_blockList.isEmpty ())
[+] 	if (!m_blockList.isEmpty())
[-] 		TRACE (
[+] 		TRACE(
[-] 			m_blockList.getCount ()
[+] 			m_blockList.getCount()
[-] 		sl::Iterator <TrackerBlockHdr> it = m_blockList.getHead ();
[+] 		sl::Iterator<TrackerBlockHdr> it = m_blockList.getHead();
[-] 			TRACE (
[+] 			TRACE(
[-] 	m_lock.unlock ();
[+] 	m_lock.unlock();
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sl_BitMap.cpp
----------------------
[-] getBit (
[+] getBit(
[-] 	return (map [page] & mask) != 0;
[+] 	return (map[page] & mask) != 0;
[-] setBit (
[+] setBit(
[-] setBitRange (
[+] setBitRange(
[-] 			mask = getBitmask (from, to);
[+] 			mask = getBitmask(from, to);
[-] 		mask = getHiBitmask (from);
[+] 		mask = getHiBitmask(from);
[-] 			mask = getLoBitmask (to);
[+] 			mask = getLoBitmask(to);
[-] 			mask = getBitmask (from, to);
[+] 			mask = getBitmask(from, to);
[-] 		mask = getHiBitmask (from);
[+] 		mask = getHiBitmask(from);
[-] 			mask = getLoBitmask (to);
[+] 			mask = getLoBitmask(to);
[-] mergeBitMaps (
[+] mergeBitMaps(
[-] 	switch (op)
[+] 	switch(op)
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] findBit (
[+] findBit(
[-] 		size_t x = *p & getHiBitmask (from);
[+] 		size_t x = *p & getHiBitmask(from);
[-] 			return i * AXL_PTR_BITS + getLoBitIdx (x);
[+] 			return i * AXL_PTR_BITS + getLoBitIdx(x);
[-] 				return i * AXL_PTR_BITS + getLoBitIdx (*p);
[+] 				return i * AXL_PTR_BITS + getLoBitIdx(*p);
[-] 		size_t x = ~*p & getHiBitmask (from);
[+] 		size_t x = ~*p & getHiBitmask(from);
[-] 			return i * AXL_PTR_BITS + getLoBitIdx (x);
[+] 			return i * AXL_PTR_BITS + getLoBitIdx(x);
[-] 				return i * AXL_PTR_BITS + getLoBitIdx (~*p);
[+] 				return i * AXL_PTR_BITS + getLoBitIdx(~*p);
[-] BitMap::create (size_t bitCount)
[+] BitMap::create(size_t bitCount)
[-] 	bool result = setBitCount (bitCount);
[+] 	bool result = setBitCount(bitCount);
[-] 	clear ();
[+] 	clear();
[-] BitMap::setBitCount (size_t bitCount)
[+] BitMap::setBitCount(size_t bitCount)
[-] 	return m_map.setCountZeroConstruct (pageCount);
[+] 	return m_map.setCountZeroConstruct(pageCount);
[-] BitMap::cmp (const BitMap& src) const
[+] BitMap::cmp(const BitMap& src) const
[-] 	size_t count = m_map.getCount ();
[+] 	size_t count = m_map.getCount();
[-] 	size_t count2 = src.m_map.getCount ();
[+] 	size_t count2 = src.m_map.getCount();
[-] 		memcmp (m_map, src.m_map, count * sizeof (size_t));
[+] 		memcmp(m_map, src.m_map, count * sizeof(size_t));
[-] BitMap::merge (
[+] BitMap::merge(
[-] 	size_t pageCount = m_map.getCount ();
[+] 	size_t pageCount = m_map.getCount();
[-] 	size_t pageCount2 = bitMap2.m_map.getCount ();
[+] 	size_t pageCount2 = bitMap2.m_map.getCount();
[-] 	return sl::mergeBitMaps (m_map, bitMap2.m_map, AXL_MIN (pageCount, pageCount2), op);
[+] 	return sl::mergeBitMaps(m_map, bitMap2.m_map, AXL_MIN(pageCount, pageCount2), op);
[-] BitMap::mergeResize (
[+] BitMap::mergeResize(
[-] 	size_t pageCount2 = bitMap2.m_map.getCount ();
[+] 	size_t pageCount2 = bitMap2.m_map.getCount();
[-] 	size_t pageCount = m_map.ensureCountZeroConstruct (pageCount2);
[+] 	size_t pageCount = m_map.ensureCountZeroConstruct(pageCount2);
[-] 	return sl::mergeBitMaps (m_map, bitMap2.m_map, AXL_MIN (pageCount, pageCount2), op);
[+] 	return sl::mergeBitMaps(m_map, bitMap2.m_map, AXL_MIN(pageCount, pageCount2), op);
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sl_BmhFind.cpp
----------------------
[-] BmhFind::BmhFind ()
[+] BmhFind::BmhFind()
[-] BmhFind::clear ()
[+] BmhFind::clear()
[-] BmhFind::setPattern (
[+] BmhFind::setPattern(
[-] 	clear ();
[+] 	clear();
[-] 	m_buffer.setCount (size * 2);
[+] 	m_buffer.setCount(size * 2);
[-] 	memcpy (m_buffer, p, size);
[+] 	memcpy(m_buffer, p, size);
[-] 	rebuildTables ();
[+] 	rebuildTables();
[-] BmhFind::find (
[+] BmhFind::find(
[-] 	p = (uchar_t*) _p;
[+] 	p = (uchar_t*)_p;
[-] 		uchar_t y = p [m];
[+] 		uchar_t y = p[m];
[-] 		if (cmpPattern (p) == -1)
[+] 		if (cmpPattern(p) == -1)
[-] 			return p - (uchar_t*) _p;
[+] 			return p - (uchar_t*)_p;
[-] 		p += m_nextBadCharTable [y];
[+] 		p += m_nextBadCharTable[y];
[-] BmhFind::reverseFind (
[+] BmhFind::reverseFind(
[-] 	p = (uchar_t*) _p + size - m_patternSize;
[+] 	p = (uchar_t*)_p + size - m_patternSize;
[-] 		if (reverseCmpPattern (p) == -1)
[+] 		if (reverseCmpPattern(p) == -1)
[-] 			return size - (p - (uchar_t*) _p);
[+] 			return size - (p - (uchar_t*)_p);
[-] 		p -= m_prevBadCharTable [y];
[+] 		p -= m_prevBadCharTable[y];
[-] 	} while (p >= (uchar_t*) _p);
[+] 	} while (p >= (uchar_t*)_p);
[-] BmhFind::incrementalFind (
[+] BmhFind::incrementalFind(
[-] 	uchar_t* p = (uchar_t*) _p;
[+] 	uchar_t* p = (uchar_t*)_p;
[-] 		memcpy (m_buffer + m_patternSize + m_incFindTailSize, _p, size);
[+] 		memcpy(m_buffer + m_patternSize + m_incFindTailSize, _p, size);
[-] 		uchar_t y = p [n + i];
[+] 		uchar_t y = p[n + i];
[-] 		if (incrementalCmpPattern (p, i) == -1)
[+] 		if (incrementalCmpPattern(p, i) == -1)
[-] 		i += m_nextBadCharTable [y];
[+] 		i += m_nextBadCharTable[y];
[-] 		updateIncrementalTail (p, size, testSize - i);
[+] 		updateIncrementalTail(p, size, testSize - i);
[-] BmhFind::reverseIncrementalFind (
[+] BmhFind::reverseIncrementalFind(
[-] 	uchar_t* p = (uchar_t*) _p;
[+] 	uchar_t* p = (uchar_t*)_p;
[-] 		memcpy (m_buffer + 2 * m_patternSize - m_incFindTailSize - size, _p, size);
[+] 		memcpy(m_buffer + 2 * m_patternSize - m_incFindTailSize - size, _p, size);
[-] 		uchar_t y = p [i];
[+] 		uchar_t y = p[i];
[-] 		if (reverseIncrementalCmpPattern (p, size, i) == -1)
[+] 		if (reverseIncrementalCmpPattern(p, size, i) == -1)
[-] 		if (i >= m_prevBadCharTable [y])
[+] 		if (i >= m_prevBadCharTable[y])
[-] 			i -= m_prevBadCharTable [y];
[+] 			i -= m_prevBadCharTable[y];
[-] 		if (m_prevBadCharTable [y] - i < m_patternSize)
[+] 		if (m_prevBadCharTable[y] - i < m_patternSize)
[-] 			updateReverseIncrementalTail (p, size, m_patternSize - (m_prevBadCharTable [y] - i));
[+] 			updateReverseIncrementalTail(p, size, m_patternSize - (m_prevBadCharTable[y] - i));
[-] BmhFind::rebuildTables ()
[+] BmhFind::rebuildTables()
[-] 		m_nextBadCharTable [i] =
[+] 		m_nextBadCharTable[i] =
[-] 		m_prevBadCharTable [i] = m_patternSize;
[+] 		m_prevBadCharTable[i] = m_patternSize;
[-] 			m_nextBadCharTable [p [i]] = m - i;
[+] 			m_nextBadCharTable[p[i]] = m - i;
[-] 			m_prevBadCharTable [p [i]] = i;
[+] 			m_prevBadCharTable[p[i]] = i;
[-] 			m_nextBadCharTable [tolower (p [i])] =
[+] 			m_nextBadCharTable[tolower(p[i])] =
[-] 			m_nextBadCharTable [toupper (p [i])] = m - i;
[+] 			m_nextBadCharTable[toupper(p[i])] = m - i;
[-] 			m_prevBadCharTable [tolower (p [i])] =
[+] 			m_prevBadCharTable[tolower(p[i])] =
[-] 			m_prevBadCharTable [toupper (p [i])] = i;
[+] 			m_prevBadCharTable[toupper(p[i])] = i;
[-] BmhFind::cmpPattern (uchar_t* _p)
[+] BmhFind::cmpPattern(uchar_t* _p)
[-] 			if (toupper (*p1) != toupper (*p2))
[+] 			if (toupper(*p1) != toupper(*p2))
[-] BmhFind::reverseCmpPattern (uchar_t* _p)
[+] BmhFind::reverseCmpPattern(uchar_t* _p)
[-] 			if (toupper (*p1) != toupper (*p2))
[+] 			if (toupper(*p1) != toupper(*p2))
[-] BmhFind::incrementalCmpPattern (
[+] BmhFind::incrementalCmpPattern(
[-] 		return cmpPattern (_p + i - m_incFindTailSize);
[+] 		return cmpPattern(_p + i - m_incFindTailSize);
[-] 			if (toupper (*p1) != toupper (*p2))
[+] 			if (toupper(*p1) != toupper(*p2))
[-] 			if (toupper (*p1) != toupper (*p2))
[+] 			if (toupper(*p1) != toupper(*p2))
[-] BmhFind::reverseIncrementalCmpPattern (
[+] BmhFind::reverseIncrementalCmpPattern(
[-] 		return reverseCmpPattern (_p + i);
[+] 		return reverseCmpPattern(_p + i);
[-] 			if (toupper (*p1) != toupper (*p2))
[+] 			if (toupper(*p1) != toupper(*p2))
[-] 			if (toupper (*p1) != toupper (*p2))
[+] 			if (toupper(*p1) != toupper(*p2))
[-] BmhFind::updateIncrementalTail (
[+] BmhFind::updateIncrementalTail(
[-] 	ASSERT (m_incFindTailSize + size >= m_patternSize);
[+] 	ASSERT(m_incFindTailSize + size >= m_patternSize);
[-] 	ASSERT (tailSize < m_patternSize);
[+] 	ASSERT(tailSize < m_patternSize);
[-] 		memcpy (m_buffer + m_patternSize, p + size - tailSize, tailSize);
[+] 		memcpy(m_buffer + m_patternSize, p + size - tailSize, tailSize);
[-] 	ASSERT (leftOver < m_incFindTailSize);
[+] 	ASSERT(leftOver < m_incFindTailSize);
[-] 	memmove (
[+] 	memmove(
[-] 	memcpy (
[+] 	memcpy(
[-] BmhFind::updateReverseIncrementalTail (
[+] BmhFind::updateReverseIncrementalTail(
[-] 	ASSERT (m_incFindTailSize + size >= m_patternSize);
[+] 	ASSERT(m_incFindTailSize + size >= m_patternSize);
[-] 	ASSERT (tailSize < m_patternSize);
[+] 	ASSERT(tailSize < m_patternSize);
[-] 		memcpy (m_buffer + 2 * m_patternSize - tailSize, p, tailSize);
[+] 		memcpy(m_buffer + 2 * m_patternSize - tailSize, p, tailSize);
[-] 	ASSERT (leftOver < m_incFindTailSize);
[+] 	ASSERT(leftOver < m_incFindTailSize);
[-] 	memmove (
[+] 	memmove(
[-] 	memcpy (
[+] 	memcpy(
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sl_BoyerMooreFind.cpp
----------------------
[-] BinaryBoyerMooreFind::setPattern (
[+] BinaryBoyerMooreFind::setPattern(
[-] 		clear ();
[+] 		clear();
[-] 		m_pattern.copyReverse ((const uchar_t*) p, size) :
[+] 		m_pattern.copyReverse((const uchar_t*) p, size) :
[-] 		m_pattern.copy ((const uchar_t*) p, size);
[+] 		m_pattern.copy((const uchar_t*) p, size);
[-] 	buildBadSkipTable ();
[+] 	buildBadSkipTable();
[-] 	return !(flags & BoyerMooreFlag_Horspool) ? buildGoodSkipTable () : true;
[+] 	return !(flags & BoyerMooreFlag_Horspool) ? buildGoodSkipTable() : true;
[-] BinaryBoyerMooreFind::buildBadSkipTable ()
[+] BinaryBoyerMooreFind::buildBadSkipTable()
[-] 	size_t patternSize = m_pattern.getCount ();
[+] 	size_t patternSize = m_pattern.getCount();
[-] 	m_badSkipTable.setCount (256);
[+] 	m_badSkipTable.setCount(256);
[-] 		m_badSkipTable [i] = patternSize;
[+] 		m_badSkipTable[i] = patternSize;
[-] 		m_badSkipTable [(uchar_t) m_pattern [i]] = j;
[+] 		m_badSkipTable[(uchar_t)m_pattern[i]] = j;
[-] BinaryBoyerMooreFind::find (
[+] BinaryBoyerMooreFind::find(
[-] 	size_t patternSize = m_pattern.getCount ();
[+] 	size_t patternSize = m_pattern.getCount();
[-] 		findImpl (BinaryBoyerMooreReverseAccessor ((const uchar_t*) p + size - 1), size) :
[+] 		findImpl(BinaryBoyerMooreReverseAccessor((const uchar_t*) p + size - 1), size) :
[-] 		findImpl (BinaryBoyerMooreAccessor ((const uchar_t*) p), size);
[+] 		findImpl(BinaryBoyerMooreAccessor((const uchar_t*) p), size);
[-] BinaryBoyerMooreFind::find (
[+] BinaryBoyerMooreFind::find(
[-] 	size_t patternSize = m_pattern.getCount ();
[+] 	size_t patternSize = m_pattern.getCount();
[-] 	size_t tailSize = incrementalContext->m_tail.getCount ();
[+] 	size_t tailSize = incrementalContext->m_tail.getCount();
[-] 			incrementalContext->m_tail.appendReverse ((const uchar_t*) p, size);
[+] 			incrementalContext->m_tail.appendReverse((const uchar_t*) p, size);
[-] 			incrementalContext->m_tail.append ((const uchar_t*) p, size);
[+] 			incrementalContext->m_tail.append((const uchar_t*) p, size);
[-] 		findImpl (BinaryBoyerMooreIncrementalReverseAccessor ((const uchar_t*) p + size - 1, incrementalContext), fullSize) :
[+] 		findImpl(BinaryBoyerMooreIncrementalReverseAccessor((const uchar_t*) p + size - 1, incrementalContext), fullSize) :
[-] 		findImpl (BinaryBoyerMooreIncrementalAccessor ((const uchar_t*) p, incrementalContext), fullSize);
[+] 		findImpl(BinaryBoyerMooreIncrementalAccessor((const uchar_t*) p, incrementalContext), fullSize);
[-] 	incrementalContext->reset ();
[+] 	incrementalContext->reset();
[-] BinaryBoyerMooreFind::findImpl (
[+] BinaryBoyerMooreFind::findImpl(
[-] 	size_t patternSize = m_pattern.getCount ();
[+] 	size_t patternSize = m_pattern.getCount();
[-] 	ASSERT (patternSize && size >= patternSize);
[+] 	ASSERT(patternSize && size >= patternSize);
[-] 				c = accessor.getChar (i);
[+] 				c = accessor.getChar(i);
[-] 				if (c != m_pattern [j])
[+] 				if (c != m_pattern[j])
[-] 			i += m_badSkipTable [c];
[+] 			i += m_badSkipTable[c];
[-] 				c = accessor.getChar (i);
[+] 				c = accessor.getChar(i);
[-] 				if (c != m_pattern [j])
[+] 				if (c != m_pattern[j])
[-] 			size_t badSkip = m_badSkipTable [c];
[+] 			size_t badSkip = m_badSkipTable[c];
[-] 			size_t goodSkip = m_goodSkipTable [j];
[+] 			size_t goodSkip = m_goodSkipTable[j];
[-] 			i += AXL_MAX (badSkip, goodSkip);
[+] 			i += AXL_MAX(badSkip, goodSkip);
[-] 	ASSERT (i > last && i - last <= size);
[+] 	ASSERT(i > last && i - last <= size);
[-] 	accessor.saveTail (i, size - i);
[+] 	accessor.saveTail(i, size - i);
[-] TextBoyerMooreFind::setPattern (
[+] TextBoyerMooreFind::setPattern(
[-] 	size_t length = codec->decodeToUtf32 (&m_pattern, p, size);
[+] 	size_t length = codec->decodeToUtf32(&m_pattern, p, size);
[-] 		clear ();
[+] 		clear();
[-] 			m_pattern [i] = enc::utfToCaseFolded (m_pattern [i]);
[+] 			m_pattern[i] = enc::utfToCaseFolded(m_pattern[i]);
[-] 		m_pattern.reverse ();
[+] 		m_pattern.reverse();
[-] 	bool result = buildBadSkipTable (badSkipTableSize);
[+] 	bool result = buildBadSkipTable(badSkipTableSize);
[-] 	return !(flags & BoyerMooreFlag_Horspool) ? buildGoodSkipTable () : true;
[+] 	return !(flags & BoyerMooreFlag_Horspool) ? buildGoodSkipTable() : true;
[-] TextBoyerMooreFind::buildBadSkipTable (size_t tableSize)
[+] TextBoyerMooreFind::buildBadSkipTable(size_t tableSize)
[-] 	size_t patternSize = m_pattern.getCount ();
[+] 	size_t patternSize = m_pattern.getCount();
[-] 	bool result = m_badSkipTable.setCount (tableSize);
[+] 	bool result = m_badSkipTable.setCount(tableSize);
[-] 		m_badSkipTable [i] = patternSize;
[+] 		m_badSkipTable[i] = patternSize;
[-] 		uint32_t c = m_pattern [i];
[+] 		uint32_t c = m_pattern[i];
[-] 		m_badSkipTable [c % tableSize] = j;
[+] 		m_badSkipTable[c % tableSize] = j;
[-] TextBoyerMooreFind::find (
[+] TextBoyerMooreFind::find(
[-] 	size_t patternLength = m_pattern.getCount ();
[+] 	size_t patternLength = m_pattern.getCount();
[-] 	size_t length = codec->decodeToUtf32 (&m_buffer, p, size);
[+] 	size_t length = codec->decodeToUtf32(&m_buffer, p, size);
[-] 		m_buffer.append (' ');
[+] 		m_buffer.append(' ');
[-] 			findImpl (TextBoyerMooreCaseFoldedReverseAccessor (m_buffer + length - 1), length, length) :
[+] 			findImpl(TextBoyerMooreCaseFoldedReverseAccessor(m_buffer + length - 1), length, length) :
[-] 			findImpl (TextBoyerMooreCaseFoldedAccessor (m_buffer), length, length) :
[+] 			findImpl(TextBoyerMooreCaseFoldedAccessor(m_buffer), length, length) :
[-] 			findImpl (TextBoyerMooreReverseAccessor (m_buffer + length - 1), length, length) :
[+] 			findImpl(TextBoyerMooreReverseAccessor(m_buffer + length - 1), length, length) :
[-] 			findImpl (TextBoyerMooreAccessor (m_buffer), length, length);
[+] 			findImpl(TextBoyerMooreAccessor(m_buffer), length, length);
[-] 	ASSERT (result <= length);
[+] 	ASSERT(result <= length);
[-] 	return codec->calcRequiredBufferSizeToEncodeFromUtf32 (m_buffer, result);
[+] 	return codec->calcRequiredBufferSizeToEncodeFromUtf32(m_buffer, result);
[-] TextBoyerMooreFind::find (
[+] TextBoyerMooreFind::find(
[-] 	size_t patternLength = m_pattern.getCount ();
[+] 	size_t patternLength = m_pattern.getCount();
[-] 	size_t chunkLength = codec->decodeToUtf32 (&m_buffer, p, size);
[+] 	size_t chunkLength = codec->decodeToUtf32(&m_buffer, p, size);
[-] 	size_t tailLength = incrementalContext->m_tail.getCount ();
[+] 	size_t tailLength = incrementalContext->m_tail.getCount();
[-] 			incrementalContext->m_tail.appendReverse (m_buffer, chunkLength);
[+] 			incrementalContext->m_tail.appendReverse(m_buffer, chunkLength);
[-] 			incrementalContext->m_tail.append (m_buffer, chunkLength);
[+] 			incrementalContext->m_tail.append(m_buffer, chunkLength);
[-] 			findImpl (
[+] 			findImpl(
[-] 				TextBoyerMooreCaseFoldedIncrementalReverseAccessor (m_buffer + chunkLength - 1, incrementalContext),
[+] 				TextBoyerMooreCaseFoldedIncrementalReverseAccessor(m_buffer + chunkLength - 1, incrementalContext),
[-] 			findImpl (
[+] 			findImpl(
[-] 				TextBoyerMooreCaseFoldedIncrementalAccessor (m_buffer, incrementalContext),
[+] 				TextBoyerMooreCaseFoldedIncrementalAccessor(m_buffer, incrementalContext),
[-] 			findImpl (
[+] 			findImpl(
[-] 				TextBoyerMooreIncrementalReverseAccessor (m_buffer + chunkLength - 1, incrementalContext),
[+] 				TextBoyerMooreIncrementalReverseAccessor(m_buffer + chunkLength - 1, incrementalContext),
[-] 			findImpl (
[+] 			findImpl(
[-] 				TextBoyerMooreIncrementalAccessor (m_buffer, incrementalContext),
[+] 				TextBoyerMooreIncrementalAccessor(m_buffer, incrementalContext),
[-] 	if ((intptr_t) result < 0)
[+] 	if ((intptr_t)result < 0)
[-] 		ASSERT (-result <= tailLength);
[+] 		ASSERT(-result <= tailLength);
[-] 		result = -codec->calcRequiredBufferSizeToEncodeFromUtf32 (incrementalContext->m_tail, -result);
[+] 		result = -codec->calcRequiredBufferSizeToEncodeFromUtf32(incrementalContext->m_tail, -result);
[-] 		ASSERT (result <= chunkLength);
[+] 		ASSERT(result <= chunkLength);
[-] 		result = codec->calcRequiredBufferSizeToEncodeFromUtf32 (m_buffer, result);
[+] 		result = codec->calcRequiredBufferSizeToEncodeFromUtf32(m_buffer, result);
[-] 	incrementalContext->reset ();
[+] 	incrementalContext->reset();
[-] TextBoyerMooreFind::findImpl (
[+] TextBoyerMooreFind::findImpl(
[-] 	size_t badSkipTableSize = m_badSkipTable.getCount ();
[+] 	size_t badSkipTableSize = m_badSkipTable.getCount();
[-] 	size_t patternSize = m_pattern.getCount ();
[+] 	size_t patternSize = m_pattern.getCount();
[-] 	ASSERT (patternSize && end >= patternSize);
[+] 	ASSERT(patternSize && end >= patternSize);
[-] 				c = accessor.getChar (i);
[+] 				c = accessor.getChar(i);
[-] 				if (c != m_pattern [j])
[+] 				if (c != m_pattern[j])
[-] 						(!accessor.isDelimChar (i - 1) || !accessor.isDelimChar (i + patternSize)))
[+] 						(!accessor.isDelimChar(i - 1) || !accessor.isDelimChar(i + patternSize)))
[-] 			i += m_badSkipTable [c % badSkipTableSize];
[+] 			i += m_badSkipTable[c % badSkipTableSize];
[-] 				c = accessor.getChar (i);
[+] 				c = accessor.getChar(i);
[-] 				if (c != m_pattern [j])
[+] 				if (c != m_pattern[j])
[-] 						(!accessor.isDelimChar (i - 1) || !accessor.isDelimChar (i + patternSize)))
[+] 						(!accessor.isDelimChar(i - 1) || !accessor.isDelimChar(i + patternSize)))
[-] 			size_t badSkip = m_badSkipTable [c % badSkipTableSize];
[+] 			size_t badSkip = m_badSkipTable[c % badSkipTableSize];
[-] 			size_t goodSkip = m_goodSkipTable [j];
[+] 			size_t goodSkip = m_goodSkipTable[j];
[-] 			i += AXL_MAX (badSkip, goodSkip);
[+] 			i += AXL_MAX(badSkip, goodSkip);
[-] 	ASSERT (i > last && i - last <= size);
[+] 	ASSERT(i > last && i - last <= size);
[-] 	accessor.saveTail (i, size - i);
[+] 	accessor.saveTail(i, size - i);
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sl_BuddyAllocMap.cpp
----------------------
[-] BuddyAllocMap::Level::format (
[+] BuddyAllocMap::Level::format(
[-] 	m_availablePageList.clear ();
[+] 	m_availablePageList.clear();
[-] 	ASSERT (count);
[+] 	ASSERT(count);
[-] 		m_availablePageList.insertTail (page);
[+] 		m_availablePageList.insertTail(page);
[-] BuddyAllocMap::Level::setPageMap (
[+] BuddyAllocMap::Level::setPageMap(
[-] 		m_availablePageList.remove (page);
[+] 		m_availablePageList.remove(page);
[-] 		m_availablePageList.insertTail (page);
[+] 		m_availablePageList.insertTail(page);
[-] BuddyAllocMap::Level::setBit (
[+] BuddyAllocMap::Level::setBit(
[-] 		ASSERT ((page->m_map & mask) == 0);
[+] 		ASSERT((page->m_map & mask) == 0);
[-] 		setPageMap (page, page->m_map | mask);
[+] 		setPageMap(page, page->m_map | mask);
[-] 		ASSERT ((page->m_map & mask) == mask);
[+] 		ASSERT((page->m_map & mask) == mask);
[-] 		setPageMap (page, page->m_map & ~mask);
[+] 		setPageMap(page, page->m_map & ~mask);
[-] BuddyAllocMap::Level::setBitRange (
[+] BuddyAllocMap::Level::setBitRange(
[-] 			mask = getBitmask (from, to);
[+] 			mask = getBitmask(from, to);
[-] 			setPageMap (page, page->m_map | mask);
[+] 			setPageMap(page, page->m_map | mask);
[-] 		setPageMap (page, page->m_map | mask);
[+] 		setPageMap(page, page->m_map | mask);
[-] 			setPageMap (page, page->m_map | mask);
[+] 			setPageMap(page, page->m_map | mask);
[-] 			setPageMap (page, page->m_map & ~mask);
[+] 			setPageMap(page, page->m_map & ~mask);
[-] 		setPageMap (page, page->m_map & ~mask);
[+] 		setPageMap(page, page->m_map & ~mask);
[-] 			setPageMap (page, page->m_map & ~mask);
[+] 			setPageMap(page, page->m_map & ~mask);
[-] BuddyAllocMap::BuddyAllocMap ()
[+] BuddyAllocMap::BuddyAllocMap()
[-] 	result = m_pageArray.setCount (totalPageCount) && m_levelArray.setCount (height);
[+] 	result = m_pageArray.setCount(totalPageCount) && m_levelArray.setCount(height);
[-] 		close ();
[+] 		close();
[-] 		level->format (page, pageCount);
[+] 		level->format(page, pageCount);
[-] BuddyAllocMap::close ()
[+] BuddyAllocMap::close()
[-] BuddyAllocMap::clear ()
[+] BuddyAllocMap::clear()
[-] BuddyAllocMap::allocate (size_t size)
[+] BuddyAllocMap::allocate(size_t size)
[-] 		err::setError (err::SystemErrorCode_InvalidParameter);
[+] 		err::setError(err::SystemErrorCode_InvalidParameter);
[-] 	ASSERT (levelIdx < m_height);
[+] 	ASSERT(levelIdx < m_height);
[-] 	page = level->getFirstAvailablePage ();
[+] 	page = level->getFirstAvailablePage();
[-] 	ASSERT (page->m_map != -1);
[+] 	ASSERT(page->m_map != -1);
[-] 	size_t pageIdx = page - level->getFirstPage ();
[+] 	size_t pageIdx = page - level->getFirstPage();
[-] 		ASSERT (!(address % bitSize)); // beacuse we below the allocation level
[+] 		ASSERT(!(address % bitSize)); // beacuse we below the allocation level
[-] BuddyAllocMap::mark (
[+] BuddyAllocMap::mark(
[-] 		ASSERT (!(address % bitSize)); // beacuse we below the allocation level
[+] 		ASSERT(!(address % bitSize)); // beacuse we below the allocation level
[-] BuddyAllocMap::free (
[+] BuddyAllocMap::free(
[-] 		ASSERT (!(address % bitSize)); // beacuse we below the allocation level
[+] 		ASSERT(!(address % bitSize)); // beacuse we below the allocation level
[-] 			ASSERT (prevPage != NULL);
[+] 			ASSERT(prevPage != NULL);
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sl_CircularBuffer.cpp
----------------------
[-] CircularBuffer::CircularBuffer ()
[+] CircularBuffer::CircularBuffer()
[-] CircularBuffer::isValid () const
[+] CircularBuffer::isValid() const
[-] 	if (m_buffer.isEmpty ()) // uninitialized
[+] 	if (m_buffer.isEmpty()) // uninitialized
[-] 		m_dataSize <= m_buffer.getCount () &&
[+] 		m_dataSize <= m_buffer.getCount() &&
[-] 		m_reader >= m_buffer && m_reader < m_buffer.getEnd () &&
[+] 		m_reader >= m_buffer && m_reader < m_buffer.getEnd() &&
[-] 		m_writer >= m_buffer && m_writer < m_buffer.getEnd () &&
[+] 		m_writer >= m_buffer && m_writer < m_buffer.getEnd() &&
[-] 				m_dataSize == m_buffer.getCount () - (m_reader - m_writer) :
[+] 				m_dataSize == m_buffer.getCount() - (m_reader - m_writer) :
[-] 				m_dataSize == m_buffer.getCount ()
[+] 				m_dataSize == m_buffer.getCount()
[-] CircularBuffer::setBufferSize (size_t size)
[+] CircularBuffer::setBufferSize(size_t size)
[-] 	ASSERT (size);
[+] 	ASSERT(size);
[-] 	if (m_buffer.getCount () == size)
[+] 	if (m_buffer.getCount() == size)
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <char> data (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<char> data(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	size_t dataSize = readAll (&data);
[+] 	size_t dataSize = readAll(&data);
[-] 	bool result = m_buffer.setCount (size);
[+] 	bool result = m_buffer.setCount(size);
[-] 	write (data, dataSize);
[+] 	write(data, dataSize);
[-] 	ASSERT (
[+] 	ASSERT(
[-] 		isValid () &&
[+] 		isValid() &&
[-] CircularBuffer::clear ()
[+] CircularBuffer::clear()
[-] CircularBuffer::readAll (sl::Array <char>* buffer)
[+] CircularBuffer::readAll(sl::Array<char>* buffer)
[-] 	bool result = buffer->setCount (m_dataSize);
[+] 	bool result = buffer->setCount(m_dataSize);
[-] 		memcpy (*buffer, m_reader, m_writer - m_reader);
[+] 		memcpy(*buffer, m_reader, m_writer - m_reader);
[-] 		size_t tailSize = m_buffer.getEnd () - m_reader;
[+] 		size_t tailSize = m_buffer.getEnd() - m_reader;
[-] 		ASSERT (tailSize);
[+] 		ASSERT(tailSize);
[-] 		memcpy (*buffer, m_reader, tailSize);
[+] 		memcpy(*buffer, m_reader, tailSize);
[-] 		memcpy (*buffer + tailSize, m_buffer, m_writer - m_buffer);
[+] 		memcpy(*buffer + tailSize, m_buffer, m_writer - m_buffer);
[-] 	ASSERT (isValid ());
[+] 	ASSERT(isValid());
[-] CircularBuffer::read (
[+] CircularBuffer::read(
[-] 		memcpy (p, m_reader, copySize);
[+] 		memcpy(p, m_reader, copySize);
[-] 		size_t tailSize = m_buffer.getEnd () - m_reader;
[+] 		size_t tailSize = m_buffer.getEnd() - m_reader;
[-] 		ASSERT (tailSize);
[+] 		ASSERT(tailSize);
[-] 			memcpy (p, m_reader, size);
[+] 			memcpy(p, m_reader, size);
[-] 			memcpy (p, m_reader, tailSize);
[+] 			memcpy(p, m_reader, tailSize);
[-] 			p = (char*) p + tailSize;
[+] 			p = (char*)p + tailSize;
[-] 			memcpy (p, m_buffer, headSize);
[+] 			memcpy(p, m_buffer, headSize);
[-] 	if (m_reader == m_buffer.getEnd ()) // wrap
[+] 	if (m_reader == m_buffer.getEnd()) // wrap
[-] 	ASSERT (isValid ());
[+] 	ASSERT(isValid());
[-] CircularBuffer::drop (size_t size)
[+] CircularBuffer::drop(size_t size)
[-] 		if (m_reader >= m_buffer.getEnd ())
[+] 		if (m_reader >= m_buffer.getEnd())
[-] 			m_reader = m_buffer + (m_reader - m_buffer.getEnd ());
[+] 			m_reader = m_buffer + (m_reader - m_buffer.getEnd());
[-] 			ASSERT (m_reader < m_writer);
[+] 			ASSERT(m_reader < m_writer);
[-] 	ASSERT (isValid ());
[+] 	ASSERT(isValid());
[-] CircularBuffer::write (
[+] CircularBuffer::write(
[-] 	if (isFull ())
[+] 	if (isFull())
[-] 		memcpy (m_writer, p, copySize);
[+] 		memcpy(m_writer, p, copySize);
[-] 		size_t tailSize = m_buffer.getEnd () - m_writer;
[+] 		size_t tailSize = m_buffer.getEnd() - m_writer;
[-] 			memcpy (m_writer, p, size);
[+] 			memcpy(m_writer, p, size);
[-] 				memcpy (m_writer, p, tailSize);
[+] 				memcpy(m_writer, p, tailSize);
[-] 				p = (char*) p + tailSize;
[+] 				p = (char*)p + tailSize;
[-] 			memcpy (m_buffer, p, headSize);
[+] 			memcpy(m_buffer, p, headSize);
[-] 	if (m_writer == m_buffer.getEnd ()) // wrap
[+] 	if (m_writer == m_buffer.getEnd()) // wrap
[-] 	ASSERT (isValid ());
[+] 	ASSERT(isValid());
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sl_CmdLineParser.cpp
----------------------
[-] CmdLineParserRoot::extractArg (
[+] CmdLineParserRoot::extractArg(
[-] 	const char* p = cmdLine.cp ();
[+] 	const char* p = cmdLine.cp();
[-] 	const char* end = cmdLine.getEnd ();
[+] 	const char* end = cmdLine.getEnd();
[-] 	while (p < end && isspace (*p))
[+] 	while (p < end && isspace(*p))
[-] 		arg->clear ();
[+] 		arg->clear();
[-] 		return p - cmdLine.cp ();
[+] 		return p - cmdLine.cp();
[-] 		while (p < end && !isspace (*p))
[+] 		while (p < end && !isspace(*p))
[-] 			err::setError ("unterminated escape sequence");
[+] 			err::setError("unterminated escape sequence");
[-] 	arg->copy (p1, p - p1);
[+] 	arg->copy(p1, p - p1);
[-] 	return p - cmdLine.cp ();
[+] 	return p - cmdLine.cp();
[-] CmdLineParserRoot::parseSwitch (
[+] CmdLineParserRoot::parseSwitch(
[-] 	const char* p = arg.cp ();
[+] 	const char* p = arg.cp();
[-] 	const char* end = arg.getEnd ();
[+] 	const char* end = arg.getEnd();
[-] 		switchName->copy (*p);
[+] 		switchName->copy(*p);
[-] 		while (p < end && *p != '=' && !isspace (*p))
[+] 		while (p < end && *p != '=' && !isspace(*p))
[-] 		switchName->copy (p0, p - p0);
[+] 		switchName->copy(p0, p - p0);
[-] 	if (p < end && !isspace (*p)) // has value
[+] 	if (p < end && !isspace(*p)) // has value
[-] 		value->copy (p, end - p);
[+] 		value->copy(p, end - p);
[-] 		value->clear ();
[+] 		value->clear();
[-] getCmdLineHelpString (const ConstList <SwitchInfo>& switchInfoList)
[+] getCmdLineHelpString(const ConstList<SwitchInfo>& switchInfoList)
[-] 	ConstIterator <SwitchInfo> it = switchInfoList.getHead ();
[+] 	ConstIterator<SwitchInfo> it = switchInfoList.getHead();
[-] 		for (; i < countof (switchInfo->m_nameTable); i++)
[+] 		for (; i < countof(switchInfo->m_nameTable); i++)
[-] 			if (!switchInfo->m_nameTable [i])
[+] 			if (!switchInfo->m_nameTable[i])
[-] 			if (switchInfo->m_nameTable [i] [1])
[+] 			if (switchInfo->m_nameTable[i] [1])
[-] 				switchLength += strlen_s (switchInfo->m_nameTable [i]);
[+] 				switchLength += strlen_s(switchInfo->m_nameTable[i]);
[-] 			switchLength += strlen_s (switchInfo->m_value);
[+] 			switchLength += strlen_s(switchInfo->m_value);
[-] 	it = switchInfoList.getHead ();
[+] 	it = switchInfoList.getHead();
[-] 			if (!string.isEmpty ())
[+] 			if (!string.isEmpty())
[-] 				string.appendNewLine ();
[+] 				string.appendNewLine();
[-] 			lineString.copy (' ', indentSize);
[+] 			lineString.copy(' ', indentSize);
[-] 			ASSERT (switchInfo->m_nameTable [0]);
[+] 			ASSERT(switchInfo->m_nameTable[0]);
[-] 			if (switchInfo->m_nameTable [0] [1])
[+] 			if (switchInfo->m_nameTable[0] [1])
[-] 				lineString += switchInfo->m_nameTable [0];
[+] 				lineString += switchInfo->m_nameTable[0];
[-] 				lineString += switchInfo->m_nameTable [0] [0];
[+] 				lineString += switchInfo->m_nameTable[0] [0];
[-] 			for (size_t i = 1; i < countof (switchInfo->m_nameTable); i++)
[+] 			for (size_t i = 1; i < countof(switchInfo->m_nameTable); i++)
[-] 				if (!switchInfo->m_nameTable [i])
[+] 				if (!switchInfo->m_nameTable[i])
[-] 				if (switchInfo->m_nameTable [i] [1])
[+] 				if (switchInfo->m_nameTable[i] [1])
[-] 					lineString += switchInfo->m_nameTable [i];
[+] 					lineString += switchInfo->m_nameTable[i];
[-] 					lineString += switchInfo->m_nameTable [i] [0];
[+] 					lineString += switchInfo->m_nameTable[i] [0];
[-] 			size_t length = lineString.getLength ();
[+] 			size_t length = lineString.getLength();
[-] 				lineString.append (' ', descriptionCol - length);
[+] 				lineString.append(' ', descriptionCol - length);
[-] 				lineString.appendNewLine ();
[+] 				lineString.appendNewLine();
[-] 				lineString.append (' ', descriptionCol);
[+] 				lineString.append(' ', descriptionCol);
[-] 		string.appendNewLine ();
[+] 		string.appendNewLine();
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sl_Guid.cpp
----------------------
[-] Guid::generate ()
[+] Guid::generate()
[-] 	memset (this, 0, sizeof (Guid));
[+] 	memset(this, 0, sizeof(Guid));
[-] Guid::parse (const sl::StringRef& string)
[+] Guid::parse(const sl::StringRef& string)
[-] 	const char* p = string.sz ();
[+] 	const char* p = string.sz();
[-] 	while (isspace (*p))
[+] 	while (isspace(*p))
[-] 		while (isspace (*p))
[+] 		while (isspace(*p))
[-] 	uint32_t a = (uint32_t) strtoul (p, &end, 16);
[+] 	uint32_t a = (uint32_t)strtoul(p, &end, 16);
[-] 		return err::fail (err::SystemErrorCode_InvalidParameter);
[+] 		return err::fail(err::SystemErrorCode_InvalidParameter);
[-] 	uint32_t b = (uint16_t) strtoul (p, &end, 16);
[+] 	uint32_t b = (uint16_t)strtoul(p, &end, 16);
[-] 		return err::fail (err::SystemErrorCode_InvalidParameter);
[+] 		return err::fail(err::SystemErrorCode_InvalidParameter);
[-] 	uint32_t c = (uint16_t) strtoul (p, &end, 16);
[+] 	uint32_t c = (uint16_t)strtoul(p, &end, 16);
[-] 		return err::fail (err::SystemErrorCode_InvalidParameter);
[+] 		return err::fail(err::SystemErrorCode_InvalidParameter);
[-] 	uint16_t d = (uint16_t) strtoul (p, &end, 16);
[+] 	uint16_t d = (uint16_t)strtoul(p, &end, 16);
[-] 		return err::fail (err::SystemErrorCode_InvalidParameter);
[+] 		return err::fail(err::SystemErrorCode_InvalidParameter);
[-] 	uint64_t e = _strtoui64 (p, &end, 16);
[+] 	uint64_t e = _strtoui64(p, &end, 16);
[-] 		return err::fail (err::SystemErrorCode_InvalidParameter);
[+] 		return err::fail(err::SystemErrorCode_InvalidParameter);
[-] 		while (isspace (*p))
[+] 		while (isspace(*p))
[-] 			return err::fail (err::SystemErrorCode_InvalidParameter);
[+] 			return err::fail(err::SystemErrorCode_InvalidParameter);
[-] 	memset (this, 0, sizeof (Guid));
[+] 	memset(this, 0, sizeof(Guid));
[-] 	m_data4 [0] = (uint8_t) ((d & 0xff00) >> 8);
[+] 	m_data4[0] = (uint8_t)((d & 0xff00) >> 8);
[-] 	m_data4 [1] = (uint8_t) (d & 0x00ff);
[+] 	m_data4[1] = (uint8_t)(d & 0x00ff);
[-] 	m_data4 [2] = (uint8_t) ((e & 0xff0000000000) >> 40);
[+] 	m_data4[2] = (uint8_t)((e & 0xff0000000000) >> 40);
[-] 	m_data4 [3] = (uint8_t) ((e & 0x00ff00000000) >> 32);
[+] 	m_data4[3] = (uint8_t)((e & 0x00ff00000000) >> 32);
[-] 	m_data4 [4] = (uint8_t) ((e & 0x0000ff000000) >> 24);
[+] 	m_data4[4] = (uint8_t)((e & 0x0000ff000000) >> 24);
[-] 	m_data4 [5] = (uint8_t) ((e & 0x000000ff0000) >> 16);
[+] 	m_data4[5] = (uint8_t)((e & 0x000000ff0000) >> 16);
[-] 	m_data4 [6] = (uint8_t) ((e & 0x00000000ff00) >> 8);
[+] 	m_data4[6] = (uint8_t)((e & 0x00000000ff00) >> 8);
[-] 	m_data4 [7] = (uint8_t) (e & 0x0000000000ff);
[+] 	m_data4[7] = (uint8_t)(e & 0x0000000000ff);
[-] Guid::getString (uint_t flags) const
[+] Guid::getString(uint_t flags) const
[-] 	static const char* formatTable [2] [2] =
[+] 	static const char* formatTable[2] [2] =
[-] 	return sl::formatString (
[+] 	return sl::formatString(
[-] 		formatTable [i1] [i2],
[+] 		formatTable[i1] [i2],
[-] 		m_data4 [0], m_data4 [1],
[+] 		m_data4[0], m_data4[1],
[-] 		m_data4 [2], m_data4 [3],
[+] 		m_data4[2], m_data4[3],
[-] 		m_data4 [4], m_data4 [5],
[+] 		m_data4[4], m_data4[5],
[-] 		m_data4 [6], m_data4 [7]
[+] 		m_data4[6], m_data4[7]
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sl_Hash.cpp
----------------------
[-] checksum16 (
[+] checksum16(
[-] 	ushort_t* p = (ushort_t*) _p;
[+] 	ushort_t* p = (ushort_t*)_p;
[-] 	uchar_t* last = (uchar_t*) _p + size - 1;
[+] 	uchar_t* last = (uchar_t*)_p + size - 1;
[-] 	for (; (uchar_t*) p < last; p++)
[+] 	for (; (uchar_t*)p < last; p++)
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sl_MemMem.cpp
----------------------
[-] memMem (
[+] memMem(
[-] 	BinaryBoyerMooreFind find (p2, size2, BoyerMooreFlag_Horspool);
[+] 	BinaryBoyerMooreFind find(p2, size2, BoyerMooreFlag_Horspool);
[-] 	size_t offset = find.find (p1, size1);
[+] 	size_t offset = find.find(p1, size1);
[-] 	return offset != -1 ? (char*) p1 + offset : NULL;
[+] 	return offset != -1 ? (char*)p1 + offset : NULL;
[-] reverseMemMem (
[+] reverseMemMem(
[-] 	BinaryBoyerMooreFind find (p2, size2, BoyerMooreFlag_Horspool | BoyerMooreFlag_Reverse);
[+] 	BinaryBoyerMooreFind find(p2, size2, BoyerMooreFlag_Horspool | BoyerMooreFlag_Reverse);
[-] 	size_t offset = find.find (p1, size1);
[+] 	size_t offset = find.find(p1, size1);
[-] 	return offset != -1 ? (char*) p1 + offset : NULL;
[+] 	return offset != -1 ? (char*)p1 + offset : NULL;
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sl_Packer.cpp
----------------------
[-] PackerSeq::pack_va (
[+] PackerSeq::pack_va(
[-] 	size_t count = m_sequence.getCount ();
[+] 	size_t count = m_sequence.getCount();
[-] 			va = m_sequence [i]->pack_va (NULL, &size, va);
[+] 			va = m_sequence[i]->pack_va(NULL, &size, va);
[-] 		uchar_t* p = (uchar_t*) _p;
[+] 		uchar_t* p = (uchar_t*)_p;
[-] 			va = m_sequence [i]->pack_va (p, &size, va);
[+] 			va = m_sequence[i]->pack_va(p, &size, va);
[-] PackerSeq::appendFormat (const char* formatString)
[+] PackerSeq::appendFormat(const char* formatString)
[-] 		return m_sequence.getCount ();
[+] 		return m_sequence.getCount();
[-] 		switch (*pF)
[+] 		switch(*pF)
[-] 			append <Pack <int> > ();
[+] 			append<Pack<int> > ();
[-] 			append <Pack <double> > ();
[+] 			append<Pack<double> > ();
[-] 			append <Pack <size_t> > ();
[+] 			append<Pack<size_t> > ();
[-] 			append <PackString> ();
[+] 			append<PackString> ();
[-] 			append <Pack <char> > ();
[+] 			append<Pack<char> > ();
[-] 			append <PackString_w> ();
[+] 			append<PackString_w> ();
[-] 			append <Pack <wchar_t> > ();
[+] 			append<Pack<wchar_t> > ();
[-] 			append <Pack <uint8_t> > ();
[+] 			append<Pack<uint8_t> > ();
[-] 			append <Pack <uint16_t> > ();
[+] 			append<Pack<uint16_t> > ();
[-] 			append <Pack <uint32_t> > ();
[+] 			append<Pack<uint32_t> > ();
[-] 			append <Pack <size_t> > ();
[+] 			append<Pack<size_t> > ();
[-] 			append <PackPtrSize> ();
[+] 			append<PackPtrSize> ();
[-] 			append <PackLastError> ();
[+] 			append<PackLastError> ();
[-] 	return m_sequence.getCount ();
[+] 	return m_sequence.getCount();
[-] Package::append_va (
[+] Package::append_va(
[-] 	packer->pack_va (NULL, &size, va);
[+] 	packer->pack_va(NULL, &size, va);
[-] 	size_t oldSize = m_buffer.getCount ();
[+] 	size_t oldSize = m_buffer.getCount();
[-] 	result = m_buffer.setCount (newSize);
[+] 	result = m_buffer.setCount(newSize);
[-] 	packer->pack_va (m_buffer + oldSize, &size, va);
[+] 	packer->pack_va(m_buffer + oldSize, &size, va);
[-] Package::append (
[+] Package::append(
[-] 	size_t oldSize = m_buffer.getCount ();
[+] 	size_t oldSize = m_buffer.getCount();
[-] 	result = m_buffer.setCount (newSize);
[+] 	result = m_buffer.setCount(newSize);
[-] 	memcpy (m_buffer + oldSize, p, size);
[+] 	memcpy(m_buffer + oldSize, p, size);
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sl_Packetizer.cpp
----------------------
[-] PacketizerRoot::writeImpl (
[+] PacketizerRoot::writeImpl(
[-] 	const char* p = (char*) p0;
[+] 	const char* p = (char*)p0;
[-] 	size_t bufferSize = m_buffer.getCount ();
[+] 	size_t bufferSize = m_buffer.getCount();
[-] 	while (bufferSize < sizeof (uint32_t)) // append signature byte-by-byte
[+] 	while (bufferSize < sizeof(uint32_t)) // append signature byte-by-byte
[-] 		if (c == signature [bufferSize])
[+] 		if (c == signature[bufferSize])
[-] 			m_buffer.append (c);
[+] 			m_buffer.append(c);
[-] 			m_buffer.clear ();
[+] 			m_buffer.clear();
[-] 			if (c == signature [0])
[+] 			if (c == signature[0])
[-] 				m_buffer.copy (c);
[+] 				m_buffer.copy(c);
[-] 	if (bufferSize < sizeof (uint64_t)) // packet size
[+] 	if (bufferSize < sizeof(uint64_t)) // packet size
[-] 		size_t chunkSize = sizeof (uint64_t) - bufferSize;
[+] 		size_t chunkSize = sizeof(uint64_t) - bufferSize;
[-] 			m_buffer.append (p, size);
[+] 			m_buffer.append(p, size);
[-] 		m_buffer.append (p, chunkSize);
[+] 		m_buffer.append(p, chunkSize);
[-] 		bufferSize = sizeof (uint64_t);
[+] 		bufferSize = sizeof(uint64_t);
[-] 	uint32_t dataSize = ((const uint32_t*) m_buffer.cp ()) [1];
[+] 	uint32_t dataSize = ((const uint32_t*) m_buffer.cp()) [1];
[-] 	uint32_t packetSize = sizeof (uint64_t) + dataSize;
[+] 	uint32_t packetSize = sizeof(uint64_t) + dataSize;
[-] 			m_buffer.append (p, size);
[+] 			m_buffer.append(p, size);
[-] 		m_buffer.append (p, chunkSize);
[+] 		m_buffer.append(p, chunkSize);
[-] 	ASSERT (size0 >= size);
[+] 	ASSERT(size0 >= size);
[-] LegacyPacketizerRoot::createHdr (size_t size)
[+] LegacyPacketizerRoot::createHdr(size_t size)
[-] 	hdr.m_dataSize = (uint16_t) size;
[+] 	hdr.m_dataSize = (uint16_t)size;
[-] 	hdr.m_checksum = checksum16 (&hdr, sizeof (hdr));
[+] 	hdr.m_checksum = checksum16(&hdr, sizeof(hdr));
[-] LegacyPacketizerRoot::writeImpl (
[+] LegacyPacketizerRoot::writeImpl(
[-] 	const char* p = (char*) p0;
[+] 	const char* p = (char*)p0;
[-] 	size_t bufferSize = m_buffer.getCount ();
[+] 	size_t bufferSize = m_buffer.getCount();
[-] 	while (bufferSize < sizeof (uint32_t)) // append signature byte-by-byte
[+] 	while (bufferSize < sizeof(uint32_t)) // append signature byte-by-byte
[-] 		if (c == signature [bufferSize])
[+] 		if (c == signature[bufferSize])
[-] 			m_buffer.append (c);
[+] 			m_buffer.append(c);
[-] 			m_buffer.clear ();
[+] 			m_buffer.clear();
[-] 			if (c == signature [0])
[+] 			if (c == signature[0])
[-] 				m_buffer.copy (c);
[+] 				m_buffer.copy(c);
[-] 	if (bufferSize < sizeof (uint64_t)) // packet size and crc
[+] 	if (bufferSize < sizeof(uint64_t)) // packet size and crc
[-] 		size_t chunkSize = sizeof (uint64_t) - bufferSize;
[+] 		size_t chunkSize = sizeof(uint64_t) - bufferSize;
[-] 			m_buffer.append (p, size);
[+] 			m_buffer.append(p, size);
[-] 		m_buffer.append (p, chunkSize);
[+] 		m_buffer.append(p, chunkSize);
[-] 		uint16_t checksum = checksum16 (m_buffer, sizeof (uint64_t));
[+] 		uint16_t checksum = checksum16(m_buffer, sizeof(uint64_t));
[-] 		bufferSize = sizeof (uint64_t);
[+] 		bufferSize = sizeof(uint64_t);
[-] 	uint32_t dataSize = ((const PacketHdr*) m_buffer.cp ())->m_dataSize;
[+] 	uint32_t dataSize = ((const PacketHdr*) m_buffer.cp())->m_dataSize;
[-] 	uint32_t packetSize = sizeof (uint64_t) + dataSize;
[+] 	uint32_t packetSize = sizeof(uint64_t) + dataSize;
[-] 			m_buffer.append (p, size);
[+] 			m_buffer.append(p, size);
[-] 		m_buffer.append (p, chunkSize);
[+] 		m_buffer.append(p, chunkSize);
[-] 	ASSERT (size0 >= size);
[+] 	ASSERT(size0 >= size);
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sl_Unpacker.cpp
----------------------
[-] Unpacker::scan_va (
[+] Unpacker::scan_va(
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_drw_MachError.cpp
----------------------
[-] MachError::create (mach_error_t code)
[+] MachError::create(mach_error_t code)
[-] 	err::ErrorHdr* error = createBuffer (sizeof (err::ErrorHdr));
[+] 	err::ErrorHdr* error = createBuffer(sizeof(err::ErrorHdr));
[-] 	error->m_size = sizeof (err::ErrorHdr);
[+] 	error->m_size = sizeof(err::ErrorHdr);
[-] 	return sizeof (err::ErrorHdr);
[+] 	return sizeof(err::ErrorHdr);
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_drw_Semaphore.cpp
----------------------
[-] Semaphore::wait (uint_t timeout)
[+] Semaphore::wait(uint_t timeout)
[-] 	mach_error_t result = ::semaphore_timedwait (m_semaphore, tspec);
[+] 	mach_error_t result = ::semaphore_timedwait(m_semaphore, tspec);
[-] 	return result == 0 ? true : err::fail (sys::drw::MachError (result));
[+] 	return result == 0 ? true : err::fail(sys::drw::MachError(result));
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_lnx_Udev.cpp
----------------------
[-] UdevContext::create ()
[+] UdevContext::create()
[-] 	close ();
[+] 	close();
[-] 	m_h = udev_new ();
[+] 	m_h = udev_new();
[-] 	return completeUdev (m_h != NULL, "udev_new");
[+] 	return completeUdev(m_h != NULL, "udev_new");
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_psx_Cond.cpp
----------------------
[-] Cond::wait (
[+] Cond::wait(
[-] 	switch (timeout)
[+] 	switch(timeout)
[-] 		result = ::pthread_cond_wait (&m_cond, mutex);
[+] 		result = ::pthread_cond_wait(&m_cond, mutex);
[-] 		sys::getAbsTimespecFromTimeout (timeout, &timespec);
[+] 		sys::getAbsTimespecFromTimeout(timeout, &timespec);
[-] 		result = ::pthread_cond_timedwait (&m_cond, mutex, &timespec);
[+] 		result = ::pthread_cond_timedwait(&m_cond, mutex, &timespec);
[-] 	return result == 0 ? true : err::fail (result);
[+] 	return result == 0 ? true : err::fail(result);
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_psx_DynamicLibrary.cpp
----------------------
[-] DynamicLibrary::open (
[+] DynamicLibrary::open(
[-] 	close ();
[+] 	close();
[-] 	m_h = ::dlopen (name.sz (), flags);
[+] 	m_h = ::dlopen(name.sz(), flags);
[-] 		err::setError (::dlerror ());
[+] 		err::setError(::dlerror());
[-] DynamicLibrary::getSymbol (const sl::StringRef& name)
[+] DynamicLibrary::getSymbol(const sl::StringRef& name)
[-] 	void* p = ::dlsym (m_h, name.sz ());
[+] 	void* p = ::dlsym(m_h, name.sz());
[-] 		err::setError (::dlerror ());
[+] 		err::setError(::dlerror());
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_psx_Mutex.cpp
----------------------
[-] MutexAttr::getProcessShared (int* value) const
[+] MutexAttr::getProcessShared(int* value) const
[-] 	int result = ::pthread_mutexattr_getpshared (&m_attr, value);
[+] 	int result = ::pthread_mutexattr_getpshared(&m_attr, value);
[-] 	return result == 0 ? true : err::fail (result);
[+] 	return result == 0 ? true : err::fail(result);
[-] MutexAttr::setProcessShared (int value)
[+] MutexAttr::setProcessShared(int value)
[-] 	int result = ::pthread_mutexattr_setpshared (&m_attr, value);
[+] 	int result = ::pthread_mutexattr_setpshared(&m_attr, value);
[-] 	return result == 0 ? true : err::fail (result);
[+] 	return result == 0 ? true : err::fail(result);
[-] MutexAttr::getType (int* value) const
[+] MutexAttr::getType(int* value) const
[-] 	int result = ::pthread_mutexattr_gettype (&m_attr, value);
[+] 	int result = ::pthread_mutexattr_gettype(&m_attr, value);
[-] 	return result == 0 ? true : err::fail (result);
[+] 	return result == 0 ? true : err::fail(result);
[-] MutexAttr::setType (int value)
[+] MutexAttr::setType(int value)
[-] 	int result = ::pthread_mutexattr_settype (&m_attr, value);
[+] 	int result = ::pthread_mutexattr_settype(&m_attr, value);
[-] 	return result == 0 ? true : err::fail (result);
[+] 	return result == 0 ? true : err::fail(result);
[-] Mutex::tryLock ()
[+] Mutex::tryLock()
[-] 	int result = ::pthread_mutex_trylock (&m_mutex);
[+] 	int result = ::pthread_mutex_trylock(&m_mutex);
[-] 	return result == 0 ? true : err::fail (result);
[+] 	return result == 0 ? true : err::fail(result);
[-] Mutex::lock (uint_t timeout)
[+] Mutex::lock(uint_t timeout)
[-] 	switch (timeout)
[+] 	switch(timeout)
[-] 		result = ::pthread_mutex_trylock (&m_mutex);
[+] 		result = ::pthread_mutex_trylock(&m_mutex);
[-] 		result = ::pthread_mutex_lock (&m_mutex);
[+] 		result = ::pthread_mutex_lock(&m_mutex);
[-] 		sys::getAbsTimespecFromTimeout (timeout, &ts);
[+] 		sys::getAbsTimespecFromTimeout(timeout, &ts);
[-] 		result = ::pthread_mutex_timedlock (&m_mutex, &ts);
[+] 		result = ::pthread_mutex_timedlock(&m_mutex, &ts);
[-] 	return result == 0 ? true : err::fail (result);
[+] 	return result == 0 ? true : err::fail(result);
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_psx_Sem.cpp
----------------------
[-] Sem::wait (uint_t timeout)
[+] Sem::wait(uint_t timeout)
[-] 	switch (timeout)
[+] 	switch(timeout)
[-] 		result = ::sem_trywait (&m_sem);
[+] 		result = ::sem_trywait(&m_sem);
[-] 		result = ::sem_wait (&m_sem);
[+] 		result = ::sem_wait(&m_sem);
[-] 		sys::getAbsTimespecFromTimeout (timeout, &timespec);
[+] 		sys::getAbsTimespecFromTimeout(timeout, &timespec);
[-] 		result = sem_timedwait (&m_sem, &timespec);
[+] 		result = sem_timedwait(&m_sem, &timespec);
[-] 	return err::complete (result == 0);
[+] 	return err::complete(result == 0);
[-] NamedSem::open (
[+] NamedSem::open(
[-] 	close ();
[+] 	close();
[-] 	m_h = ::sem_open (name.sz (), flags, mode, value);
[+] 	m_h = ::sem_open(name.sz(), flags, mode, value);
[-] 	return err::complete (m_h != SEM_FAILED);
[+] 	return err::complete(m_h != SEM_FAILED);
[-] NamedSem::wait (uint_t timeout)
[+] NamedSem::wait(uint_t timeout)
[-] 	switch (timeout)
[+] 	switch(timeout)
[-] 		result = ::sem_trywait (m_h);
[+] 		result = ::sem_trywait(m_h);
[-] 		result = ::sem_wait (m_h);
[+] 		result = ::sem_wait(m_h);
[-] 		sys::getAbsTimespecFromTimeout (timeout, &timespec);
[+] 		sys::getAbsTimespecFromTimeout(timeout, &timespec);
[-] 		result = ::sem_timedwait (m_h, &timespec);
[+] 		result = ::sem_timedwait(m_h, &timespec);
[-] 	return err::complete (result == 0);
[+] 	return err::complete(result == 0);
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_psx_Thread.cpp
----------------------
[-] Thread::create (
[+] Thread::create(
[-] 	detach ();
[+] 	detach();
[-] 	int result = ::pthread_create (&m_threadId, attr, threadFunc, context);
[+] 	int result = ::pthread_create(&m_threadId, attr, threadFunc, context);
[-] 		return err::fail (result);
[+] 		return err::fail(result);
[-] Thread::join (void** retVal)
[+] Thread::join(void** retVal)
[-] 	int result = ::pthread_join (m_threadId, retVal);
[+] 	int result = ::pthread_join(m_threadId, retVal);
[-] 		return err::fail (result);
[+] 		return err::fail(result);
[-] Thread::tryJoin (void** retVal)
[+] Thread::tryJoin(void** retVal)
[-] 	int result = ::pthread_tryjoin_np (m_threadId, retVal);
[+] 	int result = ::pthread_tryjoin_np(m_threadId, retVal);
[-] 		return err::fail (result);
[+] 		return err::fail(result);
[-] Thread::join (
[+] Thread::join(
[-] 	switch (timeout)
[+] 	switch(timeout)
[-] 		result = ::pthread_tryjoin_np (m_threadId, retVal);
[+] 		result = ::pthread_tryjoin_np(m_threadId, retVal);
[-] 		result = ::pthread_join (m_threadId, retVal);
[+] 		result = ::pthread_join(m_threadId, retVal);
[-] 		sys::getAbsTimespecFromTimeout (timeout, &timespec);
[+] 		sys::getAbsTimespecFromTimeout(timeout, &timespec);
[-] 		result = ::pthread_timedjoin_np (m_threadId, retVal, &timespec);
[+] 		result = ::pthread_timedjoin_np(m_threadId, retVal, &timespec);
[-] 		return err::fail (result);
[+] 		return err::fail(result);
[-] Thread::detach ()
[+] Thread::detach()
[-] 	int result = ::pthread_detach (m_threadId);
[+] 	int result = ::pthread_detach(m_threadId);
[-] 		return err::fail (result);
[+] 		return err::fail(result);
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_ReadWriteLock.cpp
----------------------
[-] ReadWriteLock::close ()
[+] ReadWriteLock::close()
[-] 	if (m_data && m_data != m_mapping.p ())
[+] 	if (m_data && m_data != m_mapping.p())
[-] 		AXL_MEM_FREE ((void*) m_data);
[+] 		AXL_MEM_FREE((void*)m_data);
[-] 	m_readEvent.close ();
[+] 	m_readEvent.close();
[-] 	m_writeEvent.close ();
[+] 	m_writeEvent.close();
[-] 	m_mapping.close ();
[+] 	m_mapping.close();
[-] ReadWriteLock::create ()
[+] ReadWriteLock::create()
[-] 	close ();
[+] 	close();
[-] 	m_data = AXL_MEM_ZERO_NEW (Data);
[+] 	m_data = AXL_MEM_ZERO_NEW(Data);
[-] 	m_readEvent.create ();
[+] 	m_readEvent.create();
[-] 	m_writeEvent.create ();
[+] 	m_writeEvent.create();
[-] ReadWriteLock::create (
[+] ReadWriteLock::create(
[-] 	close ();
[+] 	close();
[-] 		m_mapping.open (mappingName, sizeof (Data)) &&
[+] 		m_mapping.open(mappingName, sizeof(Data)) &&
[-] 		m_readEvent.create (readEventName) &&
[+] 		m_readEvent.create(readEventName) &&
[-] 		m_writeEvent.create (writeEventName);
[+] 		m_writeEvent.create(writeEventName);
[-] 	m_data = (Data*) m_mapping.p ();
[+] 	m_data = (Data*)m_mapping.p();
[-] 	memset ((void*) m_data, 0, sizeof (Data));
[+] 	memset((void*)m_data, 0, sizeof(Data));
[-] ReadWriteLock::open (
[+] ReadWriteLock::open(
[-] 	close ();
[+] 	close();
[-] 		m_mapping.open (mappingName, sizeof (Data), io::FileFlag_OpenExisting) &&
[+] 		m_mapping.open(mappingName, sizeof(Data), io::FileFlag_OpenExisting) &&
[-] 		m_readEvent.open (readEventName) &&
[+] 		m_readEvent.open(readEventName) &&
[-] 		m_writeEvent.open (writeEventName);
[+] 		m_writeEvent.open(writeEventName);
[-] 	m_data = (Data*) m_mapping.p ();
[+] 	m_data = (Data*)m_mapping.p();
[-] 		err::setError (err::SystemErrorCode_InvalidParameter);
[+] 		err::setError(err::SystemErrorCode_InvalidParameter);
[-] ReadWriteLock::readLock (uint_t timeout)
[+] ReadWriteLock::readLock(uint_t timeout)
[-] 	sys::atomicLock (&m_data->m_lock);
[+] 	sys::atomicLock(&m_data->m_lock);
[-] 		sys::atomicUnlock (&m_data->m_lock);
[+] 		sys::atomicUnlock(&m_data->m_lock);
[-] 		m_readEvent.reset ();
[+] 		m_readEvent.reset();
[-] 		sys::atomicUnlock (&m_data->m_lock);
[+] 		sys::atomicUnlock(&m_data->m_lock);
[-] 		result = m_readEvent.wait (timeout);
[+] 		result = m_readEvent.wait(timeout);
[-] 		sys::atomicLock (&m_data->m_lock);
[+] 		sys::atomicLock(&m_data->m_lock);
[-] 				m_writeEvent.signal ();
[+] 				m_writeEvent.signal();
[-] 	sys::atomicUnlock (&m_data->m_lock);
[+] 	sys::atomicUnlock(&m_data->m_lock);
[-] ReadWriteLock::readUnlock ()
[+] ReadWriteLock::readUnlock()
[-] 	sys::atomicLock (&m_data->m_lock);
[+] 	sys::atomicLock(&m_data->m_lock);
[-] 	ASSERT (m_data->m_activeReadCount && !m_data->m_activeWriteCount);
[+] 	ASSERT(m_data->m_activeReadCount && !m_data->m_activeWriteCount);
[-] 			m_writeEvent.signal ();
[+] 			m_writeEvent.signal();
[-] 			m_readEvent.signal ();
[+] 			m_readEvent.signal();
[-] 	sys::atomicUnlock (&m_data->m_lock);
[+] 	sys::atomicUnlock(&m_data->m_lock);
[-] ReadWriteLock::writeLock (uint_t timeout)
[+] ReadWriteLock::writeLock(uint_t timeout)
[-] 	sys::atomicLock (&m_data->m_lock);
[+] 	sys::atomicLock(&m_data->m_lock);
[-] 		sys::atomicUnlock (&m_data->m_lock);
[+] 		sys::atomicUnlock(&m_data->m_lock);
[-] 		m_writeEvent.reset ();
[+] 		m_writeEvent.reset();
[-] 		sys::atomicUnlock (&m_data->m_lock);
[+] 		sys::atomicUnlock(&m_data->m_lock);
[-] 		result = m_writeEvent.wait (timeout);
[+] 		result = m_writeEvent.wait(timeout);
[-] 		sys::atomicLock (&m_data->m_lock);
[+] 		sys::atomicLock(&m_data->m_lock);
[-] 				m_readEvent.signal ();
[+] 				m_readEvent.signal();
[-] 	sys::atomicUnlock (&m_data->m_lock);
[+] 	sys::atomicUnlock(&m_data->m_lock);
[-] ReadWriteLock::writeUnlock ()
[+] ReadWriteLock::writeUnlock()
[-] 	sys::atomicLock (&m_data->m_lock);
[+] 	sys::atomicLock(&m_data->m_lock);
[-] 	ASSERT (!m_data->m_activeReadCount && m_data->m_activeWriteCount == 1);
[+] 	ASSERT(!m_data->m_activeReadCount && m_data->m_activeWriteCount == 1);
[-] 		m_readEvent.signal ();
[+] 		m_readEvent.signal();
[-] 		m_writeEvent.signal ();
[+] 		m_writeEvent.signal();
[-] 	sys::atomicUnlock (&m_data->m_lock);
[+] 	sys::atomicUnlock(&m_data->m_lock);
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_Time.cpp
----------------------
[-] GetSystemTimePreciseAsFileTimeFunc (FILETIME* time);
[+] GetSystemTimePreciseAsFileTimeFunc(FILETIME* time);
[-] initPreciseTimestamps ()
[+] initPreciseTimestamps()
[-] 	HMODULE kernel32 = ::GetModuleHandleW (L"kernel32.dll");
[+] 	HMODULE kernel32 = ::GetModuleHandleW(L"kernel32.dll");
[-] 	ASSERT (kernel32);
[+] 	ASSERT(kernel32);
[-] 	systemTimePreciseAsFileTime = (GetSystemTimePreciseAsFileTimeFunc*) ::GetProcAddress (kernel32, "GetSystemTimePreciseAsFileTime");
[+] 	systemTimePreciseAsFileTime = (GetSystemTimePreciseAsFileTimeFunc*) ::GetProcAddress(kernel32, "GetSystemTimePreciseAsFileTime");
[-] initPreciseTimestamps ()
[+] initPreciseTimestamps()
[-] 	mach_timebase_info (&g_machTimeBaseInfo);
[+] 	mach_timebase_info(&g_machTimeBaseInfo);
[-] 	g_machBaseTimestamp = sys::getTimestamp ();
[+] 	g_machBaseTimestamp = sys::getTimestamp();
[-] 	g_machBaseAbsoluteTime = mach_absolute_time ();
[+] 	g_machBaseAbsoluteTime = mach_absolute_time();
[-] initPreciseTimestamps ()
[+] initPreciseTimestamps()
[-] getTimestamp ()
[+] getTimestamp()
[-] 	::GetSystemTimeAsFileTime ((FILETIME*) &timestamp);
[+] 	::GetSystemTimeAsFileTime((FILETIME*) &timestamp);
[-] 	gettimeofday (&tval, NULL);
[+] 	gettimeofday(&tval, NULL);
[-] 	timestamp = (uint64_t) (tval.tv_sec + AXL_SYS_EPOCH_DIFF) * 10000000 + tval.tv_usec * 10;
[+] 	timestamp = (uint64_t)(tval.tv_sec + AXL_SYS_EPOCH_DIFF) * 10000000 + tval.tv_usec * 10;
[-] 	clock_gettime (CLOCK_REALTIME_COARSE, &tspec);
[+] 	clock_gettime(CLOCK_REALTIME_COARSE, &tspec);
[-] 	clock_gettime (CLOCK_REALTIME, &tspec);
[+] 	clock_gettime(CLOCK_REALTIME, &tspec);
[-] 	timestamp = (uint64_t) (tspec.tv_sec + AXL_SYS_EPOCH_DIFF) * 10000000 + tspec.tv_nsec / 100;
[+] 	timestamp = (uint64_t)(tspec.tv_sec + AXL_SYS_EPOCH_DIFF) * 10000000 + tspec.tv_nsec / 100;
[-] getPreciseTimestamp ()
[+] getPreciseTimestamp()
[-] 	systemTimePreciseAsFileTime ((FILETIME*) &timestamp);
[+] 	systemTimePreciseAsFileTime((FILETIME*) &timestamp);
[-] 	uint64_t elapsed = mach_absolute_time () - g_machBaseAbsoluteTime;
[+] 	uint64_t elapsed = mach_absolute_time() - g_machBaseAbsoluteTime;
[-] 	gettimeofday (&tval, NULL);
[+] 	gettimeofday(&tval, NULL);
[-] 	timestamp = (uint64_t) (tval.tv_sec + AXL_SYS_EPOCH_DIFF) * 10000000 + tval.tv_usec * 10;
[+] 	timestamp = (uint64_t)(tval.tv_sec + AXL_SYS_EPOCH_DIFF) * 10000000 + tval.tv_usec * 10;
[-] 	clock_gettime (CLOCK_REALTIME, &tspec);
[+] 	clock_gettime(CLOCK_REALTIME, &tspec);
[-] 	timestamp = (uint64_t) (tspec.tv_sec + AXL_SYS_EPOCH_DIFF) * 10000000 + tspec.tv_nsec / 100;
[+] 	timestamp = (uint64_t)(tspec.tv_sec + AXL_SYS_EPOCH_DIFF) * 10000000 + tspec.tv_nsec / 100;
[-] sleep (uint32_t msCount)
[+] sleep(uint32_t msCount)
[-] 	::Sleep (msCount);
[+] 	::Sleep(msCount);
[-] 	getTimespecFromTimeout (msCount, &timespec);
[+] 	getTimespecFromTimeout(msCount, &timespec);
[-] 	nanosleep (&timespec, NULL);
[+] 	nanosleep(&timespec, NULL);
[-] Time::getTimestampImpl (
[+] Time::getTimestampImpl(
[-] 	::SystemTimeToFileTime (&sysTime, (FILETIME*) &timestamp);
[+] 	::SystemTimeToFileTime(&sysTime, (FILETIME*) &timestamp);
[-] 		::FileTimeToLocalFileTime ((const FILETIME*) &timestamp, (FILETIME*) &timestamp);
[+] 		::FileTimeToLocalFileTime((const FILETIME*) &timestamp, (FILETIME*) &timestamp);
[-] 		timestamp += (int64_t) getTimeZoneOffsetInMinutes (timeZone) * 60 * 10000000;
[+] 		timestamp += (int64_t)getTimeZoneOffsetInMinutes(timeZone)* 60 * 10000000;
[-] 		mktime (&tmStruct) :
[+] 		mktime(&tmStruct) :
[-] 		timegm (&tmStruct) + getTimeZoneOffsetInMinutes (timeZone) * 60;
[+] 		timegm(&tmStruct) + getTimeZoneOffsetInMinutes(timeZone)* 60;
[-] 	timestamp = (uint64_t) (posixTime + AXL_SYS_EPOCH_DIFF) * 10000000;
[+] 	timestamp = (uint64_t)(posixTime + AXL_SYS_EPOCH_DIFF) * 10000000;
[-] Time::setTimestampImpl (
[+] Time::setTimestampImpl(
[-] 		::FileTimeToLocalFileTime ((const FILETIME*) &timestamp, (FILETIME*) &timestamp);
[+] 		::FileTimeToLocalFileTime((const FILETIME*) &timestamp, (FILETIME*) &timestamp);
[-] 		timestamp += (int64_t) getTimeZoneOffsetInMinutes (timeZone) * 60 * 10000000;
[+] 		timestamp += (int64_t)getTimeZoneOffsetInMinutes(timeZone)* 60 * 10000000;
[-] 	::FileTimeToSystemTime ((const FILETIME*) &timestamp, &sysTime);
[+] 	::FileTimeToSystemTime((const FILETIME*) &timestamp, &sysTime);
[-] 		tmStruct = localtime (&posixTime);
[+] 		tmStruct = localtime(&posixTime);
[-] 		posixTime += getTimeZoneOffsetInMinutes (timeZone) * 60;
[+] 		posixTime += getTimeZoneOffsetInMinutes(timeZone)* 60;
[-] 		tmStruct = gmtime (&posixTime);
[+] 		tmStruct = gmtime(&posixTime);
[-] 	%p	p/a (lower-case pm/am)
[+] 	%p	p/a(lower-case pm/am)
[-] 	%P	P/A (upper-case PM/AM)
[+] 	%P	P/A(upper-case PM/AM)
[-] 	%D	day of month (leading zero if one-digit)
[+] 	%D	day of month(leading zero if one-digit)
[-] 	%d	day of month (no leading-zero)
[+] 	%d	day of month(no leading-zero)
[-] 	%M	month number (leading zero if one-digit)
[+] 	%M	month number(leading zero if one-digit)
[-] 	%o	month number (no leading-zero)
[+] 	%o	month number(no leading-zero)
[-] 	%n	month name (short)
[+] 	%n	month name(short)
[-] 	%N	month name (full)
[+] 	%N	month name(full)
[-] 	%w	day of week (short)
[+] 	%w	day of week(short)
[-] 	%W	day of week (full)
[+] 	%W	day of week(full)
[-] Time::format (
[+] Time::format(
[-] 	static const char* weekDayShortNameTable [7] =
[+] 	static const char* weekDayShortNameTable[7] =
[-] 	static const char* weekDayFullNameTable [7] =
[+] 	static const char* weekDayFullNameTable[7] =
[-] 	static const char* monthShortNameTable [12] =
[+] 	static const char* monthShortNameTable[12] =
[-] 	static const char* monthFullNameTable [12] =
[+] 	static const char* monthFullNameTable[12] =
[-] 	string->clear ();
[+] 	string->clear();
[-] 	const char* p = formatString.cp ();
[+] 	const char* p = formatString.cp();
[-] 	const char* end = formatString.getEnd ();
[+] 	const char* end = formatString.getEnd();
[-] 		string->append (p0, p - p0);
[+] 		string->append(p0, p - p0);
[-] 			return string->getLength ();
[+] 			return string->getLength();
[-] 		switch (*p)
[+] 		switch(*p)
[-] 			string->appendFormat ("%02d", m_hour);
[+] 			string->appendFormat("%02d", m_hour);
[-] 			string->appendFormat ("%d", h12 ? h12 : 12);
[+] 			string->appendFormat("%d", h12 ? h12 : 12);
[-] 			string->appendFormat ("%02d", m_minute);
[+] 			string->appendFormat("%02d", m_minute);
[-] 			string->appendFormat ("%02d", m_second);
[+] 			string->appendFormat("%02d", m_second);
[-] 			string->appendFormat ("%03d", m_milliSecond);
[+] 			string->appendFormat("%03d", m_milliSecond);
[-] 			string->appendFormat ("%03d", m_microSecond);
[+] 			string->appendFormat("%03d", m_microSecond);
[-] 			string->append (m_hour >= 12 ? 'p' : 'a');
[+] 			string->append(m_hour >= 12 ? 'p' : 'a');
[-] 			string->append (m_hour >= 12 ? 'P' : 'A');
[+] 			string->append(m_hour >= 12 ? 'P' : 'A');
[-] 			string->appendFormat ("%02d", m_year % 100);
[+] 			string->appendFormat("%02d", m_year % 100);
[-] 			string->appendFormat ("%04d", m_year);
[+] 			string->appendFormat("%04d", m_year);
[-] 			string->appendFormat ("%02d", m_monthDay);
[+] 			string->appendFormat("%02d", m_monthDay);
[-] 			string->appendFormat ("%d", m_monthDay);
[+] 			string->appendFormat("%d", m_monthDay);
[-] 			string->appendFormat ("%02d", m_month + 1);
[+] 			string->appendFormat("%02d", m_month + 1);
[-] 			string->appendFormat ("%d", m_month + 1);
[+] 			string->appendFormat("%d", m_month + 1);
[-] 			string->append (monthShortNameTable [m_month % 12]);
[+] 			string->append(monthShortNameTable[m_month % 12]);
[-] 			string->append (monthFullNameTable [m_month % 12]);
[+] 			string->append(monthFullNameTable[m_month % 12]);
[-] 			string->append (weekDayShortNameTable [m_dayOfWeek % 7]);
[+] 			string->append(weekDayShortNameTable[m_dayOfWeek % 7]);
[-] 			string->append (weekDayFullNameTable [m_dayOfWeek % 7]);
[+] 			string->append(weekDayFullNameTable[m_dayOfWeek % 7]);
[-] 			string->append (*p);
[+] 			string->append(*p);
[-] 	string->append (p0, p - p0);
[+] 	string->append(p0, p - p0);
[-] 	return string->getLength ();
[+] 	return string->getLength();
[-] getAbsTimespecFromTimeout (
[+] getAbsTimespecFromTimeout(
[-] 	gettimeofday (&tval, NULL);
[+] 	gettimeofday(&tval, NULL);
[-] 	int result = clock_gettime (CLOCK_REALTIME, tspec);
[+] 	int result = clock_gettime(CLOCK_REALTIME, tspec);
[-] 	ASSERT (result == 0);
[+] 	ASSERT(result == 0);
[-] 	uint64_t nsec = tspec->tv_nsec + (uint64_t) (timeout % 1000) * 1000000;
[+] 	uint64_t nsec = tspec->tv_nsec + (uint64_t)(timeout % 1000) * 1000000;
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_TlsMgr.cpp
----------------------
[-] TlsMgr::TlsMgr ()
[+] TlsMgr::TlsMgr()
[-] 	m_tlsIdx = ::TlsAlloc ();
[+] 	m_tlsIdx = ::TlsAlloc();
[-] TlsMgr::~TlsMgr ()
[+] TlsMgr::~TlsMgr()
[-] 	Page* page = findCurrentThreadPage ();
[+] 	Page* page = findCurrentThreadPage();
[-] 		AXL_MEM_DELETE (page);
[+] 		AXL_MEM_DELETE(page);
[-] 		setCurrentThreadPage (NULL);
[+] 		setCurrentThreadPage(NULL);
[-] 	::TlsFree (m_tlsIdx);
[+] 	::TlsFree(m_tlsIdx);
[-] TlsMgr::tlsCallback (
[+] TlsMgr::tlsCallback(
[-] 	TlsMgr* self = getTlsMgr ();
[+] 	TlsMgr* self = getTlsMgr();
[-] 	Page* page = self->findCurrentThreadPage ();
[+] 	Page* page = self->findCurrentThreadPage();
[-] 	AXL_MEM_DELETE (page);
[+] 	AXL_MEM_DELETE(page);
[-] 	::TlsSetValue (self->m_tlsIdx, NULL);
[+] 	::TlsSetValue(self->m_tlsIdx, NULL);
[-] TlsMgr::TlsMgr ()
[+] TlsMgr::TlsMgr()
[-] 	::pthread_key_create (&m_tlsKey, tlsDestructor);
[+] 	::pthread_key_create(&m_tlsKey, tlsDestructor);
[-] TlsMgr::~TlsMgr ()
[+] TlsMgr::~TlsMgr()
[-] 	Page* page = findCurrentThreadPage ();
[+] 	Page* page = findCurrentThreadPage();
[-] 		AXL_MEM_DELETE (page);
[+] 		AXL_MEM_DELETE(page);
[-] 		setCurrentThreadPage (NULL);
[+] 		setCurrentThreadPage(NULL);
[-] 	::pthread_key_delete (m_tlsKey);
[+] 	::pthread_key_delete(m_tlsKey);
[-] TlsMgr::getSlotValue (size_t slot)
[+] TlsMgr::getSlotValue(size_t slot)
[-] 	Page* page = findCurrentThreadPage ();
[+] 	Page* page = findCurrentThreadPage();
[-] 	size_t count = page->m_array.getCount ();
[+] 	size_t count = page->m_array.getCount();
[-] 	sl::BoxListEntry <TlsValue>* entry = page->m_array [slot];
[+] 	sl::BoxListEntry<TlsValue>* entry = page->m_array[slot];
[-] TlsMgr::setSlotValue (
[+] TlsMgr::setSlotValue(
[-] 	Page* page = getCurrentThreadPage ();
[+] 	Page* page = getCurrentThreadPage();
[-] 	size_t count = page->m_array.getCount ();
[+] 	size_t count = page->m_array.getCount();
[-] 			return TlsValue ();
[+] 			return TlsValue();
[-] 		page->m_array.setCountZeroConstruct (slot + 1);
[+] 		page->m_array.setCountZeroConstruct(slot + 1);
[-] 	sl::BoxListEntry <TlsValue>* entry = page->m_array [slot];
[+] 	sl::BoxListEntry<TlsValue>* entry = page->m_array[slot];
[-] 			page->m_valueList.remove (entry);
[+] 			page->m_valueList.remove(entry);
[-] 			page->m_array [slot] = NULL;
[+] 			page->m_array[slot] = NULL;
[-] 		entry = page->m_valueList.insertTail (value).getEntry ();
[+] 		entry = page->m_valueList.insertTail(value).getEntry();
[-] 		page->m_array [slot] = entry;
[+] 		page->m_array[slot] = entry;
[-] TlsMgr::getCurrentThreadPage ()
[+] TlsMgr::getCurrentThreadPage()
[-] 	Page* page = findCurrentThreadPage ();
[+] 	Page* page = findCurrentThreadPage();
[-] 	page = AXL_MEM_NEW (Page);
[+] 	page = AXL_MEM_NEW(Page);
[-] 	setCurrentThreadPage (page);
[+] 	setCurrentThreadPage(page);
[-] #pragma section (AXL_SYS_TLS_CALLBACK_SECTION, long, read)
[+] #pragma section(AXL_SYS_TLS_CALLBACK_SECTION, long, read)
[-] __declspec(allocate (AXL_SYS_TLS_CALLBACK_SECTION))
[+] __declspec(allocate(AXL_SYS_TLS_CALLBACK_SECTION))
[-] #	pragma comment (linker, "/INCLUDE:_tls_used")
[+] #	pragma comment(linker, "/INCLUDE:_tls_used")
[-] #	pragma comment (linker, "/INCLUDE:axl_g_sys_pfTlsCallback")
[+] #	pragma comment(linker, "/INCLUDE:axl_g_sys_pfTlsCallback")
[-] #	pragma comment (linker, "/INCLUDE:__tls_used")
[+] #	pragma comment(linker, "/INCLUDE:__tls_used")
[-] #	pragma comment (linker, "/INCLUDE:_axl_g_sys_pfTlsCallback")
[+] #	pragma comment(linker, "/INCLUDE:_axl_g_sys_pfTlsCallback")
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_win_AccessToken.cpp
----------------------
[-] bool AccessToken::openProcessToken (
[+] bool AccessToken::openProcessToken(
[-] 	close ();
[+] 	close();
[-] 	bool_t result = ::OpenProcessToken (process, access, &m_h);
[+] 	bool_t result = ::OpenProcessToken(process, access, &m_h);
[-] 	return err::complete (result);
[+] 	return err::complete(result);
[-] AccessToken::openThreadToken (
[+] AccessToken::openThreadToken(
[-] 	close ();
[+] 	close();
[-] 	bool_t result = ::OpenThreadToken (thread, access, openAsSelf, &m_h);
[+] 	bool_t result = ::OpenThreadToken(thread, access, openAsSelf, &m_h);
[-] 	return err::complete (result);
[+] 	return err::complete(result);
[-] AccessToken::getTokenInformation (
[+] AccessToken::getTokenInformation(
[-] 	sl::Array <char>* buffer
[+] 	sl::Array<char>* buffer
[-] 	bool_t result = ::GetTokenInformation (m_h, infoClass, NULL, 0, &size);
[+] 	bool_t result = ::GetTokenInformation(m_h, infoClass, NULL, 0, &size);
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] 		buffer->setCount (size) &&
[+] 		buffer->setCount(size) &&
[-] 		getTokenInformation (infoClass, buffer->p (), size, &size);
[+] 		getTokenInformation(infoClass, buffer->p(), size, &size);
[-] AccessToken::isMemberOf (PSID group)
[+] AccessToken::isMemberOf(PSID group)
[-] 	sl::Array <char> buffer;
[+] 	sl::Array<char> buffer;
[-] 	bool result = getTokenInformation (TokenGroups, &buffer);
[+] 	bool result = getTokenInformation(TokenGroups, &buffer);
[-] 	ASSERT (buffer.getCount () >= sizeof (TOKEN_GROUPS));
[+] 	ASSERT(buffer.getCount() >= sizeof(TOKEN_GROUPS));
[-] 	const TOKEN_GROUPS* groups = (const TOKEN_GROUPS*) buffer.cp ();
[+] 	const TOKEN_GROUPS* groups = (const TOKEN_GROUPS*) buffer.cp();
[-] 		if (::EqualSid (groups->Groups [i].Sid, group))
[+] 		if (::EqualSid(groups->Groups[i].Sid, group))
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_win_Bstr.cpp
----------------------
[-] Bstr::copy (
[+] Bstr::copy(
[-] 	close ();
[+] 	close();
[-] 	m_h = ::SysAllocStringLen (p, length);
[+] 	m_h = ::SysAllocStringLen(p, length);
[-] 	return m_h ? true : err::fail (err::SystemErrorCode_InsufficientResources);
[+] 	return m_h ? true : err::fail(err::SystemErrorCode_InsufficientResources);
----------------------
27/02/2019 18:01:47 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_win_DeviceInfo.cpp
----------------------
[-] DeviceInfo::getDeviceRegistryProperty (
[+] DeviceInfo::getDeviceRegistryProperty(
[-] 	sl::Array <char>* buffer
[+] 	sl::Array<char>* buffer
[-] 	getDeviceRegistryProperty (propId, NULL, 0, &requiredSize);
[+] 	getDeviceRegistryProperty(propId, NULL, 0, &requiredSize);
[-] 	buffer->setCount (requiredSize);
[+] 	buffer->setCount(requiredSize);
[-] 	return getDeviceRegistryProperty (propId, buffer->p (), requiredSize, NULL);
[+] 	return getDeviceRegistryProperty(propId, buffer->p(), requiredSize, NULL);
[-] DeviceInfo::getDeviceRegistryProperty (
[+] DeviceInfo::getDeviceRegistryProperty(
[-] 	sl::Array <char> buffer;
[+] 	sl::Array<char> buffer;
[-] 	bool result = getDeviceRegistryProperty (propId, &buffer);
[+] 	bool result = getDeviceRegistryProperty(propId, &buffer);
[-] 	string->copy ((const utf16_t*) buffer.cp (), buffer.getCount () / sizeof (utf16_t));
[+] 	string->copy((const utf16_t*) buffer.cp(), buffer.getCount() / sizeof(utf16_t));
[-] DeviceInfo::getDeviceRegistryProperty (
[+] DeviceInfo::getDeviceRegistryProperty(
[-] 	sl::Array <char> buffer;
[+] 	sl::Array<char> buffer;
[-] 	bool result = getDeviceRegistryProperty (propId, &buffer);
[+] 	bool result = getDeviceRegistryProperty(propId, &buffer);
[-] 	string->copy ((const utf16_t*) buffer.cp (), buffer.getCount () / sizeof (utf16_t));
[+] 	string->copy((const utf16_t*) buffer.cp(), buffer.getCount() / sizeof(utf16_t));
[-] DeviceInfo::openDeviceRegistryKey (REGSAM keyAccess)
[+] DeviceInfo::openDeviceRegistryKey(REGSAM keyAccess)
[-] 	HKEY key = ::SetupDiOpenDevRegKey (m_devInfoSet, &m_devInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DEV, keyAccess);
[+] 	HKEY key = ::SetupDiOpenDevRegKey(m_devInfoSet, &m_devInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DEV, keyAccess);
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
[-] DeviceInfo::getClassInstallParams (sl::Array <char>* buffer)
[+] DeviceInfo::getClassInstallParams(sl::Array<char>* buffer)
[-] 	getClassInstallParams (NULL, 0, &requiredSize);
[+] 	getClassInstallParams(NULL, 0, &requiredSize);
[-] 	buffer->setCount (requiredSize);
[+] 	buffer->setCount(requiredSize);
[-] 	return getClassInstallParams (buffer->p (), requiredSize, NULL);
[+] 	return getClassInstallParams(buffer->p(), requiredSize, NULL);
[-] DeviceInfo::restartDevice (bool* isRebootRequired)
[+] DeviceInfo::restartDevice(bool* isRebootRequired)
[-] 		setClassInstallParams (&propChangeParams, sizeof (propChangeParams)) &&
[+] 		setClassInstallParams(&propChangeParams, sizeof(propChangeParams)) &&
[-] 		callClassInstaller (DIF_PROPERTYCHANGE);
[+] 		callClassInstaller(DIF_PROPERTYCHANGE);
[-] 		setClassInstallParams (&propChangeParams, sizeof (propChangeParams)) &&
[+] 		setClassInstallParams(&propChangeParams, sizeof(propChangeParams)) &&
[-] 		callClassInstaller (DIF_PROPERTYCHANGE);
[+] 		callClassInstaller(DIF_PROPERTYCHANGE);
[-] 	devInstallParams.cbSize = sizeof (devInstallParams);
[+] 	devInstallParams.cbSize = sizeof(devInstallParams);
[-] 	result = getDeviceInstallParams (&devInstallParams);
[+] 	result = getDeviceInstallParams(&devInstallParams);
[-] DeviceInfoSet::create (uint_t flags)
[+] DeviceInfoSet::create(uint_t flags)
[-] 	close ();
[+] 	close();
[-] 	m_h = ::SetupDiGetClassDevsW (NULL, NULL, NULL, flags | DIGCF_ALLCLASSES);
[+] 	m_h = ::SetupDiGetClassDevsW(NULL, NULL, NULL, flags | DIGCF_ALLCLASSES);
[-] 	return err::complete (m_h != INVALID_HANDLE_VALUE);
[+] 	return err::complete(m_h != INVALID_HANDLE_VALUE);
[-] DeviceInfoSet::create (
[+] DeviceInfoSet::create(
[-] 	close ();
[+] 	close();
[-] 	m_h = ::SetupDiGetClassDevsW (&classGuid, NULL, NULL, flags);
[+] 	m_h = ::SetupDiGetClassDevsW(&classGuid, NULL, NULL, flags);
[-] 	return err::complete (m_h != INVALID_HANDLE_VALUE);
[+] 	return err::complete(m_h != INVALID_HANDLE_VALUE);
[-] DeviceInfoSet::create (
[+] DeviceInfoSet::create(
[-] 	close ();
[+] 	close();
[-] 	m_h = ::SetupDiGetClassDevsW (NULL, enumerator.szn (), NULL, flags);
[+] 	m_h = ::SetupDiGetClassDevsW(NULL, enumerator.szn(), NULL, flags);
[-] 	return err::complete (m_h != INVALID_HANDLE_VALUE);
[+] 	return err::complete(m_h != INVALID_HANDLE_VALUE);
[-] DeviceInfoSet::getDeviceInfo (
[+] DeviceInfoSet::getDeviceInfo(
[-] 	bool_t result = ::SetupDiEnumDeviceInfo (m_h, (DWORD) i, &deviceInfo->m_devInfoData);
[+] 	bool_t result = ::SetupDiEnumDeviceInfo(m_h, (DWORD)i, &deviceInfo->m_devInfoData);
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] DeviceInfoSet::getDeviceClassGuids (
[+] DeviceInfoSet::getDeviceClassGuids(
[-] 	sl::Array <GUID>* buffer
[+] 	sl::Array<GUID>* buffer
[-] 	getDeviceClassGuids (name, NULL, 0, &requiredCount);
[+] 	getDeviceClassGuids(name, NULL, 0, &requiredCount);
[-] 	buffer->setCount (requiredCount);
[+] 	buffer->setCount(requiredCount);
[-] 	return getDeviceClassGuids (name, buffer->p (), requiredCount, &requiredCount);
[+] 	return getDeviceClassGuids(name, buffer->p(), requiredCount, &requiredCount);
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_win_JobObject.cpp
----------------------
[-] JobObject::queryInformation (
[+] JobObject::queryInformation(
[-] 	bool_t result = ::QueryInformationJobObject (m_h, infoClass, p,  (dword_t) size, &resultSize);
[+] 	bool_t result = ::QueryInformationJobObject(m_h, infoClass, p,  (dword_t)size, &resultSize);
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_win_Library.cpp
----------------------
[-] Library::loadLibrary (const sl::StringRef_w& fileName)
[+] Library::loadLibrary(const sl::StringRef_w& fileName)
[-] 	close ();
[+] 	close();
[-] 	m_h = ::LoadLibraryW (fileName.sz ());
[+] 	m_h = ::LoadLibraryW(fileName.sz());
[-] 	return err::complete (m_h != NULL);
[+] 	return err::complete(m_h != NULL);
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_win_NtDll.cpp
----------------------
[-] initNtDllFunctions ()
[+] initNtDllFunctions()
[-] 	HMODULE hNtDll = ::GetModuleHandleW (L"ntdll.dll");
[+] 	HMODULE hNtDll = ::GetModuleHandleW(L"ntdll.dll");
[-] 	ASSERT (hNtDll);
[+] 	ASSERT(hNtDll);
[-] 	ntQueryDirectoryFile = (NtQueryDirectoryFileFunc*) ::GetProcAddress (hNtDll, "NtQueryDirectoryFile");
[+] 	ntQueryDirectoryFile = (NtQueryDirectoryFileFunc*) ::GetProcAddress(hNtDll, "NtQueryDirectoryFile");
[-] 	ntOpenDirectoryObject = (NtOpenDirectoryObjectFunc*) ::GetProcAddress (hNtDll, "NtOpenDirectoryObject");
[+] 	ntOpenDirectoryObject = (NtOpenDirectoryObjectFunc*) ::GetProcAddress(hNtDll, "NtOpenDirectoryObject");
[-] 	ntQueryDirectoryObject = (NtQueryDirectoryObjectFunc*) ::GetProcAddress (hNtDll, "NtQueryDirectoryObject");
[+] 	ntQueryDirectoryObject = (NtQueryDirectoryObjectFunc*) ::GetProcAddress(hNtDll, "NtQueryDirectoryObject");
[-] 	ntOpenSymbolicLinkObject = (NtOpenSymbolicLinkObjectFunc*) ::GetProcAddress (hNtDll, "NtOpenSymbolicLinkObject");
[+] 	ntOpenSymbolicLinkObject = (NtOpenSymbolicLinkObjectFunc*) ::GetProcAddress(hNtDll, "NtOpenSymbolicLinkObject");
[-] 	ntQuerySymbolicLinkObject = (NtQuerySymbolicLinkObjectFunc*) ::GetProcAddress (hNtDll, "NtQuerySymbolicLinkObject");
[+] 	ntQuerySymbolicLinkObject = (NtQuerySymbolicLinkObjectFunc*) ::GetProcAddress(hNtDll, "NtQuerySymbolicLinkObject");
[-] 	ntQueryInformationFile = (NtQueryInformationFileFunc*) ::GetProcAddress (hNtDll, "NtQueryInformationFile");
[+] 	ntQueryInformationFile = (NtQueryInformationFileFunc*) ::GetProcAddress(hNtDll, "NtQueryInformationFile");
[-] 	ntQueryObject = (NtQueryObjectFunc*) ::GetProcAddress (hNtDll, "NtQueryObject");
[+] 	ntQueryObject = (NtQueryObjectFunc*) ::GetProcAddress(hNtDll, "NtQueryObject");
[-] 	ASSERT (ntQueryDirectoryFile);
[+] 	ASSERT(ntQueryDirectoryFile);
[-] 	ASSERT (ntOpenDirectoryObject);
[+] 	ASSERT(ntOpenDirectoryObject);
[-] 	ASSERT (ntQueryDirectoryObject);
[+] 	ASSERT(ntQueryDirectoryObject);
[-] 	ASSERT (ntOpenSymbolicLinkObject);
[+] 	ASSERT(ntOpenSymbolicLinkObject);
[-] 	ASSERT (ntQuerySymbolicLinkObject);
[+] 	ASSERT(ntQuerySymbolicLinkObject);
[-] 	ASSERT (ntQueryInformationFile);
[+] 	ASSERT(ntQueryInformationFile);
[-] 	ASSERT (ntQueryObject);
[+] 	ASSERT(ntQueryObject);
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_win_NtStatus.cpp
----------------------
[-] RtlNtStatusToDosErrorFunc (long);
[+] RtlNtStatusToDosErrorFunc(long);
[-] NtStatusProvider::getErrorDescription (long status)
[+] NtStatusProvider::getErrorDescription(long status)
[-] 	static HMODULE ntDll = ::GetModuleHandleW (L"ntdll.dll");
[+] 	static HMODULE ntDll = ::GetModuleHandleW(L"ntdll.dll");
[-] 	static RtlNtStatusToDosErrorFunc* rtlNtStatusToDosErrorFunc = (RtlNtStatusToDosErrorFunc*) ::GetProcAddress (ntDll, "RtlNtStatusToDosError");
[+] 	static RtlNtStatusToDosErrorFunc* rtlNtStatusToDosErrorFunc = (RtlNtStatusToDosErrorFunc*) ::GetProcAddress(ntDll, "RtlNtStatusToDosError");
[-] 		winError = rtlNtStatusToDosErrorFunc (status);
[+] 		winError = rtlNtStatusToDosErrorFunc(status);
[-] 		return WinErrorProvider::getErrorDescription (winError);
[+] 		return WinErrorProvider::getErrorDescription(winError);
[-] 	::FormatMessageW (
[+] 	::FormatMessageW(
[-] 		MAKELANGID (LANG_ENGLISH, SUBLANG_DEFAULT),
[+] 		MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),
[-] 		return sl::formatString ("ntstatus 0x%08x", status);
[+] 		return sl::formatString("ntstatus 0x%08x", status);
[-] 	::LocalFree (message);
[+] 	::LocalFree(message);
[-] NtStatus::create (long status)
[+] NtStatus::create(long status)
[-] 	err::ErrorHdr* error = createBuffer (sizeof (err::ErrorHdr));
[+] 	err::ErrorHdr* error = createBuffer(sizeof(err::ErrorHdr));
[-] 	error->m_size = sizeof (err::ErrorHdr);
[+] 	error->m_size = sizeof(err::ErrorHdr);
[-] 	return sizeof (err::ErrorHdr);
[+] 	return sizeof(err::ErrorHdr);
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_win_Process.cpp
----------------------
[-] Process::createProcess (
[+] Process::createProcess(
[-] 	close ();
[+] 	close();
[-] 	result = ::CreateProcessW (
[+] 	result = ::CreateProcessW(
[-] 		appName.szn (),
[+] 		appName.szn(),
[-] 		mutableCmdLine.getBuffer (),
[+] 		mutableCmdLine.getBuffer(),
[-] 		(SECURITY_ATTRIBUTES*) processAttr,
[+] 		(SECURITY_ATTRIBUTES*)processAttr,
[-] 		(SECURITY_ATTRIBUTES*) threadAttr,
[+] 		(SECURITY_ATTRIBUTES*)threadAttr,
[-] 		(void*) environment,
[+] 		(void*)environment,
[-] 		currentDir.szn (),
[+] 		currentDir.szn(),
[-] 		(STARTUPINFOW*) startupInfo,
[+] 		(STARTUPINFOW*)startupInfo,
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] 		::CloseHandle (processInfo.hThread);
[+] 		::CloseHandle(processInfo.hThread);
[-] syncExec (
[+] syncExec(
[-] 	sl::Array <char>* output,
[+] 	sl::Array<char>* output,
[-] 	secAttr.nLength = sizeof (SECURITY_ATTRIBUTES);
[+] 	secAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
[-] 		::CreatePipe (parentStdOut.p (), childStdOut.p (), &secAttr, 0) &&
[+] 		::CreatePipe(parentStdOut.p(), childStdOut.p(), &secAttr, 0) &&
[-] 		::CreatePipe (childStdIn.p (), parentStdIn.p (), &secAttr, 0);
[+] 		::CreatePipe(childStdIn.p(), parentStdIn.p(), &secAttr, 0);
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] 	startupInfo.cb = sizeof (STARTUPINFO);
[+] 	startupInfo.cb = sizeof(STARTUPINFO);
[-] 	result = process.createProcess (cmdLine, true, CREATE_NEW_CONSOLE, &startupInfo);
[+] 	result = process.createProcess(cmdLine, true, CREATE_NEW_CONSOLE, &startupInfo);
[-] 	childStdOut.close ();
[+] 	childStdOut.close();
[-] 	childStdIn.close ();
[+] 	childStdIn.close();
[-] 	output->clear ();
[+] 	output->clear();
[-] 		char buffer [1024];
[+] 		char buffer[1024];
[-] 		size_t size = parentStdOut.read (buffer, countof (buffer));
[+] 		size_t size = parentStdOut.read(buffer, countof(buffer));
[-] 			if (err::getLastError ()->m_code == ERROR_BROKEN_PIPE)
[+] 			if (err::getLastError()->m_code == ERROR_BROKEN_PIPE)
[-] 		output->append (buffer, size);
[+] 		output->append(buffer, size);
[-] 		process.getExitCode (exitCode);
[+] 		process.getExitCode(exitCode);
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_win_Service.cpp
----------------------
[-] Service::setDescription (const sl::StringRef_w& description)
[+] Service::setDescription(const sl::StringRef_w& description)
[-] 	SERVICE_DESCRIPTIONW info = { (WCHAR*) description.sz () };
[+] 	SERVICE_DESCRIPTIONW info = { (WCHAR*)description.sz() };
[-] 	return changeServiceConfig2 (SERVICE_CONFIG_DESCRIPTION, &info);
[+] 	return changeServiceConfig2(SERVICE_CONFIG_DESCRIPTION, &info);
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_win_ServiceMgr.cpp
----------------------
[-] ServiceMgr::open (
[+] ServiceMgr::open(
[-] 	close ();
[+] 	close();
[-] 	m_h = ::OpenSCManagerW (machineName.szn (), databaseName.szn (), access);
[+] 	m_h = ::OpenSCManagerW(machineName.szn(), databaseName.szn(), access);
[-] 	return err::complete (m_h != NULL);
[+] 	return err::complete(m_h != NULL);
[-] ServiceMgr::createService (
[+] ServiceMgr::createService(
[-] 	SC_HANDLE h = ::CreateServiceW (
[+] 	SC_HANDLE h = ::CreateServiceW(
[-] 		name.szn (),
[+] 		name.szn(),
[-] 		displayName.szn (),
[+] 		displayName.szn(),
[-] 		binaryFilePath.szn (),
[+] 		binaryFilePath.szn(),
[-] 		loadOrderGroup.szn (),
[+] 		loadOrderGroup.szn(),
[-] 		dependencies.szn (),
[+] 		dependencies.szn(),
[-] 		startName.szn (),
[+] 		startName.szn(),
[-] 		password.szn ()
[+] 		password.szn()
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
[-] 	service->attach (h);
[+] 	service->attach(h);
[-] ServiceMgr::openService (
[+] ServiceMgr::openService(
[-] 	SC_HANDLE h = ::OpenServiceW (m_h, name.szn (), access);
[+] 	SC_HANDLE h = ::OpenServiceW(m_h, name.szn(), access);
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
[-] 	service->attach (h);
[+] 	service->attach(h);
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_win_Sid.cpp
----------------------
[-] Sid::create_va (
[+] Sid::create_va(
[-] 	size_t size = ::GetSidLengthRequired ((uchar_t) subAuthorityCount);
[+] 	size_t size = ::GetSidLengthRequired((uchar_t)subAuthorityCount);
[-] 	SID* sid = createBuffer (size, false);
[+] 	SID* sid = createBuffer(size, false);
[-] 	bool_t result = ::InitializeSid (sid, identifierAuthority, (uchar_t) subAuthorityCount);
[+] 	bool_t result = ::InitializeSid(sid, identifierAuthority, (uchar_t)subAuthorityCount);
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] 	dword_t* subAuthorityTable = ::GetSidSubAuthority (sid, 0);
[+] 	dword_t* subAuthorityTable = ::GetSidSubAuthority(sid, 0);
[-] 		subAuthorityTable [i] = va.arg <dword_t> ();
[+] 		subAuthorityTable[i] = va.arg<dword_t> ();
[-] Sid::parse (const sl::StringRef& string)
[+] Sid::parse(const sl::StringRef& string)
[-] 	result = ::ConvertStringSidToSidA (string.sz (), (PSID*) &sid);
[+] 	result = ::ConvertStringSidToSidA(string.sz(), (PSID*) &sid);
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] 	result = copy (sid);
[+] 	result = copy(sid);
[-] 	::LocalFree (sid);
[+] 	::LocalFree(sid);
[-] Sid::parse (const sl::StringRef_w& string)
[+] Sid::parse(const sl::StringRef_w& string)
[-] 	result = ::ConvertStringSidToSidW (string.sz (), (PSID*) &sid);
[+] 	result = ::ConvertStringSidToSidW(string.sz(), (PSID*) &sid);
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] 	result = copy (sid);
[+] 	result = copy(sid);
[-] 	::LocalFree (sid);
[+] 	::LocalFree(sid);
[-] Sid::getString (sl::String* string) const
[+] Sid::getString(sl::String* string) const
[-] 		string->clear ();
[+] 		string->clear();
[-] 	bool_t result = ::ConvertSidToStringSidA (m_p, &stringBuffer);
[+] 	bool_t result = ::ConvertSidToStringSidA(m_p, &stringBuffer);
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] 	result = string->copy (stringBuffer);
[+] 	result = string->copy(stringBuffer);
[-] Sid::lookupAccountName (
[+] Sid::lookupAccountName(
[-] 	char sidBuffer [SECURITY_MAX_SID_SIZE];
[+] 	char sidBuffer[SECURITY_MAX_SID_SIZE];
[-] 	dword_t sidSize = sizeof (sidBuffer);
[+] 	dword_t sidSize = sizeof(sidBuffer);
[-] 	char domainNameBuffer [MAX_PATH];
[+] 	char domainNameBuffer[MAX_PATH];
[-] 	dword_t domainNameLength = sizeof (domainNameBuffer);
[+] 	dword_t domainNameLength = sizeof(domainNameBuffer);
[-] 	bool_t result = ::LookupAccountNameA (
[+] 	bool_t result = ::LookupAccountNameA(
[-] 		systemName.szn (),
[+] 		systemName.szn(),
[-] 		accountName.szn (),
[+] 		accountName.szn(),
[-] 		(SID*) sidBuffer,
[+] 		(SID*)sidBuffer,
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] 	return copy ((SID*) sidBuffer) != -1;
[+] 	return copy((SID*)sidBuffer) != -1;
[-] Sid::lookupAccountName (
[+] Sid::lookupAccountName(
[-] 	char sidBuffer [SECURITY_MAX_SID_SIZE];
[+] 	char sidBuffer[SECURITY_MAX_SID_SIZE];
[-] 	dword_t sidSize = sizeof (sidBuffer);
[+] 	dword_t sidSize = sizeof(sidBuffer);
[-] 	wchar_t domainNameBuffer [MAX_PATH];
[+] 	wchar_t domainNameBuffer[MAX_PATH];
[-] 	dword_t domainNameLength = sizeof (domainNameBuffer) / sizeof (wchar_t);
[+] 	dword_t domainNameLength = sizeof(domainNameBuffer) / sizeof(wchar_t);
[-] 	bool_t result = ::LookupAccountNameW (
[+] 	bool_t result = ::LookupAccountNameW(
[-] 		systemName.szn (),
[+] 		systemName.szn(),
[-] 		accountName.szn (),
[+] 		accountName.szn(),
[-] 		(SID*) sidBuffer,
[+] 		(SID*)sidBuffer,
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] 	return copy ((SID*) sidBuffer) != -1;
[+] 	return copy((SID*)sidBuffer) != -1;
[-] Sid::lookupAccountSid (
[+] Sid::lookupAccountSid(
[-] 	char accountNameBuffer [MAX_PATH];
[+] 	char accountNameBuffer[MAX_PATH];
[-] 	dword_t accountNameLength = sizeof (accountNameBuffer);
[+] 	dword_t accountNameLength = sizeof(accountNameBuffer);
[-] 	char domainNameBuffer [MAX_PATH];
[+] 	char domainNameBuffer[MAX_PATH];
[-] 	dword_t domainNameLength = sizeof (domainNameBuffer);
[+] 	dword_t domainNameLength = sizeof(domainNameBuffer);
[-] 		return err::fail (err::SystemErrorCode_InvalidParameter);
[+] 		return err::fail(err::SystemErrorCode_InvalidParameter);
[-] 	bool_t result = ::LookupAccountSidA (
[+] 	bool_t result = ::LookupAccountSidA(
[-] 		systemName.szn (),
[+] 		systemName.szn(),
[-] 		(SID*) sid,
[+] 		(SID*)sid,
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] 	accountName->copy (accountNameBuffer, accountNameLength);
[+] 	accountName->copy(accountNameBuffer, accountNameLength);
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_win_Thread.cpp
----------------------
[-] Thread::create (
[+] Thread::create(
[-] 	close ();
[+] 	close();
[-] 	m_h = ::CreateThread (secAttr, stackSize, threadFunc, context, flags, &threadId);
[+] 	m_h = ::CreateThread(secAttr, stackSize, threadFunc, context, flags, &threadId);
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_win_VirtualMemory.cpp
----------------------
[-] VirtualMemory::alloc (
[+] VirtualMemory::alloc(
[-] 	release ();
[+] 	release();
[-] 	void* p = ::VirtualAlloc (p0, size, allocationFlags, protectionFlags);
[+] 	void* p = ::VirtualAlloc(p0, size, allocationFlags, protectionFlags);
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
[-] VirtualMemory::release ()
[+] VirtualMemory::release()
[-] 	::VirtualFree (m_p, m_size, MEM_RELEASE);
[+] 	::VirtualFree(m_p, m_size, MEM_RELEASE);
[-] VirtualMemory::protect (
[+] VirtualMemory::protect(
[-] 	bool_t result = ::VirtualProtect (m_p, m_size, protectionFlags, &prevProtectionFlags);
[+] 	bool_t result = ::VirtualProtect(m_p, m_size, protectionFlags, &prevProtectionFlags);
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_win_WaitableHandle.cpp
----------------------
[-] WaitableHandle::completeWait (dword_t result)
[+] WaitableHandle::completeWait(dword_t result)
[-] 	switch (result)
[+] 	switch(result)
[-] 		return err::failWithLastSystemError (WaitResult_Fail);
[+] 		return err::failWithLastSystemError(WaitResult_Fail);
[-] 			return (WaitResult) (WaitResult_Object0 + result - WAIT_OBJECT_0);
[+] 			return (WaitResult)(WaitResult_Object0 + result - WAIT_OBJECT_0);
[-] 		err::setError (err::SystemErrorCode_InvalidParameter);
[+] 		err::setError(err::SystemErrorCode_InvalidParameter);
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sys_win_WinError.cpp
----------------------
[-] getSystemMessage (dword_t code)
[+] getSystemMessage(dword_t code)
[-] 		EnglishLangId = MAKELANGID (LANG_ENGLISH, SUBLANG_ENGLISH_US),
[+] 		EnglishLangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
[-] 		NeutralLangId = MAKELANGID (LANG_NEUTRAL, SUBLANG_NEUTRAL),
[+] 		NeutralLangId = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
[-] 	::FormatMessageW (Flags, NULL, code, EnglishLangId, (LPWSTR) &message, 0, NULL);
[+] 	::FormatMessageW(Flags, NULL, code, EnglishLangId, (LPWSTR) &message, 0, NULL);
[-] 		::FormatMessageW (Flags, NULL, code, NeutralLangId, (LPWSTR) &message, 0, NULL);
[+] 		::FormatMessageW(Flags, NULL, code, NeutralLangId, (LPWSTR) &message, 0, NULL);
[-] WinErrorProvider::getErrorDescription (dword_t code)
[+] WinErrorProvider::getErrorDescription(dword_t code)
[-] 	wchar_t* message = getSystemMessage (code);
[+] 	wchar_t* message = getSystemMessage(code);
[-] 		HRESULT hresult = HRESULT_FROM_SETUPAPI (code);
[+] 		HRESULT hresult = HRESULT_FROM_SETUPAPI(code);
[-] 		message = getSystemMessage (hresult);
[+] 		message = getSystemMessage(hresult);
[-] 			return sl::formatString ("winerror #%d", code);
[+] 			return sl::formatString("winerror #%d", code);
[-] 	::LocalFree (message);
[+] 	::LocalFree(message);
[-] WinError::create (dword_t code)
[+] WinError::create(dword_t code)
[-] 	err::ErrorHdr* error = createBuffer (sizeof (err::ErrorHdr));
[+] 	err::ErrorHdr* error = createBuffer(sizeof(err::ErrorHdr));
[-] 	error->m_size = sizeof (err::ErrorHdr);
[+] 	error->m_size = sizeof(err::ErrorHdr);
[-] 	return sizeof (err::ErrorHdr);
[+] 	return sizeof(err::ErrorHdr);
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_core\axl_sl_BoyerMooreAccessor.h
----------------------
[-] 	BoyerMooreAccessor (const T* p)
[+] 	BoyerMooreAccessor(const T* p)
[-] 	getChar (size_t i) const
[+] 	getChar(size_t i) const
[-] 		return m_p [i];
[+] 		return m_p[i];
[-] 	saveTail (
[+] 	saveTail(
[-] class BoyerMooreReverseAccessor: public BoyerMooreAccessor <T>
[+] class BoyerMooreReverseAccessor: public BoyerMooreAccessor<T>
[-] 	BoyerMooreReverseAccessor (const T* p)
[+] 	BoyerMooreReverseAccessor(const T* p)
[-] 		: BoyerMooreAccessor <T>  (p)
[+] 		: BoyerMooreAccessor<T>  (p)
[-] 	getChar (size_t i) const
[+] 	getChar(size_t i) const
[-] 		return this->m_p [-i];
[+] 		return this->m_p[-i];
[-] class BoyerMooreIncrementalAccessor: public BoyerMooreAccessor <T>
[+] class BoyerMooreIncrementalAccessor: public BoyerMooreAccessor<T>
[-] 	BoyerMooreIncrementalContext <T>* m_incrementalContext;
[+] 	BoyerMooreIncrementalContext<T>* m_incrementalContext;
[-] 	BoyerMooreIncrementalAccessor (
[+] 	BoyerMooreIncrementalAccessor(
[-] 		BoyerMooreIncrementalContext <T>* incrementalContext
[+] 		BoyerMooreIncrementalContext<T>* incrementalContext
[-] 		): BoyerMooreAccessor <T>  (p)
[+] 		): BoyerMooreAccessor<T>  (p)
[-] 	getChar (size_t i) const
[+] 	getChar(size_t i) const
[-] 		size_t tailLength = m_incrementalContext->m_tail.getCount ();
[+] 		size_t tailLength = m_incrementalContext->m_tail.getCount();
[-] 			this->m_incrementalContext->m_tail [i] :
[+] 			this->m_incrementalContext->m_tail[i] :
[-] 			this->m_p [i - tailLength];
[+] 			this->m_p[i - tailLength];
[-] 	saveTail (
[+] 	saveTail(
[-] 			m_incrementalContext->m_tail.clear ();
[+] 			m_incrementalContext->m_tail.clear();
[-] 		size_t tailLength = m_incrementalContext->m_tail.getCount ();
[+] 		size_t tailLength = m_incrementalContext->m_tail.getCount();
[-] 			ASSERT (size > tailLength - i);
[+] 			ASSERT(size > tailLength - i);
[-] 			m_incrementalContext->m_tail.remove (0, i);
[+] 			m_incrementalContext->m_tail.remove(0, i);
[-] 			m_incrementalContext->m_tail.append (this->m_p, copySize);
[+] 			m_incrementalContext->m_tail.append(this->m_p, copySize);
[-] 			m_incrementalContext->m_tail.copy (this->m_p + i - tailLength, size);
[+] 			m_incrementalContext->m_tail.copy(this->m_p + i - tailLength, size);
[-] class BoyerMooreIncrementalReverseAccessor: public BoyerMooreIncrementalAccessor <T>
[+] class BoyerMooreIncrementalReverseAccessor: public BoyerMooreIncrementalAccessor<T>
[-] 	BoyerMooreIncrementalReverseAccessor (
[+] 	BoyerMooreIncrementalReverseAccessor(
[-] 		BoyerMooreIncrementalContext <T>* incrementalContext
[+] 		BoyerMooreIncrementalContext<T>* incrementalContext
[-] 		): BoyerMooreIncrementalAccessor <T> (p, incrementalContext)
[+] 		): BoyerMooreIncrementalAccessor<T> (p, incrementalContext)
[-] 	getChar (size_t i) const
[+] 	getChar(size_t i) const
[-] 		size_t tailLength = this->m_incrementalContext->m_tail.getCount ();
[+] 		size_t tailLength = this->m_incrementalContext->m_tail.getCount();
[-] 			this->m_incrementalContext->m_tail [i] :
[+] 			this->m_incrementalContext->m_tail[i] :
[-] 			this->m_p [-(i - tailLength)]; // tail is already reversed
[+] 			this->m_p[-(i - tailLength)]; // tail is already reversed
[-] 	saveTail (
[+] 	saveTail(
[-] 			this->m_incrementalContext->m_tail.clear ();
[+] 			this->m_incrementalContext->m_tail.clear();
[-] 		size_t tailLength = this->m_incrementalContext->m_tail.getCount ();
[+] 		size_t tailLength = this->m_incrementalContext->m_tail.getCount();
[-] 			ASSERT (size > tailLength - i);
[+] 			ASSERT(size > tailLength - i);
[-] 			this->m_incrementalContext->m_tail.remove (0, i);
[+] 			this->m_incrementalContext->m_tail.remove(0, i);
[-] 			this->m_incrementalContext->m_tail.appendReverse (this->m_p - copySize + 1, copySize);
[+] 			this->m_incrementalContext->m_tail.appendReverse(this->m_p - copySize + 1, copySize);
[-] 			this->m_incrementalContext->m_tail.copyReverse (this->m_p - size - (i - tailLength) + 1, size);
[+] 			this->m_incrementalContext->m_tail.copyReverse(this->m_p - size - (i - tailLength) + 1, size);
[-] 	TextBoyerMooreAccessorImpl (const utf32_t* p):
[+] 	TextBoyerMooreAccessorImpl(const utf32_t* p):
[-] 		Base (p)
[+] 		Base(p)
[-] 	isDelimChar (size_t i) const
[+] 	isDelimChar(size_t i) const
[-] 		return i == -1 ? true : !enc::utfIsLetterOrNumber (Base::getChar (i));
[+] 		return i == -1 ? true : !enc::utfIsLetterOrNumber(Base::getChar(i));
[-] 	TextBoyerMooreIncrementalAccessorImpl (
[+] 	TextBoyerMooreIncrementalAccessorImpl(
[-] 		BoyerMooreIncrementalContext <utf32_t>* incrementalContext
[+] 		BoyerMooreIncrementalContext<utf32_t>* incrementalContext
[-] 	isDelimChar (size_t i) const
[+] 	isDelimChar(size_t i) const
[-] 		utf32_t c = i != -1 ? Base::getChar (i) : this->m_incrementalContext->m_prefix;
[+] 		utf32_t c = i != -1 ? Base::getChar(i) : this->m_incrementalContext->m_prefix;
[-] 		return !enc::utfIsLetterOrNumber (c);
[+] 		return !enc::utfIsLetterOrNumber(c);
[-] 	saveTail (
[+] 	saveTail(
[-] 		ASSERT (i);
[+] 		ASSERT(i);
[-] 		this->m_incrementalContext->m_prefix = Base::getChar (i - 1);
[+] 		this->m_incrementalContext->m_prefix = Base::getChar(i - 1);
[-] 		Base::saveTail (i, size);
[+] 		Base::saveTail(i, size);
[-] class TextBoyerMooreCaseFoldedAccessorImpl: public TextBoyerMooreAccessorImpl <Base>
[+] class TextBoyerMooreCaseFoldedAccessorImpl: public TextBoyerMooreAccessorImpl<Base>
[-] 	TextBoyerMooreCaseFoldedAccessorImpl (const utf32_t* p):
[+] 	TextBoyerMooreCaseFoldedAccessorImpl(const utf32_t* p):
[-] 		TextBoyerMooreAccessorImpl <Base> (p)
[+] 		TextBoyerMooreAccessorImpl<Base> (p)
[-] 	getChar (size_t i) const
[+] 	getChar(size_t i) const
[-] 		return enc::utfToCaseFolded (Base::getChar (i));
[+] 		return enc::utfToCaseFolded(Base::getChar(i));
[-] class TextBoyerMooreCaseFoldedIncrementalAccessorImpl: public TextBoyerMooreIncrementalAccessorImpl <Base>
[+] class TextBoyerMooreCaseFoldedIncrementalAccessorImpl: public TextBoyerMooreIncrementalAccessorImpl<Base>
[-] 	TextBoyerMooreCaseFoldedIncrementalAccessorImpl (
[+] 	TextBoyerMooreCaseFoldedIncrementalAccessorImpl(
[-] 		BoyerMooreIncrementalContext <utf32_t>* incrementalContext
[+] 		BoyerMooreIncrementalContext<utf32_t>* incrementalContext
[-] 		): TextBoyerMooreIncrementalAccessorImpl <Base> (p, incrementalContext)
[+] 		): TextBoyerMooreIncrementalAccessorImpl<Base> (p, incrementalContext)
[-] 	getChar (size_t i) const
[+] 	getChar(size_t i) const
[-] 		return enc::utfToCaseFolded (Base::getChar (i));
[+] 		return enc::utfToCaseFolded(Base::getChar(i));
[-] typedef BoyerMooreAccessor <uchar_t> BinaryBoyerMooreAccessor;
[+] typedef BoyerMooreAccessor<uchar_t> BinaryBoyerMooreAccessor;
[-] typedef BoyerMooreReverseAccessor <uchar_t> BinaryBoyerMooreReverseAccessor;
[+] typedef BoyerMooreReverseAccessor<uchar_t> BinaryBoyerMooreReverseAccessor;
[-] typedef BoyerMooreIncrementalAccessor <uchar_t> BinaryBoyerMooreIncrementalAccessor;
[+] typedef BoyerMooreIncrementalAccessor<uchar_t> BinaryBoyerMooreIncrementalAccessor;
[-] typedef BoyerMooreIncrementalReverseAccessor <uchar_t> BinaryBoyerMooreIncrementalReverseAccessor;
[+] typedef BoyerMooreIncrementalReverseAccessor<uchar_t> BinaryBoyerMooreIncrementalReverseAccessor;
[-] TextBoyerMooreAccessorImpl <BoyerMooreAccessor <utf32_t> >
[+] TextBoyerMooreAccessorImpl<BoyerMooreAccessor<utf32_t> >
[-] TextBoyerMooreAccessorImpl <BoyerMooreReverseAccessor <utf32_t> >
[+] TextBoyerMooreAccessorImpl<BoyerMooreReverseAccessor<utf32_t> >
[-] TextBoyerMooreIncrementalAccessorImpl <BoyerMooreIncrementalAccessor <utf32_t> >
[+] TextBoyerMooreIncrementalAccessorImpl<BoyerMooreIncrementalAccessor<utf32_t> >
[-] TextBoyerMooreIncrementalAccessorImpl <BoyerMooreIncrementalReverseAccessor <utf32_t> >
[+] TextBoyerMooreIncrementalAccessorImpl<BoyerMooreIncrementalReverseAccessor<utf32_t> >
[-] TextBoyerMooreCaseFoldedAccessorImpl <BoyerMooreAccessor <utf32_t> >
[+] TextBoyerMooreCaseFoldedAccessorImpl<BoyerMooreAccessor<utf32_t> >
[-] TextBoyerMooreCaseFoldedAccessorImpl <BoyerMooreReverseAccessor <utf32_t> >
[+] TextBoyerMooreCaseFoldedAccessorImpl<BoyerMooreReverseAccessor<utf32_t> >
[-] TextBoyerMooreCaseFoldedIncrementalAccessorImpl <BoyerMooreIncrementalAccessor <utf32_t> >
[+] TextBoyerMooreCaseFoldedIncrementalAccessorImpl<BoyerMooreIncrementalAccessor<utf32_t> >
[-] TextBoyerMooreCaseFoldedIncrementalAccessorImpl <BoyerMooreIncrementalReverseAccessor <utf32_t> >
[+] TextBoyerMooreCaseFoldedIncrementalAccessorImpl<BoyerMooreIncrementalReverseAccessor<utf32_t> >
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_cry\axl_cry_BigNum.cpp
----------------------
[-] BnCtx::getBigNum ()
[+] BnCtx::getBigNum()
[-] 	BIGNUM* result = BN_CTX_get (m_h);
[+] 	BIGNUM* result = BN_CTX_get(m_h);
[-] 		setLastCryptoError ();
[+] 		setLastCryptoError();
[-] BigNum::create ()
[+] BigNum::create()
[-] 	close ();
[+] 	close();
[-] 	m_h = BN_new ();
[+] 	m_h = BN_new();
[-] 	return completeWithLastCryptoError (m_h != NULL);
[+] 	return completeWithLastCryptoError(m_h != NULL);
[-] BigNum::createCopy (BIGNUM* src)
[+] BigNum::createCopy(BIGNUM* src)
[-] 	close ();
[+] 	close();
[-] 	m_h = BN_dup (src);
[+] 	m_h = BN_dup(src);
[-] 	return completeWithLastCryptoError (m_h != NULL);
[+] 	return completeWithLastCryptoError(m_h != NULL);
[-] BigNum::getData (
[+] BigNum::getData(
[-] 	ASSERT (size >= getSize ());
[+] 	ASSERT(size >= getSize());
[-] 	int result = BN_bn2bin (m_h, (uchar_t*) p);
[+] 	int result = BN_bn2bin(m_h, (uchar_t*)p);
[-] 		setLastCryptoError ();
[+] 		setLastCryptoError();
[-] BigNum::getDecString (sl::String* string)
[+] BigNum::getDecString(sl::String* string)
[-] 	char* p = BN_bn2dec (m_h);
[+] 	char* p = BN_bn2dec(m_h);
[-] 		setLastCryptoError ();
[+] 		setLastCryptoError();
[-] 	OPENSSL_free (p);
[+] 	OPENSSL_free(p);
[-] BigNum::getHexString (sl::String* string)
[+] BigNum::getHexString(sl::String* string)
[-] 	char* p = BN_bn2hex (m_h);
[+] 	char* p = BN_bn2hex(m_h);
[-] 		setLastCryptoError ();
[+] 		setLastCryptoError();
[-] 	OPENSSL_free (p);
[+] 	OPENSSL_free(p);
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_cry\axl_cry_Bio.cpp
----------------------
[-] Bio::create (
[+] Bio::create(
[-] 	close ();
[+] 	close();
[-] 	m_h = BIO_new_mem_buf ((void*) p, size);
[+] 	m_h = BIO_new_mem_buf((void*)p, size);
[-] 		err::setError (err::SystemErrorCode_InsufficientResources);
[+] 		err::setError(err::SystemErrorCode_InsufficientResources);
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_cry\axl_cry_CryptoError.cpp
----------------------
[-] 		ERR_load_crypto_strings ();
[+] 		ERR_load_crypto_strings();
[-] CryptoErrorProvider::getErrorDescription (const err::ErrorRef& error)
[+] CryptoErrorProvider::getErrorDescription(const err::ErrorRef& error)
[-] 	sl::callOnce (LoadCryptoStrings (), 0);
[+] 	sl::callOnce(LoadCryptoStrings(), 0);
[-] 	return ERR_reason_error_string (error->m_code);
[+] 	return ERR_reason_error_string(error->m_code);
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_cry\axl_cry_EcKey.cpp
----------------------
[-] EcKey::setFlags (uint_t flags)
[+] EcKey::setFlags(uint_t flags)
[-] 	int prevFlags = getFlags ();
[+] 	int prevFlags = getFlags();
[-] 	addFlags (flags & ~prevFlags);
[+] 	addFlags(flags & ~prevFlags);
[-] 	removeFlags (prevFlags & ~flags);
[+] 	removeFlags(prevFlags & ~flags);
[-] EcKey::create ()
[+] EcKey::create()
[-] 	close ();
[+] 	close();
[-] 	m_h = EC_KEY_new ();
[+] 	m_h = EC_KEY_new();
[-] 	return completeWithLastCryptoError (m_h != NULL);
[+] 	return completeWithLastCryptoError(m_h != NULL);
[-] EcKey::create (uint_t curveId)
[+] EcKey::create(uint_t curveId)
[-] 	close ();
[+] 	close();
[-] 	m_h = EC_KEY_new_by_curve_name (curveId);
[+] 	m_h = EC_KEY_new_by_curve_name(curveId);
[-] 	return completeWithLastCryptoError (m_h != NULL);
[+] 	return completeWithLastCryptoError(m_h != NULL);
[-] EcKey::createCopy (EC_KEY* src)
[+] EcKey::createCopy(EC_KEY* src)
[-] 	close ();
[+] 	close();
[-] 	m_h = EC_KEY_dup (src);
[+] 	m_h = EC_KEY_dup(src);
[-] 	return completeWithLastCryptoError (m_h != NULL);
[+] 	return completeWithLastCryptoError(m_h != NULL);
[-] EcKey::setPublicKeyData (
[+] EcKey::setPublicKeyData(
[-] 	EC_GROUP* group = getGroup ();
[+] 	EC_GROUP* group = getGroup();
[-] 	EcPoint key (group);
[+] 	EcPoint key(group);
[-] 		key.setData (group, p, size, ctx) &&
[+] 		key.setData(group, p, size, ctx) &&
[-] 		setPublicKey (key);
[+] 		setPublicKey(key);
[-] EcKey::setPublicKeyDecString (
[+] EcKey::setPublicKeyDecString(
[-] 	EC_GROUP* group = getGroup ();
[+] 	EC_GROUP* group = getGroup();
[-] 	EcPoint key (group);
[+] 	EcPoint key(group);
[-] 		key.setDecString (getGroup (), string, ctx) &&
[+] 		key.setDecString(getGroup(), string, ctx) &&
[-] 		setPublicKey (key);
[+] 		setPublicKey(key);
[-] EcKey::setPublicKeyHexString (
[+] EcKey::setPublicKeyHexString(
[-] 	EC_GROUP* group = getGroup ();
[+] 	EC_GROUP* group = getGroup();
[-] 	EcPoint key (group);
[+] 	EcPoint key(group);
[-] 		key.setHexString (group, string, ctx) &&
[+] 		key.setHexString(group, string, ctx) &&
[-] 		setPublicKey (key);
[+] 		setPublicKey(key);
[-] EcKey::signHash (
[+] EcKey::signHash(
[-] 	ASSERT (signatureBufferSize >= getMaxSignatureSize ());
[+] 	ASSERT(signatureBufferSize >= getMaxSignatureSize());
[-] 	uint_t resultSize = (uint_t) signatureBufferSize;
[+] 	uint_t resultSize = (uint_t)signatureBufferSize;
[-] 	int result = ECDSA_sign (
[+] 	int result = ECDSA_sign(
[-] 		(int) hashSize,
[+] 		(int)hashSize,
[-] 		(uchar_t*) signatureBuffer,
[+] 		(uchar_t*)signatureBuffer,
[-] 		setLastCryptoError ();
[+] 		setLastCryptoError();
[-] 	ASSERT (resultSize <= signatureBufferSize);
[+] 	ASSERT(resultSize <= signatureBufferSize);
[-] EcKey::signHash (
[+] EcKey::signHash(
[-] 	sl::Array <char>* signature,
[+] 	sl::Array<char>* signature,
[-] 	size_t maxSize = getMaxSignatureSize ();
[+] 	size_t maxSize = getMaxSignatureSize();
[-] 	bool result = signature->setCount (maxSize);
[+] 	bool result = signature->setCount(maxSize);
[-] 	size_t size = signHash (*signature, maxSize, hash, hashSize);
[+] 	size_t size = signHash(*signature, maxSize, hash, hashSize);
[-] 	ASSERT (size <= maxSize);
[+] 	ASSERT(size <= maxSize);
[-] 	signature->setCount (size);
[+] 	signature->setCount(size);
[-] generateEcProductKey (
[+] generateEcProductKey(
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <char> signature (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<char> signature(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	EcKey ecKey (ecKey0);
[+] 	EcKey ecKey(ecKey0);
[-] 		ecKey.sign (&signature, userName.cp (), userName.getLength ()) &&
[+] 		ecKey.sign(&signature, userName.cp(), userName.getLength()) &&
[-] 		enc::Base32Encoding::encode (productKey, signature, signature.getCount (), hyphenDistance) != -1;
[+] 		enc::Base32Encoding::encode(productKey, signature, signature.getCount(), hyphenDistance) != -1;
[-] 	ecKey.detach ();
[+] 	ecKey.detach();
[-] verifyEcProductKey (
[+] verifyEcProductKey(
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <char> signature (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<char> signature(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	EcKey ecKey (ecKey0);
[+] 	EcKey ecKey(ecKey0);
[-] 		enc::Base32Encoding::decode (&signature, productKey) != -1 &&
[+] 		enc::Base32Encoding::decode(&signature, productKey) != -1 &&
[-] 		ecKey.verify (userName.cp (), userName.getLength (), signature, signature.getCount ());
[+] 		ecKey.verify(userName.cp(), userName.getLength(), signature, signature.getCount());
[-] 	ecKey.detach ();
[+] 	ecKey.detach();
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_cry\axl_cry_EcPoint.cpp
----------------------
[-] EcPoint::create (EC_GROUP* group)
[+] EcPoint::create(EC_GROUP* group)
[-] 	close ();
[+] 	close();
[-] 	m_h = EC_POINT_new (group);
[+] 	m_h = EC_POINT_new(group);
[-] 	return completeWithLastCryptoError (m_h != NULL);
[+] 	return completeWithLastCryptoError(m_h != NULL);
[-] EcPoint::createCopy (
[+] EcPoint::createCopy(
[-] 	close ();
[+] 	close();
[-] 	m_h = EC_POINT_dup (src, group);
[+] 	m_h = EC_POINT_dup(src, group);
[-] 	return completeWithLastCryptoError (m_h != NULL);
[+] 	return completeWithLastCryptoError(m_h != NULL);
[-] EcPoint::getData (
[+] EcPoint::getData(
[-] 	sl::Array <char>* data,
[+] 	sl::Array<char>* data,
[-] 	int result = EC_POINT_point2oct (group, m_h, form, NULL, 0, ctx);
[+] 	int result = EC_POINT_point2oct(group, m_h, form, NULL, 0, ctx);
[-] 		setLastCryptoError ();
[+] 		setLastCryptoError();
[-] 	data->setCount (result);
[+] 	data->setCount(result);
[-] 	result = EC_POINT_point2oct (group, m_h, form, (uchar_t*) data->p (), size, ctx);
[+] 	result = EC_POINT_point2oct(group, m_h, form, (uchar_t*)data->p(), size, ctx);
[-] 		setLastCryptoError ();
[+] 		setLastCryptoError();
[-] EcPoint::getHexString (
[+] EcPoint::getHexString(
[-] 	char* p = EC_POINT_point2hex (group, m_h, form, ctx);
[+] 	char* p = EC_POINT_point2hex(group, m_h, form, ctx);
[-] 	OPENSSL_free (p);
[+] 	OPENSSL_free(p);
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_cry\axl_cry_Rsa.cpp
----------------------
[-] Rsa::readPublicKey (BIO* bio)
[+] Rsa::readPublicKey(BIO* bio)
[-] 	close ();
[+] 	close();
[-] 	bool result = PEM_read_bio_RSA_PUBKEY (bio, &m_h, 0, NULL) != NULL;
[+] 	bool result = PEM_read_bio_RSA_PUBKEY(bio, &m_h, 0, NULL) != NULL;
[-] 	return completeWithLastCryptoError (result);
[+] 	return completeWithLastCryptoError(result);
[-] Rsa::readPrivateKey (BIO* bio)
[+] Rsa::readPrivateKey(BIO* bio)
[-] 	close ();
[+] 	close();
[-] 	bool result = PEM_read_bio_RSAPrivateKey (bio, &m_h, 0, NULL) != NULL;
[+] 	bool result = PEM_read_bio_RSAPrivateKey(bio, &m_h, 0, NULL) != NULL;
[-] 	return completeWithLastCryptoError (result);
[+] 	return completeWithLastCryptoError(result);
[-] Rsa::signHash (
[+] Rsa::signHash(
[-] 	ASSERT (signatureBufferSize >= getSize ());
[+] 	ASSERT(signatureBufferSize >= getSize());
[-] 	uint_t signatureSize = (uint_t) signatureBufferSize;
[+] 	uint_t signatureSize = (uint_t)signatureBufferSize;
[-] 	int result = RSA_sign (
[+] 	int result = RSA_sign(
[-] 		(int) hashSize,
[+] 		(int)hashSize,
[-] 		(uchar_t*) signatureBuffer,
[+] 		(uchar_t*)signatureBuffer,
[-] 		setLastCryptoError ();
[+] 		setLastCryptoError();
[-] 	ASSERT (signatureSize <= signatureBufferSize);
[+] 	ASSERT(signatureSize <= signatureBufferSize);
[-] Rsa::signHash (
[+] Rsa::signHash(
[-] 	sl::Array <char>* signature,
[+] 	sl::Array<char>* signature,
[-] 	size_t signatureBufferSize = getSize ();
[+] 	size_t signatureBufferSize = getSize();
[-] 	bool result = signature->setCount (signatureBufferSize);
[+] 	bool result = signature->setCount(signatureBufferSize);
[-] 	size_t size = signHash (type, *signature, signatureBufferSize, hash, hashSize);
[+] 	size_t size = signHash(type, *signature, signatureBufferSize, hash, hashSize);
[-] 	ASSERT (size <= signatureBufferSize);
[+] 	ASSERT(size <= signatureBufferSize);
[-] 	signature->setCount (size);
[+] 	signature->setCount(size);
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_fsm\axl_fsm_Dfa.cpp
----------------------
[-] DfaState::DfaState ()
[+] DfaState::DfaState()
[-] DfaState::addNfaState (NfaState* nfaState)
[+] DfaState::addNfaState(NfaState* nfaState)
[-] 	bool result = m_nfaStateSet.addState (nfaState);
[+] 	bool result = m_nfaStateSet.addState(nfaState);
[-] 		ASSERT (nfaState->m_captureId != -1);
[+] 		ASSERT(nfaState->m_captureId != -1);
[-] 		m_openCaptureIdSet.setBitResize (nfaState->m_captureId);
[+] 		m_openCaptureIdSet.setBitResize(nfaState->m_captureId);
[-] 		ASSERT (nfaState->m_captureId != -1);
[+] 		ASSERT(nfaState->m_captureId != -1);
[-] 		m_closeCaptureIdSet.setBitResize (nfaState->m_captureId);
[+] 		m_closeCaptureIdSet.setBitResize(nfaState->m_captureId);
[-] DfaState::makeEpsilonClosure ()
[+] DfaState::makeEpsilonClosure()
[-] 	sl::Array <NfaState*> workingSet = m_nfaStateSet.m_stateArray;
[+] 	sl::Array<NfaState*> workingSet = m_nfaStateSet.m_stateArray;
[-] 	while (!workingSet.isEmpty ())
[+] 	while (!workingSet.isEmpty())
[-] 		NfaState* nfaState = workingSet.getBackAndPop ();
[+] 		NfaState* nfaState = workingSet.getBackAndPop();
[-] 		bool isAdded = addNfaState (nfaState->m_outState);
[+] 		bool isAdded = addNfaState(nfaState->m_outState);
[-] 			workingSet.append (nfaState->m_outState);
[+] 			workingSet.append(nfaState->m_outState);
[-] 			isAdded = addNfaState (nfaState->m_outState2);
[+] 			isAdded = addNfaState(nfaState->m_outState2);
[-] 				workingSet.append (nfaState->m_outState2);
[+] 				workingSet.append(nfaState->m_outState2);
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_fsm\axl_fsm_Nfa.cpp
----------------------
[-] MatchCondition::MatchCondition ()
[+] MatchCondition::MatchCondition()
[-] MatchCondition::addChar (uchar_t c)
[+] MatchCondition::addChar(uchar_t c)
[-] 	switch (m_conditionKind)
[+] 	switch(m_conditionKind)
[-] 		ASSERT (m_char < 256);
[+] 		ASSERT(m_char < 256);
[-] 		m_charSet.setBitCount (256);
[+] 		m_charSet.setBitCount(256);
[-] 		m_charSet.setBit (m_char);
[+] 		m_charSet.setBit(m_char);
[-] 		m_charSet.setBit (c);
[+] 		m_charSet.setBit(c);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] NfaState::NfaState ()
[+] NfaState::NfaState()
[-] NfaState::createEpsilonLink (NfaState* outState)
[+] NfaState::createEpsilonLink(NfaState* outState)
[-] 	ASSERT (!(m_flags & NfaStateFlag_TransitionMask) && !m_outState && !m_outState2);
[+] 	ASSERT(!(m_flags & NfaStateFlag_TransitionMask) && !m_outState && !m_outState2);
[-] NfaState::createEpsilonLink (
[+] NfaState::createEpsilonLink(
[-] 	ASSERT (!(m_flags & NfaStateFlag_TransitionMask) && !m_outState && !m_outState2);
[+] 	ASSERT(!(m_flags & NfaStateFlag_TransitionMask) && !m_outState && !m_outState2);
[-] NfaState::createCharMatch (
[+] NfaState::createCharMatch(
[-] NfaStateSet::addState (NfaState* state)
[+] NfaStateSet::addState(NfaState* state)
[-] 	if (m_stateSet.getBit (state->m_id))
[+] 	if (m_stateSet.getBit(state->m_id))
[-] 	m_stateArray.append (state);
[+] 	m_stateArray.append(state);
[-] 	if (state->m_id >= m_stateSet.getBitCount ())
[+] 	if (state->m_id >= m_stateSet.getBitCount())
[-] 		m_stateSet.setBitCount (state->m_id + 1);
[+] 		m_stateSet.setBitCount(state->m_id + 1);
[-] 	m_stateSet.setBit (state->m_id);
[+] 	m_stateSet.setBit(state->m_id);
[-] NfaTransitionMgr::clear ()
[+] NfaTransitionMgr::clear()
[-] 	m_transitionList.clear ();
[+] 	m_transitionList.clear();
[-] 	memset (m_transitionMap, 0, sizeof (m_transitionMap));
[+] 	memset(m_transitionMap, 0, sizeof(m_transitionMap));
[-] NfaTransitionMgr::addMatchState (NfaState* state)
[+] NfaTransitionMgr::addMatchState(NfaState* state)
[-] 	ASSERT (state->m_flags & NfaStateFlag_Match);
[+] 	ASSERT(state->m_flags & NfaStateFlag_Match);
[-] 	switch (state->m_matchCondition.m_conditionKind)
[+] 	switch(state->m_matchCondition.m_conditionKind)
[-] 		addMatchCharTransition (state->m_matchCondition.m_char, state->m_outState);
[+] 		addMatchCharTransition(state->m_matchCondition.m_char, state->m_outState);
[-] 			if (state->m_matchCondition.m_charSet.getBit (i))
[+] 			if (state->m_matchCondition.m_charSet.getBit(i))
[-] 				addMatchCharTransition (i, state->m_outState);
[+] 				addMatchCharTransition(i, state->m_outState);
[-] 			addMatchCharTransition (i, state->m_outState);
[+] 			addMatchCharTransition(i, state->m_outState);
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] NfaTransitionMgr::finalize ()
[+] NfaTransitionMgr::finalize()
[-] 	NfaStateSetMap <NfaTransition*> transitionMap;
[+] 	NfaStateSetMap<NfaTransition*> transitionMap;
[-] 	sl::Iterator <NfaTransition> transitionIt = m_transitionList.getHead ();
[+] 	sl::Iterator<NfaTransition> transitionIt = m_transitionList.getHead();
[-] 		ASSERT (transition->m_matchCondition.m_conditionKind == MatchConditionKind_Char);
[+] 		ASSERT(transition->m_matchCondition.m_conditionKind == MatchConditionKind_Char);
[-] 		NfaStateSetMap <NfaTransition*>::Iterator mapIt = transitionMap.visit (&transition->m_outStateSet);
[+] 		NfaStateSetMap<NfaTransition*>::Iterator mapIt = transitionMap.visit(&transition->m_outStateSet);
[-] 		prevTransition->m_matchCondition.addChar (transition->m_matchCondition.m_char);
[+] 		prevTransition->m_matchCondition.addChar(transition->m_matchCondition.m_char);
[-] 		m_transitionList.erase (transition);
[+] 		m_transitionList.erase(transition);
[-] NfaTransitionMgr::addMatchCharTransition (
[+] NfaTransitionMgr::addMatchCharTransition(
[-] 	ASSERT (c < countof (m_transitionMap));
[+] 	ASSERT(c < countof(m_transitionMap));
[-] 	NfaTransition* transition = m_transitionMap [c];
[+] 	NfaTransition* transition = m_transitionMap[c];
[-] 		transition = AXL_MEM_NEW (NfaTransition);
[+] 		transition = AXL_MEM_NEW(NfaTransition);
[-] 		m_transitionList.insertTail (transition);
[+] 		m_transitionList.insertTail(transition);
[-] 		m_transitionMap [c] = transition;
[+] 		m_transitionMap[c] = transition;
[-] 	transition->m_outStateSet.addState (outState);
[+] 	transition->m_outStateSet.addState(outState);
----------------------
27/02/2019 18:01:48 - C:\Projects\repos\ioninja\axl\src\axl_fsm\axl_fsm_Regex.cpp
----------------------
[-] getCharSetString (const sl::BitMap* charSet)
[+] getCharSetString(const sl::BitMap* charSet)
[-] 		bool isSet = charSet->getBit (i);
[+] 		bool isSet = charSet->getBit(i);
[-] 				string.appendFormat (isprint (c1) ? "%c" : "\\x%02x", c1);
[+] 				string.appendFormat(isprint(c1) ? "%c" : "\\x%02x", c1);
[-] 				string.appendFormat (isprint (c2) ? "%c" : "\\x%02x", c2);
[+] 				string.appendFormat(isprint(c2) ? "%c" : "\\x%02x", c2);
[-] 			string.appendFormat (isprint (c2) ? "%c" : "\\x%02x", c2);
[+] 			string.appendFormat(isprint(c2) ? "%c" : "\\x%02x", c2);
[-] getMatchConditionString (const MatchCondition* condition)
[+] getMatchConditionString(const MatchCondition* condition)
[-] 	switch (condition->m_conditionKind)
[+] 	switch(condition->m_conditionKind)
[-] 		string.format (isprint (condition->m_char) ? "'%c'" : "'\\x%02x'", condition->m_char);
[+] 		string.format(isprint(condition->m_char) ? "'%c'" : "'\\x%02x'", condition->m_char);
[-] 		string.format ("[%s]", getCharSetString (&condition->m_charSet).sz ());
[+] 		string.format("[%s]", getCharSetString (&condition->m_charSet).sz ());
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] Regex::clear ()
[+] Regex::clear()
[-] 	m_nfaStateList.clear ();
[+] 	m_nfaStateList.clear();
[-] 	m_nfaStateArray.clear ();
[+] 	m_nfaStateArray.clear();
[-] 	m_dfaStateList.clear ();
[+] 	m_dfaStateList.clear();
[-] 	m_dfaStateArray.clear ();
[+] 	m_dfaStateArray.clear();
[-] Regex::match (const sl::StringRef& string)
[+] Regex::match(const sl::StringRef& string)
[-] Regex::compile (const sl::StringRef& source)
[+] Regex::compile(const sl::StringRef& source)
[-] 	RegexCompiler compiler (this);
[+] 	RegexCompiler compiler(this);
[-] 	return compiler.compile (source);
[+] 	return compiler.compile(source);
[-] Regex::print () const
[+] Regex::print() const
[-] 	printf ("NFA\n");
[+] 	printf("NFA\n");
[-] 	printf ("==================\n");
[+] 	printf("==================\n");
[-] 	sl::ConstIterator <NfaState> nfaIt = m_nfaStateList.getHead ();
[+] 	sl::ConstIterator<NfaState> nfaIt = m_nfaStateList.getHead();
[-] 		printf (
[+] 		printf(
[-] 			printf ("open (%d) ", nfaState->m_captureId);
[+] 			printf("open (%d) ", nfaState->m_captureId);
[-] 			printf ("close (%d) ", nfaState->m_captureId);
[+] 			printf("close (%d) ", nfaState->m_captureId);
[-] 			ASSERT (nfaState->m_outState && !nfaState->m_outState2);
[+] 			ASSERT(nfaState->m_outState && !nfaState->m_outState2);
[-] 			printf ("%s -> %02d", getMatchConditionString (&nfaState->m_matchCondition).sz (), nfaState->m_outState->m_id);
[+] 			printf("%s -> %02d", getMatchConditionString (&nfaState->m_matchCondition).sz (), nfaState->m_outState->m_id);
[-] 			ASSERT (nfaState->m_outState);
[+] 			ASSERT(nfaState->m_outState);
[-] 			printf ("eps -> %02d", nfaState->m_outState->m_id);
[+] 			printf("eps -> %02d", nfaState->m_outState->m_id);
[-] 				printf (", %02d", nfaState->m_outState2->m_id);
[+] 				printf(", %02d", nfaState->m_outState2->m_id);
[-] 		printf ("\n");
[+] 		printf("\n");
[-] 	printf ("\nDFA\n");
[+] 	printf("\nDFA\n");
[-] 	printf ("==================\n");
[+] 	printf("==================\n");
[-] 	sl::ConstIterator <DfaState> dfaIt = m_dfaStateList.getHead ();
[+] 	sl::ConstIterator<DfaState> dfaIt = m_dfaStateList.getHead();
[-] 		printf (
[+] 		printf(
[-] 		size_t count = dfaState->m_nfaStateSet.m_stateArray.getCount ();
[+] 		size_t count = dfaState->m_nfaStateSet.m_stateArray.getCount();
[-] 			NfaState* nfaState = dfaState->m_nfaStateSet.m_stateArray [i];
[+] 			NfaState* nfaState = dfaState->m_nfaStateSet.m_stateArray[i];
[-] 			printf ("%02d ", nfaState->m_id);
[+] 			printf("%02d ", nfaState->m_id);
[-] 		printf ("}");
[+] 		printf("}");
[-] 		size_t i = dfaState->m_openCaptureIdSet.findBit (0);
[+] 		size_t i = dfaState->m_openCaptureIdSet.findBit(0);
[-] 			printf (" open ( ");
[+] 			printf(" open ( ");
[-] 				printf ("%d ", i);
[+] 				printf("%d ", i);
[-] 				i = dfaState->m_openCaptureIdSet.findBit (i + 1);
[+] 				i = dfaState->m_openCaptureIdSet.findBit(i + 1);
[-] 			printf (")");
[+] 			printf(")");
[-] 		i = dfaState->m_closeCaptureIdSet.findBit (0);
[+] 		i = dfaState->m_closeCaptureIdSet.findBit(0);
[-] 			printf (" close ( ");
[+] 			printf(" close ( ");
[-] 				printf ("%d ", i);
[+] 				printf("%d ", i);
[-] 				i = dfaState->m_closeCaptureIdSet.findBit (i + 1);
[+] 				i = dfaState->m_closeCaptureIdSet.findBit(i + 1);
[-] 			printf (")");
[+] 			printf(")");
[-] 		printf ("\n");
[+] 		printf("\n");
[-] 		sl::ConstIterator <DfaTransition> dfaTransitionIt = dfaState->m_transitionList.getHead ();
[+] 		sl::ConstIterator<DfaTransition> dfaTransitionIt = dfaState->m_transitionList.getHead();
[-] 			printf ("    %s -> %02d\n", getMatchConditionString (&transition->m_matchCondition).sz (), transition->m_outState->m_id);
[+] 			printf("    %s -> %02d\n", getMatchConditionString (&transition->m_matchCondition).sz (), transition->m_outState->m_id);
[-] initValidSingleTable (bool* table)
[+] initValidSingleTable(bool* table)
[-] 	table ['.'] = true;
[+] 	table['.'] = true;
[-] 	table ['['] = true;
[+] 	table['['] = true;
[-] 	table ['('] = true;
[+] 	table['('] = true;
[-] 	table ['^'] = true;
[+] 	table['^'] = true;
[-] 	table ['$'] = true;
[+] 	table['$'] = true;
[-] 	table ['d'] = true;
[+] 	table['d'] = true;
[-] 	table ['D'] = true;
[+] 	table['D'] = true;
[-] 	table ['h'] = true;
[+] 	table['h'] = true;
[-] 	table ['H'] = true;
[+] 	table['H'] = true;
[-] 	table ['w'] = true;
[+] 	table['w'] = true;
[-] 	table ['W'] = true;
[+] 	table['W'] = true;
[-] 	table ['s'] = true;
[+] 	table['s'] = true;
[-] 	table ['S'] = true;
[+] 	table['S'] = true;
[-] RegexCompiler::Token::isValidSingle ()
[+] RegexCompiler::Token::isValidSingle()
[-] 	static bool validSingleTable [256] = { 0 };
[+] 	static bool validSingleTable[256] = { 0 };
[-] 	sl::callOnce (initValidSingleTable, validSingleTable);
[+] 	sl::callOnce(initValidSingleTable, validSingleTable);
[-] 	return validSingleTable [(uchar_t) m_char];
[+] 	return validSingleTable[(uchar_t)m_char];
[-] RegexCompiler::construct (
[+] RegexCompiler::construct(
[-] RegexCompiler::compile (
[+] RegexCompiler::compile(
[-] 	m_regex->clear ();
[+] 	m_regex->clear();
[-] 	bool result = incrementalCompile (source, acceptContext);
[+] 	bool result = incrementalCompile(source, acceptContext);
[-] 	finalize ();
[+] 	finalize();
[-] RegexCompiler::incrementalCompile (
[+] RegexCompiler::incrementalCompile(
[-] 	m_p = source.cp ();
[+] 	m_p = source.cp();
[-] 	m_end = source.getEnd ();
[+] 	m_end = source.getEnd();
[-] 	NfaState* oldStart = !m_regex->m_nfaStateList.isEmpty () ?
[+] 	NfaState* oldStart = !m_regex->m_nfaStateList.isEmpty() ?
[-] 		*m_regex->m_nfaStateList.getHead () :
[+] 		*m_regex->m_nfaStateList.getHead() :
[-] 	NfaState* body = expression ();
[+] 	NfaState* body = expression();
[-] 	bool result = expectEof ();
[+] 	bool result = expectEof();
[-] 	NfaState* accept = *m_regex->m_nfaStateList.getTail ();
[+] 	NfaState* accept = *m_regex->m_nfaStateList.getTail();
[-] 		NfaState* split = AXL_MEM_NEW (NfaState);
[+] 		NfaState* split = AXL_MEM_NEW(NfaState);
[-] 		split->createEpsilonLink (oldStart, body);
[+] 		split->createEpsilonLink(oldStart, body);
[-] 		m_regex->m_nfaStateList.insertHead (split);
[+] 		m_regex->m_nfaStateList.insertHead(split);
[-] RegexCompiler::finalize ()
[+] RegexCompiler::finalize()
[-] 	assignNfaIds ();
[+] 	assignNfaIds();
[-] 	makeDfa ();
[+] 	makeDfa();
[-] 	minimizeDfa ();
[+] 	minimizeDfa();
[-] 	assignDfaIds ();
[+] 	assignDfaIds();
[-] RegexCompiler::assignNfaIds ()
[+] RegexCompiler::assignNfaIds()
[-] 	size_t nfaStateCount = m_regex->m_nfaStateList.getCount ();
[+] 	size_t nfaStateCount = m_regex->m_nfaStateList.getCount();
[-] 	m_regex->m_nfaStateArray.setCount (nfaStateCount);
[+] 	m_regex->m_nfaStateArray.setCount(nfaStateCount);
[-] 	sl::Iterator <NfaState> nfaIt = m_regex->m_nfaStateList.getHead ();
[+] 	sl::Iterator<NfaState> nfaIt = m_regex->m_nfaStateList.getHead();
[-] 		m_regex->m_nfaStateArray [i] = nfaState;
[+] 		m_regex->m_nfaStateArray[i] = nfaState;
[-] RegexCompiler::assignDfaIds ()
[+] RegexCompiler::assignDfaIds()
[-] 	size_t dfaStateCount = m_regex->m_dfaStateList.getCount ();
[+] 	size_t dfaStateCount = m_regex->m_dfaStateList.getCount();
[-] 	m_regex->m_dfaStateArray.setCount (dfaStateCount);
[+] 	m_regex->m_dfaStateArray.setCount(dfaStateCount);
[-] 	sl::Iterator <DfaState> dfaIt = m_regex->m_dfaStateList.getHead ();
[+] 	sl::Iterator<DfaState> dfaIt = m_regex->m_dfaStateList.getHead();
[-] 		m_regex->m_dfaStateArray [i] = state;
[+] 		m_regex->m_dfaStateArray[i] = state;
[-] RegexCompiler::makeDfa ()
[+] RegexCompiler::makeDfa()
[-] 	m_regex->m_dfaStateList.clear ();
[+] 	m_regex->m_dfaStateList.clear();
[-] 	if (m_regex->m_nfaStateList.isEmpty ())
[+] 	if (m_regex->m_nfaStateList.isEmpty())
[-] 	sl::Array <DfaState*> workingSet;
[+] 	sl::Array<DfaState*> workingSet;
[-] 	NfaStateSetMap <DfaState*> dfaStateMap;
[+] 	NfaStateSetMap<DfaState*> dfaStateMap;
[-] 	DfaState* dfaState = AXL_MEM_NEW (DfaState);
[+] 	DfaState* dfaState = AXL_MEM_NEW(DfaState);
[-] 	dfaState->addNfaState (*m_regex->m_nfaStateList.getHead ());
[+] 	dfaState->addNfaState(*m_regex->m_nfaStateList.getHead());
[-] 	dfaState->makeEpsilonClosure ();
[+] 	dfaState->makeEpsilonClosure();
[-] 	m_regex->m_dfaStateList.insertTail (dfaState);
[+] 	m_regex->m_dfaStateList.insertTail(dfaState);
[-] 	workingSet.append (dfaState);
[+] 	workingSet.append(dfaState);
[-] 	dfaStateMap [&dfaState->m_nfaStateSet] = dfaState;
[+] 	dfaStateMap[&dfaState->m_nfaStateSet] = dfaState;
[-] 	while (!workingSet.isEmpty ())
[+] 	while (!workingSet.isEmpty())
[-] 		DfaState* dfaState = workingSet.getBackAndPop ();
[+] 		DfaState* dfaState = workingSet.getBackAndPop();
[-] 		nfaTransitionMgr.clear ();
[+] 		nfaTransitionMgr.clear();
[-] 		size_t nfaStateCount = dfaState->m_nfaStateSet.m_stateArray.getCount ();
[+] 		size_t nfaStateCount = dfaState->m_nfaStateSet.m_stateArray.getCount();
[-] 			NfaState* nfaState = dfaState->m_nfaStateSet.m_stateArray [i];
[+] 			NfaState* nfaState = dfaState->m_nfaStateSet.m_stateArray[i];
[-] 				nfaTransitionMgr.addMatchState (nfaState);
[+] 				nfaTransitionMgr.addMatchState(nfaState);
[-] 		nfaTransitionMgr.finalize ();
[+] 		nfaTransitionMgr.finalize();
[-] 		sl::ConstList <NfaTransition> nfaTransitionList = nfaTransitionMgr.getTransitionList ();
[+] 		sl::ConstList<NfaTransition> nfaTransitionList = nfaTransitionMgr.getTransitionList();
[-] 		sl::ConstIterator <NfaTransition> nfaTransitionIt = nfaTransitionList.getHead ();
[+] 		sl::ConstIterator<NfaTransition> nfaTransitionIt = nfaTransitionList.getHead();
[-] 			DfaState* dfaState2 = AXL_MEM_NEW (DfaState);
[+] 			DfaState* dfaState2 = AXL_MEM_NEW(DfaState);
[-] 			size_t outCount = nfaTransition->m_outStateSet.m_stateArray.getCount ();
[+] 			size_t outCount = nfaTransition->m_outStateSet.m_stateArray.getCount();
[-] 				NfaState* nfaState = nfaTransition->m_outStateSet.m_stateArray [i];
[+] 				NfaState* nfaState = nfaTransition->m_outStateSet.m_stateArray[i];
[-] 				dfaState2->addNfaState (nfaState);
[+] 				dfaState2->addNfaState(nfaState);
[-] 			dfaState2->makeEpsilonClosure ();
[+] 			dfaState2->makeEpsilonClosure();
[-] 			NfaStateSetMap <DfaState*>::Iterator mapIt = dfaStateMap.visit (&dfaState2->m_nfaStateSet);
[+] 			NfaStateSetMap<DfaState*>::Iterator mapIt = dfaStateMap.visit(&dfaState2->m_nfaStateSet);
[-] 				AXL_MEM_DELETE (dfaState2);
[+] 				AXL_MEM_DELETE(dfaState2);
[-] 				m_regex->m_dfaStateList.insertTail (dfaState2);
[+] 				m_regex->m_dfaStateList.insertTail(dfaState2);
[-] 				workingSet.append (dfaState2);
[+] 				workingSet.append(dfaState2);
[-] 			DfaTransition* dfaTransition = AXL_MEM_NEW (DfaTransition);
[+] 			DfaTransition* dfaTransition = AXL_MEM_NEW(DfaTransition);
[-] 			dfaState->m_transitionList.insertTail (dfaTransition);
[+] 			dfaState->m_transitionList.insertTail(dfaTransition);
[-] RegexCompiler::minimizeDfa ()
[+] RegexCompiler::minimizeDfa()
[-] getHexValue (
[+] getHexValue(
[-] RegexCompiler::readHexEscapeSequence (uchar_t* c)
[+] RegexCompiler::readHexEscapeSequence(uchar_t* c)
[-] 	ASSERT (*m_p == 'x');
[+] 	ASSERT(*m_p == 'x');
[-] 		getHexValue (m_p [0], &x1) &&
[+] 		getHexValue(m_p[0], &x1) &&
[-] 		getHexValue (m_p [1], &x2);
[+] 		getHexValue(m_p[1], &x2);
[-] 		err::setFormatStringError ("invalid hex escape sequence");
[+] 		err::setFormatStringError("invalid hex escape sequence");
[-] RegexCompiler::readEscapeSequence (uchar_t* c)
[+] RegexCompiler::readEscapeSequence(uchar_t* c)
[-] 	ASSERT (*m_p == '\\');
[+] 	ASSERT(*m_p == '\\');
[-] 		err::setError ("invalid escape sequence");
[+] 		err::setError("invalid escape sequence");
[-] 	switch (*m_p)
[+] 	switch(*m_p)
[-] 		return readHexEscapeSequence (c);
[+] 		return readHexEscapeSequence(c);
[-] RegexCompiler::readLiteral (sl::String* string)
[+] RegexCompiler::readLiteral(sl::String* string)
[-] 	ASSERT (delimiter == '"' || delimiter == '\'');
[+] 	ASSERT(delimiter == '"' || delimiter == '\'');
[-] 			err::setError ("unclosed literal");
[+] 			err::setError("unclosed literal");
[-] 		switch (*p)
[+] 		switch(*p)
[-] 				err::setError ("invalid escape sequence");
[+] 				err::setError("invalid escape sequence");
[-] 				size_t size = enc::EscapeEncoding::decode (string, sl::StringRef (m_p, p - m_p));
[+] 				size_t size = enc::EscapeEncoding::decode(string, sl::StringRef(m_p, p - m_p));
[-] RegexCompiler::readHexLiteral (sl::String* string)
[+] RegexCompiler::readHexLiteral(sl::String* string)
[-] 	ASSERT (m_p [0] == '0' && m_p [1] == 'x');
[+] 	ASSERT(m_p[0] == '0' && m_p[1] == 'x');
[-] 	ASSERT (delimiter == '"' || delimiter == '\'');
[+] 	ASSERT(delimiter == '"' || delimiter == '\'');
[-] 			err::setError ("unclosed literal");
[+] 			err::setError("unclosed literal");
[-] 		switch (*p)
[+] 		switch(*p)
[-] 				sl::Array <char> buffer;
[+] 				sl::Array<char> buffer;
[-] 				size_t size = enc::HexEncoding::decode (&buffer, sl::StringRef (m_p, p - m_p));
[+] 				size_t size = enc::HexEncoding::decode(&buffer, sl::StringRef(m_p, p - m_p));
[-] 				string->copy (buffer, size);
[+] 				string->copy(buffer, size);
[-] RegexCompiler::readIdentifier (sl::String* name)
[+] RegexCompiler::readIdentifier(sl::String* name)
[-] 	ASSERT (isalpha ((uchar_t) *m_p) || *m_p == '_');
[+] 	ASSERT(isalpha((uchar_t)*m_p) || *m_p == '_');
[-] 	name->copy ((uchar_t) *m_p++);
[+] 	name->copy((uchar_t)*m_p++);
[-] 	while (m_p < m_end && isalnum ((uchar_t) *m_p) || *m_p == '_')
[+] 	while (m_p < m_end && isalnum((uchar_t)*m_p) || *m_p == '_')
[-] 		name->append ((uchar_t) *m_p);
[+] 		name->append((uchar_t)*m_p);
[-] RegexCompiler::readQuantifier (size_t* count)
[+] RegexCompiler::readQuantifier(size_t* count)
[-] 	char buffer [16] = { 0 };
[+] 	char buffer[16] = { 0 };
[-] 		i < countof (buffer) - 1 && m_p < m_end && isdigit ((uchar_t) *m_p);
[+] 		i < countof(buffer) - 1 && m_p < m_end && isdigit((uchar_t)*m_p);
[-] 		buffer [i] = *m_p;
[+] 		buffer[i] = *m_p;
[-] 	long n  = strtoul (buffer, &end, 10);
[+] 	long n  = strtoul(buffer, &end, 10);
[-] 		result = expectSpecialChar ('}');
[+] 		result = expectSpecialChar('}');
[-] 		err::setFormatStringError (
[+] 		err::setFormatStringError(
[-] RegexCompiler::getToken (Token* token)
[+] RegexCompiler::getToken(Token* token)
[-] 			switch (*m_p)
[+] 			switch(*m_p)
[-] 					err::setError ("invalid escape sequence");
[+] 					err::setError("invalid escape sequence");
[-] 				switch (m_p [1])
[+] 				switch(m_p[1])
[-] 					token->m_char = m_p [1];
[+] 					token->m_char = m_p[1];
[-] 					if (m_p + 2 < m_end && m_p [2] == '\n')
[+] 					if (m_p + 2 < m_end && m_p[2] == '\n')
[-] 					return readEscapeSequence (&token->m_char);
[+] 					return readEscapeSequence(&token->m_char);
[-] 			switch (*m_p)
[+] 			switch(*m_p)
[-] 					err::setError ("invalid escape sequence");
[+] 					err::setError("invalid escape sequence");
[-] 				switch (m_p [1])
[+] 				switch(m_p[1])
[-] 					token->m_char = m_p [1];
[+] 					token->m_char = m_p[1];
[-] 					if (m_p + 2 < m_end && m_p [2] == '\n')
[+] 					if (m_p + 2 < m_end && m_p[2] == '\n')
[-] 					return readEscapeSequence (&token->m_char);
[+] 					return readEscapeSequence(&token->m_char);
[-] 				return readLiteral (&token->m_string);
[+] 				return readLiteral(&token->m_string);
[-] 				if (m_p + 2 < m_end && m_p [1] == 'x' && (m_p [2] == '"' || m_p [2] == '\''))
[+] 				if (m_p + 2 < m_end && m_p[1] == 'x' && (m_p[2] == '"' || m_p [2] == '\''))
[-] 					return readHexLiteral (&token->m_string);
[+] 					return readHexLiteral(&token->m_string);
[-] 				if (isalpha ((uchar_t) *m_p) || *m_p == '_')
[+] 				if (isalpha((uchar_t)*m_p) || *m_p == '_')
[-] 					return readIdentifier (&token->m_string);
[+] 					return readIdentifier(&token->m_string);
[-] RegexCompiler::expectSpecialChar (char c)
[+] RegexCompiler::expectSpecialChar(char c)
[-] 	bool result = getToken (&token);
[+] 	bool result = getToken(&token);
[-] 	if (!token.isSpecialChar (c))
[+] 	if (!token.isSpecialChar(c))
[-] 		err::setFormatStringError ("'%c' expected", c);
[+] 		err::setFormatStringError("'%c' expected", c);
[-] RegexCompiler::expectEof ()
[+] RegexCompiler::expectEof()
[-] 	bool result = getToken (&token);
[+] 	bool result = getToken(&token);
[-] 	if (!token.isSpecialChar (0))
[+] 	if (!token.isSpecialChar(0))
[-] 		err::setError ("invalid regexp syntax");
[+] 		err::setError("invalid regexp syntax");
[-] RegexCompiler::expression ()
[+] RegexCompiler::expression()
[-] 	NfaState* op1 = concat ();
[+] 	NfaState* op1 = concat();
[-] 	bool result = getToken (&token);
[+] 	bool result = getToken(&token);
[-] 	if (!token.isSpecialChar ('|'))
[+] 	if (!token.isSpecialChar('|'))
[-] 	NfaState* accept1 = *m_regex->m_nfaStateList.getTail ();
[+] 	NfaState* accept1 = *m_regex->m_nfaStateList.getTail();
[-] 	NfaState* op2 = expression ();
[+] 	NfaState* op2 = expression();
[-] 	NfaState* accept2 = *m_regex->m_nfaStateList.getTail ();
[+] 	NfaState* accept2 = *m_regex->m_nfaStateList.getTail();
[-] 	NfaState* start = AXL_MEM_NEW (NfaState);
[+] 	NfaState* start = AXL_MEM_NEW(NfaState);
[-] 	NfaState* accept = AXL_MEM_NEW (NfaState);
[+] 	NfaState* accept = AXL_MEM_NEW(NfaState);
[-] 	m_regex->m_nfaStateList.insertBefore (start, op1);
[+] 	m_regex->m_nfaStateList.insertBefore(start, op1);
[-] 	m_regex->m_nfaStateList.insertTail (accept);
[+] 	m_regex->m_nfaStateList.insertTail(accept);
[-] 	start->createEpsilonLink (op1, op2);
[+] 	start->createEpsilonLink(op1, op2);
[-] 	accept1->createEpsilonLink (accept);
[+] 	accept1->createEpsilonLink(accept);
[-] 	accept2->createEpsilonLink (accept);
[+] 	accept2->createEpsilonLink(accept);
[-] RegexCompiler::concat ()
[+] RegexCompiler::concat()
[-] 	NfaState* start = repeat ();
[+] 	NfaState* start = repeat();
[-] 		bool result = getToken (&token);
[+] 		bool result = getToken(&token);
[-] 		if (!token.isValidSingle ())
[+] 		if (!token.isValidSingle())
[-] 		NfaState* accept1 = *m_regex->m_nfaStateList.getTail ();
[+] 		NfaState* accept1 = *m_regex->m_nfaStateList.getTail();
[-] 		NfaState* op2 = repeat ();
[+] 		NfaState* op2 = repeat();
[-] 		accept1->createEpsilonLink (op2);
[+] 		accept1->createEpsilonLink(op2);
[-] RegexCompiler::repeat ()
[+] RegexCompiler::repeat()
[-] 	NfaState* start = single ();
[+] 	NfaState* start = single();
[-] 	bool result = getToken (&token);
[+] 	bool result = getToken(&token);
[-] 		switch (token.m_char)
[+] 		switch(token.m_char)
[-] 			return question (start);
[+] 			return question(start);
[-] 			return star (start);
[+] 			return star(start);
[-] 			return plus (start);
[+] 			return plus(start);
[-] 			result = readQuantifier (&count);
[+] 			result = readQuantifier(&count);
[-] 			return result ? quantify (start, count) : NULL;
[+] 			return result ? quantify(start, count) : NULL;
[-] RegexCompiler::question (NfaState* start)
[+] RegexCompiler::question(NfaState* start)
[-] 	NfaState* accept = *m_regex->m_nfaStateList.getTail ();
[+] 	NfaState* accept = *m_regex->m_nfaStateList.getTail();
[-] 	NfaState* split = AXL_MEM_NEW (NfaState);
[+] 	NfaState* split = AXL_MEM_NEW(NfaState);
[-] 	m_regex->m_nfaStateList.insertBefore (split, start);
[+] 	m_regex->m_nfaStateList.insertBefore(split, start);
[-] 	split->createEpsilonLink (start, accept);
[+] 	split->createEpsilonLink(start, accept);
[-] RegexCompiler::star (NfaState* start)
[+] RegexCompiler::star(NfaState* start)
[-] 	NfaState* oldAccept = *m_regex->m_nfaStateList.getTail ();
[+] 	NfaState* oldAccept = *m_regex->m_nfaStateList.getTail();
[-] 	NfaState* newAccept = AXL_MEM_NEW (NfaState);
[+] 	NfaState* newAccept = AXL_MEM_NEW(NfaState);
[-] 	m_regex->m_nfaStateList.insertTail (newAccept);
[+] 	m_regex->m_nfaStateList.insertTail(newAccept);
[-] 	NfaState* split = AXL_MEM_NEW (NfaState);
[+] 	NfaState* split = AXL_MEM_NEW(NfaState);
[-] 	m_regex->m_nfaStateList.insertBefore (split, start);
[+] 	m_regex->m_nfaStateList.insertBefore(split, start);
[-] 	split->createEpsilonLink (start, newAccept);
[+] 	split->createEpsilonLink(start, newAccept);
[-] 	oldAccept->createEpsilonLink (start, newAccept);
[+] 	oldAccept->createEpsilonLink(start, newAccept);
[-] RegexCompiler::plus (NfaState* start)
[+] RegexCompiler::plus(NfaState* start)
[-] 	NfaState* oldAccept = *m_regex->m_nfaStateList.getTail ();
[+] 	NfaState* oldAccept = *m_regex->m_nfaStateList.getTail();
[-] 	NfaState* newAccept = AXL_MEM_NEW (NfaState);
[+] 	NfaState* newAccept = AXL_MEM_NEW(NfaState);
[-] 	m_regex->m_nfaStateList.insertTail (newAccept);
[+] 	m_regex->m_nfaStateList.insertTail(newAccept);
[-] 	oldAccept->createEpsilonLink (start, newAccept);
[+] 	oldAccept->createEpsilonLink(start, newAccept);
[-] RegexCompiler::quantify (
[+] RegexCompiler::quantify(
[-] 	ASSERT (count <= Const_MaxQuantifier);
[+] 	ASSERT(count <= Const_MaxQuantifier);
[-] 	NfaState* accept = *m_regex->m_nfaStateList.getTail ();
[+] 	NfaState* accept = *m_regex->m_nfaStateList.getTail();
[-] 		start = clone (start, accept);
[+] 		start = clone(start, accept);
[-] 		accept->createEpsilonLink (start);
[+] 		accept->createEpsilonLink(start);
[-] 		accept = *m_regex->m_nfaStateList.getTail ();
[+] 		accept = *m_regex->m_nfaStateList.getTail();
[-] RegexCompiler::clone (
[+] RegexCompiler::clone(
[-] 	sl::SimpleHashTable <NfaState*, NfaState*> stateMap;
[+] 	sl::SimpleHashTable<NfaState*, NfaState*> stateMap;
[-] 	sl::Iterator <NfaState> end = m_regex->m_nfaStateList.getTail ();
[+] 	sl::Iterator<NfaState> end = m_regex->m_nfaStateList.getTail();
[-] 	sl::Iterator <NfaState> it = first;
[+] 	sl::Iterator<NfaState> it = first;
[-] 		NfaState* newState = AXL_MEM_NEW (NfaState);
[+] 		NfaState* newState = AXL_MEM_NEW(NfaState);
[-] 		stateMap [oldState] = newState;
[+] 		stateMap[oldState] = newState;
[-] 		m_regex->m_nfaStateList.insertTail (newState);
[+] 		m_regex->m_nfaStateList.insertTail(newState);
[-] 		sl::HashTableIterator <NfaState*, NfaState*> mapIt;
[+] 		sl::HashTableIterator<NfaState*, NfaState*> mapIt;
[-] 			mapIt = stateMap.find (state->m_outState);
[+] 			mapIt = stateMap.find(state->m_outState);
[-] 			mapIt = stateMap.find (state->m_outState2);
[+] 			mapIt = stateMap.find(state->m_outState2);
[-] RegexCompiler::single ()
[+] RegexCompiler::single()
[-] 	result = getToken (&token);
[+] 	result = getToken(&token);
[-] 	switch (token.m_tokenKind)
[+] 	switch(token.m_tokenKind)
[-] 		switch (token.m_char)
[+] 		switch(token.m_char)
[-] 			if (m_p + 1 < m_end && m_p [0] == '?' && m_p [1] == ':')
[+] 			if (m_p + 1 < m_end && m_p[0] == '?' && m_p[1] == ':')
[-] 				return nonCapturingGroup ();
[+] 				return nonCapturingGroup();
[-] 				return nonCapturingGroup ();
[+] 				return nonCapturingGroup();
[-] 				return capturingGroup ();
[+] 				return capturingGroup();
[-] 			return charClass ();
[+] 			return charClass();
[-] 			return stdCharClass (token.m_char);
[+] 			return stdCharClass(token.m_char);
[-] 			return any ();
[+] 			return any();
[-] 			err::setError ("invalid regexp syntax");
[+] 			err::setError("invalid regexp syntax");
[-] 		return ch (token.m_char);
[+] 		return ch(token.m_char);
[-] 		return literal (token.m_string);
[+] 		return literal(token.m_string);
[-] 		return namedRegex (token.m_string);
[+] 		return namedRegex(token.m_string);
[-] 		err::setError ("invalid regexp syntax");
[+] 		err::setError("invalid regexp syntax");
[-] RegexCompiler::literal (const sl::StringRef& string)
[+] RegexCompiler::literal(const sl::StringRef& string)
[-] 	NfaState* start = AXL_MEM_NEW (NfaState);
[+] 	NfaState* start = AXL_MEM_NEW(NfaState);
[-] 	m_regex->m_nfaStateList.insertTail (start);
[+] 	m_regex->m_nfaStateList.insertTail(start);
[-] 	const char* p = string.cp ();
[+] 	const char* p = string.cp();
[-] 	const char* end = string.getEnd ();
[+] 	const char* end = string.getEnd();
[-] 		ch ((uchar_t) *p, mid);
[+] 		ch((uchar_t)*p, mid);
[-] 		mid = *m_regex->m_nfaStateList.getTail ();
[+] 		mid = *m_regex->m_nfaStateList.getTail();
[-] RegexCompiler::ch (uint_t c)
[+] RegexCompiler::ch(uint_t c)
[-] 	NfaState* start = AXL_MEM_NEW (NfaState);
[+] 	NfaState* start = AXL_MEM_NEW(NfaState);
[-] 	m_regex->m_nfaStateList.insertTail (start);
[+] 	m_regex->m_nfaStateList.insertTail(start);
[-] 	ch (c, start);
[+] 	ch(c, start);
[-] RegexCompiler::ch (
[+] RegexCompiler::ch(
[-] 	NfaState* accept = AXL_MEM_NEW (NfaState);
[+] 	NfaState* accept = AXL_MEM_NEW(NfaState);
[-] 	m_regex->m_nfaStateList.insertTail (accept);
[+] 	m_regex->m_nfaStateList.insertTail(accept);
[-] 	start->createCharMatch (c, accept);
[+] 	start->createCharMatch(c, accept);
[-] RegexCompiler::charClass ()
[+] RegexCompiler::charClass()
[-] 	NfaState* start = AXL_MEM_NEW (NfaState);
[+] 	NfaState* start = AXL_MEM_NEW(NfaState);
[-] 	start->m_matchCondition.m_charSet.setBitCount (256);
[+] 	start->m_matchCondition.m_charSet.setBitCount(256);
[-] 	m_regex->m_nfaStateList.insertTail (start);
[+] 	m_regex->m_nfaStateList.insertTail(start);
[-] 			err::setError ("invalid character class");
[+] 			err::setError("invalid character class");
[-] 		result = charClassItem (&start->m_matchCondition.m_charSet);
[+] 		result = charClassItem(&start->m_matchCondition.m_charSet);
[-] 		err::setError ("empty character class");
[+] 		err::setError("empty character class");
[-] 		start->m_matchCondition.m_charSet.inverse ();
[+] 		start->m_matchCondition.m_charSet.inverse();
[-] 	NfaState* accept = AXL_MEM_NEW (NfaState);
[+] 	NfaState* accept = AXL_MEM_NEW(NfaState);
[-] 	m_regex->m_nfaStateList.insertTail (accept);
[+] 	m_regex->m_nfaStateList.insertTail(accept);
[-] RegexCompiler::charClassItem (sl::BitMap* charSet)
[+] RegexCompiler::charClassItem(sl::BitMap* charSet)
[-] 	ASSERT (m_p < m_end);
[+] 	ASSERT(m_p < m_end);
[-] 	switch (*m_p)
[+] 	switch(*m_p)
[-] 			err::setError ("invalid escape sequence");
[+] 			err::setError("invalid escape sequence");
[-] 		switch (m_p [1])
[+] 		switch(m_p[1])
[-] 			stdCharClass (m_p [1], charSet);
[+] 			stdCharClass(m_p[1], charSet);
[-] 		result = readEscapeSequence (&c1);
[+] 		result = readEscapeSequence(&c1);
[-] 		charSet->setBit (c1);
[+] 		charSet->setBit(c1);
[-] 		err::setError ("invalid char class");
[+] 		err::setError("invalid char class");
[-] 	switch (*m_p)
[+] 	switch(*m_p)
[-] 		result = readEscapeSequence (&c2);
[+] 		result = readEscapeSequence(&c2);
[-] 	charSet->setBitRange (c1, c2 + 1);
[+] 	charSet->setBitRange(c1, c2 + 1);
[-] RegexCompiler::stdCharClass (uint_t c)
[+] RegexCompiler::stdCharClass(uint_t c)
[-] 	NfaState* start = AXL_MEM_NEW (NfaState);
[+] 	NfaState* start = AXL_MEM_NEW(NfaState);
[-] 	start->m_matchCondition.m_charSet.setBitCount (256);
[+] 	start->m_matchCondition.m_charSet.setBitCount(256);
[-] 	m_regex->m_nfaStateList.insertTail (start);
[+] 	m_regex->m_nfaStateList.insertTail(start);
[-] 	stdCharClass (c, &start->m_matchCondition.m_charSet);
[+] 	stdCharClass(c, &start->m_matchCondition.m_charSet);
[-] 	NfaState* accept = AXL_MEM_NEW (NfaState);
[+] 	NfaState* accept = AXL_MEM_NEW(NfaState);
[-] 	m_regex->m_nfaStateList.insertTail (accept);
[+] 	m_regex->m_nfaStateList.insertTail(accept);
[-] RegexCompiler::stdCharClass (
[+] RegexCompiler::stdCharClass(
[-] 	switch (c)
[+] 	switch(c)
[-] 		charSet->setBitRange ('0', '9' + 1);
[+] 		charSet->setBitRange('0', '9' + 1);
[-] 		charSet->setBitRange ('0', '9' + 1);
[+] 		charSet->setBitRange('0', '9' + 1);
[-] 		charSet->setBitRange ('a', 'f' + 1);
[+] 		charSet->setBitRange('a', 'f' + 1);
[-] 		charSet->setBitRange ('A', 'F' + 1);
[+] 		charSet->setBitRange('A', 'F' + 1);
[-] 		charSet->setBitRange ('a', 'z' + 1);
[+] 		charSet->setBitRange('a', 'z' + 1);
[-] 		charSet->setBitRange ('A', 'Z' + 1);
[+] 		charSet->setBitRange('A', 'Z' + 1);
[-] 		charSet->setBitRange ('0', '9' + 1);
[+] 		charSet->setBitRange('0', '9' + 1);
[-] 		charSet->setBit ('_');
[+] 		charSet->setBit('_');
[-] 		charSet->setBit (' ');
[+] 		charSet->setBit(' ');
[-] 		charSet->setBit ('\t');
[+] 		charSet->setBit('\t');
[-] 		charSet->setBit ('\r');
[+] 		charSet->setBit('\r');
[-] 		charSet->setBit ('\n');
[+] 		charSet->setBit('\n');
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 		charSet->inverse ();
[+] 		charSet->inverse();
[-] RegexCompiler::any ()
[+] RegexCompiler::any()
[-] 	NfaState* start = AXL_MEM_NEW (NfaState);
[+] 	NfaState* start = AXL_MEM_NEW(NfaState);
[-] 	m_regex->m_nfaStateList.insertTail (start);
[+] 	m_regex->m_nfaStateList.insertTail(start);
[-] 	NfaState* accept = AXL_MEM_NEW (NfaState);
[+] 	NfaState* accept = AXL_MEM_NEW(NfaState);
[-] 	m_regex->m_nfaStateList.insertTail (accept);
[+] 	m_regex->m_nfaStateList.insertTail(accept);
[-] RegexCompiler::capturingGroup ()
[+] RegexCompiler::capturingGroup()
[-] 	NfaState* open = AXL_MEM_NEW (NfaState);
[+] 	NfaState* open = AXL_MEM_NEW(NfaState);
[-] 	m_regex->m_nfaStateList.insertTail (open);
[+] 	m_regex->m_nfaStateList.insertTail(open);
[-] 	NfaState* start = nonCapturingGroup ();
[+] 	NfaState* start = nonCapturingGroup();
[-] 	NfaState* accept = *m_regex->m_nfaStateList.getTail ();
[+] 	NfaState* accept = *m_regex->m_nfaStateList.getTail();
[-] 	NfaState* close = AXL_MEM_NEW (NfaState);
[+] 	NfaState* close = AXL_MEM_NEW(NfaState);
[-] 	m_regex->m_nfaStateList.insertTail (close);
[+] 	m_regex->m_nfaStateList.insertTail(close);
[-] 	open->createEpsilonLink (start);
[+] 	open->createEpsilonLink(start);
[-] 	accept->createEpsilonLink (close);
[+] 	accept->createEpsilonLink(close);
[-] RegexCompiler::nonCapturingGroup ()
[+] RegexCompiler::nonCapturingGroup()
[-] 	NfaState* start = expression ();
[+] 	NfaState* start = expression();
[-] 	bool result = expectSpecialChar (')');
[+] 	bool result = expectSpecialChar(')');
[-] RegexCompiler::namedRegex (const sl::StringRef& name)
[+] RegexCompiler::namedRegex(const sl::StringRef& name)
[-] 		err::setFormatStringError ("named regexp '%s' is used but name manager is not set", name.sz ());
[+] 		err::setFormatStringError("named regexp '%s' is used but name manager is not set", name.sz ());
[-] 	sl::StringRef source = m_nameMgr->findName (name);
[+] 	sl::StringRef source = m_nameMgr->findName(name);
[-] 	if (source.isEmpty ())
[+] 	if (source.isEmpty())
[-] 		err::setFormatStringError ("named regexp '%s' is not defined", name.sz ());
[+] 		err::setFormatStringError("named regexp '%s' is not defined", name.sz ());
[-] 	RegexCompiler subRegexCompiler (Flag_NonCapturingGroups, &subRegex, m_nameMgr);
[+] 	RegexCompiler subRegexCompiler(Flag_NonCapturingGroups, &subRegex, m_nameMgr);
[-] 	bool result = subRegexCompiler.compile (source);
[+] 	bool result = subRegexCompiler.compile(source);
[-] 	NfaState* start = *subRegex.m_nfaStateList.getHead ();
[+] 	NfaState* start = *subRegex.m_nfaStateList.getHead();
[-] 	NfaState* accept = *subRegex.m_nfaStateList.getTail ();
[+] 	NfaState* accept = *subRegex.m_nfaStateList.getTail();
[-] 	ASSERT (accept->m_flags & NfaStateFlag_Accept);
[+] 	ASSERT(accept->m_flags & NfaStateFlag_Accept);
[-] 	m_regex->m_nfaStateList.insertListTail (&subRegex.m_nfaStateList);
[+] 	m_regex->m_nfaStateList.insertListTail(&subRegex.m_nfaStateList);
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_AnsiAttrParser.cpp
----------------------
[-] AnsiAttrParser::AnsiAttrParser ()
[+] AnsiAttrParser::AnsiAttrParser()
[-] AnsiAttrParser::parse (
[+] AnsiAttrParser::parse(
[-] 	static SetAttrFuncPtr setAttrFuncTable [108] = { 0 };
[+] 	static SetAttrFuncPtr setAttrFuncTable[108] = { 0 };
[-] 		setAttrFuncTable [0] = &AnsiAttrParser::clear;
[+] 		setAttrFuncTable[0] = &AnsiAttrParser::clear;
[-] 		setAttrFuncTable [1] = &AnsiAttrParser::setBoldOn;
[+] 		setAttrFuncTable[1] = &AnsiAttrParser::setBoldOn;
[-] 		setAttrFuncTable [3] = &AnsiAttrParser::setItalicOn;
[+] 		setAttrFuncTable[3] = &AnsiAttrParser::setItalicOn;
[-] 		setAttrFuncTable [4] = &AnsiAttrParser::setUnderlineOn;
[+] 		setAttrFuncTable[4] = &AnsiAttrParser::setUnderlineOn;
[-] 		setAttrFuncTable [7] = &AnsiAttrParser::setInverseOn;
[+] 		setAttrFuncTable[7] = &AnsiAttrParser::setInverseOn;
[-] 			setAttrFuncTable [i] = &AnsiAttrParser::setFont;
[+] 			setAttrFuncTable[i] = &AnsiAttrParser::setFont;
[-] 		setAttrFuncTable [22] = &AnsiAttrParser::setBoldOff;
[+] 		setAttrFuncTable[22] = &AnsiAttrParser::setBoldOff;
[-] 		setAttrFuncTable [23] = &AnsiAttrParser::setItalicOff;
[+] 		setAttrFuncTable[23] = &AnsiAttrParser::setItalicOff;
[-] 		setAttrFuncTable [24] = &AnsiAttrParser::setUnderlineOff;
[+] 		setAttrFuncTable[24] = &AnsiAttrParser::setUnderlineOff;
[-] 		setAttrFuncTable [27] = &AnsiAttrParser::setInverseOff;
[+] 		setAttrFuncTable[27] = &AnsiAttrParser::setInverseOff;
[-] 			setAttrFuncTable [i] = &AnsiAttrParser::setTextColor;
[+] 			setAttrFuncTable[i] = &AnsiAttrParser::setTextColor;
[-] 		setAttrFuncTable [39] = &AnsiAttrParser::setBaseTextColor;
[+] 		setAttrFuncTable[39] = &AnsiAttrParser::setBaseTextColor;
[-] 			setAttrFuncTable [i] = &AnsiAttrParser::setBackColor;
[+] 			setAttrFuncTable[i] = &AnsiAttrParser::setBackColor;
[-] 		setAttrFuncTable [49] = &AnsiAttrParser::setBaseBackColor;
[+] 		setAttrFuncTable[49] = &AnsiAttrParser::setBaseBackColor;
[-] 			setAttrFuncTable [i] = &AnsiAttrParser::setBrightTextColor;
[+] 			setAttrFuncTable[i] = &AnsiAttrParser::setBrightTextColor;
[-] 			setAttrFuncTable [i] = &AnsiAttrParser::setBrightBackColor;
[+] 			setAttrFuncTable[i] = &AnsiAttrParser::setBrightBackColor;
[-] 	const char* p = string.cp ();
[+] 	const char* p = string.cp();
[-] 	const char* end = string.getEnd ();
[+] 	const char* end = string.getEnd();
[-] 		uint_t attr = strtoul (p, &attrEnd, 10);
[+] 		uint_t attr = strtoul(p, &attrEnd, 10);
[-] 		if (attr < countof (setAttrFuncTable))
[+] 		if (attr < countof(setAttrFuncTable))
[-] 			SetAttrFuncPtr setAttrFunc = setAttrFuncTable [attr];
[+] 			SetAttrFuncPtr setAttrFunc = setAttrFuncTable[attr];
[-] AnsiAttrParser::clear (uint_t)
[+] AnsiAttrParser::clear(uint_t)
[-] AnsiAttrParser::setInverse (bool isInversed)
[+] AnsiAttrParser::setInverse(bool isInversed)
[-] AnsiAttrParser::setFontFlag (uint_t flag)
[+] AnsiAttrParser::setFontFlag(uint_t flag)
[-] AnsiAttrParser::clearFontFlag (uint_t flag)
[+] AnsiAttrParser::clearFontFlag(uint_t flag)
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_Color.cpp
----------------------
[-] Palette::getColorRgb (uint_t color)
[+] Palette::getColorRgb(uint_t color)
[-] 	color = i < m_count ? m_colorArray [i] : -1;
[+] 	color = i < m_count ? m_colorArray[i] : -1;
[-] 		color = i < m_count ? m_colorArray [i] : -1;
[+] 		color = i < m_count ? m_colorArray[i] : -1;
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_Engine.cpp
----------------------
[-] Engine::Engine ()
[+] Engine::Engine()
[-] 	static uint_t colorInitTable [StdPalColor__Count] =
[+] 	static uint_t colorInitTable[StdPalColor__Count] =
[-] 	ASSERT (sizeof (colorInitTable) == sizeof (m_stdPalColorTable));
[+] 	ASSERT(sizeof(colorInitTable) == sizeof(m_stdPalColorTable));
[-] 	memcpy (m_stdPalColorTable, colorInitTable, sizeof (m_stdPalColorTable));
[+] 	memcpy(m_stdPalColorTable, colorInitTable, sizeof(m_stdPalColorTable));
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_FontDesc.cpp
----------------------
[-] getFontFlagString (FontFlag flag)
[+] getFontFlagString(FontFlag flag)
[-] 	static const char* stringTable [] =
[+] 	static const char* stringTable[] =
[-] 	size_t i = sl::getLoBitIdx32 (flag >> 8);
[+] 	size_t i = sl::getLoBitIdx32(flag >> 8);
[-] 	return i < countof (stringTable) ?
[+] 	return i < countof(stringTable) ?
[-] 		stringTable [i] :
[+] 		stringTable[i] :
[-] FontDesc::setup (
[+] FontDesc::setup(
[-] 	size_t length = family.getLength ();
[+] 	size_t length = family.getLength();
[-] 	if (length >= countof (m_family))
[+] 	if (length >= countof(m_family))
[-] 		length = countof (m_family) - 1;
[+] 		length = countof(m_family) - 1;
[-] 	memcpy (m_family, family.cp (), length);
[+] 	memcpy(m_family, family.cp(), length);
[-] 	m_family [length] = 0;
[+] 	m_family[length] = 0;
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_GdiCanvas.cpp
----------------------
[-] GdiCanvas::GdiCanvas ()
[+] GdiCanvas::GdiCanvas()
[-] 	m_engine = GdiEngine::getSingleton ();
[+] 	m_engine = GdiEngine::getSingleton();
[-] GdiCanvas::attach (
[+] GdiCanvas::attach(
[-] 	release ();
[+] 	release();
[-] GdiCanvas::release ()
[+] GdiCanvas::release()
[-] 		::SelectObject (m_h, m_hPrevBitmap);
[+] 		::SelectObject(m_h, m_hPrevBitmap);
[-] 		::SelectObject (m_h, m_hPrevFont);
[+] 		::SelectObject(m_h, m_hPrevFont);
[-] 		::DeleteObject (m_hBitmap);
[+] 		::DeleteObject(m_hBitmap);
[-] 		::DeleteDC (m_hCompatibleDc);
[+] 		::DeleteDC(m_hCompatibleDc);
[-] 	switch (m_destructKind)
[+] 	switch(m_destructKind)
[-] 		::DeleteDC (m_h);
[+] 		::DeleteDC(m_h);
[-] 		::ReleaseDC (m_hWnd, m_h);
[+] 		::ReleaseDC(m_hWnd, m_h);
[-] GdiCanvas::drawRect (
[+] GdiCanvas::drawRect(
[-] 	color = overlayColor (m_baseTextAttr.m_backColor, color);
[+] 	color = overlayColor(m_baseTextAttr.m_backColor, color);
[-] 			::SetBkColor (m_h, m_palette.getColorRgb (color));
[+] 			::SetBkColor(m_h, m_palette.getColorRgb(color));
[-] 	::ExtTextOut (m_h, 0, 0, ETO_OPAQUE, &gdiRect, NULL, 0, NULL);
[+] 	::ExtTextOut(m_h, 0, 0, ETO_OPAQUE, &gdiRect, NULL, 0, NULL);
[-] GdiCanvas::drawText_utf8 (
[+] GdiCanvas::drawText_utf8(
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String_w text_w (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String_w text_w(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	text_w.copy (text);
[+] 	text_w.copy(text);
[-] 	return drawText_utf16 (
[+] 	return drawText_utf16(
[-] GdiCanvas::drawText_utf16 (
[+] GdiCanvas::drawText_utf16(
[-] 	textColor = overlayColor (m_baseTextAttr.m_foreColor, textColor);
[+] 	textColor = overlayColor(m_baseTextAttr.m_foreColor, textColor);
[-] 	backColor = overlayColor (m_baseTextAttr.m_backColor, backColor);
[+] 	backColor = overlayColor(m_baseTextAttr.m_backColor, backColor);
[-] 	fontFlags = overlayFontFlags (m_baseTextAttr.m_fontFlags, fontFlags);
[+] 	fontFlags = overlayFontFlags(m_baseTextAttr.m_fontFlags, fontFlags);
[-] 	Font* font = m_baseFont->getFontMod (fontFlags);
[+] 	Font* font = m_baseFont->getFontMod(fontFlags);
[-] 		ASSERT (font->getEngine ()->getEngineKind () == EngineKind_Gdi);
[+] 		ASSERT(font->getEngine()->getEngineKind() == EngineKind_Gdi);
[-] 		GdiFont* gdiFont = (GdiFont*) font;
[+] 		GdiFont* gdiFont = (GdiFont*)font;
[-] 		HFONT hPrevFont = (HFONT) ::SelectObject (m_h, *gdiFont);
[+] 		HFONT hPrevFont = (HFONT) ::SelectObject(m_h, *gdiFont);
[-] 			::SetTextColor (m_h, m_palette.getColorRgb (textColor));
[+] 			::SetTextColor(m_h, m_palette.getColorRgb(textColor));
[-] 			::SetBkColor (m_h, m_palette.getColorRgb (backColor));
[+] 			::SetBkColor(m_h, m_palette.getColorRgb(backColor));
[-] 		length = wcslen_s (text);
[+] 		length = wcslen_s(text);
[-] 	::ExtTextOutW (m_h, x, y, ETO_OPAQUE, &gdiRect, text, length, NULL);
[+] 	::ExtTextOutW(m_h, x, y, ETO_OPAQUE, &gdiRect, text, length, NULL);
[-] GdiCanvas::drawText_utf32 (
[+] GdiCanvas::drawText_utf32(
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String_w text_w (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String_w text_w(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	string.copy (text, length);
[+] 	string.copy(text, length);
[-] 	return drawText_utf16 (
[+] 	return drawText_utf16(
[-] GdiCanvas::drawImage (
[+] GdiCanvas::drawImage(
[-] 	ASSERT (image->getEngine ()->getEngineKind () == EngineKind_Gdi);
[+] 	ASSERT(image->getEngine()->getEngineKind() == EngineKind_Gdi);
[-] 	GdiImage* gdiImage = (GdiImage*) image;
[+] 	GdiImage* gdiImage = (GdiImage*)image;
[-] 		m_hCompatibleDc = ::CreateCompatibleDC (screenDc);
[+] 		m_hCompatibleDc = ::CreateCompatibleDC(screenDc);
[-] 	HBITMAP hPrevBitmap = (HBITMAP) ::SelectObject (m_hCompatibleDc, *gdiImage);
[+] 	HBITMAP hPrevBitmap = (HBITMAP) ::SelectObject(m_hCompatibleDc, *gdiImage);
[-] 	::BitBlt (
[+] 	::BitBlt(
[-] 	::SelectObject (m_hCompatibleDc, hPrevBitmap);
[+] 	::SelectObject(m_hCompatibleDc, hPrevBitmap);
[-] GdiCanvas::copyRect (
[+] GdiCanvas::copyRect(
[-] 	ASSERT (srcCanvas->getEngine ()->getEngineKind () == EngineKind_Gdi);
[+] 	ASSERT(srcCanvas->getEngine()->getEngineKind() == EngineKind_Gdi);
[-] 	GdiCanvas* dc = (GdiCanvas*) srcCanvas;
[+] 	GdiCanvas* dc = (GdiCanvas*)srcCanvas;
[-] 	::BitBlt (
[+] 	::BitBlt(
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_GdiCursor.cpp
----------------------
[-] GdiCursor::GdiCursor ()
[+] GdiCursor::GdiCursor()
[-] 	m_engine = GdiEngine::getSingleton ();
[+] 	m_engine = GdiEngine::getSingleton();
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_GdiEngine.cpp
----------------------
[-] GdiEngine::GdiEngine ()
[+] GdiEngine::GdiEngine()
[-] 	updateStdPalette ();
[+] 	updateStdPalette();
[-] GdiEngine::~GdiEngine ()
[+] GdiEngine::~GdiEngine()
[-] 		::DestroyWindow (m_hWndClipboardOwner);
[+] 		::DestroyWindow(m_hWndClipboardOwner);
[-] GdiEngine::updateStdPalette ()
[+] GdiEngine::updateStdPalette()
[-] 	g_stdPalColorArray [~ColorFlag_Index & StdPalColor_WidgetText]    = inverseRgb (::GetSysColor (COLOR_WINDOWTEXT));
[+] 	g_stdPalColorArray[~ColorFlag_Index & StdPalColor_WidgetText]    = inverseRgb(::GetSysColor(COLOR_WINDOWTEXT));
[-] 	g_stdPalColorArray [~ColorFlag_Index & StdPalColor_WidgetBack]    = inverseRgb (::GetSysColor (COLOR_WINDOW));
[+] 	g_stdPalColorArray[~ColorFlag_Index & StdPalColor_WidgetBack]    = inverseRgb(::GetSysColor(COLOR_WINDOW));
[-] 	g_stdPalColorArray [~ColorFlag_Index & StdPalColor_GrayText]      = inverseRgb (::GetSysColor (COLOR_GRAYTEXT));
[+] 	g_stdPalColorArray[~ColorFlag_Index & StdPalColor_GrayText]      = inverseRgb(::GetSysColor(COLOR_GRAYTEXT));
[-] 	g_stdPalColorArray [~ColorFlag_Index & StdPalColor_SelectionText] = inverseRgb (::GetSysColor (COLOR_HIGHLIGHTTEXT));
[+] 	g_stdPalColorArray[~ColorFlag_Index & StdPalColor_SelectionText] = inverseRgb(::GetSysColor(COLOR_HIGHLIGHTTEXT));
[-] 	g_stdPalColorArray [~ColorFlag_Index & StdPalColor_SelectionBack] = inverseRgb (::GetSysColor (COLOR_HIGHLIGHT));
[+] 	g_stdPalColorArray[~ColorFlag_Index & StdPalColor_SelectionBack] = inverseRgb(::GetSysColor(COLOR_HIGHLIGHT));
[-] 	g_stdPalColorArray [~ColorFlag_Index & StdPalColor_3DFace]        = inverseRgb (::GetSysColor (COLOR_3DFACE));
[+] 	g_stdPalColorArray[~ColorFlag_Index & StdPalColor_3DFace]        = inverseRgb(::GetSysColor(COLOR_3DFACE));
[-] 	g_stdPalColorArray [~ColorFlag_Index & StdPalColor_3DShadow]      = inverseRgb (::GetSysColor (COLOR_3DSHADOW));
[+] 	g_stdPalColorArray[~ColorFlag_Index & StdPalColor_3DShadow]      = inverseRgb(::GetSysColor(COLOR_3DSHADOW));
[-] 	g_stdPalColorArray [~ColorFlag_Index & StdPalColor_3DDarkShadow]  = inverseRgb (::GetSysColor (COLOR_3DDKSHADOW));
[+] 	g_stdPalColorArray[~ColorFlag_Index & StdPalColor_3DDarkShadow]  = inverseRgb(::GetSysColor(COLOR_3DDKSHADOW));
[-] 	g_stdPalColorArray [~ColorFlag_Index & StdPalColor_3DLight]       = inverseRgb (::GetSysColor (COLOR_3DLIGHT));
[+] 	g_stdPalColorArray[~ColorFlag_Index & StdPalColor_3DLight]       = inverseRgb(::GetSysColor(COLOR_3DLIGHT));
[-] 	g_stdPalColorArray [~ColorFlag_Index & StdPalColor_3DHiLight]     = inverseRgb (::GetSysColor (COLOR_3DHILIGHT));
[+] 	g_stdPalColorArray[~ColorFlag_Index & StdPalColor_3DHiLight]     = inverseRgb(::GetSysColor(COLOR_3DHILIGHT));
[-] ref::Ptr <Font>
[+] ref::Ptr<Font>
[-] GdiEngine::createStdFont (StdFontKind fontKind)
[+] GdiEngine::createStdFont(StdFontKind fontKind)
[-] 	switch (fontKind)
[+] 	switch(fontKind)
[-] 		return createStockFont (DEFAULT_GUI_FONT);
[+] 		return createStockFont(DEFAULT_GUI_FONT);
[-] 		buildLogFont (&logFont, L"Courier New", 10);
[+] 		buildLogFont(&logFont, L"Courier New", 10);
[-] 		hFont = ::CreateFontIndirectW (&logFont);
[+] 		hFont = ::CreateFontIndirectW(&logFont);
[-] 		ASSERT (hFont);
[+] 		ASSERT(hFont);
[-] 		return createFont (hFont);
[+] 		return createFont(hFont);
[-] ref::Ptr <Font>
[+] ref::Ptr<Font>
[-] GdiEngine::createFont (
[+] GdiEngine::createFont(
[-] 	buildLogFont (&logFont, family, pointSize, flags);
[+] 	buildLogFont(&logFont, family, pointSize, flags);
[-] 	HFONT hFont = ::CreateFontIndirect (&logFont);
[+] 	HFONT hFont = ::CreateFontIndirect(&logFont);
[-] 		return err::failWithLastSystemError (ref::g_nullPtr);
[+] 		return err::failWithLastSystemError(ref::g_nullPtr);
[-] 	return createFont (hFont);
[+] 	return createFont(hFont);
[-] ref::Ptr <Font>
[+] ref::Ptr<Font>
[-] GdiEngine::createStockFont (int stockFontKind)
[+] GdiEngine::createStockFont(int stockFontKind)
[-] 	HGDIOBJ h = ::GetStockObject (stockFontKind);
[+] 	HGDIOBJ h = ::GetStockObject(stockFontKind);
[-] 	dword_t gdiObjectType = ::GetObjectType (h);
[+] 	dword_t gdiObjectType = ::GetObjectType(h);
[-] 		err::setError (err::SystemErrorCode_InvalidHandle);
[+] 		err::setError(err::SystemErrorCode_InvalidHandle);
[-] 	return createFont ((HFONT) h);
[+] 	return createFont((HFONT)h);
[-] ref::Ptr <Font>
[+] ref::Ptr<Font>
[-] GdiEngine::createFont (HFONT hFont)
[+] GdiEngine::createFont(HFONT hFont)
[-] 	GdiFont* font = AXL_MEM_NEW (GdiFont);
[+] 	GdiFont* font = AXL_MEM_NEW(GdiFont);
[-] 	::GetObjectW (hFont, sizeof (logFont), &logFont);
[+] 	::GetObjectW(hFont, sizeof(logFont), &logFont);
[-] 	getFontDescFromLogFont (&logFont, &font->m_fontDesc);
[+] 	getFontDescFromLogFont(&logFont, &font->m_fontDesc);
[-] 	ref::Ptr <GdiFontuple> fontTuple = AXL_REF_NEW (GdiFontuple);
[+] 	ref::Ptr<GdiFontuple> fontTuple = AXL_REF_NEW(GdiFontuple);
[-] 	fontTuple->m_fontModArray [font->m_fontDesc.m_flags] = font;
[+] 	fontTuple->m_fontModArray[font->m_fontDesc.m_flags] = font;
[-] 	return ref::Ptr <Font> (font, fontTuple);
[+] 	return ref::Ptr<Font> (font, fontTuple);
[-] GdiEngine::getFontMod (
[+] GdiEngine::getFontMod(
[-] 	ASSERT (_pBaseFont->getEngine () == this);
[+] 	ASSERT(_pBaseFont->getEngine() == this);
[-] 	GdiFont* baseFont = (GdiFont*) _pBaseFont;
[+] 	GdiFont* baseFont = (GdiFont*)_pBaseFont;
[-] 	GdiFontuple* fontTuple = (GdiFontuple*) baseFont->m_tuple;
[+] 	GdiFontuple* fontTuple = (GdiFontuple*)baseFont->m_tuple;
[-] 	getLogFontFromFontDesc (*fontTuple->m_baseFont->getFontDesc (), &logFont);
[+] 	getLogFontFromFontDesc(*fontTuple->m_baseFont->getFontDesc(), &logFont);
[-] 	modifyLogFont (&logFont, flags);
[+] 	modifyLogFont(&logFont, flags);
[-] 	HFONT hFont = ::CreateFontIndirect (&logFont);
[+] 	HFONT hFont = ::CreateFontIndirect(&logFont);
[-] 		return err::failWithLastSystemError ((Font*) NULL);
[+] 		return err::failWithLastSystemError((Font*)NULL);
[-] 	GdiFont* font = AXL_MEM_NEW (GdiFont);
[+] 	GdiFont* font = AXL_MEM_NEW(GdiFont);
[-] 	ASSERT (!(flags & FontFlag_Transparent) && flags < countof (fontTuple->m_fontModArray));
[+] 	ASSERT(!(flags & FontFlag_Transparent) && flags < countof(fontTuple->m_fontModArray));
[-] 	ASSERT (!fontTuple->m_fontModArray [flags]);
[+] 	ASSERT(!fontTuple->m_fontModArray[flags]);
[-] 	fontTuple->m_fontModArray [flags] = font;
[+] 	fontTuple->m_fontModArray[flags] = font;
[-] ref::Ptr <Cursor>
[+] ref::Ptr<Cursor>
[-] GdiEngine::createStockCursor (LPCTSTR stockCursorRes)
[+] GdiEngine::createStockCursor(LPCTSTR stockCursorRes)
[-] 	HCURSOR h = ::LoadCursor (NULL, stockCursorRes);
[+] 	HCURSOR h = ::LoadCursor(NULL, stockCursorRes);
[-] 		return err::failWithLastSystemError (ref::g_nullPtr);
[+] 		return err::failWithLastSystemError(ref::g_nullPtr);
[-] 	ref::Ptr <GdiCursor> cursor = AXL_REF_NEW (ref::Box <GdiCursor>);
[+] 	ref::Ptr<GdiCursor> cursor = AXL_REF_NEW(ref::Box<GdiCursor>);
[-] ref::Ptr <Cursor>
[+] ref::Ptr<Cursor>
[-] GdiEngine::createStdCursor (StdCursorKind cursorKind)
[+] GdiEngine::createStdCursor(StdCursorKind cursorKind)
[-] 	static LPCTSTR stockCursorResTable [StdCursorKind__Count] =
[+] 	static LPCTSTR stockCursorResTable[StdCursorKind__Count] =
[-] 	ASSERT (cursorKind < StdCursorKind__Count);
[+] 	ASSERT(cursorKind < StdCursorKind__Count);
[-] 	return createStockCursor (stockCursorResTable [cursorKind]);
[+] 	return createStockCursor(stockCursorResTable[cursorKind]);
[-] ref::Ptr <Image>
[+] ref::Ptr<Image>
[-] GdiEngine::createImage ()
[+] GdiEngine::createImage()
[-] 	ref::Ptr <GdiImage> image = AXL_REF_NEW (ref::Box <GdiImage>);
[+] 	ref::Ptr<GdiImage> image = AXL_REF_NEW(ref::Box<GdiImage>);
[-] ref::Ptr <Image>
[+] ref::Ptr<Image>
[-] GdiEngine::createImage (
[+] GdiEngine::createImage(
[-] 	switch (pixelFormat)
[+] 	switch(pixelFormat)
[-] 		err::setFormatStringError ("unsupported pixel format '%s'", getPixelFormatString (pixelFormat));
[+] 		err::setFormatStringError("unsupported pixel format '%s'", getPixelFormatString (pixelFormat));
[-] 		hBitmap = ::CreateBitmap (
[+] 		hBitmap = ::CreateBitmap(
[-] 			return err::failWithLastSystemError (ref::g_nullPtr);
[+] 			return err::failWithLastSystemError(ref::g_nullPtr);
[-] 		bitmapInfo.bmiHeader.biSize = sizeof (bitmapInfo.bmiHeader);
[+] 		bitmapInfo.bmiHeader.biSize = sizeof(bitmapInfo.bmiHeader);
[-] 		hBitmap = ::CreateCompatibleBitmap (
[+] 		hBitmap = ::CreateCompatibleBitmap(
[-] 			return err::failWithLastSystemError (ref::g_nullPtr);
[+] 			return err::failWithLastSystemError(ref::g_nullPtr);
[-] 		bool_t result = ::SetDIBits (
[+] 		bool_t result = ::SetDIBits(
[-] 			return err::failWithLastSystemError (ref::g_nullPtr);
[+] 			return err::failWithLastSystemError(ref::g_nullPtr);
[-] 	ref::Ptr <GdiImage> image = AXL_REF_NEW (ref::Box <GdiImage>);
[+] 	ref::Ptr<GdiImage> image = AXL_REF_NEW(ref::Box<GdiImage>);
[-] ref::Ptr <Canvas>
[+] ref::Ptr<Canvas>
[-] GdiEngine::createOffscreenCanvas (
[+] GdiEngine::createOffscreenCanvas(
[-] 	HBITMAP hBitmap = ::CreateCompatibleBitmap (screenDc, width, height);
[+] 	HBITMAP hBitmap = ::CreateCompatibleBitmap(screenDc, width, height);
[-] 		return err::failWithLastSystemError (ref::g_nullPtr);
[+] 		return err::failWithLastSystemError(ref::g_nullPtr);
[-] 	HDC hdc = ::CreateCompatibleDC (screenDc);
[+] 	HDC hdc = ::CreateCompatibleDC(screenDc);
[-] 	ref::Ptr <GdiCanvas> dc = AXL_REF_NEW (ref::Box <GdiCanvas>);
[+] 	ref::Ptr<GdiCanvas> dc = AXL_REF_NEW(ref::Box<GdiCanvas>);
[-] 	dc->attach (hdc, NULL, GdiCanvas::DestructKind_DeleteDc);
[+] 	dc->attach(hdc, NULL, GdiCanvas::DestructKind_DeleteDc);
[-] 	dc->m_hPrevBitmap = (HBITMAP) ::SelectObject (hdc, hBitmap);
[+] 	dc->m_hPrevBitmap = (HBITMAP) ::SelectObject(hdc, hBitmap);
[-] GdiEngine::registerClipboardFormat (const sl::StringRef& formatName)
[+] GdiEngine::registerClipboardFormat(const sl::StringRef& formatName)
[-] 	err::setError (err::SystemErrorCode_NotImplemented);
[+] 	err::setError(err::SystemErrorCode_NotImplemented);
[-] GdiEngine::readClipboard (sl::String* string)
[+] GdiEngine::readClipboard(sl::String* string)
[-] 	bool result = openClipboard ();
[+] 	bool result = openClipboard();
[-] 	HANDLE hData = ::GetClipboardData (CF_TEXT);
[+] 	HANDLE hData = ::GetClipboardData(CF_TEXT);
[-] 		err::setError (err::SystemErrorCode_InvalidDeviceRequest);
[+] 		err::setError(err::SystemErrorCode_InvalidDeviceRequest);
[-] 	string->clear ();
[+] 	string->clear();
[-] 	size_t size = ::GlobalSize (hData);
[+] 	size_t size = ::GlobalSize(hData);
[-] 	void* data = ::GlobalLock (hData);
[+] 	void* data = ::GlobalLock(hData);
[-] 	ASSERT (data);
[+] 	ASSERT(data);
[-] 	string->copy ((char*) data);
[+] 	string->copy((char*)data);
[-] 	::CloseClipboard ();
[+] 	::CloseClipboard();
[-] GdiEngine::readClipboard (
[+] GdiEngine::readClipboard(
[-] 	sl::Array <char>* data
[+] 	sl::Array<char>* data
[-] 	err::setError (err::SystemErrorCode_NotImplemented);
[+] 	err::setError(err::SystemErrorCode_NotImplemented);
[-] GdiEngine::writeClipboard (const sl::StringRef& string)
[+] GdiEngine::writeClipboard(const sl::StringRef& string)
[-] 	bool result = openClipboard ();
[+] 	bool result = openClipboard();
[-] 	HGLOBAL hData = ::GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, length + 1);
[+] 	HGLOBAL hData = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, length + 1);
[-] 	void* p = ::GlobalLock (hData);
[+] 	void* p = ::GlobalLock(hData);
[-] 	memcpy (p, string, length);
[+] 	memcpy(p, string, length);
[-] 	((char*) p) [length] = 0;
[+] 	((char*)p) [length] = 0;
[-] 	::GlobalUnlock (hData);
[+] 	::GlobalUnlock(hData);
[-] 	::SetClipboardData (CF_TEXT, hData);
[+] 	::SetClipboardData(CF_TEXT, hData);
[-] 	::CloseClipboard ();
[+] 	::CloseClipboard();
[-] GdiEngine::writeClipboard (
[+] GdiEngine::writeClipboard(
[-] 	err::setError (err::SystemErrorCode_NotImplemented);
[+] 	err::setError(err::SystemErrorCode_NotImplemented);
[-] GdiEngine::openClipboard ()
[+] GdiEngine::openClipboard()
[-] 		m_hWndClipboardOwner = ::CreateWindowExW (
[+] 		m_hWndClipboardOwner = ::CreateWindowExW(
[-] 			g::getModule ()->getModuleHandle (),
[+] 			g::getModule()->getModuleHandle(),
[-] 			return err::failWithLastSystemError ();
[+] 			return err::failWithLastSystemError();
[-] 	result = ::OpenClipboard (m_hWndClipboardOwner);
[+] 	result = ::OpenClipboard(m_hWndClipboardOwner);
[-] 	return err::complete (result);
[+] 	return err::complete(result);
[-] GdiEngine::showCaret (
[+] GdiEngine::showCaret(
[-] GdiEngine::hideCaret ()
[+] GdiEngine::hideCaret()
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_GdiFont.cpp
----------------------
[-] buildLogFont (
[+] buildLogFont(
[-] 	memset (logFont, 0, sizeof (LOGFONT));
[+] 	memset(logFont, 0, sizeof(LOGFONT));
[-] 	size_t length = family.getLength ();
[+] 	size_t length = family.getLength();
[-] 	memcpy (
[+] 	memcpy(
[-] 		AXL_MIN (countof (logFont->lfFaceName), length) * sizeof (wchar_t)
[+] 		AXL_MIN(countof(logFont->lfFaceName), length) * sizeof(wchar_t)
[-] 	::SetMapMode (screenDc, MM_TEXT);
[+] 	::SetMapMode(screenDc, MM_TEXT);
[-] 	logFont->lfHeight = -::MulDiv (pointSize, ::GetDeviceCaps (screenDc, LOGPIXELSY), 72);
[+] 	logFont->lfHeight = -::MulDiv(pointSize, ::GetDeviceCaps(screenDc, LOGPIXELSY), 72);
[-] 	modifyLogFont (logFont, flags);
[+] 	modifyLogFont(logFont, flags);
[-] modifyLogFont (
[+] modifyLogFont(
[-] getFontDescFromLogFont (
[+] getFontDescFromLogFont(
[-] 	memset (fontDesc, 0, sizeof (FontDesc));
[+] 	memset(fontDesc, 0, sizeof(FontDesc));
[-] 	memcpy (
[+] 	memcpy(
[-] 		(AXL_MIN (countof (logFont->lfFaceName), countof (fontDesc->m_family)) - 1) * sizeof (char)
[+] 		(AXL_MIN(countof(logFont->lfFaceName), countof(fontDesc->m_family)) - 1) * sizeof(char)
[-] 	::SetMapMode (screenDc, MM_TEXT);
[+] 	::SetMapMode(screenDc, MM_TEXT);
[-] 		::MulDiv (-logFont->lfHeight, 72, ::GetDeviceCaps (screenDc, LOGPIXELSY));
[+] 		::MulDiv(-logFont->lfHeight, 72, ::GetDeviceCaps(screenDc, LOGPIXELSY));
[-] GdiFont::GdiFont ()
[+] GdiFont::GdiFont()
[-] 	m_engine = GdiEngine::getSingleton ();
[+] 	m_engine = GdiEngine::getSingleton();
[-] GdiFont::getLogFont (LOGFONTW* logFont)
[+] GdiFont::getLogFont(LOGFONTW* logFont)
[-] 	bool_t result = ::GetObject (m_h, sizeof (LOGFONT), logFont);
[+] 	bool_t result = ::GetObject(m_h, sizeof(LOGFONT), logFont);
[-] 	return err::complete (result);
[+] 	return err::complete(result);
[-] GdiFont::isMonospace ()
[+] GdiFont::isMonospace()
[-] 	getLogFont (&logFont);
[+] 	getLogFont(&logFont);
[-] GdiFont::calcTextSize_utf8 (const sl::StringRef_utf8& text)
[+] GdiFont::calcTextSize_utf8(const sl::StringRef_utf8& text)
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String_w string (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String_w string(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	string.copy (text, length);
[+] 	string.copy(text, length);
[-] 	return calcTextSize_utf16 (string, string.getLength ());
[+] 	return calcTextSize_utf16(string, string.getLength());
[-] GdiFont::calcTextSize_utf16 (const sl::StringRef_utf16& text)
[+] GdiFont::calcTextSize_utf16(const sl::StringRef_utf16& text)
[-] 		length = wcslen_s (text);
[+] 		length = wcslen_s(text);
[-] 	HFONT hOldFont = (HFONT) ::SelectObject (screenDc, m_h);
[+] 	HFONT hOldFont = (HFONT) ::SelectObject(screenDc, m_h);
[-] 	::GetTextExtentPoint32W (screenDc, text, length, &size);
[+] 	::GetTextExtentPoint32W(screenDc, text, length, &size);
[-] 	::SelectObject (screenDc, hOldFont);
[+] 	::SelectObject(screenDc, hOldFont);
[-] 	return Size (size.cx, size.cy);
[+] 	return Size(size.cx, size.cy);
[-] GdiFont::calcTextSize_utf32 (const sl::StringRef_utf32& text)
[+] GdiFont::calcTextSize_utf32(const sl::StringRef_utf32& text)
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String_w string (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String_w string(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	string.copy (text, length);
[+] 	string.copy(text, length);
[-] 	return calcTextSize_utf16 (string, string.getLength ());
[+] 	return calcTextSize_utf16(string, string.getLength());
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_GdiImage.cpp
----------------------
[-] GdiImage::GdiImage ()
[+] GdiImage::GdiImage()
[-] 	m_engine = GdiEngine::getSingleton ();
[+] 	m_engine = GdiEngine::getSingleton();
[-] GdiImage::getData (
[+] GdiImage::getData(
[-] 	bitmapInfo.bmiHeader.biSize = sizeof (bitmapInfo.bmiHeader);
[+] 	bitmapInfo.bmiHeader.biSize = sizeof(bitmapInfo.bmiHeader);
[-] 		result = ::GetDIBits (screenDc, m_h, top, height, data, &bitmapInfo, DIB_RGB_COLORS);
[+] 		result = ::GetDIBits(screenDc, m_h, top, height, data, &bitmapInfo, DIB_RGB_COLORS);
[-] 		return err::complete (result);
[+] 		return err::complete(result);
[-] 	char buffer [1024];
[+] 	char buffer[1024];
[-] 	sl::Array <uint_t> colorBuffer (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<uint_t> colorBuffer(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	colorBuffer.setCount (m_size.m_width * height);
[+] 	colorBuffer.setCount(m_size.m_width * height);
[-] 	result = ::GetDIBits (screenDc, m_h, top, height, colorBuffer, &bitmapInfo, DIB_RGB_COLORS);
[+] 	result = ::GetDIBits(screenDc, m_h, top, height, colorBuffer, &bitmapInfo, DIB_RGB_COLORS);
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] 	uint_t* dst = (uint_t*) data;
[+] 	uint_t* dst = (uint_t*)data;
[-] 		memcpy (dst, src, width * sizeof (uint_t));
[+] 		memcpy(dst, src, width * sizeof(uint_t));
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_GdiWidget.cpp
----------------------
[-] buildScrollInfo (
[+] buildScrollInfo(
[-] 	memset (scrollInfo, 0, sizeof (SCROLLINFO));
[+] 	memset(scrollInfo, 0, sizeof(SCROLLINFO));
[-] 	scrollInfo->cbSize = sizeof (SCROLLINFO);
[+] 	scrollInfo->cbSize = sizeof(SCROLLINFO);
[-] getModifierKeys ()
[+] getModifierKeys()
[-] 	if (::GetAsyncKeyState (VK_SHIFT) & 0x8000)
[+] 	if (::GetAsyncKeyState(VK_SHIFT) & 0x8000)
[-] 	if (::GetAsyncKeyState (VK_CONTROL) & 0x8000)
[+] 	if (::GetAsyncKeyState(VK_CONTROL) & 0x8000)
[-] 	if (::GetAsyncKeyState (VK_MENU) & 0x8000)
[+] 	if (::GetAsyncKeyState(VK_MENU) & 0x8000)
[-] getMouseButtons ()
[+] getMouseButtons()
[-] 	if (::GetAsyncKeyState (VK_LBUTTON) & 0x8000)
[+] 	if (::GetAsyncKeyState(VK_LBUTTON) & 0x8000)
[-] 	if (::GetAsyncKeyState (VK_RBUTTON) & 0x8000)
[+] 	if (::GetAsyncKeyState(VK_RBUTTON) & 0x8000)
[-] 	if (::GetAsyncKeyState (VK_MBUTTON) & 0x8000)
[+] 	if (::GetAsyncKeyState(VK_MBUTTON) & 0x8000)
[-] ref::Ptr <Canvas>
[+] ref::Ptr<Canvas>
[-] GdiWidgetImpl::getCanvas (HWND hWnd)
[+] GdiWidgetImpl::getCanvas(HWND hWnd)
[-] 	HDC hdc = ::GetDC (hWnd);
[+] 	HDC hdc = ::GetDC(hWnd);
[-] 	ref::Ptr <GdiCanvas> dc = AXL_REF_NEW (ref::Box <GdiCanvas>);
[+] 	ref::Ptr<GdiCanvas> dc = AXL_REF_NEW(ref::Box<GdiCanvas>);
[-] 	dc->attach (hdc, hWnd, GdiCanvas::DestructKind_ReleaseDc);
[+] 	dc->attach(hdc, hWnd, GdiCanvas::DestructKind_ReleaseDc);
[-] GdiWidgetImpl::windowProc (
[+] GdiWidgetImpl::windowProc(
[-] 	ASSERT (m_engine->getEngineKind () == EngineKind_Gdi);
[+] 	ASSERT(m_engine->getEngineKind() == EngineKind_Gdi);
[-] 	if (checkMsgMap (WidgetMsgCode_Gdi))
[+] 	if (checkMsgMap(WidgetMsgCode_Gdi))
[-] 		WidgetGdiMsg msg (wmMsg, wParam, lParam);
[+] 		WidgetGdiMsg msg(wmMsg, wParam, lParam);
[-] 		processWidgetMsg (&msg, &isHandled);
[+] 		processWidgetMsg(&msg, &isHandled);
[-] 	switch (wmMsg)
[+] 	switch(wmMsg)
[-] 		if (checkMsgMap (WidgetMsgCode_Close))
[+] 		if (checkMsgMap(WidgetMsgCode_Close))
[-] 			processWidgetMsg (&WidgetMsg (WidgetMsgCode_Close), isHandled_o);
[+] 			processWidgetMsg(&WidgetMsg(WidgetMsgCode_Close), isHandled_o);
[-] 		if (checkMsgMap (WidgetMsgCode_SetFocus))
[+] 		if (checkMsgMap(WidgetMsgCode_SetFocus))
[-] 			processWidgetMsg (&WidgetMsg (WidgetMsgCode_SetFocus), isHandled_o);
[+] 			processWidgetMsg(&WidgetMsg(WidgetMsgCode_SetFocus), isHandled_o);
[-] 		if (checkMsgMap (WidgetMsgCode_KillFocus))
[+] 		if (checkMsgMap(WidgetMsgCode_KillFocus))
[-] 			processWidgetMsg (&WidgetMsg (WidgetMsgCode_KillFocus), isHandled_o);
[+] 			processWidgetMsg(&WidgetMsg(WidgetMsgCode_KillFocus), isHandled_o);
[-] 		if (checkMsgMap (WidgetMsgCode_Size))
[+] 		if (checkMsgMap(WidgetMsgCode_Size))
[-] 			processWmSize (hWnd, isHandled_o);
[+] 			processWmSize(hWnd, isHandled_o);
[-] 		if (checkMsgMap (WidgetMsgCode_Scroll))
[+] 		if (checkMsgMap(WidgetMsgCode_Scroll))
[-] 			processWmScroll (hWnd, Orientation_Horizontal, LOWORD (wParam), isHandled_o);
[+] 			processWmScroll(hWnd, Orientation_Horizontal, LOWORD(wParam), isHandled_o);
[-] 		if (checkMsgMap (WidgetMsgCode_Scroll))
[+] 		if (checkMsgMap(WidgetMsgCode_Scroll))
[-] 			processWmScroll (hWnd, Orientation_Vertical, LOWORD (wParam), isHandled_o);
[+] 			processWmScroll(hWnd, Orientation_Vertical, LOWORD(wParam), isHandled_o);
[-] 		if (checkMsgMap (WidgetMsgCode_Paint))
[+] 		if (checkMsgMap(WidgetMsgCode_Paint))
[-] 			processWmPaint (hWnd, isHandled_o);
[+] 			processWmPaint(hWnd, isHandled_o);
[-] 		lResult = processWmSetCursor (hWnd, isHandled_o);
[+] 		lResult = processWmSetCursor(hWnd, isHandled_o);
[-] 		if (checkMsgMap (WidgetMsgCode_MouseMove))
[+] 		if (checkMsgMap(WidgetMsgCode_MouseMove))
[-] 			processWmMouse (
[+] 			processWmMouse(
[-] 				(short) LOWORD(lParam),
[+] 				(short)LOWORD(lParam),
[-] 				(short) HIWORD(lParam),
[+] 				(short)HIWORD(lParam),
[-] 		if (checkMsgMap (WidgetMsgCode_MouseLeave))
[+] 		if (checkMsgMap(WidgetMsgCode_MouseLeave))
[-] 			processWidgetMsg (&WidgetMsg (WidgetMsgCode_MouseLeave), isHandled_o);
[+] 			processWidgetMsg(&WidgetMsg(WidgetMsgCode_MouseLeave), isHandled_o);
[-] 		if (checkMsgMap (WidgetMsgCode_MouseCaptureLost))
[+] 		if (checkMsgMap(WidgetMsgCode_MouseCaptureLost))
[-] 			processWidgetMsg (&WidgetMsg (WidgetMsgCode_MouseCaptureLost), isHandled_o);
[+] 			processWidgetMsg(&WidgetMsg(WidgetMsgCode_MouseCaptureLost), isHandled_o);
[-] 		if (checkMsgMap (WidgetMsgCode_MouseButtonDown))
[+] 		if (checkMsgMap(WidgetMsgCode_MouseButtonDown))
[-] 			processWmMouse (
[+] 			processWmMouse(
[-] 				(short) LOWORD(lParam),
[+] 				(short)LOWORD(lParam),
[-] 				(short) HIWORD(lParam),
[+] 				(short)HIWORD(lParam),
[-] 		if (checkMsgMap (WidgetMsgCode_MouseButtonUp))
[+] 		if (checkMsgMap(WidgetMsgCode_MouseButtonUp))
[-] 			processWmMouse (
[+] 			processWmMouse(
[-] 				(short) LOWORD(lParam),
[+] 				(short)LOWORD(lParam),
[-] 				(short) HIWORD(lParam),
[+] 				(short)HIWORD(lParam),
[-] 		if (checkMsgMap (WidgetMsgCode_MouseButtonDoubleClick))
[+] 		if (checkMsgMap(WidgetMsgCode_MouseButtonDoubleClick))
[-] 			processWmMouse (
[+] 			processWmMouse(
[-] 				(short) LOWORD(lParam),
[+] 				(short)LOWORD(lParam),
[-] 				(short) HIWORD(lParam),
[+] 				(short)HIWORD(lParam),
[-] 		if (checkMsgMap (WidgetMsgCode_MouseButtonDown))
[+] 		if (checkMsgMap(WidgetMsgCode_MouseButtonDown))
[-] 			processWmMouse (
[+] 			processWmMouse(
[-] 				(short) LOWORD(lParam),
[+] 				(short)LOWORD(lParam),
[-] 				(short) HIWORD(lParam),
[+] 				(short)HIWORD(lParam),
[-] 		if (checkMsgMap (WidgetMsgCode_MouseButtonUp))
[+] 		if (checkMsgMap(WidgetMsgCode_MouseButtonUp))
[-] 			processWmMouse (
[+] 			processWmMouse(
[-] 				(short) LOWORD(lParam),
[+] 				(short)LOWORD(lParam),
[-] 				(short) HIWORD(lParam),
[+] 				(short)HIWORD(lParam),
[-] 		if (checkMsgMap (WidgetMsgCode_MouseButtonDoubleClick))
[+] 		if (checkMsgMap(WidgetMsgCode_MouseButtonDoubleClick))
[-] 			processWmMouse (
[+] 			processWmMouse(
[-] 				(short) LOWORD(lParam),
[+] 				(short)LOWORD(lParam),
[-] 				(short) HIWORD(lParam),
[+] 				(short)HIWORD(lParam),
[-] 		if (checkMsgMap (WidgetMsgCode_MouseButtonDown))
[+] 		if (checkMsgMap(WidgetMsgCode_MouseButtonDown))
[-] 			processWmMouse (
[+] 			processWmMouse(
[-] 				(short) LOWORD(lParam),
[+] 				(short)LOWORD(lParam),
[-] 				(short) HIWORD(lParam),
[+] 				(short)HIWORD(lParam),
[-] 		if (checkMsgMap (WidgetMsgCode_MouseButtonUp))
[+] 		if (checkMsgMap(WidgetMsgCode_MouseButtonUp))
[-] 			processWmMouse (
[+] 			processWmMouse(
[-] 				(short) LOWORD(lParam),
[+] 				(short)LOWORD(lParam),
[-] 				(short) HIWORD(lParam),
[+] 				(short)HIWORD(lParam),
[-] 		if (checkMsgMap (WidgetMsgCode_MouseButtonDoubleClick))
[+] 		if (checkMsgMap(WidgetMsgCode_MouseButtonDoubleClick))
[-] 			processWmMouse (
[+] 			processWmMouse(
[-] 				(short) LOWORD(lParam),
[+] 				(short)LOWORD(lParam),
[-] 				(short) HIWORD(lParam),
[+] 				(short)HIWORD(lParam),
[-] 		if (checkMsgMap (WidgetMsgCode_MouseWheel))
[+] 		if (checkMsgMap(WidgetMsgCode_MouseWheel))
[-] 			processWmMouseWheel (
[+] 			processWmMouseWheel(
[-] 				(short) HIWORD(wParam) / WHEEL_DELTA,
[+] 				(short)HIWORD(wParam) / WHEEL_DELTA,
[-] 		if (checkMsgMap (WidgetMsgCode_KeyDown))
[+] 		if (checkMsgMap(WidgetMsgCode_KeyDown))
[-] 			processWmKey (WidgetMsgCode_KeyDown, (uint_t) wParam, isHandled_o);
[+] 			processWmKey(WidgetMsgCode_KeyDown, (uint_t)wParam, isHandled_o);
[-] 		if (checkMsgMap (WidgetMsgCode_KeyUp))
[+] 		if (checkMsgMap(WidgetMsgCode_KeyUp))
[-] 			processWmKey (WidgetMsgCode_KeyUp, (uint_t) wParam, isHandled_o);
[+] 			processWmKey(WidgetMsgCode_KeyUp, (uint_t)wParam, isHandled_o);
[-] 		lResult = axl_win_TPropertyCtrl_IsMenu (propertyCtrl) ? MA_NOACTIVATE : defWindowProc (hWnd, msg, wParam, lParam);
[+] 		lResult = axl_win_TPropertyCtrl_IsMenu(propertyCtrl) ? MA_NOACTIVATE : defWindowProc(hWnd, msg, wParam, lParam);
[-] 		StockCtrlPaint_Closehemes (&propertyCtrl->m_stockCtrlPaint);
[+] 		StockCtrlPaint_Closehemes(&propertyCtrl->m_stockCtrlPaint);
[-] 		StockCtrlPaint_NcPaintEdge (&propertyCtrl->m_stockCtrlPaint, hWnd, (HRGN) wParam);
[+] 		StockCtrlPaint_NcPaintEdge(&propertyCtrl->m_stockCtrlPaint, hWnd, (HRGN)wParam);
[-] 		lResult = axl_win_TPropertyCtrl_OnTimer (propertyCtrl, (int) wParam);
[+] 		lResult = axl_win_TPropertyCtrl_OnTimer(propertyCtrl, (int)wParam);
[-] GdiWidgetImpl::processWmMouse (
[+] GdiWidgetImpl::processWmMouse(
[-] 	msg.m_modifierKeys = getModifierKeys ();
[+] 	msg.m_modifierKeys = getModifierKeys();
[-] 	msg.m_buttons = getMouseButtons ();
[+] 	msg.m_buttons = getMouseButtons();
[-] 	processWidgetMsg (&msg, isHandled_o);
[+] 	processWidgetMsg(&msg, isHandled_o);
[-] GdiWidgetImpl::processWmKey (
[+] GdiWidgetImpl::processWmKey(
[-] 	msg.m_modifierKeys = getModifierKeys ();
[+] 	msg.m_modifierKeys = getModifierKeys();
[-] 	processWidgetMsg (&msg, isHandled_o);
[+] 	processWidgetMsg(&msg, isHandled_o);
[-] GdiWidgetImpl::processWmMouseWheel (
[+] GdiWidgetImpl::processWmMouseWheel(
[-] 	::GetCursorPos (&point);
[+] 	::GetCursorPos(&point);
[-] 	::ScreenToClient (hWnd, &point);
[+] 	::ScreenToClient(hWnd, &point);
[-] 	msg.m_modifierKeys = getModifierKeys ();
[+] 	msg.m_modifierKeys = getModifierKeys();
[-] 	msg.m_buttons = getMouseButtons ();
[+] 	msg.m_buttons = getMouseButtons();
[-] 	processWidgetMsg (&msg, isHandled_o);
[+] 	processWidgetMsg(&msg, isHandled_o);
[-] GdiWidgetImpl::processWmSize (
[+] GdiWidgetImpl::processWmSize(
[-] 	::GetClientRect (hWnd, &rect);
[+] 	::GetClientRect(hWnd, &rect);
[-] 	Size size (rect.right - rect.left, rect.bottom - rect.top);
[+] 	Size size(rect.right - rect.left, rect.bottom - rect.top);
[-] 	processWidgetMsg (&WidgetMsgParam <uint_t> (WidgetMsgCode_Size, mask), isHandled_o);
[+] 	processWidgetMsg(&WidgetMsgParam<uint_t> (WidgetMsgCode_Size, mask), isHandled_o);
[-] GdiWidgetImpl::processWmScroll (
[+] GdiWidgetImpl::processWmScroll(
[-] 	ASSERT ((size_t) orientation < 2);
[+] 	ASSERT((size_t)orientation < 2);
[-] 	WidgetScrollBar* scrollBar = &m_scrollBarArray [orientation];
[+] 	WidgetScrollBar* scrollBar = &m_scrollBarArray[orientation];
[-] 	int bar = getScrollBarFromOrientation (orientation);
[+] 	int bar = getScrollBarFromOrientation(orientation);
[-] 	scrollInfo.cbSize = sizeof (scrollInfo);
[+] 	scrollInfo.cbSize = sizeof(scrollInfo);
[-] 	::GetScrollInfo (hWnd, bar, &scrollInfo);
[+] 	::GetScrollInfo(hWnd, bar, &scrollInfo);
[-] 	intptr_t maxPos = scrollBar->getMaxPos ();
[+] 	intptr_t maxPos = scrollBar->getMaxPos();
[-] 	switch (code)
[+] 	switch(code)
[-] 		scrollInfo.nPos = (int) newPos;
[+] 		scrollInfo.nPos = (int)newPos;
[-] 		::SetScrollInfo (hWnd, bar, &scrollInfo, TRUE);
[+] 		::SetScrollInfo(hWnd, bar, &scrollInfo, TRUE);
[-] 	processWidgetMsg (&WidgetMsgParam <uint_t> (WidgetMsgCode_Scroll, 1 << orientation), isHandled_o);
[+] 	processWidgetMsg(&WidgetMsgParam<uint_t> (WidgetMsgCode_Scroll, 1 << orientation), isHandled_o);
[-] GdiWidgetImpl::processWmPaint (
[+] GdiWidgetImpl::processWmPaint(
[-] 	HDC hdc = ::BeginPaint (hWnd, &paintStruct);
[+] 	HDC hdc = ::BeginPaint(hWnd, &paintStruct);
[-] 	dc.attach (hdc, NULL, GdiCanvas::DestructKind_None);
[+] 	dc.attach(hdc, NULL, GdiCanvas::DestructKind_None);
[-] 	Rect rect (
[+] 	Rect rect(
[-] 	processWidgetMsg (&WidgetPaintMsg (&dc, rect), &isHandled);
[+] 	processWidgetMsg(&WidgetPaintMsg(&dc, rect), &isHandled);
[-] 	::EndPaint (hWnd, &paintStruct);
[+] 	::EndPaint(hWnd, &paintStruct);
[-] GdiWidgetImpl::processWmSetCursor (
[+] GdiWidgetImpl::processWmSetCursor(
[-] 	::GetCursorPos (&mousePos);
[+] 	::GetCursorPos(&mousePos);
[-] 	::ScreenToClient (hWnd, &mousePos);
[+] 	::ScreenToClient(hWnd, &mousePos);
[-] 	::GetClientRect (hWnd, &clientRect);
[+] 	::GetClientRect(hWnd, &clientRect);
[-] 	bool_t isOnClientRect = ::PtInRect (&clientRect, mousePos);
[+] 	bool_t isOnClientRect = ::PtInRect(&clientRect, mousePos);
[-] 		::SetCursor (NULL);
[+] 		::SetCursor(NULL);
[-] 		ASSERT (m_cursor->getEngine ()->getEngineKind () == EngineKind_Gdi);
[+] 		ASSERT(m_cursor->getEngine()->getEngineKind() == EngineKind_Gdi);
[-] 		::SetCursor (*(GdiCursor*) m_cursor);
[+] 		::SetCursor(*(GdiCursor*)m_cursor);
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_HyperlinkAnchorArray.cpp
----------------------
[-] HyperlinkAnchorArray::find (size_t offset) const
[+] HyperlinkAnchorArray::find(size_t offset) const
[-] 	size_t end = m_array.getCount ();
[+] 	size_t end = m_array.getCount();
[-] 		HyperlinkAnchor* anchor = m_array [mid];
[+] 		HyperlinkAnchor* anchor = m_array[mid];
[-] HyperlinkAnchorArray::openHyperlink (
[+] HyperlinkAnchorArray::openHyperlink(
[-] 	size_t count = m_array.getCount ();
[+] 	size_t count = m_array.getCount();
[-] 		anchor = m_array [count - 1];
[+] 		anchor = m_array[count - 1];
[-] 				HyperlinkAnchor* prevAnchor = m_array [count - 2];
[+] 				HyperlinkAnchor* prevAnchor = m_array[count - 2];
[-] 					m_list.removeTail ();
[+] 					m_list.removeTail();
[-] 					m_array.pop ();
[+] 					m_array.pop();
[-] 					AXL_MEM_DELETE (anchor);
[+] 					AXL_MEM_DELETE(anchor);
[-] 	anchor = AXL_MEM_NEW (HyperlinkAnchor);
[+] 	anchor = AXL_MEM_NEW(HyperlinkAnchor);
[-] 	m_list.insertTail (anchor);
[+] 	m_list.insertTail(anchor);
[-] 	m_array.append (anchor);
[+] 	m_array.append(anchor);
[-] HyperlinkAnchorArray::closeHyperlink (
[+] HyperlinkAnchorArray::closeHyperlink(
[-] 	if (!isHyperlinkOpened ())
[+] 	if (!isHyperlinkOpened())
[-] 	if (!closeEmpty && m_list.getTail ()->m_offset == offset)
[+] 	if (!closeEmpty && m_list.getTail()->m_offset == offset)
[-] 	return openHyperlink (offset, NULL);
[+] 	return openHyperlink(offset, NULL);
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_HyperText.cpp
----------------------
[-] HyperText::clear ()
[+] HyperText::clear()
[-] 	m_source.clear ();
[+] 	m_source.clear();
[-] 	m_text.clear ();
[+] 	m_text.clear();
[-] 	m_attrArray.clear ();
[+] 	m_attrArray.clear();
[-] 	m_hyperlinkArray.clear ();
[+] 	m_hyperlinkArray.clear();
[-] 	m_hyperlinkXMap.clear ();
[+] 	m_hyperlinkXMap.clear();
[-] HyperText::backspace (size_t backLength)
[+] HyperText::backspace(size_t backLength)
[-] 	size_t length = m_text.getLength ();
[+] 	size_t length = m_text.getLength();
[-] 		m_text.clear ();
[+] 		m_text.clear();
[-] 	m_text.chop (backLength);
[+] 	m_text.chop(backLength);
[-] HyperText::appendPlainText (const sl::StringRef& text)
[+] HyperText::appendPlainText(const sl::StringRef& text)
[-] 	size_t i = text.reverseFind ('\x15'); // Ctrl+U -- clear
[+] 	size_t i = text.reverseFind('\x15'); // Ctrl+U -- clear
[-] 		clear ();
[+] 		clear();
[-] 		return appendPlainText (text.getSubString (i + 1));
[+] 		return appendPlainText(text.getSubString(i + 1));
[-] 	m_source.append (text);
[+] 	m_source.append(text);
[-] 	return m_text.append (text);
[+] 	return m_text.append(text);
[-] HyperText::appendChar (
[+] HyperText::appendChar(
[-] 		clear ();
[+] 		clear();
[-] 	m_source.append (c, count);
[+] 	m_source.append(c, count);
[-] 	return m_text.append (c, count);
[+] 	return m_text.append(c, count);
[-] HyperText::appendHyperText (
[+] HyperText::appendHyperText(
[-] 	size_t i = text.reverseFind ('\x15'); // Ctrl+U -- clear
[+] 	size_t i = text.reverseFind('\x15'); // Ctrl+U -- clear
[-] 		clear ();
[+] 		clear();
[-] 		return appendHyperText (baseAttr, text.getSubString (i + 1));
[+] 		return appendHyperText(baseAttr, text.getSubString(i + 1));
[-] 	size_t lastLength = m_text.getLength ();
[+] 	size_t lastLength = m_text.getLength();
[-] 	const char* p = text.cp ();
[+] 	const char* p = text.cp();
[-] 	const char* end = text.getEnd ();
[+] 	const char* end = text.getEnd();
[-] 	m_source.append (text);
[+] 	m_source.append(text);
[-] 		size_t textLength = m_text.append (p, token - p);
[+] 		size_t textLength = m_text.append(p, token - p);
[-] 			if (p [1] == '\\') // ST: string terminator
[+] 			if (p[1] == '\\') // ST: string terminator
[-] 			m_hyperlinkArray.openHyperlink (textLength, sl::StringRef (arg, argEnd - arg));
[+] 			m_hyperlinkArray.openHyperlink(textLength, sl::StringRef(arg, argEnd - arg));
[-] 			while (p < end && !isalpha (*p))
[+] 			while (p < end && !isalpha(*p))
[-] 			switch (*p)
[+] 			switch(*p)
[-] 				m_hyperlinkArray.closeHyperlink (textLength);
[+] 				m_hyperlinkArray.closeHyperlink(textLength);
[-] 				m_attrArray.setAttr (lastLength, textLength, attr);
[+] 				m_attrArray.setAttr(lastLength, textLength, attr);
[-] 				attrParser.parse (
[+] 				attrParser.parse(
[-] 					sl::StringRef (arg, argEnd - arg)
[+] 					sl::StringRef(arg, argEnd - arg)
[-] 				backspace (argEnd == arg ? 1 : atoi (arg));
[+] 				backspace(argEnd == arg ? 1 : atoi(arg));
[-] 				clear ();
[+] 				clear();
[-] 	m_attrArray.setAttr (lastLength, m_text.getLength (), attr);
[+] 	m_attrArray.setAttr(lastLength, m_text.getLength(), attr);
[-] 	return m_text.getLength ();
[+] 	return m_text.getLength();
[-] HyperText::findHyperlinkByX (int x) const
[+] HyperText::findHyperlinkByX(int x) const
[-] 	size_t end = m_hyperlinkXMap.getCount ();
[+] 	size_t end = m_hyperlinkXMap.getCount();
[-] 		const HyperlinkXMapEntry* mapEntry = &m_hyperlinkXMap [mid];
[+] 		const HyperlinkXMapEntry* mapEntry = &m_hyperlinkXMap[mid];
[-] 	return result && !result->m_hyperlink.isEmpty () ? result : NULL;
[+] 	return result && !result->m_hyperlink.isEmpty() ? result : NULL;
[-] HyperText::calcHyperlinkXMap (Font* baseFont)
[+] HyperText::calcHyperlinkXMap(Font* baseFont)
[-] 	size_t length = m_text.getLength ();
[+] 	size_t length = m_text.getLength();
[-] 	size_t attrCount = m_attrArray.getCount ();
[+] 	size_t attrCount = m_attrArray.getCount();
[-] 	size_t hyperlinkCount = m_hyperlinkArray.getCount ();
[+] 	size_t hyperlinkCount = m_hyperlinkArray.getCount();
[-] 	Font* font = baseFont->getFontMod (fontFlags);
[+] 	Font* font = baseFont->getFontMod(fontFlags);
[-] 	m_hyperlinkXMap.setCount (hyperlinkCount);
[+] 	m_hyperlinkXMap.setCount(hyperlinkCount);
[-] 	sl::ConstIterator <HyperlinkAnchor> it = m_hyperlinkArray.getHead ();
[+] 	sl::ConstIterator<HyperlinkAnchor> it = m_hyperlinkArray.getHead();
[-] 			size = font->calcTextSize_utf32 (m_text.getSubString (offset, attrAnchor->m_offset - offset));
[+] 			size = font->calcTextSize_utf32(m_text.getSubString(offset, attrAnchor->m_offset - offset));
[-] 			font = baseFont->getFontMod (fontFlags);
[+] 			font = baseFont->getFontMod(fontFlags);
[-] 		size = font->calcTextSize_utf32 (m_text.getSubString (offset, hyperlinkAnchor->m_offset - offset));
[+] 		size = font->calcTextSize_utf32(m_text.getSubString(offset, hyperlinkAnchor->m_offset - offset));
[-] HyperText::calcTextSize (Font* baseFont) const
[+] HyperText::calcTextSize(Font* baseFont) const
[-] 	size_t length = m_text.getLength ();
[+] 	size_t length = m_text.getLength();
[-] 	size_t attrCount = m_attrArray.getCount ();
[+] 	size_t attrCount = m_attrArray.getCount();
[-] 	Font* font = baseFont->getFontMod (fontFlags);
[+] 	Font* font = baseFont->getFontMod(fontFlags);
[-] 		const TextAttrAnchor* attrAnchor = &m_attrArray [i];
[+] 		const TextAttrAnchor* attrAnchor = &m_attrArray[i];
[-] 		size = font->calcTextSize_utf32 (m_text.getSubString (offset, attrAnchor->m_offset - offset));
[+] 		size = font->calcTextSize_utf32(m_text.getSubString(offset, attrAnchor->m_offset - offset));
[-] 		font = baseFont->getFontMod (fontFlags);
[+] 		font = baseFont->getFontMod(fontFlags);
[-] 	size = font->calcTextSize_utf32 (m_text.getSubString (offset, length - offset));
[+] 	size = font->calcTextSize_utf32(m_text.getSubString(offset, length - offset));
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_ImageDesc.cpp
----------------------
[-] getPixelFormatString (PixelFormat pixelFormat)
[+] getPixelFormatString(PixelFormat pixelFormat)
[-] 	static const char* stringTable [] =
[+] 	static const char* stringTable[] =
[-] 	return (size_t) pixelFormat < countof (stringTable) ?
[+] 	return (size_t)pixelFormat < countof(stringTable) ?
[-] 		stringTable [pixelFormat] :
[+] 		stringTable[pixelFormat] :
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_QtCaret.cpp
----------------------
[-] QtCaret::show (
[+] QtCaret::show(
[-] 	ASSERT (widgetDriver);
[+] 	ASSERT(widgetDriver);
[-] 		m_widgetDriver->redraw (m_rect);
[+] 		m_widgetDriver->redraw(m_rect);
[-] 	widgetDriver->redraw (rect);
[+] 	widgetDriver->redraw(rect);
[-] 	setSingleShot (false);
[+] 	setSingleShot(false);
[-] 	start (interval);
[+] 	start(interval);
[-] QtCaret::hide (WidgetDriver* widgetDriver)
[+] QtCaret::hide(WidgetDriver* widgetDriver)
[-] 		m_widgetDriver->redraw (m_rect);
[+] 		m_widgetDriver->redraw(m_rect);
[-] 	stop ();
[+] 	stop();
[-] 	m_widgetDriver->redraw (m_rect);
[+] 	m_widgetDriver->redraw(m_rect);
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_QtEngine.cpp
----------------------
[-] QtFont* QtFontTuple::attachFont (QFont qtFont)
[+] QtFont* QtFontTuple::attachFont(QFont qtFont)
[-] 	clear ();
[+] 	clear();
[-] 	QtFont* font = AXL_MEM_NEW (QtFont);
[+] 	QtFont* font = AXL_MEM_NEW(QtFont);
[-] 	m_fontModArray [0] = font;
[+] 	m_fontModArray[0] = font;
[-] QtEngine::QtEngine ():
[+] QtEngine::QtEngine():
[-] 	m_sharedOffscreenCanvasCache (this)
[+] 	m_sharedOffscreenCanvasCache(this)
[-] 	memset (m_stdFontTupleArray, 0, sizeof (m_stdFontTupleArray));
[+] 	memset(m_stdFontTupleArray, 0, sizeof(m_stdFontTupleArray));
[-] 	memset (m_stdCursorArray, 0, sizeof (m_stdCursorArray));
[+] 	memset(m_stdCursorArray, 0, sizeof(m_stdCursorArray));
[-] 	m_toolTipTimer.setSingleShot (true);
[+] 	m_toolTipTimer.setSingleShot(true);
[-] 	updateStdPalette ();
[+] 	updateStdPalette();
[-] QtEngine::~QtEngine ()
[+] QtEngine::~QtEngine()
[-] 	for (size_t i = 0; i < countof (m_stdFontTupleArray); i++)
[+] 	for (size_t i = 0; i < countof(m_stdFontTupleArray); i++)
[-] 		if (m_stdFontTupleArray [i])
[+] 		if (m_stdFontTupleArray[i])
[-] 			AXL_MEM_DELETE (m_stdFontTupleArray [i]);
[+] 			AXL_MEM_DELETE(m_stdFontTupleArray[i]);
[-] 	for (size_t i = 0; i < countof (m_stdCursorArray); i++)
[+] 	for (size_t i = 0; i < countof(m_stdCursorArray); i++)
[-] 		if (m_stdCursorArray [i])
[+] 		if (m_stdCursorArray[i])
[-] 			AXL_MEM_DELETE (m_stdCursorArray [i]);
[+] 			AXL_MEM_DELETE(m_stdCursorArray[i]);
[-] QtEngine::updateStdPalette ()
[+] QtEngine::updateStdPalette()
[-] 	QPalette palette = QApplication::palette ();
[+] 	QPalette palette = QApplication::palette();
[-] 	m_stdPalColorTable [~ColorFlag_Index & StdPalColor_WidgetText]    = palette.color (QPalette::Text).rgb() & ColorFlag_RgbMask;
[+] 	m_stdPalColorTable[~ColorFlag_Index & StdPalColor_WidgetText]    = palette.color(QPalette::Text).rgb() & ColorFlag_RgbMask;
[-] 	m_stdPalColorTable [~ColorFlag_Index & StdPalColor_WidgetBack]    = palette.color (QPalette::Base).rgb() & ColorFlag_RgbMask;
[+] 	m_stdPalColorTable[~ColorFlag_Index & StdPalColor_WidgetBack]    = palette.color(QPalette::Base).rgb() & ColorFlag_RgbMask;
[-] 	m_stdPalColorTable [~ColorFlag_Index & StdPalColor_GrayText]      = palette.color (QPalette::Disabled, QPalette::WindowText).rgb() & ColorFlag_RgbMask;
[+] 	m_stdPalColorTable[~ColorFlag_Index & StdPalColor_GrayText]      = palette.color(QPalette::Disabled, QPalette::WindowText).rgb() & ColorFlag_RgbMask;
[-] 	m_stdPalColorTable [~ColorFlag_Index & StdPalColor_SelectionText] = palette.color (QPalette::HighlightedText).rgb() & ColorFlag_RgbMask;
[+] 	m_stdPalColorTable[~ColorFlag_Index & StdPalColor_SelectionText] = palette.color(QPalette::HighlightedText).rgb() & ColorFlag_RgbMask;
[-] 	m_stdPalColorTable [~ColorFlag_Index & StdPalColor_SelectionBack] = palette.color (QPalette::Highlight).rgb() & ColorFlag_RgbMask;
[+] 	m_stdPalColorTable[~ColorFlag_Index & StdPalColor_SelectionBack] = palette.color(QPalette::Highlight).rgb() & ColorFlag_RgbMask;
[-] 	m_stdPalColorTable [~ColorFlag_Index & StdPalColor_3DFace]        = palette.color (QPalette::Button).rgb() & ColorFlag_RgbMask;
[+] 	m_stdPalColorTable[~ColorFlag_Index & StdPalColor_3DFace]        = palette.color(QPalette::Button).rgb() & ColorFlag_RgbMask;
[-] 	m_stdPalColorTable [~ColorFlag_Index & StdPalColor_3DShadow]      = palette.color (QPalette::Dark).rgb() & ColorFlag_RgbMask;
[+] 	m_stdPalColorTable[~ColorFlag_Index & StdPalColor_3DShadow]      = palette.color(QPalette::Dark).rgb() & ColorFlag_RgbMask;
[-] 	m_stdPalColorTable [~ColorFlag_Index & StdPalColor_3DDarkShadow]  = palette.color (QPalette::Shadow).rgb() & ColorFlag_RgbMask;
[+] 	m_stdPalColorTable[~ColorFlag_Index & StdPalColor_3DDarkShadow]  = palette.color(QPalette::Shadow).rgb() & ColorFlag_RgbMask;
[-] 	m_stdPalColorTable [~ColorFlag_Index & StdPalColor_3DLight]       = palette.color (QPalette::Midlight).rgb() & ColorFlag_RgbMask;
[+] 	m_stdPalColorTable[~ColorFlag_Index & StdPalColor_3DLight]       = palette.color(QPalette::Midlight).rgb() & ColorFlag_RgbMask;
[-] 	m_stdPalColorTable [~ColorFlag_Index & StdPalColor_3DHiLight]     = palette.color (QPalette::Light).rgb() & ColorFlag_RgbMask;
[+] 	m_stdPalColorTable[~ColorFlag_Index & StdPalColor_3DHiLight]     = palette.color(QPalette::Light).rgb() & ColorFlag_RgbMask;
[-] QtEngine::createOffscreenCanvas (
[+] QtEngine::createOffscreenCanvas(
[-] 	ASSERT (canvas->getEngine () == this);
[+] 	ASSERT(canvas->getEngine() == this);
[-] 	QtCanvas* qtCanvas = (QtCanvas*) canvas;
[+] 	QtCanvas* qtCanvas = (QtCanvas*)canvas;
[-] 	qtCanvas->m_qtPixmap = QPixmap (width, height);
[+] 	qtCanvas->m_qtPixmap = QPixmap(width, height);
[-] 	qtCanvas->m_qtPainter.begin (&qtCanvas->m_qtPixmap);
[+] 	qtCanvas->m_qtPainter.begin(&qtCanvas->m_qtPixmap);
[-] QtEngine::releaseOffscreenCanvas (Canvas* canvas)
[+] QtEngine::releaseOffscreenCanvas(Canvas* canvas)
[-] 	ASSERT (canvas->getEngine () == this);
[+] 	ASSERT(canvas->getEngine() == this);
[-] 	QtCanvas* qtCanvas = (QtCanvas*) canvas;
[+] 	QtCanvas* qtCanvas = (QtCanvas*)canvas;
[-] 	qtCanvas->m_qtPainter.end ();
[+] 	qtCanvas->m_qtPainter.end();
[-] 	qtCanvas->m_qtPixmap = QPixmap ();
[+] 	qtCanvas->m_qtPixmap = QPixmap();
[-] QtEngine::drawRect (
[+] QtEngine::drawRect(
[-] 	ASSERT (canvas->getEngine () == this);
[+] 	ASSERT(canvas->getEngine() == this);
[-] 	QtCanvas* qtCanvas = (QtCanvas*) canvas;
[+] 	QtCanvas* qtCanvas = (QtCanvas*)canvas;
[-] 	ASSERT (!(color & ColorFlag_Undefined));
[+] 	ASSERT(!(color & ColorFlag_Undefined));
[-] 	color = qtCanvas->m_palette.getColorRgb (color);
[+] 	color = qtCanvas->m_palette.getColorRgb(color);
[-] 	qtCanvas->m_qtPainter.fillRect (left, top, right - left, bottom - top, color);
[+] 	qtCanvas->m_qtPainter.fillRect(left, top, right - left, bottom - top, color);
[-] QtEngine::drawAlphaRect (
[+] QtEngine::drawAlphaRect(
[-] 	ASSERT (canvas->getEngine () == this);
[+] 	ASSERT(canvas->getEngine() == this);
[-] 	QtCanvas* qtCanvas = (QtCanvas*) canvas;
[+] 	QtCanvas* qtCanvas = (QtCanvas*)canvas;
[-] 	ASSERT (!(color & ColorFlag_Undefined));
[+] 	ASSERT(!(color & ColorFlag_Undefined));
[-] 	QColor qtColor = qtCanvas->m_palette.getColorRgb (color);
[+] 	QColor qtColor = qtCanvas->m_palette.getColorRgb(color);
[-] 	qtColor.setAlpha (alpha);
[+] 	qtColor.setAlpha(alpha);
[-] 	qtCanvas->m_qtPainter.fillRect (left, top, right - left, bottom - top, qtColor);
[+] 	qtCanvas->m_qtPainter.fillRect(left, top, right - left, bottom - top, qtColor);
[-] QtEngine::drawText_qt (
[+] QtEngine::drawText_qt(
[-] 	ASSERT (canvas->getEngine () == this);
[+] 	ASSERT(canvas->getEngine() == this);
[-] 	QtCanvas* qtCanvas = (QtCanvas*) canvas;
[+] 	QtCanvas* qtCanvas = (QtCanvas*)canvas;
[-] 	Font* font = qtCanvas->m_font->getFontMod (fontFlags);
[+] 	Font* font = qtCanvas->m_font->getFontMod(fontFlags);
[-] 		ASSERT (font->getEngine () == this);
[+] 		ASSERT(font->getEngine() == this);
[-] 		QtFont* qtFont = (QtFont*) font;
[+] 		QtFont* qtFont = (QtFont*)font;
[-] 		qtCanvas->m_qtPainter.setFont (qtFont->m_qtFont);
[+] 		qtCanvas->m_qtPainter.setFont(qtFont->m_qtFont);
[-] 		textColor = qtCanvas->m_palette.getColorRgb (textColor);
[+] 		textColor = qtCanvas->m_palette.getColorRgb(textColor);
[-] 			qtCanvas->m_qtPainter.setPen (textColor);
[+] 			qtCanvas->m_qtPainter.setPen(textColor);
[-] 		drawRect (canvas, left, top, right, bottom, backColor);
[+] 		drawRect(canvas, left, top, right, bottom, backColor);
[-] 	qtCanvas->m_qtPainter.drawText (x, y, right - x, bottom - y, 0, string);
[+] 	qtCanvas->m_qtPainter.drawText(x, y, right - x, bottom - y, 0, string);
[-] QtEngine::drawText_utf8 (
[+] QtEngine::drawText_utf8(
[-] 	return drawText_qt (
[+] 	return drawText_qt(
[-] 		QString::fromUtf8 (text.cp (), text.getLength ())
[+] 		QString::fromUtf8(text.cp(), text.getLength())
[-] QtEngine::drawText_utf16 (
[+] QtEngine::drawText_utf16(
[-] 	return drawText_qt (
[+] 	return drawText_qt(
[-] 		QString ((const QChar*) text.cp (), text.getLength ())
[+] 		QString((const QChar*) text.cp(), text.getLength())
[-] QtEngine::drawText_utf32 (
[+] QtEngine::drawText_utf32(
[-] 	return drawText_qt (
[+] 	return drawText_qt(
[-] 		QString::fromUcs4 ((const uint*) text.cp (), text.getLength ())
[+] 		QString::fromUcs4((const uint*) text.cp(), text.getLength())
[-] QtEngine::drawImage (
[+] QtEngine::drawImage(
[-] 	ASSERT (canvas->getEngine () == this);
[+] 	ASSERT(canvas->getEngine() == this);
[-] 	QtCanvas* qtCanvas = (QtCanvas*) canvas;
[+] 	QtCanvas* qtCanvas = (QtCanvas*)canvas;
[-] 	ASSERT (image->getEngine () == this);
[+] 	ASSERT(image->getEngine() == this);
[-] 	QtImage* qtImage = (QtImage*) image;
[+] 	QtImage* qtImage = (QtImage*)image;
[-] 	qtCanvas->m_qtPainter.drawImage (
[+] 	qtCanvas->m_qtPainter.drawImage(
[-] QtEngine::copyRect (
[+] QtEngine::copyRect(
[-] 	ASSERT (canvas->getEngine () == this);
[+] 	ASSERT(canvas->getEngine() == this);
[-] 	QtCanvas* qtCanvas = (QtCanvas*) canvas;
[+] 	QtCanvas* qtCanvas = (QtCanvas*)canvas;
[-] 	ASSERT (srcCanvas->getEngine () == this);
[+] 	ASSERT(srcCanvas->getEngine() == this);
[-] 	QtCanvas* qtSrcCanvas = (QtCanvas*) srcCanvas;
[+] 	QtCanvas* qtSrcCanvas = (QtCanvas*)srcCanvas;
[-] 	if (!qtSrcCanvas->m_qtPixmap.isNull ())
[+] 	if (!qtSrcCanvas->m_qtPixmap.isNull())
[-] 	qtCanvas->m_qtPainter.drawPixmap (
[+] 	qtCanvas->m_qtPainter.drawPixmap(
[-] QtEngine::clearFontTuple (FontTuple* fontTuple)
[+] QtEngine::clearFontTuple(FontTuple* fontTuple)
[-] 	ASSERT (fontTuple->getEngine () == this);
[+] 	ASSERT(fontTuple->getEngine() == this);
[-] 	QtFontTuple* qtFontTuple = (QtFontTuple*) fontTuple;
[+] 	QtFontTuple* qtFontTuple = (QtFontTuple*)fontTuple;
[-] 	for (size_t i = 0; i < countof (qtFontTuple->m_fontModArray); i++)
[+] 	for (size_t i = 0; i < countof(qtFontTuple->m_fontModArray); i++)
[-] 		Font* font = qtFontTuple->m_fontModArray [i];
[+] 		Font* font = qtFontTuple->m_fontModArray[i];
[-] 		ASSERT (font->getEngine () == this);
[+] 		ASSERT(font->getEngine() == this);
[-] 		AXL_MEM_DELETE ((QtFont*) font);
[+] 		AXL_MEM_DELETE((QtFont*)font);
[-] 	memset (qtFontTuple->m_fontModArray, 0, sizeof (qtFontTuple->m_fontModArray));
[+] 	memset(qtFontTuple->m_fontModArray, 0, sizeof(qtFontTuple->m_fontModArray));
[-] QtEngine::getStdFontTuple (StdFontKind fontKind)
[+] QtEngine::getStdFontTuple(StdFontKind fontKind)
[-] 	ASSERT (fontKind < countof (m_stdFontTupleArray));
[+] 	ASSERT(fontKind < countof(m_stdFontTupleArray));
[-] 	if (m_stdFontTupleArray [fontKind])
[+] 	if (m_stdFontTupleArray[fontKind])
[-] 		return m_stdFontTupleArray [fontKind];
[+] 		return m_stdFontTupleArray[fontKind];
[-] 	QtFontTuple* fontTuple = AXL_MEM_NEW (QtFontTuple);
[+] 	QtFontTuple* fontTuple = AXL_MEM_NEW(QtFontTuple);
[-] 	QtFont* font = AXL_MEM_NEW (QtFont);
[+] 	QtFont* font = AXL_MEM_NEW(QtFont);
[-] 	m_stdFontTupleArray [fontKind] = fontTuple;
[+] 	m_stdFontTupleArray[fontKind] = fontTuple;
[-] 	fontTuple->m_fontModArray [0] = font;
[+] 	fontTuple->m_fontModArray[0] = font;
[-] 	switch (fontKind)
[+] 	switch(fontKind)
[-] 		font->m_qtFont = QApplication::font ();
[+] 		font->m_qtFont = QApplication::font();
[-] 		font->m_qtFont = QFont ("Consolas", 10);
[+] 		font->m_qtFont = QFont("Consolas", 10);
[-] 		font->m_qtFont = QFont ("Menlo", 12);
[+] 		font->m_qtFont = QFont("Menlo", 12);
[-] 		font->m_qtFont = QFont ("Monospace", 10);
[+] 		font->m_qtFont = QFont("Monospace", 10);
[-] 		font->m_qtFont.setFixedPitch (true);
[+] 		font->m_qtFont.setFixedPitch(true);
[-] 		font->m_qtFont.setKerning (false);
[+] 		font->m_qtFont.setKerning(false);
[-] 		font->m_qtFont.setStyleHint (
[+] 		font->m_qtFont.setStyleHint(
[-] 			(QFont::StyleStrategy) (QFont::NoFontMerging | QFont::ForceIntegerMetrics)
[+] 			(QFont::StyleStrategy)(QFont::NoFontMerging | QFont::ForceIntegerMetrics)
[-] QtEngine::createFont (
[+] QtEngine::createFont(
[-] 	ASSERT (fontTuple->getEngine () == this);
[+] 	ASSERT(fontTuple->getEngine() == this);
[-] 	QtFontTuple* qtFontTuple = (QtFontTuple*) fontTuple;
[+] 	QtFontTuple* qtFontTuple = (QtFontTuple*)fontTuple;
[-] 	clearFontTuple (qtFontTuple);
[+] 	clearFontTuple(qtFontTuple);
[-] 	QtFont* qtBaseFont = AXL_MEM_NEW (QtFont);
[+] 	QtFont* qtBaseFont = AXL_MEM_NEW(QtFont);
[-] 	qtBaseFont->m_qtFont = QFont (QString::fromUtf8 (family.cp (), family.getLength ()), pointSize, QFont::Normal);
[+] 	qtBaseFont->m_qtFont = QFont(QString::fromUtf8(family.cp(), family.getLength()), pointSize, QFont::Normal);
[-] 	qtFontTuple->m_fontModArray [0] = qtBaseFont;
[+] 	qtFontTuple->m_fontModArray[0] = qtBaseFont;
[-] 	QtFont* qtFont = AXL_MEM_NEW (QtFont);
[+] 	QtFont* qtFont = AXL_MEM_NEW(QtFont);
[-] 	qtFont->m_qtFont.setBold ((flags & FontFlag_Bold) != 0);
[+] 	qtFont->m_qtFont.setBold((flags & FontFlag_Bold) != 0);
[-] 	qtFont->m_qtFont.setItalic ((flags & FontFlag_Italic) != 0);
[+] 	qtFont->m_qtFont.setItalic((flags & FontFlag_Italic) != 0);
[-] 	qtFont->m_qtFont.setUnderline ((flags & FontFlag_Underline) != 0);
[+] 	qtFont->m_qtFont.setUnderline((flags & FontFlag_Underline) != 0);
[-] 	qtFont->m_qtFont.setStrikeOut ((flags & FontFlag_Strikeout) != 0);
[+] 	qtFont->m_qtFont.setStrikeOut((flags & FontFlag_Strikeout) != 0);
[-] 	qtFontTuple->m_fontModArray [flags] = qtFont;
[+] 	qtFontTuple->m_fontModArray[flags] = qtFont;
[-] QtEngine::getFontMod (
[+] QtEngine::getFontMod(
[-] 	ASSERT (fontTuple->getEngine () == this);
[+] 	ASSERT(fontTuple->getEngine() == this);
[-] 	QtFontTuple* qtFontTuple = (QtFontTuple*) fontTuple;
[+] 	QtFontTuple* qtFontTuple = (QtFontTuple*)fontTuple;
[-] 	QtFont* qtBaseFont = (QtFont*) qtFontTuple->m_fontModArray [0];
[+] 	QtFont* qtBaseFont = (QtFont*)qtFontTuple->m_fontModArray[0];
[-] 	ASSERT (qtBaseFont);
[+] 	ASSERT(qtBaseFont);
[-] 	QtFont* qtFont = AXL_MEM_NEW (QtFont);
[+] 	QtFont* qtFont = AXL_MEM_NEW(QtFont);
[-] 	qtFont->m_qtFont.setBold ((flags & FontFlag_Bold) != 0);
[+] 	qtFont->m_qtFont.setBold((flags & FontFlag_Bold) != 0);
[-] 	qtFont->m_qtFont.setItalic ((flags & FontFlag_Italic) != 0);
[+] 	qtFont->m_qtFont.setItalic((flags & FontFlag_Italic) != 0);
[-] 	qtFont->m_qtFont.setUnderline ((flags & FontFlag_Underline) != 0);
[+] 	qtFont->m_qtFont.setUnderline((flags & FontFlag_Underline) != 0);
[-] 	qtFont->m_qtFont.setStrikeOut ((flags & FontFlag_Strikeout) != 0);
[+] 	qtFont->m_qtFont.setStrikeOut((flags & FontFlag_Strikeout) != 0);
[-] 	ASSERT (!qtFontTuple->m_fontModArray [flags]);
[+] 	ASSERT(!qtFontTuple->m_fontModArray[flags]);
[-] 	qtFontTuple->m_fontModArray [flags] = qtFont;
[+] 	qtFontTuple->m_fontModArray[flags] = qtFont;
[-] QtEngine::getFontDesc (
[+] QtEngine::getFontDesc(
[-] 	ASSERT (font->getEngine () == this);
[+] 	ASSERT(font->getEngine() == this);
[-] 	QtFont* qtFont = (QtFont*) font;
[+] 	QtFont* qtFont = (QtFont*)font;
[-] 	QFontInfo qtFontInfo (qtFont->m_qtFont);
[+] 	QFontInfo qtFontInfo(qtFont->m_qtFont);
[-] 	QString family = qtFontInfo.family ();
[+] 	QString family = qtFontInfo.family();
[-] 	QByteArray familyUtf = family.toUtf8 ();
[+] 	QByteArray familyUtf = family.toUtf8();
[-] 	size_t length = familyUtf.size ();
[+] 	size_t length = familyUtf.size();
[-] 	if (length >= countof (fontDesc->m_family))
[+] 	if (length >= countof(fontDesc->m_family))
[-] 		length = countof (fontDesc->m_family) - 1;
[+] 		length = countof(fontDesc->m_family) - 1;
[-] 	memcpy (fontDesc->m_family, familyUtf, length);
[+] 	memcpy(fontDesc->m_family, familyUtf, length);
[-] 	fontDesc->m_family [length] = 0;
[+] 	fontDesc->m_family[length] = 0;
[-] 	fontDesc->m_pointSize = qtFontInfo.pointSize ();
[+] 	fontDesc->m_pointSize = qtFontInfo.pointSize();
[-] 	if (qtFontInfo.weight () >= QFont::Bold)
[+] 	if (qtFontInfo.weight() >= QFont::Bold)
[-] 	if (qtFontInfo.italic ())
[+] 	if (qtFontInfo.italic())
[-] 	if (qtFontInfo.underline ())
[+] 	if (qtFontInfo.underline())
[-] 	if (qtFontInfo.strikeOut ())
[+] 	if (qtFontInfo.strikeOut())
[-] QtEngine::isMonospaceFont (Font* font)
[+] QtEngine::isMonospaceFont(Font* font)
[-] 	ASSERT (font->getEngine () == this);
[+] 	ASSERT(font->getEngine() == this);
[-] 	QtFont* qtFont = (QtFont*) font;
[+] 	QtFont* qtFont = (QtFont*)font;
[-] 	QFontInfo qtFontInfo (qtFont->m_qtFont);
[+] 	QFontInfo qtFontInfo(qtFont->m_qtFont);
[-] 	return qtFontInfo.fixedPitch ();
[+] 	return qtFontInfo.fixedPitch();
[-] QtEngine::calcTextSize_qt (
[+] QtEngine::calcTextSize_qt(
[-] 	ASSERT (font->getEngine () == this);
[+] 	ASSERT(font->getEngine() == this);
[-] 	QtFont* qtFont = (QtFont*) font;
[+] 	QtFont* qtFont = (QtFont*)font;
[-] 	QFontMetrics qtFontMetrics (qtFont->m_qtFont);
[+] 	QFontMetrics qtFontMetrics(qtFont->m_qtFont);
[-] 	size.m_width = qtFontMetrics.width (string);
[+] 	size.m_width = qtFontMetrics.width(string);
[-] 	size.m_height = qtFontMetrics.height ();
[+] 	size.m_height = qtFontMetrics.height();
[-] QtEngine::calcTextSize_utf8 (
[+] QtEngine::calcTextSize_utf8(
[-] 	return calcTextSize_qt (font, QString::fromUtf8 (text.cp (), text.getLength ()));
[+] 	return calcTextSize_qt(font, QString::fromUtf8(text.cp(), text.getLength()));
[-] QtEngine::calcTextSize_utf16 (
[+] QtEngine::calcTextSize_utf16(
[-] 	return calcTextSize_qt (font, QString ((const QChar*) text.cp (), text.getLength ()));
[+] 	return calcTextSize_qt(font, QString((const QChar*) text.cp(), text.getLength()));
[-] QtEngine::calcTextSize_utf32 (
[+] QtEngine::calcTextSize_utf32(
[-] 	return calcTextSize_qt (font, QString::fromUcs4 ((const uint*) text.cp (), text.getLength ()));
[+] 	return calcTextSize_qt(font, QString::fromUcs4((const uint*) text.cp(), text.getLength()));
[-] QtEngine::createImage (
[+] QtEngine::createImage(
[-] 	ASSERT (image->getEngine () == this);
[+] 	ASSERT(image->getEngine() == this);
[-] 	QtImage* qtImage = (QtImage*) image;
[+] 	QtImage* qtImage = (QtImage*)image;
[-] 	qtImage->m_qtImage = QImage (width, height, QImage::Format_ARGB32_Premultiplied);
[+] 	qtImage->m_qtImage = QImage(width, height, QImage::Format_ARGB32_Premultiplied);
[-] QtEngine::getImageDesc (
[+] QtEngine::getImageDesc(
[-] 	ASSERT (image->getEngine () == this);
[+] 	ASSERT(image->getEngine() == this);
[-] 	QtImage* qtImage = (QtImage*) image;
[+] 	QtImage* qtImage = (QtImage*)image;
[-] 	imageDesc->m_size.m_width = qtImage->m_qtImage.width ();
[+] 	imageDesc->m_size.m_width = qtImage->m_qtImage.width();
[-] 	imageDesc->m_size.m_height = qtImage->m_qtImage.height ();
[+] 	imageDesc->m_size.m_height = qtImage->m_qtImage.height();
[-] QtEngine::getStdCursor (StdCursorKind cursorKind)
[+] QtEngine::getStdCursor(StdCursorKind cursorKind)
[-] 	ASSERT (cursorKind < countof (m_stdCursorArray));
[+] 	ASSERT(cursorKind < countof(m_stdCursorArray));
[-] 	if (m_stdCursorArray [cursorKind])
[+] 	if (m_stdCursorArray[cursorKind])
[-] 		return m_stdCursorArray [cursorKind];
[+] 		return m_stdCursorArray[cursorKind];
[-] 	static Qt::CursorShape stdCursorShapeTable [StdCursorKind__Count] =
[+] 	static Qt::CursorShape stdCursorShapeTable[StdCursorKind__Count] =
[-] 	ASSERT (cursorKind < countof (stdCursorShapeTable));
[+] 	ASSERT(cursorKind < countof(stdCursorShapeTable));
[-] 	Qt::CursorShape cursorShape = stdCursorShapeTable [cursorKind];
[+] 	Qt::CursorShape cursorShape = stdCursorShapeTable[cursorKind];
[-] 	QtCursor* cursor = AXL_MEM_NEW (QtCursor);
[+] 	QtCursor* cursor = AXL_MEM_NEW(QtCursor);
[-] 	cursor->m_qtCursor = QCursor (cursorShape);
[+] 	cursor->m_qtCursor = QCursor(cursorShape);
[-] 	m_stdCursorArray [cursorKind] = cursor;
[+] 	m_stdCursorArray[cursorKind] = cursor;
[-] QtEngine::registerClipboardFormat (const sl::StringRef& formatName)
[+] QtEngine::registerClipboardFormat(const sl::StringRef& formatName)
[-] 	sl::StringHashTableIterator <uintptr_t> it = m_clipboardFormatNameMap.find (formatName);
[+] 	sl::StringHashTableIterator<uintptr_t> it = m_clipboardFormatNameMap.find(formatName);
[-] 	size_t count = m_clipboardFormatNameTable.getCount ();
[+] 	size_t count = m_clipboardFormatNameTable.getCount();
[-] 	m_clipboardFormatNameTable.append (formatName);
[+] 	m_clipboardFormatNameTable.append(formatName);
[-] 	m_clipboardFormatNameMap [formatName] = count;
[+] 	m_clipboardFormatNameMap[formatName] = count;
[-] QtEngine::readClipboard (sl::String* string)
[+] QtEngine::readClipboard(sl::String* string)
[-] 	QClipboard* qtClipboard = QApplication::clipboard ();
[+] 	QClipboard* qtClipboard = QApplication::clipboard();
[-] 	QString qtString = qtClipboard->text ();
[+] 	QString qtString = qtClipboard->text();
[-] 	QByteArray data = qtString.toUtf8 ();
[+] 	QByteArray data = qtString.toUtf8();
[-] 	string->copy (data.constData (), data.size ());
[+] 	string->copy(data.constData(), data.size());
[-] QtEngine::readClipboard (
[+] QtEngine::readClipboard(
[-] 	sl::Array <char>* data
[+] 	sl::Array<char>* data
[-] 	size_t count = m_clipboardFormatNameTable.getCount ();
[+] 	size_t count = m_clipboardFormatNameTable.getCount();
[-] 		err::setError (err::SystemErrorCode_InvalidParameter);
[+] 		err::setError(err::SystemErrorCode_InvalidParameter);
[-] 	const char* formatName = m_clipboardFormatNameTable [format];
[+] 	const char* formatName = m_clipboardFormatNameTable[format];
[-] 	QClipboard* qtClipboard = QApplication::clipboard ();
[+] 	QClipboard* qtClipboard = QApplication::clipboard();
[-] 	const QMimeData* mimeData = qtClipboard->mimeData ();
[+] 	const QMimeData* mimeData = qtClipboard->mimeData();
[-] 	QByteArray qtData = mimeData->data (formatName);
[+] 	QByteArray qtData = mimeData->data(formatName);
[-] 	data->copy (qtData.constData (), qtData.size ());
[+] 	data->copy(qtData.constData(), qtData.size());
[-] QtEngine::writeClipboard (const sl::StringRef& string)
[+] QtEngine::writeClipboard(const sl::StringRef& string)
[-] 	m_qtClipboardMimeData->setText (QString::fromUtf8 (string.cp (), string.getLength ()));
[+] 	m_qtClipboardMimeData->setText(QString::fromUtf8(string.cp(), string.getLength()));
[-] QtEngine::writeClipboard (
[+] QtEngine::writeClipboard(
[-] 	size_t count = m_clipboardFormatNameTable.getCount ();
[+] 	size_t count = m_clipboardFormatNameTable.getCount();
[-] 		err::setError (err::SystemErrorCode_InvalidParameter);
[+] 		err::setError(err::SystemErrorCode_InvalidParameter);
[-] 	const char* formatName = m_clipboardFormatNameTable [format];
[+] 	const char* formatName = m_clipboardFormatNameTable[format];
[-] 	m_qtClipboardMimeData->setData (formatName, QByteArray ((const char*) data, size));
[+] 	m_qtClipboardMimeData->setData(formatName, QByteArray((const char*) data, size));
[-] QtEngine::commitClipboard ()
[+] QtEngine::commitClipboard()
[-] 	QClipboard* qtClipboard = QApplication::clipboard ();
[+] 	QClipboard* qtClipboard = QApplication::clipboard();
[-] 	qtClipboard->setMimeData (m_qtClipboardMimeData);
[+] 	qtClipboard->setMimeData(m_qtClipboardMimeData);
[-] QtEngine::isWidgetFocused (WidgetDriver* widgetDriver)
[+] QtEngine::isWidgetFocused(WidgetDriver* widgetDriver)
[-] 	ASSERT (widgetDriver->getEngine () == this);
[+] 	ASSERT(widgetDriver->getEngine() == this);
[-] 	QtWidgetBase* qtWidget = (QtWidgetBase*) widgetDriver->getEngineWidget ();
[+] 	QtWidgetBase* qtWidget = (QtWidgetBase*)widgetDriver->getEngineWidget();
[-] 	return qtWidget->viewport ()->hasFocus ();
[+] 	return qtWidget->viewport()->hasFocus();
[-] QtEngine::setWidgetFocus (WidgetDriver* widgetDriver)
[+] QtEngine::setWidgetFocus(WidgetDriver* widgetDriver)
[-] 	ASSERT (widgetDriver->getEngine () == this);
[+] 	ASSERT(widgetDriver->getEngine() == this);
[-] 	QtWidgetBase* qtWidget = (QtWidgetBase*) widgetDriver->getEngineWidget ();
[+] 	QtWidgetBase* qtWidget = (QtWidgetBase*)widgetDriver->getEngineWidget();
[-] 	qtWidget->viewport ()->setFocus ();
[+] 	qtWidget->viewport()->setFocus();
[-] QtEngine::redrawWidget (
[+] QtEngine::redrawWidget(
[-] 	ASSERT (widgetDriver->getEngine () == this);
[+] 	ASSERT(widgetDriver->getEngine() == this);
[-] 	QtWidgetBase* qtWidget = (QtWidgetBase*) widgetDriver->getEngineWidget ();
[+] 	QtWidgetBase* qtWidget = (QtWidgetBase*)widgetDriver->getEngineWidget();
[-] 		qtWidget->viewport ()->update ();
[+] 		qtWidget->viewport()->update();
[-] 		qtWidget->viewport ()->update (left, top, right - left, bottom - top);
[+] 		qtWidget->viewport()->update(left, top, right - left, bottom - top);
[-] QtEngine::redrawWidgetImmediate (
[+] QtEngine::redrawWidgetImmediate(
[-] 	ASSERT (widgetDriver->getEngine () == this);
[+] 	ASSERT(widgetDriver->getEngine() == this);
[-] 	QtWidgetBase* qtWidget = (QtWidgetBase*) widgetDriver->getEngineWidget ();
[+] 	QtWidgetBase* qtWidget = (QtWidgetBase*)widgetDriver->getEngineWidget();
[-] 		qtWidget->viewport ()->repaint ();
[+] 		qtWidget->viewport()->repaint();
[-] 		qtWidget->viewport ()->repaint (left, top, right - left, bottom - top);
[+] 		qtWidget->viewport()->repaint(left, top, right - left, bottom - top);
[-] QtEngine::scrollWidget (
[+] QtEngine::scrollWidget(
[-] 	ASSERT (widgetDriver->getEngine () == this);
[+] 	ASSERT(widgetDriver->getEngine() == this);
[-] 	QtWidgetBase* qtWidget = (QtWidgetBase*) widgetDriver->getEngineWidget ();
[+] 	QtWidgetBase* qtWidget = (QtWidgetBase*)widgetDriver->getEngineWidget();
[-] 	qtWidget->viewport ()->scroll (dx, dy);
[+] 	qtWidget->viewport()->scroll(dx, dy);
[-] QtEngine::scrollWidgetRect (
[+] QtEngine::scrollWidgetRect(
[-] 	ASSERT (widgetDriver->getEngine () == this);
[+] 	ASSERT(widgetDriver->getEngine() == this);
[-] 	QtWidgetBase* qtWidget = (QtWidgetBase*) widgetDriver->getEngineWidget ();
[+] 	QtWidgetBase* qtWidget = (QtWidgetBase*)widgetDriver->getEngineWidget();
[-] 	qtWidget->viewport ()->scroll (dx, dy, QRect (left, top, right - left, bottom - top));
[+] 	qtWidget->viewport()->scroll(dx, dy, QRect(left, top, right - left, bottom - top));
[-] QtEngine::setWidgetCursor (
[+] QtEngine::setWidgetCursor(
[-] 	ASSERT (widgetDriver->getEngine () == this);
[+] 	ASSERT(widgetDriver->getEngine() == this);
[-] 	QtWidgetBase* qtWidget = (QtWidgetBase*) widgetDriver->getEngineWidget ();
[+] 	QtWidgetBase* qtWidget = (QtWidgetBase*)widgetDriver->getEngineWidget();
[-] 	ASSERT (cursor->getEngine () == this);
[+] 	ASSERT(cursor->getEngine() == this);
[-] 	QtCursor* qtCursor = (QtCursor*) cursor;
[+] 	QtCursor* qtCursor = (QtCursor*)cursor;
[-] 	qtWidget->viewport ()->setCursor (qtCursor->m_qtCursor);
[+] 	qtWidget->viewport()->setCursor(qtCursor->m_qtCursor);
[-] QtEngine::setMouseCapture (WidgetDriver* widgetDriver)
[+] QtEngine::setMouseCapture(WidgetDriver* widgetDriver)
[-] 	ASSERT (widgetDriver->getEngine () == this);
[+] 	ASSERT(widgetDriver->getEngine() == this);
[-] 	QtWidgetBase* qtWidget = (QtWidgetBase*) widgetDriver->getEngineWidget ();
[+] 	QtWidgetBase* qtWidget = (QtWidgetBase*)widgetDriver->getEngineWidget();
[-] 	qtWidget->viewport ()->grabMouse ();
[+] 	qtWidget->viewport()->grabMouse();
[-] QtEngine::releaseMouse (WidgetDriver* widgetDriver)
[+] QtEngine::releaseMouse(WidgetDriver* widgetDriver)
[-] 	ASSERT (widgetDriver->getEngine () == this);
[+] 	ASSERT(widgetDriver->getEngine() == this);
[-] 	QtWidgetBase* qtWidget = (QtWidgetBase*) widgetDriver->getEngineWidget ();
[+] 	QtWidgetBase* qtWidget = (QtWidgetBase*)widgetDriver->getEngineWidget();
[-] 	qtWidget->viewport ()->releaseMouse ();
[+] 	qtWidget->viewport()->releaseMouse();
[-] QtEngine::updateWidgetScrollBar (
[+] QtEngine::updateWidgetScrollBar(
[-] 	ASSERT (widgetDriver->getEngine () == this);
[+] 	ASSERT(widgetDriver->getEngine() == this);
[-] 	QtWidgetBase* qtWidget = (QtWidgetBase*) widgetDriver->getEngineWidget ();
[+] 	QtWidgetBase* qtWidget = (QtWidgetBase*)widgetDriver->getEngineWidget();
[-] 	ASSERT ((size_t) orientation < 2);
[+] 	ASSERT((size_t)orientation < 2);
[-] 	const WidgetScrollBar* scrollBar = &widgetDriver->m_scrollBarArray [orientation];
[+] 	const WidgetScrollBar* scrollBar = &widgetDriver->m_scrollBarArray[orientation];
[-] 		qtWidget->horizontalScrollBar () :
[+] 		qtWidget->horizontalScrollBar() :
[-] 		qtWidget->verticalScrollBar ();
[+] 		qtWidget->verticalScrollBar();
[-] 	qtScrollBar->setPageStep (scrollBar->m_page);
[+] 	qtScrollBar->setPageStep(scrollBar->m_page);
[-] 	qtScrollBar->setMaximum (maximum);
[+] 	qtScrollBar->setMaximum(maximum);
[-] 	qtScrollBar->setValue (scrollBar->m_pos);
[+] 	qtScrollBar->setValue(scrollBar->m_pos);
[-] QtEngine::sendWidgetNotification (
[+] QtEngine::sendWidgetNotification(
[-] 	ASSERT (widgetDriver->getEngine () == this);
[+] 	ASSERT(widgetDriver->getEngine() == this);
[-] 	QtWidgetBase* qtWidget = (QtWidgetBase*) widgetDriver->getEngineWidget ();
[+] 	QtWidgetBase* qtWidget = (QtWidgetBase*)widgetDriver->getEngineWidget();
[-] 	qtWidget->emitNotificationSignal (code, params);
[+] 	qtWidget->emitNotificationSignal(code, params);
[-] QtEngine::postWidgetThreadMsg (
[+] QtEngine::postWidgetThreadMsg(
[-] 	const ref::Ptr <void>& params
[+] 	const ref::Ptr<void>& params
[-] 	ASSERT (widgetDriver->getEngine () == this);
[+] 	ASSERT(widgetDriver->getEngine() == this);
[-] 	QtWidgetBase* qtWidget = (QtWidgetBase*) widgetDriver->getEngineWidget ();
[+] 	QtWidgetBase* qtWidget = (QtWidgetBase*)widgetDriver->getEngineWidget();
[-] 	qtWidget->postThreadMsg (code, params);
[+] 	qtWidget->postThreadMsg(code, params);
[-] QtEngine::startWidgetAnimation (WidgetDriver* widgetDriver)
[+] QtEngine::startWidgetAnimation(WidgetDriver* widgetDriver)
[-] 	ASSERT (widgetDriver->getEngine () == this);
[+] 	ASSERT(widgetDriver->getEngine() == this);
[-] 	QtWidgetBase* qtWidget = (QtWidgetBase*) widgetDriver->getEngineWidget ();
[+] 	QtWidgetBase* qtWidget = (QtWidgetBase*)widgetDriver->getEngineWidget();
[-] 	qtWidget->m_animationTimer.start (10, qtWidget);
[+] 	qtWidget->m_animationTimer.start(10, qtWidget);
[-] QtEngine::stopWidgetAnimation (WidgetDriver* widgetDriver)
[+] QtEngine::stopWidgetAnimation(WidgetDriver* widgetDriver)
[-] 	ASSERT (widgetDriver->getEngine () == this);
[+] 	ASSERT(widgetDriver->getEngine() == this);
[-] 	QtWidgetBase* qtWidget = (QtWidgetBase*) widgetDriver->getEngineWidget ();
[+] 	QtWidgetBase* qtWidget = (QtWidgetBase*)widgetDriver->getEngineWidget();
[-] 	qtWidget->m_animationTimer.stop ();
[+] 	qtWidget->m_animationTimer.stop();
[-] QtEngine::scheduleToolTipMsg (
[+] QtEngine::scheduleToolTipMsg(
[-] 	ASSERT (widgetDriver->getEngine () == this);
[+] 	ASSERT(widgetDriver->getEngine() == this);
[-] 	QtWidgetBase* qtWidget = (QtWidgetBase*) widgetDriver->getEngineWidget ();
[+] 	QtWidgetBase* qtWidget = (QtWidgetBase*)widgetDriver->getEngineWidget();
[-] 	m_toolTipTimer.stop ();
[+] 	m_toolTipTimer.stop();
[-] 	m_toolTipTimer.disconnect ();
[+] 	m_toolTipTimer.disconnect();
[-] 	QObject::connect (
[+] 	QObject::connect(
[-] 		SIGNAL (timeout ()),
[+] 		SIGNAL(timeout()),
[-] 		SLOT (toolTipTimerSlot ())
[+] 		SLOT(toolTipTimerSlot())
[-] 	m_toolTipTimer.start (timeout ? timeout : Def_ToolTipTimeout);
[+] 	m_toolTipTimer.start(timeout ? timeout : Def_ToolTipTimeout);
[-] QtEngine::cancelToolTipMsg (WidgetDriver* widgetDriver)
[+] QtEngine::cancelToolTipMsg(WidgetDriver* widgetDriver)
[-] 	ASSERT (widgetDriver->getEngine () == this);
[+] 	ASSERT(widgetDriver->getEngine() == this);
[-] 	QtWidgetBase* qtWidget = (QtWidgetBase*) widgetDriver->getEngineWidget ();
[+] 	QtWidgetBase* qtWidget = (QtWidgetBase*)widgetDriver->getEngineWidget();
[-] 	if (!m_toolTipTimer.isActive ())
[+] 	if (!m_toolTipTimer.isActive())
[-] 	bool result = m_toolTipTimer.disconnect (qtWidget);
[+] 	bool result = m_toolTipTimer.disconnect(qtWidget);
[-] 	m_toolTipTimer.stop ();
[+] 	m_toolTipTimer.stop();
[-] QtEngine::showToolTip (
[+] QtEngine::showToolTip(
[-] 	ASSERT (widgetDriver->getEngine () == this);
[+] 	ASSERT(widgetDriver->getEngine() == this);
[-] 	QtWidgetBase* qtWidget = (QtWidgetBase*) widgetDriver->getEngineWidget ();
[+] 	QtWidgetBase* qtWidget = (QtWidgetBase*)widgetDriver->getEngineWidget();
[-] 	QPoint pos = qtWidget->mapToGlobal (QPoint (x, y));
[+] 	QPoint pos = qtWidget->mapToGlobal(QPoint(x, y));
[-] 	QString qtText = QString::fromUtf8 (toolTip.cp (), toolTip.getLength ());
[+] 	QString qtText = QString::fromUtf8(toolTip.cp(), toolTip.getLength());
[-] 	QToolTip::showText (pos, qtText, qtWidget);
[+] 	QToolTip::showText(pos, qtText, qtWidget);
[-] QtEngine::hideToolTip (WidgetDriver* widgetDriver)
[+] QtEngine::hideToolTip(WidgetDriver* widgetDriver)
[-] 	QToolTip::hideText ();
[+] 	QToolTip::hideText();
[-] QtEngine::processUiEvents (uint32_t timeLimit)
[+] QtEngine::processUiEvents(uint32_t timeLimit)
[-] 		qApp->processEvents (QEventLoop::AllEvents, timeLimit) :
[+] 		qApp->processEvents(QEventLoop::AllEvents, timeLimit) :
[-] 		qApp->processEvents (QEventLoop::AllEvents);
[+] 		qApp->processEvents(QEventLoop::AllEvents);
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_QtWidget.cpp
----------------------
[-] getMouseButtonFromQtButton (Qt::MouseButton qtButton)
[+] getMouseButtonFromQtButton(Qt::MouseButton qtButton)
[-] 	return (MouseButton) (qtButton & 0x7);
[+] 	return (MouseButton)(qtButton & 0x7);
[-] getMouseButtonsFromQtButtons (int qtButtons)
[+] getMouseButtonsFromQtButtons(int qtButtons)
[-] getModifierKeysFromQtModifiers (int qtModifiers)
[+] getModifierKeysFromQtModifiers(int qtModifiers)
[-] getKeyFromQtKey (int qtKey)
[+] getKeyFromQtKey(int qtKey)
[-] 	ASSERT (qtKey & 0x01000000);
[+] 	ASSERT(qtKey & 0x01000000);
[-] 	static uint_t keyTable [] =
[+] 	static uint_t keyTable[] =
[-] 	return index < countof (keyTable) ? keyTable [index] : 0;
[+] 	return index < countof(keyTable) ? keyTable[index] : 0;
[-] QtWidgetBase::QtWidgetBase (
[+] QtWidgetBase::QtWidgetBase(
[-] 	QAbstractScrollArea (parent)
[+] 	QAbstractScrollArea(parent)
[-] 	setMouseTracking (true);
[+] 	setMouseTracking(true);
[-] QtWidgetBase::postThreadMsg (
[+] QtWidgetBase::postThreadMsg(
[-] 	const ref::Ptr <void>& params
[+] 	const ref::Ptr<void>& params
[-] 	WidgetThreadMsg* msg = AXL_MEM_NEW (WidgetThreadMsg);
[+] 	WidgetThreadMsg* msg = AXL_MEM_NEW(WidgetThreadMsg);
[-] 	emit threadMsgSignal (msg);
[+] 	emit threadMsgSignal(msg);
[-] QtWidgetBase::threadMsgSlot (WidgetThreadMsg* msg)
[+] QtWidgetBase::threadMsgSlot(WidgetThreadMsg* msg)
[-] 	m_widgetDriver->processMsg (msg, &isHandled);
[+] 	m_widgetDriver->processMsg(msg, &isHandled);
[-] 	AXL_MEM_DELETE (msg);
[+] 	AXL_MEM_DELETE(msg);
[-] QtWidgetBase::toolTipTimerSlot ()
[+] QtWidgetBase::toolTipTimerSlot()
[-] 	QPoint pos = mapFromGlobal (QCursor::pos ());
[+] 	QPoint pos = mapFromGlobal(QCursor::pos());
[-] 	msg.m_point.setup (pos.x (), pos.y ());
[+] 	msg.m_point.setup(pos.x(), pos.y());
[-] 	msg.m_buttons = getMouseButtonsFromQtButtons (QApplication::mouseButtons ());
[+] 	msg.m_buttons = getMouseButtonsFromQtButtons(QApplication::mouseButtons());
[-] 	msg.m_modifierKeys = getModifierKeysFromQtModifiers (QApplication::keyboardModifiers ());
[+] 	msg.m_modifierKeys = getModifierKeysFromQtModifiers(QApplication::keyboardModifiers());
[-] 	m_widgetDriver->processMsg (&msg, &isHandled);
[+] 	m_widgetDriver->processMsg(&msg, &isHandled);
[-] QtWidgetBase::wheelEvent (QWheelEvent* e)
[+] QtWidgetBase::wheelEvent(QWheelEvent* e)
[-] 	if (!m_widgetDriver->checkMsgMap (WidgetMsgCode_MouseWheel))
[+] 	if (!m_widgetDriver->checkMsgMap(WidgetMsgCode_MouseWheel))
[-] 		e->ignore ();
[+] 		e->ignore();
[-] 	msg.m_point.setup (e->x (), e->y ());
[+] 	msg.m_point.setup(e->x(), e->y());
[-] 	msg.m_buttons = getMouseButtonsFromQtButtons (e->buttons ());
[+] 	msg.m_buttons = getMouseButtonsFromQtButtons(e->buttons());
[-] 	msg.m_modifierKeys = getModifierKeysFromQtModifiers (e->modifiers ());
[+] 	msg.m_modifierKeys = getModifierKeysFromQtModifiers(e->modifiers());
[-] 	msg.m_wheelDelta = e->delta ();
[+] 	msg.m_wheelDelta = e->delta();
[-] 	m_widgetDriver->processMsg (&msg, &isHandled);
[+] 	m_widgetDriver->processMsg(&msg, &isHandled);
[-] 		e->ignore ();
[+] 		e->ignore();
[-] QtWidgetBase::paintEvent (QPaintEvent* e)
[+] QtWidgetBase::paintEvent(QPaintEvent* e)
[-] 	if (!m_widgetDriver->checkMsgMap (WidgetMsgCode_Paint))
[+] 	if (!m_widgetDriver->checkMsgMap(WidgetMsgCode_Paint))
[-] 		e->ignore ();
[+] 		e->ignore();
[-] 	canvas.m_qtPainter.begin (viewport ());
[+] 	canvas.m_qtPainter.begin(viewport());
[-] 	canvas.m_font = m_widgetDriver->getFont ();
[+] 	canvas.m_font = m_widgetDriver->getFont();
[-] 	canvas.m_colorAttr = m_widgetDriver->getColorAttr ();
[+] 	canvas.m_colorAttr = m_widgetDriver->getColorAttr();
[-] 	canvas.m_palette = m_widgetDriver->getPalette ();
[+] 	canvas.m_palette = m_widgetDriver->getPalette();
[-] 	QRect rect = e->rect ();
[+] 	QRect rect = e->rect();
[-] 	QRegion region = e->region ();
[+] 	QRegion region = e->region();
[-] 	WidgetPaintMsg msg (&canvas);
[+] 	WidgetPaintMsg msg(&canvas);
[-] 	msg.m_rect.m_left   = rect.x ();
[+] 	msg.m_rect.m_left   = rect.x();
[-] 	msg.m_rect.m_top    = rect.y ();
[+] 	msg.m_rect.m_top    = rect.y();
[-] 	msg.m_rect.m_right  = rect.x () + rect.width ();
[+] 	msg.m_rect.m_right  = rect.x() + rect.width();
[-] 	msg.m_rect.m_bottom = rect.y () + rect.height ();
[+] 	msg.m_rect.m_bottom = rect.y() + rect.height();
[-] 	size_t rectCount = region.rectCount ();
[+] 	size_t rectCount = region.rectCount();
[-] 	if (rectCount > countof (msg.m_region))
[+] 	if (rectCount > countof(msg.m_region))
[-] 		msg.m_region [0] = msg.m_rect;
[+] 		msg.m_region[0] = msg.m_rect;
[-] 		QVector <QRect> rectVector = region.rects ();
[+] 		QVector<QRect> rectVector = region.rects();
[-] 		const QRect* src = rectVector.constBegin ();
[+] 		const QRect* src = rectVector.constBegin();
[-] 			dst->m_left   = src->x ();
[+] 			dst->m_left   = src->x();
[-] 			dst->m_top    = src->y ();
[+] 			dst->m_top    = src->y();
[-] 			dst->m_right  = src->x () + src->width ();
[+] 			dst->m_right  = src->x() + src->width();
[-] 			dst->m_bottom = src->y () + src->height ();
[+] 			dst->m_bottom = src->y() + src->height();
[-] 	m_widgetDriver->processMsg (&msg, &isHandled);
[+] 	m_widgetDriver->processMsg(&msg, &isHandled);
[-] 	if (m_widgetDriver->isCaretVisible () &&
[+] 	if (m_widgetDriver->isCaretVisible() &&
[-] 		((QtEngine*) m_widgetDriver->getEngine ())->isCaretVisible ())
[+] 		((QtEngine*)m_widgetDriver->getEngine())->isCaretVisible())
[-] 		Point caretPos = m_widgetDriver->getCaretPos ();
[+] 		Point caretPos = m_widgetDriver->getCaretPos();
[-] 		Size caretSize = m_widgetDriver->getCaretSize ();
[+] 		Size caretSize = m_widgetDriver->getCaretSize();
[-] 		canvas.m_qtPainter.setCompositionMode (QPainter::RasterOp_SourceXorDestination);
[+] 		canvas.m_qtPainter.setCompositionMode(QPainter::RasterOp_SourceXorDestination);
[-] 		canvas.m_qtPainter.fillRect (
[+] 		canvas.m_qtPainter.fillRect(
[-] 	canvas.m_qtPainter.end ();
[+] 	canvas.m_qtPainter.end();
[-] QtWidgetBase::resizeEvent (QResizeEvent* e)
[+] QtWidgetBase::resizeEvent(QResizeEvent* e)
[-] 	if (!m_widgetDriver->checkMsgMap (WidgetMsgCode_Size))
[+] 	if (!m_widgetDriver->checkMsgMap(WidgetMsgCode_Size))
[-] 		e->ignore ();
[+] 		e->ignore();
[-] 	QSize qtSize = viewport ()->size ();
[+] 	QSize qtSize = viewport()->size();
[-] 	Size size (qtSize.width (), qtSize.height ());
[+] 	Size size(qtSize.width(), qtSize.height());
[-] 	WidgetMsgParam <uint_t> msg (WidgetMsgCode_Size, mask);
[+] 	WidgetMsgParam<uint_t> msg(WidgetMsgCode_Size, mask);
[-] 	m_widgetDriver->processMsg (&msg, &isHandled);
[+] 	m_widgetDriver->processMsg(&msg, &isHandled);
[-] 		e->ignore ();
[+] 		e->ignore();
[-] QtWidgetBase::scrollContentsBy (
[+] QtWidgetBase::scrollContentsBy(
[-] 		m_widgetDriver->m_scrollBarArray [Orientation_Vertical].m_pos = verticalScrollBar ()->value ();
[+] 		m_widgetDriver->m_scrollBarArray[Orientation_Vertical].m_pos = verticalScrollBar()->value();
[-] 		m_widgetDriver->m_scrollBarArray [Orientation_Horizontal].m_pos = horizontalScrollBar ()->value ();
[+] 		m_widgetDriver->m_scrollBarArray[Orientation_Horizontal].m_pos = horizontalScrollBar()->value();
[-] 	if (!m_widgetDriver->checkMsgMap (WidgetMsgCode_Size))
[+] 	if (!m_widgetDriver->checkMsgMap(WidgetMsgCode_Size))
[-] 	WidgetMsgParam <uint_t> msg (WidgetMsgCode_Scroll, mask);
[+] 	WidgetMsgParam<uint_t> msg(WidgetMsgCode_Scroll, mask);
[-] 	m_widgetDriver->processMsg (&msg, &isHandled);
[+] 	m_widgetDriver->processMsg(&msg, &isHandled);
[-] QtWidgetBase::genericEventImpl (
[+] QtWidgetBase::genericEventImpl(
[-] 	if (!m_widgetDriver->checkMsgMap (msgCode))
[+] 	if (!m_widgetDriver->checkMsgMap(msgCode))
[-] 		e->ignore ();
[+] 		e->ignore();
[-] 	WidgetMsg msg (msgCode);
[+] 	WidgetMsg msg(msgCode);
[-] 	m_widgetDriver->processMsg (&msg, &isHandled);
[+] 	m_widgetDriver->processMsg(&msg, &isHandled);
[-] 		e->ignore ();
[+] 		e->ignore();
[-] QtWidgetBase::mouseEventImpl (
[+] QtWidgetBase::mouseEventImpl(
[-] 	if (!m_widgetDriver->checkMsgMap (msgCode))
[+] 	if (!m_widgetDriver->checkMsgMap(msgCode))
[-] 		e->ignore ();
[+] 		e->ignore();
[-] 	msg.m_point.setup (e->x (), e->y ());
[+] 	msg.m_point.setup(e->x(), e->y());
[-] 	msg.m_buttons = getMouseButtonsFromQtButtons (e->buttons ());
[+] 	msg.m_buttons = getMouseButtonsFromQtButtons(e->buttons());
[-] 	msg.m_modifierKeys = getModifierKeysFromQtModifiers (e->modifiers ());
[+] 	msg.m_modifierKeys = getModifierKeysFromQtModifiers(e->modifiers());
[-] 	msg.m_button = getMouseButtonFromQtButton (e->button ());
[+] 	msg.m_button = getMouseButtonFromQtButton(e->button());
[-] 	m_widgetDriver->processMsg (&msg, &isHandled);
[+] 	m_widgetDriver->processMsg(&msg, &isHandled);
[-] 		e->ignore ();
[+] 		e->ignore();
[-] QtWidgetBase::keyEventImpl (
[+] QtWidgetBase::keyEventImpl(
[-] 	if (!m_widgetDriver->checkMsgMap (msgCode))
[+] 	if (!m_widgetDriver->checkMsgMap(msgCode))
[-] 		e->ignore ();
[+] 		e->ignore();
[-] 	int qtKey = e->key ();
[+] 	int qtKey = e->key();
[-] 		msg.m_key = getKeyFromQtKey (qtKey);
[+] 		msg.m_key = getKeyFromQtKey(qtKey);
[-] 		msg.m_char = e->text ().at (0).unicode ();
[+] 		msg.m_char = e->text().at(0).unicode();
[-] 	msg.m_modifierKeys = getModifierKeysFromQtModifiers (e->modifiers ());
[+] 	msg.m_modifierKeys = getModifierKeysFromQtModifiers(e->modifiers());
[-] 	m_widgetDriver->processMsg (&msg, &isHandled);
[+] 	m_widgetDriver->processMsg(&msg, &isHandled);
[-] 		e->ignore ();
[+] 		e->ignore();
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_TextAttrAnchorArray.cpp
----------------------
[-] TextAttrAnchorArray::trace ()
[+] TextAttrAnchorArray::trace()
[-] 	size_t count = getCount ();
[+] 	size_t count = getCount();
[-] 	TRACE ("--- CTextAttrAnchorArray {%d}---\n", count);
[+] 	TRACE("--- CTextAttrAnchorArray {%d}---\n", count);
[-] 		const TextAttrAnchor* anchor = &(m_array [i]);
[+] 		const TextAttrAnchor* anchor = &(m_array[i]);
[-] 		TRACE ("[%d] ofs:%02x fc:%x\n", i, anchor->m_offset, anchor->m_attr.m_foreColor);
[+] 		TRACE("[%d] ofs:%02x fc:%x\n", i, anchor->m_offset, anchor->m_attr.m_foreColor);
[-] TextAttrAnchorArray::findAnchor (size_t offset) const
[+] TextAttrAnchorArray::findAnchor(size_t offset) const
[-] 	size_t count = m_array.getCount ();
[+] 	size_t count = m_array.getCount();
[-] 		const TextAttrAnchor* anchor = &m_array [mid];
[+] 		const TextAttrAnchor* anchor = &m_array[mid];
[-] 		ASSERT (mid < count);
[+] 		ASSERT(mid < count);
[-] TextAttrAnchorArray::getStartAnchor (size_t offset)
[+] TextAttrAnchorArray::getStartAnchor(size_t offset)
[-] 	size_t index = findAnchor (offset);
[+] 	size_t index = findAnchor(offset);
[-] 		m_array.insert (0, TextAttrAnchor (offset, TextAttr ()));
[+] 		m_array.insert(0, TextAttrAnchor(offset, TextAttr()));
[-] 	TextAttrAnchor* anchor = &m_array [index];
[+] 	TextAttrAnchor* anchor = &m_array[index];
[-] 	m_array.insert (index, TextAttrAnchor (offset, lastAttr));
[+] 	m_array.insert(index, TextAttrAnchor(offset, lastAttr));
[-] TextAttrAnchorArray::getEndAnchor (size_t offset)
[+] TextAttrAnchorArray::getEndAnchor(size_t offset)
[-] 	size_t index = findAnchor (offset);
[+] 	size_t index = findAnchor(offset);
[-] 		m_array.insert (0, TextAttrAnchor (offset, TextAttr ()));
[+] 		m_array.insert(0, TextAttrAnchor(offset, TextAttr()));
[-] 	TextAttrAnchor* anchor = &m_array [index];
[+] 	TextAttrAnchor* anchor = &m_array[index];
[-] 	m_array.insert (index, TextAttrAnchor (offset, lastAttr));
[+] 	m_array.insert(index, TextAttrAnchor(offset, lastAttr));
[-] TextAttrAnchorArray::normalize (
[+] TextAttrAnchorArray::normalize(
[-] 		lastAnchor = m_array [start - 1];
[+] 		lastAnchor = m_array[start - 1];
[-] 		TextAttrAnchor* anchor = &m_array [i];
[+] 		TextAttrAnchor* anchor = &m_array[i];
[-] 		if (anchor->m_attr.cmp (lastAnchor.m_attr) == 0)
[+] 		if (anchor->m_attr.cmp(lastAnchor.m_attr) == 0)
[-] 				m_array.remove (removeIndex, removeCount);
[+] 				m_array.remove(removeIndex, removeCount);
[-] 		m_array.remove (removeIndex, removeCount);
[+] 		m_array.remove(removeIndex, removeCount);
[-] TextAttrAnchorArray::clearBefore (size_t offset)
[+] TextAttrAnchorArray::clearBefore(size_t offset)
[-] 	size_t anchor = findAnchor (offset);
[+] 	size_t anchor = findAnchor(offset);
[-] 		m_array.remove (0, anchor + 1);
[+] 		m_array.remove(0, anchor + 1);
[-] TextAttrAnchorArray::setAttr (
[+] TextAttrAnchorArray::setAttr(
[-] 	m_array.ensureExclusive ();
[+] 	m_array.ensureExclusive();
[-] 	size_t endIdx = getEndAnchor (endOffset);
[+] 	size_t endIdx = getEndAnchor(endOffset);
[-] 	size_t oldCount = m_array.getCount ();
[+] 	size_t oldCount = m_array.getCount();
[-] 	size_t startIdx = getStartAnchor (beginOffset);
[+] 	size_t startIdx = getStartAnchor(beginOffset);
[-] 	if (startIdx <= endIdx && m_array.getCount () > oldCount)
[+] 	if (startIdx <= endIdx && m_array.getCount() > oldCount)
[-] 		m_array [i].m_attr.overlay (attr);
[+] 		m_array[i].m_attr.overlay(attr);
[-] 	normalize (startIdx, endIdx);
[+] 	normalize(startIdx, endIdx);
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_TextPainter.cpp
----------------------
[-] TextPainter::init (Canvas* canvas)
[+] TextPainter::init(Canvas* canvas)
[-] TextPainter::drawSpace_p (
[+] TextPainter::drawSpace_p(
[-] 	m_canvas->drawRect (rect, color);
[+] 	m_canvas->drawRect(rect, color);
[-] TextPainter::drawSpace (
[+] TextPainter::drawSpace(
[-] 	Size size = m_canvas->m_font->calcTextSize (sl::StringRef (" ", 1));
[+] 	Size size = m_canvas->m_font->calcTextSize(sl::StringRef(" ", 1));
[-] 	return drawSpace_p (length * size.m_width, color);
[+] 	return drawSpace_p(length * size.m_width, color);
[-] TextPainter::drawText_utf8 (
[+] TextPainter::drawText_utf8(
[-] 	if (text.isEmpty ())
[+] 	if (text.isEmpty())
[-] 	Font* font = m_canvas->m_font->getFontMod (fontFlags);
[+] 	Font* font = m_canvas->m_font->getFontMod(fontFlags);
[-] 	Size size = font->calcTextSize_utf8 (text);
[+] 	Size size = font->calcTextSize_utf8(text);
[-] 	m_canvas->drawText_utf8 (
[+] 	m_canvas->drawText_utf8(
[-] TextPainter::drawText_utf32 (
[+] TextPainter::drawText_utf32(
[-] 	if (text.isEmpty ())
[+] 	if (text.isEmpty())
[-] 	Font* font = m_canvas->m_font->getFontMod (fontFlags);
[+] 	Font* font = m_canvas->m_font->getFontMod(fontFlags);
[-] 	Size size = font->calcTextSize_utf32 (text);
[+] 	Size size = font->calcTextSize_utf32(text);
[-] 	m_canvas->drawText_utf32 (
[+] 	m_canvas->drawText_utf32(
[-] TextPainter::drawHyperText_utf8 (
[+] TextPainter::drawHyperText_utf8(
[-] 	if (!attrArray || attrArray->isEmpty ())
[+] 	if (!attrArray || attrArray->isEmpty())
[-] 		return drawText_utf8 (textColor0, backColor0, fontFlags0, text);
[+] 		return drawText_utf8(textColor0, backColor0, fontFlags0, text);
[-] 	if (text.isEmpty ())
[+] 	if (text.isEmpty())
[-] 	TextAttr attr0 (textColor0, backColor0, fontFlags0);
[+] 	TextAttr attr0(textColor0, backColor0, fontFlags0);
[-] 	const TextAttrAnchor* nextAttr = attrArray->cp ();
[+] 	const TextAttrAnchor* nextAttr = attrArray->cp();
[-] 	const TextAttrAnchor* attrEnd = nextAttr + attrArray->getCount ();
[+] 	const TextAttrAnchor* attrEnd = nextAttr + attrArray->getCount();
[-] 		attr.overlay (nextAttr->m_attr);
[+] 		attr.overlay(nextAttr->m_attr);
[-] 	const utf8_t* p = text.cp ();
[+] 	const utf8_t* p = text.cp();
[-] 	size_t length = text.getLength ();
[+] 	size_t length = text.getLength();
[-] 			return drawText_utf8 (attr, sl::StringRef_utf8 (p, leftover));
[+] 			return drawText_utf8(attr, sl::StringRef_utf8(p, leftover));
[-] 		drawText_utf8 (attr, sl::StringRef_utf8 (p, chunk));
[+] 		drawText_utf8(attr, sl::StringRef_utf8(p, chunk));
[-] 		attr.overlay (attr0, nextAttr->m_attr);
[+] 		attr.overlay(attr0, nextAttr->m_attr);
[-] 		drawText_utf8 (attr, sl::StringRef_utf8 (p, leftover));
[+] 		drawText_utf8(attr, sl::StringRef_utf8(p, leftover));
[-] TextPainter::drawHyperText_utf32 (
[+] TextPainter::drawHyperText_utf32(
[-] 	if (!attrArray || attrArray->isEmpty ())
[+] 	if (!attrArray || attrArray->isEmpty())
[-] 		return drawText_utf32 (textColor0, backColor0, fontFlags0, text);
[+] 		return drawText_utf32(textColor0, backColor0, fontFlags0, text);
[-] 	if (text.isEmpty ())
[+] 	if (text.isEmpty())
[-] 	TextAttr attr0 (textColor0, backColor0, fontFlags0);
[+] 	TextAttr attr0(textColor0, backColor0, fontFlags0);
[-] 	const TextAttrAnchor* nextAttr = attrArray->cp ();
[+] 	const TextAttrAnchor* nextAttr = attrArray->cp();
[-] 	const TextAttrAnchor* attrEnd = nextAttr + attrArray->getCount ();
[+] 	const TextAttrAnchor* attrEnd = nextAttr + attrArray->getCount();
[-] 		attr.overlay (attr, nextAttr->m_attr);
[+] 		attr.overlay(attr, nextAttr->m_attr);
[-] 	const utf32_t* p = text.cp ();
[+] 	const utf32_t* p = text.cp();
[-] 	size_t length = text.getLength ();
[+] 	size_t length = text.getLength();
[-] 			return drawText_utf32 (attr, sl::StringRef_utf32 (p, leftover));
[+] 			return drawText_utf32(attr, sl::StringRef_utf32(p, leftover));
[-] 		drawText_utf32 (attr, sl::StringRef_utf32 (p, chunk));
[+] 		drawText_utf32(attr, sl::StringRef_utf32(p, chunk));
[-] 		attr.overlay (attr0, nextAttr->m_attr);
[+] 		attr.overlay(attr0, nextAttr->m_attr);
[-] 		drawText_utf32 (attr, sl::StringRef_utf32 (p, leftover));
[+] 		drawText_utf32(attr, sl::StringRef_utf32(p, leftover));
[-] TextPainter::drawSelHyperText_utf8 (
[+] TextPainter::drawSelHyperText_utf8(
[-] 		return drawHyperText_utf8 (textColor, backColor, fontFlags, attrArray, text);
[+] 		return drawHyperText_utf8(textColor, backColor, fontFlags, attrArray, text);
[-] 		m_selOverlayBuffer.copy (attrArray->cp (), attrArray->getCount ());
[+] 		m_selOverlayBuffer.copy(attrArray->cp(), attrArray->getCount());
[-] 		m_selOverlayBuffer.clear ();
[+] 		m_selOverlayBuffer.clear();
[-] 	m_selOverlayBuffer.setAttr (selStart, selEnd, selAttr);
[+] 	m_selOverlayBuffer.setAttr(selStart, selEnd, selAttr);
[-] 	return drawHyperText_utf8 (textColor, backColor, fontFlags, &m_selOverlayBuffer, text);
[+] 	return drawHyperText_utf8(textColor, backColor, fontFlags, &m_selOverlayBuffer, text);
[-] TextPainter::drawSelHyperText_utf32 (
[+] TextPainter::drawSelHyperText_utf32(
[-] 		return drawHyperText_utf32 (textColor, backColor, fontFlags, attrArray, text);
[+] 		return drawHyperText_utf32(textColor, backColor, fontFlags, attrArray, text);
[-] 		m_selOverlayBuffer.copy (attrArray->cp (), attrArray->getCount ());
[+] 		m_selOverlayBuffer.copy(attrArray->cp(), attrArray->getCount());
[-] 		m_selOverlayBuffer.clear ();
[+] 		m_selOverlayBuffer.clear();
[-] 	m_selOverlayBuffer.setAttr (selStart, selEnd, selAttr);
[+] 	m_selOverlayBuffer.setAttr(selStart, selEnd, selAttr);
[-] 	return drawHyperText_utf32 (textColor, backColor, fontFlags, &m_selOverlayBuffer, text);
[+] 	return drawHyperText_utf32(textColor, backColor, fontFlags, &m_selOverlayBuffer, text);
[-] TextPainter::drawBinHex (
[+] TextPainter::drawBinHex(
[-] 	enc::HexEncoding::encode (&m_stringBuffer, p, size, 0);
[+] 	enc::HexEncoding::encode(&m_stringBuffer, p, size, 0);
[-] 	m_stringBuffer.append (' ');
[+] 	m_stringBuffer.append(' ');
[-] 		ASSERT (j < m_stringBuffer.getLength ());
[+] 		ASSERT(j < m_stringBuffer.getLength());
[-] 		char* buffer = m_stringBuffer.getBuffer ();
[+] 		char* buffer = m_stringBuffer.getBuffer();
[-] 		buffer [i] = buffer [j];
[+] 		buffer[i] = buffer[j];
[-] 		buffer [j] = ' ';
[+] 		buffer[j] = ' ';
[-] 	return drawText_utf8 (
[+] 	return drawText_utf8(
[-] TextPainter::drawHyperBinHex (
[+] TextPainter::drawHyperBinHex(
[-] 	if (!attrArray || attrArray->isEmpty ())
[+] 	if (!attrArray || attrArray->isEmpty())
[-] 		return drawBinHex (textColor0, backColor0, fontFlags0, halfBitOffset, p0, size);
[+] 		return drawBinHex(textColor0, backColor0, fontFlags0, halfBitOffset, p0, size);
[-] 	TextAttr attr0 (textColor0, backColor0, fontFlags0);
[+] 	TextAttr attr0(textColor0, backColor0, fontFlags0);
[-] 	const TextAttrAnchor* nextAttr = attrArray->cp ();
[+] 	const TextAttrAnchor* nextAttr = attrArray->cp();
[-] 	const TextAttrAnchor* attrEnd = nextAttr + attrArray->getCount ();
[+] 	const TextAttrAnchor* attrEnd = nextAttr + attrArray->getCount();
[-] 		attr.overlay (attr, nextAttr->m_attr);
[+] 		attr.overlay(attr, nextAttr->m_attr);
[-] 			return drawBinHex (attr, halfBitOffset, p, leftover);
[+] 			return drawBinHex(attr, halfBitOffset, p, leftover);
[-] 		drawBinHex (attr, halfBitOffset, p, chunk);
[+] 		drawBinHex(attr, halfBitOffset, p, chunk);
[-] 		attr.overlay (attr0, nextAttr->m_attr);
[+] 		attr.overlay(attr0, nextAttr->m_attr);
[-] 		drawBinHex (attr, halfBitOffset, p, leftover);
[+] 		drawBinHex(attr, halfBitOffset, p, leftover);
[-] TextPainter::drawSelHyperBinHex (
[+] TextPainter::drawSelHyperBinHex(
[-] 		return drawHyperBinHex (textColor0, backColor0, fontFlags0, attrArray, halfBitOffset, p, size);
[+] 		return drawHyperBinHex(textColor0, backColor0, fontFlags0, attrArray, halfBitOffset, p, size);
[-] 		m_selOverlayBuffer.copy (attrArray->cp (), attrArray->getCount ());
[+] 		m_selOverlayBuffer.copy(attrArray->cp(), attrArray->getCount());
[-] 		m_selOverlayBuffer.clear ();
[+] 		m_selOverlayBuffer.clear();
[-] 	m_selOverlayBuffer.setAttr (selStart, selEnd, selAttr);
[+] 	m_selOverlayBuffer.setAttr(selStart, selEnd, selAttr);
[-] 	return drawHyperBinHex (textColor0, backColor0, fontFlags0, &m_selOverlayBuffer, halfBitOffset, p, size);
[+] 	return drawHyperBinHex(textColor0, backColor0, fontFlags0, &m_selOverlayBuffer, halfBitOffset, p, size);
[-] TextPainter::buildBinTextString (
[+] TextPainter::buildBinTextString(
[-] 	sl::Array <utf32_t>* binTextBuffer,
[+] 	sl::Array<utf32_t>* binTextBuffer,
[-] 	size_t length = buildBinTextBuffer (binTextBuffer, codec, p, dataSize, bufferSize, unprintableChar);
[+] 	size_t length = buildBinTextBuffer(binTextBuffer, codec, p, dataSize, bufferSize, unprintableChar);
[-] 	stringBuffer->copy (sl::StringRef_utf32 (*binTextBuffer, length));
[+] 	stringBuffer->copy(sl::StringRef_utf32(*binTextBuffer, length));
[-] TextPainter::buildBinTextString (
[+] TextPainter::buildBinTextString(
[-] 	sl::Array <utf32_t> binTextBuffer;
[+] 	sl::Array<utf32_t> binTextBuffer;
[-] 	buildBinTextString (&binTextBuffer, &stringBuffer, codec, p, dataSize, bufferSize, unprintableChar);
[+] 	buildBinTextString(&binTextBuffer, &stringBuffer, codec, p, dataSize, bufferSize, unprintableChar);
[-] TextPainter::buildBinTextBuffer (
[+] TextPainter::buildBinTextBuffer(
[-] 	sl::Array <utf32_t>* binTextBuffer,
[+] 	sl::Array<utf32_t>* binTextBuffer,
[-] 	binTextBuffer->setCount (dataSize);
[+] 	binTextBuffer->setCount(dataSize);
[-] 	utf32_t* buffer = binTextBuffer->p ();
[+] 	utf32_t* buffer = binTextBuffer->p();
[-] 	size_t unitSize = codec->getUnitSize ();
[+] 	size_t unitSize = codec->getUnitSize();
[-] 	AXL_TODO ("do a whole buffer decode rather than codepoint-after-codepoint")
[+] 	AXL_TODO("do a whole buffer decode rather than codepoint-after-codepoint")
[-] 		codec->decodeToUtf32 (&codePoint, 1, p, leftover, &takenSize);
[+] 		codec->decodeToUtf32(&codePoint, 1, p, leftover, &takenSize);
[-] 				buffer [i] = unprintableChar;
[+] 				buffer[i] = unprintableChar;
[-] 		buffer [i] = enc::utfIsPrintableNonMark (codePoint) ? codePoint : unprintableChar;
[+] 		buffer[i] = enc::utfIsPrintableNonMark(codePoint) ? codePoint : unprintableChar;
[-] 			buffer [i] = unprintableChar;
[+] 			buffer[i] = unprintableChar;
[-] TextPainter::drawBinText (
[+] TextPainter::drawBinText(
[-] 	size_t length = buildBinTextBuffer (codec, p, dataSize, bufferSize);
[+] 	size_t length = buildBinTextBuffer(codec, p, dataSize, bufferSize);
[-] 	return drawText_utf32 (sl::StringRef_utf32 (m_binTextBuffer, length));
[+] 	return drawText_utf32(sl::StringRef_utf32(m_binTextBuffer, length));
[-] TextPainter::drawHyperBinText (
[+] TextPainter::drawHyperBinText(
[-] 	size_t length = buildBinTextBuffer (codec, p, dataSize, bufferSize);
[+] 	size_t length = buildBinTextBuffer(codec, p, dataSize, bufferSize);
[-] 	return drawHyperText_utf32 (
[+] 	return drawHyperText_utf32(
[-] 		sl::StringRef_utf32 (m_binTextBuffer, length)
[+] 		sl::StringRef_utf32(m_binTextBuffer, length)
[-] TextPainter::drawSelHyperBinText (
[+] TextPainter::drawSelHyperBinText(
[-] 	size_t length = buildBinTextBuffer (codec, p, dataSize, bufferSize);
[+] 	size_t length = buildBinTextBuffer(codec, p, dataSize, bufferSize);
[-] 	return drawSelHyperText_utf32 (
[+] 	return drawSelHyperText_utf32(
[-] 		sl::StringRef_utf32 (m_binTextBuffer, length)
[+] 		sl::StringRef_utf32(m_binTextBuffer, length)
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_gui\axl_gui_Widget.cpp
----------------------
[-] WidgetDriver::WidgetDriver (const WidgetConstructParam& param):
[+] WidgetDriver::WidgetDriver(const WidgetConstructParam& param):
[-] 	GuiItem (param.m_engine)
[+] 	GuiItem(param.m_engine)
[-] 	m_cursor = m_engine->getStdCursor (StdCursorKind_Arrow);
[+] 	m_cursor = m_engine->getStdCursor(StdCursorKind_Arrow);
[-] 	m_font = m_engine->getStdFont (StdFontKind_Monospace);
[+] 	m_font = m_engine->getStdFont(StdFontKind_Monospace);
[-] 	m_caretSize.m_height = m_font->calcTextSize ('|').m_height;
[+] 	m_caretSize.m_height = m_font->calcTextSize('|').m_height;
[-] WidgetDriver::setFont (Font* font)
[+] WidgetDriver::setFont(Font* font)
[-] 	m_caretSize.m_height = m_font->calcTextSize ('|').m_height;
[+] 	m_caretSize.m_height = m_font->calcTextSize('|').m_height;
[-] WidgetDriver::setCaretVisible (bool isVisible)
[+] WidgetDriver::setCaretVisible(bool isVisible)
[-] 		return m_engine->showCaret (this, Rect (m_caretPos, m_caretSize));
[+] 		return m_engine->showCaret(this, Rect(m_caretPos, m_caretSize));
[-] 	m_engine->hideCaret (this);
[+] 	m_engine->hideCaret(this);
[-] WidgetDriver::setCaretSize (
[+] WidgetDriver::setCaretSize(
[-] 	m_caretSize.setup (width, height);
[+] 	m_caretSize.setup(width, height);
[-] 	return m_isCaretVisible ? m_engine->showCaret (this, Rect (m_caretPos, m_caretSize)) : true;
[+] 	return m_isCaretVisible ? m_engine->showCaret(this, Rect(m_caretPos, m_caretSize)) : true;
[-] WidgetDriver::setCaretPos (
[+] WidgetDriver::setCaretPos(
[-] 	m_caretPos.setup (x, y);
[+] 	m_caretPos.setup(x, y);
[-] 	return m_isCaretVisible ? m_engine->showCaret (this, Rect (m_caretPos, m_caretSize)) : true;
[+] 	return m_isCaretVisible ? m_engine->showCaret(this, Rect(m_caretPos, m_caretSize)) : true;
[-] WidgetDriver::updateScrollBars (uint_t mask)
[+] WidgetDriver::updateScrollBars(uint_t mask)
[-] 		result = updateScrollBar (Orientation_Vertical);
[+] 		result = updateScrollBar(Orientation_Vertical);
[-] 		result = updateScrollBar (Orientation_Horizontal) || result;
[+] 		result = updateScrollBar(Orientation_Horizontal) || result;
[-] WidgetDriver::postThreadMsg (
[+] WidgetDriver::postThreadMsg(
[-] 		return m_engine->postWidgetThreadMsg (this, code, ref::Ptr <void> ());
[+] 		return m_engine->postWidgetThreadMsg(this, code, ref::Ptr<void> ());
[-] 	ref::RefCount* refCount = AXL_REF_NEW_EXTRA (ref::RefCount, size);
[+] 	ref::RefCount* refCount = AXL_REF_NEW_EXTRA(ref::RefCount, size);
[-] 	ref::Ptr <void> params (refCount + 1, refCount);
[+] 	ref::Ptr<void> params(refCount + 1, refCount);
[-] 	memcpy (params, p, size);
[+] 	memcpy(params, p, size);
[-] 	return m_engine->postWidgetThreadMsg (this, code, params);
[+] 	return m_engine->postWidgetThreadMsg(this, code, params);
[-] WidgetDriver::processMsg (
[+] WidgetDriver::processMsg(
[-] 	ASSERT (msg->m_msgCode < WidgetMsgCode__Count);
[+] 	ASSERT(msg->m_msgCode < WidgetMsgCode__Count);
[-] 	Widget* widget = containerof (this, Widget, m_widgetDriver);
[+] 	Widget* widget = containerof(this, Widget, m_widgetDriver);
[-] 		m_msgMap = widget->getWidgetMsgMap ();
[+] 		m_msgMap = widget->getWidgetMsgMap();
[-] 		WidgetMsgProc proc = msgMap->m_msgProcTable [msg->m_msgCode];
[+] 		WidgetMsgProc proc = msgMap->m_msgProcTable[msg->m_msgCode];
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_ini\axl_ini_GenericParser.cpp
----------------------
[-] GenericParser::onSection (const sl::StringRef& sectionName)
[+] GenericParser::onSection(const sl::StringRef& sectionName)
[-] 	ASSERT (m_ini);
[+] 	ASSERT(m_ini);
[-] 	sl::StringHashTableIterator <Section*> it = m_ini->m_namedSectionMap.find (sectionName);
[+] 	sl::StringHashTableIterator<Section*> it = m_ini->m_namedSectionMap.find(sectionName);
[-] 	Section* section = AXL_MEM_NEW (Section);
[+] 	Section* section = AXL_MEM_NEW(Section);
[-] 	m_ini->m_namedSectionList.insertTail (section);
[+] 	m_ini->m_namedSectionList.insertTail(section);
[-] 	m_ini->m_namedSectionMap [section->m_name] = section;
[+] 	m_ini->m_namedSectionMap[section->m_name] = section;
[-] GenericParser::onKeyValue (
[+] GenericParser::onKeyValue(
[-] 	ASSERT (m_currentSection);
[+] 	ASSERT(m_currentSection);
[-] 	if (value.isEmpty ())
[+] 	if (value.isEmpty())
[-] 		m_currentSection->m_unnamedValueList.insertTail (keyName);
[+] 		m_currentSection->m_unnamedValueList.insertTail(keyName);
[-] 	sl::StringHashTableIterator <NamedValue*> it = m_currentSection->m_namedValueMap.find (keyName);
[+] 	sl::StringHashTableIterator<NamedValue*> it = m_currentSection->m_namedValueMap.find(keyName);
[-] 	NamedValue* namedValue = AXL_MEM_NEW (NamedValue);
[+] 	NamedValue* namedValue = AXL_MEM_NEW(NamedValue);
[-] 	m_currentSection->m_namedValueList.insertTail (namedValue);
[+] 	m_currentSection->m_namedValueList.insertTail(namedValue);
[-] 	m_currentSection->m_namedValueMap [namedValue->m_value] = namedValue;
[+] 	m_currentSection->m_namedValueMap[namedValue->m_value] = namedValue;
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_ini\axl_ini_Lexer.cpp
----------------------
[-] Lexer::create (
[+] Lexer::create(
[-] 	this->reset ();
[+] 	this->reset();
[-] 	init ();
[+] 	init();
[-] 	p   = (char*) source.cp ();
[+] 	p   = (char*)source.cp();
[-] 	eof = (char*) source.getEnd ();
[+] 	eof = (char*)source.getEnd();
[-] Lexer::parseSection (
[+] Lexer::parseSection(
[-] 	ASSERT (*p == '[' && end [-1] == ']');
[+] 	ASSERT(*p == '[' && end[-1] == ']');
[-] 	while (p < end && isspace (*p))
[+] 	while (p < end && isspace(*p))
[-] 	while (p < end && isspace (end [-1]))
[+] 	while (p < end && isspace(end[-1]))
[-] 		m_sectionName.copy (p, end - p);
[+] 		m_sectionName.copy(p, end - p);
[-] 	stop ();
[+] 	stop();
[-] Lexer::parseKeyValue (
[+] Lexer::parseKeyValue(
[-] 	ASSERT (!isspace (*p));
[+] 	ASSERT(!isspace(*p));
[-] 	while (p < end  && *p != '=' && !isspace (*p))
[+] 	while (p < end  && *p != '=' && !isspace(*p))
[-] 	m_keyName.copy (p0, p - p0);
[+] 	m_keyName.copy(p0, p - p0);
[-] 	while (p < end && isspace (*p))
[+] 	while (p < end && isspace(*p))
[-] 		while (p < end && isspace (*p))
[+] 		while (p < end && isspace(*p))
[-] 		while (p < end && isspace (end [-1]))
[+] 		while (p < end && isspace(end[-1]))
[-] 			m_value.copy (p, length);
[+] 			m_value.copy(p, length);
[-] 			if (m_value [0] == '"' && m_value [length - 1] == '"')
[+] 			if (m_value[0] == '"' && m_value [length - 1] == '"')
[-] 				m_value = enc::EscapeEncoding::decode (m_value.getSubString (1, length - 2));
[+] 				m_value = enc::EscapeEncoding::decode(m_value.getSubString(1, length - 2));
[-] 	stop ();
[+] 	stop();
[-] Lexer::scanLine ()
[+] Lexer::scanLine()
[-] 	m_sectionName.clear ();
[+] 	m_sectionName.clear();
[-] 	m_keyName.clear ();
[+] 	m_keyName.clear();
[-] 	m_value.clear ();
[+] 	m_value.clear();
[-] 	bool result = exec ();
[+] 	bool result = exec();
[-] 		err::setError ("invalid syntax");
[+] 		err::setError("invalid syntax");
[-] 		lex::pushSrcPosError (m_filePath, m_line, p - m_begin - m_lineOffset);
[+] 		lex::pushSrcPosError(m_filePath, m_line, p - m_begin - m_lineOffset);
[-] Lexer::reset ()
[+] Lexer::reset()
[-] 	m_filePath.clear ();
[+] 	m_filePath.clear();
[-] 	m_sectionName.clear ();
[+] 	m_sectionName.clear();
[-] 	m_keyName.clear ();
[+] 	m_keyName.clear();
[-] 	m_value.clear ();
[+] 	m_value.clear();
[-] Lexer::newLine (char* line)
[+] Lexer::newLine(char* line)
[-] 	ASSERT (line [-1] == '\n');
[+] 	ASSERT(line[-1] == '\n');
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_drw_SerialPortEnumerator.cpp
----------------------
[-] 	createPortList (sl::List <SerialPortDesc>* portList);
[+] 	createPortList(sl::List<SerialPortDesc>* portList);
[-] printDeviceProperties (const iok::RegistryEntry& device)
[+] printDeviceProperties(const iok::RegistryEntry& device)
[-] 	iok::RegistryEntry parent = device.getParentEntry ();
[+] 	iok::RegistryEntry parent = device.getParentEntry();
[-] 		indent = printDeviceProperties (parent);
[+] 		indent = printDeviceProperties(parent);
[-] 	cf::MutableDictionaryRef propDict = device.getAllProperties ();
[+] 	cf::MutableDictionaryRef propDict = device.getAllProperties();
[-] 	sl::Array <const void*> keyArray;
[+] 	sl::Array<const void*> keyArray;
[-] 	sl::Array <const void*> valueArray;
[+] 	sl::Array<const void*> valueArray;
[-] 	size_t count = propDict.getCount ();
[+] 	size_t count = propDict.getCount();
[-] 	propDict.getKeysAndValues (&keyArray, &valueArray);
[+] 	propDict.getKeysAndValues(&keyArray, &valueArray);
[-] 		printf ("\t");
[+] 		printf("\t");
[-] 	printf ("deviceName = %s\n", device.getName ().sz ());
[+] 	printf("deviceName = %s\n", device.getName ().sz ());
[-] 			printf ("\t");
[+] 			printf("\t");
[-] 		printf (
[+] 		printf(
[-] 			cf::TypeRef (keyArray [i]).toString ().sz (),
[+] 			cf::TypeRef(keyArray[i]).toString().sz(),
[-] 			cf::TypeRef (valueArray [i]).toString ().sz ()
[+] 			cf::TypeRef(valueArray[i]).toString().sz()
[-] 	printf ("\n");
[+] 	printf("\n");
[-] SerialPortEnumerator::createPortList (sl::List <SerialPortDesc>* portList)
[+] SerialPortEnumerator::createPortList(sl::List<SerialPortDesc>* portList)
[-] 	portList->clear ();
[+] 	portList->clear();
[-] 	cf::MutableDictionaryRef dict = iok::createServiceMatchingDictionary (kIOSerialBSDServiceValue);
[+] 	cf::MutableDictionaryRef dict = iok::createServiceMatchingDictionary(kIOSerialBSDServiceValue);
[-] 	dict.setValue (CFSTR (kIOSerialBSDTypeKey), CFSTR (kIOSerialBSDAllTypes));
[+] 	dict.setValue(CFSTR(kIOSerialBSDTypeKey), CFSTR(kIOSerialBSDAllTypes));
[-] 	iok::Iterator it = iok::findMatchingServices (dict);
[+] 	iok::Iterator it = iok::findMatchingServices(dict);
[-] 	iok::RegistryEntry port = it.next ().p ();
[+] 	iok::RegistryEntry port = it.next().p();
[-] 	for (; port; port = it.next ().p ())
[+] 	for (; port; port = it.next().p())
[-] 		printDeviceProperties (port);
[+] 		printDeviceProperties(port);
[-] 		cf::TypeRef prop = port.getProperty (kIOCalloutDeviceKey);
[+] 		cf::TypeRef prop = port.getProperty(kIOCalloutDeviceKey);
[-] 			prop = port.getProperty (kIODialinDeviceKey);
[+] 			prop = port.getProperty(kIODialinDeviceKey);
[-] 		name = prop.toString ();
[+] 		name = prop.toString();
[-] 		prop = port.getProperty (kIOTTYDeviceKey);
[+] 		prop = port.getProperty(kIOTTYDeviceKey);
[-] 		description = prop ? prop.toString () : port.getName ();
[+] 		description = prop ? prop.toString() : port.getName();
[-] 		SerialPortDesc* portDesc = AXL_MEM_NEW (SerialPortDesc);
[+] 		SerialPortDesc* portDesc = AXL_MEM_NEW(SerialPortDesc);
[-] 		portList->insertTail (portDesc);
[+] 		portList->insertTail(portDesc);
[-] 	return portList->getCount ();
[+] 	return portList->getCount();
[-] createSerialPortDescList (sl::List <SerialPortDesc>* portList)
[+] createSerialPortDescList(sl::List<SerialPortDesc>* portList)
[-] 	return SerialPortEnumerator::createPortList (portList);
[+] 	return SerialPortEnumerator::createPortList(portList);
----------------------
27/02/2019 18:01:49 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_File.cpp
----------------------
[-] File::open (
[+] File::open(
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String_w fileName_w (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String_w fileName_w(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	bool result = m_file.create (
[+] 	bool result = m_file.create(
[-] 		m_file.setSize (0);
[+] 		m_file.setSize(0);
[-] File::open (
[+] File::open(
[-] 	bool result = m_file.open (fileName.sz (), posixFlags);
[+] 	bool result = m_file.open(fileName.sz(), posixFlags);
[-] 		::unlink (fileName.sz ());
[+] 		::unlink(fileName.sz());
[-] 		m_file.setSize (0);
[+] 		m_file.setSize(0);
[-] copyFile (
[+] copyFile(
[-] 	bool result = srcFile.open (srcFileName, FileFlag_ReadOnly);
[+] 	bool result = srcFile.open(srcFileName, FileFlag_ReadOnly);
[-] 	return copyFile (&srcFile, dstFileName, size);
[+] 	return copyFile(&srcFile, dstFileName, size);
[-] copyFile (
[+] copyFile(
[-] 	bool result = dstFile.open (dstFileName);
[+] 	bool result = dstFile.open(dstFileName);
[-] 	return copyFile (srcFile, &dstFile, size);
[+] 	return copyFile(srcFile, &dstFile, size);
[-] copyFile (
[+] copyFile(
[-] 	const g::SystemInfo* systemInfo = g::getModule ()->getSystemInfo ();
[+] 	const g::SystemInfo* systemInfo = g::getModule()->getSystemInfo();
[-] 		size = srcFile->getSize ();
[+] 		size = srcFile->getSize();
[-] 	result = dstFile->setSize (size);
[+] 	result = dstFile->setSize(size);
[-] 		srcMapping.create (srcFile->m_file, NULL, PAGE_READONLY, size) &&
[+] 		srcMapping.create(srcFile->m_file, NULL, PAGE_READONLY, size) &&
[-] 		dstMapping.create (dstFile->m_file, NULL, PAGE_READWRITE, size);
[+] 		dstMapping.create(dstFile->m_file, NULL, PAGE_READWRITE, size);
[-] 			blockSize = (size_t) size;
[+] 			blockSize = (size_t)size;
[-] 		const void* src = srcView.view (srcMapping, FILE_MAP_READ, offset, blockSize);
[+] 		const void* src = srcView.view(srcMapping, FILE_MAP_READ, offset, blockSize);
[-] 		void* dst = dstView.view (dstMapping, FILE_MAP_READ | FILE_MAP_WRITE, offset, blockSize);
[+] 		void* dst = dstView.view(dstMapping, FILE_MAP_READ | FILE_MAP_WRITE, offset, blockSize);
[-] 		memcpy (dst, src, blockSize);
[+] 		memcpy(dst, src, blockSize);
[-] 	srcMapping.close ();
[+] 	srcMapping.close();
[-] 	dstMapping.close ();
[+] 	dstMapping.close();
[-] 	srcView.close ();
[+] 	srcView.close();
[-] 	dstView.close ();
[+] 	dstView.close();
[-] 			blockSize = (size_t) size;
[+] 			blockSize = (size_t)size;
[-] 		const void* src = srcMapping.map (NULL, blockSize, PROT_READ, MAP_SHARED, srcFile->m_file, offset);
[+] 		const void* src = srcMapping.map(NULL, blockSize, PROT_READ, MAP_SHARED, srcFile->m_file, offset);
[-] 		void* dst = dstMapping.map (NULL, blockSize, PROT_READ | PROT_WRITE, MAP_SHARED, dstFile->m_file, offset);
[+] 		void* dst = dstMapping.map(NULL, blockSize, PROT_READ | PROT_WRITE, MAP_SHARED, dstFile->m_file, offset);
[-] 		memcpy (dst, src, blockSize);
[+] 		memcpy(dst, src, blockSize);
[-] 	srcMapping.close ();
[+] 	srcMapping.close();
[-] 	dstMapping.close ();
[+] 	dstMapping.close();
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_FileEnumerator.cpp
----------------------
[-] FileEnumerator::openDir (const sl::StringRef& dir)
[+] FileEnumerator::openDir(const sl::StringRef& dir)
[-] 	close ();
[+] 	close();
[-] 	m_nextFileName.clear ();
[+] 	m_nextFileName.clear();
[-] 	fileName.append (L"\\*.*");
[+] 	fileName.append(L"\\*.*");
[-] 	m_h = ::FindFirstFileW (fileName, &findData);
[+] 	m_h = ::FindFirstFileW(fileName, &findData);
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] FileEnumerator::getNextFileName ()
[+] FileEnumerator::getNextFileName()
[-] 	if (!isOpen ())
[+] 	if (!isOpen())
[-] 		return sl::String ();
[+] 		return sl::String();
[-] 	bool_t result = ::FindNextFileW (m_h, &findData);
[+] 	bool_t result = ::FindNextFileW(m_h, &findData);
[-] 		m_nextFileName.clear ();
[+] 		m_nextFileName.clear();
[-] FileEnumerator::openDir (const sl::StringRef& dir)
[+] FileEnumerator::openDir(const sl::StringRef& dir)
[-] 	close ();
[+] 	close();
[-] 	m_nextFileName.clear ();
[+] 	m_nextFileName.clear();
[-] 	m_h = ::opendir (dir.sz ());
[+] 	m_h = ::opendir(dir.sz());
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] 	int result = readdir_r (m_h, &dirEntry, &dirEntryPtr);
[+] 	int result = readdir_r(m_h, &dirEntry, &dirEntryPtr);
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] FileEnumerator::getNextFileName ()
[+] FileEnumerator::getNextFileName()
[-] 	if (!isOpen ())
[+] 	if (!isOpen())
[-] 		return sl::String ();
[+] 		return sl::String();
[-] 	int result = readdir_r (m_h, &dirEntry, &dirEntryPtr);
[+] 	int result = readdir_r(m_h, &dirEntry, &dirEntryPtr);
[-] 		m_nextFileName.clear ();
[+] 		m_nextFileName.clear();
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_FilePathUtils.cpp
----------------------
[-] get_current_dir_name ()
[+] get_current_dir_name()
[-] 		char* buffer = (char*) ::malloc (size);
[+] 		char* buffer = (char*) ::malloc(size);
[-] 		char* result = ::getcwd (buffer, size);
[+] 		char* result = ::getcwd(buffer, size);
[-] 		::free (buffer);
[+] 		::free(buffer);
[-] getTempDir ()
[+] getTempDir()
[-] 	wchar_t dir [1024] = { 0 };
[+] 	wchar_t dir[1024] = { 0 };
[-] 	::GetTempPathW (countof (dir) - 1, dir);
[+] 	::GetTempPathW(countof(dir) - 1, dir);
[-] getCurrentDir ()
[+] getCurrentDir()
[-] 	wchar_t dir [1024] = { 0 };
[+] 	wchar_t dir[1024] = { 0 };
[-] 	::GetCurrentDirectoryW (countof (dir) - 1, dir);
[+] 	::GetCurrentDirectoryW(countof(dir) - 1, dir);
[-] 	char* p = ::get_current_dir_name ();
[+] 	char* p = ::get_current_dir_name();
[-] 	::free (p);
[+] 	::free(p);
[-] setCurrentDir (const sl::StringRef& dir)
[+] setCurrentDir(const sl::StringRef& dir)
[-] 	bool_t result = ::SetCurrentDirectoryW (dir.s2 ().sz ());
[+] 	bool_t result = ::SetCurrentDirectoryW(dir.s2().sz());
[-] 	return err::complete (result);
[+] 	return err::complete(result);
[-] 	int result = ::chdir (dir.sz ());
[+] 	int result = ::chdir(dir.sz());
[-] 	return err::complete (result == 0);
[+] 	return err::complete(result == 0);
[-] getExeFilePath ()
[+] getExeFilePath()
[-] 	char buffer [1024] = { 0 };
[+] 	char buffer[1024] = { 0 };
[-] 	::GetModuleFileNameA (::GetModuleHandle (NULL), buffer, countof (buffer) - 1);
[+] 	::GetModuleFileNameA(::GetModuleHandle(NULL), buffer, countof(buffer) - 1);
[-] 	::readlink ("/proc/self/exe", buffer, countof (buffer) - 1);
[+] 	::readlink("/proc/self/exe", buffer, countof (buffer) - 1);
[-] 	uint32_t size = sizeof (buffer);
[+] 	uint32_t size = sizeof(buffer);
[-] 	_NSGetExecutablePath (buffer, &size);
[+] 	_NSGetExecutablePath(buffer, &size);
[-] getExeDir ()
[+] getExeDir()
[-] 	return io::getDir (io::getExeFilePath ());
[+] 	return io::getDir(io::getExeFilePath());
[-] doesFileExist (const sl::StringRef& fileName)
[+] doesFileExist(const sl::StringRef& fileName)
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String_w fileName_w (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String_w fileName_w(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	dword_t attributes = ::GetFileAttributesW (fileName_w);
[+] 	dword_t attributes = ::GetFileAttributesW(fileName_w);
[-] 	return ::access (fileName.sz (), F_OK) != -1;
[+] 	return ::access(fileName.sz(), F_OK) != -1;
[-] isDir (const sl::StringRef_w& fileName)
[+] isDir(const sl::StringRef_w& fileName)
[-] 	dword_t attributes = ::GetFileAttributesW (fileName.sz ());
[+] 	dword_t attributes = ::GetFileAttributesW(fileName.sz());
[-] isDir (const sl::StringRef& fileName)
[+] isDir(const sl::StringRef& fileName)
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String_w fileName_w (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String_w fileName_w(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	return isDir (fileName_w);
[+] 	return isDir(fileName_w);
[-] ensureDirExists (const sl::StringRef& fileName)
[+] ensureDirExists(const sl::StringRef& fileName)
[-] 	char buffer [256] = { 0 };
[+] 	char buffer[256] = { 0 };
[-] 	sl::String_w fileName_w (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String_w fileName_w(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	if (fileName_w.isEmpty () || isDir (fileName_w))
[+] 	if (fileName_w.isEmpty() || isDir(fileName_w))
[-] 	wchar_t* p = fileName_w.getBuffer ();
[+] 	wchar_t* p = fileName_w.getBuffer();
[-] 	if (p [1] == ':')
[+] 	if (p[1] == ':')
[-] 		*(wchar_t*) p2 = 0;
[+] 		*(wchar_t*)p2 = 0;
[-] 		if (!isDir (fileName_w))
[+] 		if (!isDir(fileName_w))
[-] 			bool_t result = ::CreateDirectoryW (fileName_w, NULL);
[+] 			bool_t result = ::CreateDirectoryW(fileName_w, NULL);
[-] 				return err::failWithLastSystemError ();
[+] 				return err::failWithLastSystemError();
[-] isDir (const sl::StringRef& fileName)
[+] isDir(const sl::StringRef& fileName)
[-] 	int result = ::stat (fileName.sz (), &st);
[+] 	int result = ::stat(fileName.sz(), &st);
[-] 	return result == 0 && S_ISDIR (st.st_mode);
[+] 	return result == 0 && S_ISDIR(st.st_mode);
[-] ensureDirExists (const sl::StringRef& fileName0)
[+] ensureDirExists(const sl::StringRef& fileName0)
[-] 	if (fileName0.isEmpty() || isDir (fileName0))
[+] 	if (fileName0.isEmpty() || isDir(fileName0))
[-] 	char* p = fileName.getBuffer (); // ensure exclusive buffer (we're going to modify it)
[+] 	char* p = fileName.getBuffer(); // ensure exclusive buffer (we're going to modify it)
[-] 		if (!isDir (fileName))
[+] 		if (!isDir(fileName))
[-] 			int result = ::mkdir (fileName, S_IRWXU);
[+] 			int result = ::mkdir(fileName, S_IRWXU);
[-] 				return err::failWithLastSystemError ();
[+] 				return err::failWithLastSystemError();
[-] getFullFilePath (const sl::StringRef& fileName)
[+] getFullFilePath(const sl::StringRef& fileName)
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String_w fileName_w (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String_w fileName_w(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	size_t bufferLength = ::GetFullPathNameW (fileName_w, 0, NULL, NULL);
[+] 	size_t bufferLength = ::GetFullPathNameW(fileName_w, 0, NULL, NULL);
[-] 		return err::failWithLastSystemError (NULL);
[+] 		return err::failWithLastSystemError(NULL);
[-] 		wchar_t* p = filePath.createBuffer (bufferLength);
[+] 		wchar_t* p = filePath.createBuffer(bufferLength);
[-] 		size_t actualLength = ::GetFullPathNameW (fileName_w, bufferLength, p, NULL);
[+] 		size_t actualLength = ::GetFullPathNameW(fileName_w, bufferLength, p, NULL);
[-] 		ASSERT (actualLength != bufferLength); // on success, it should be bufferLength - 1
[+] 		ASSERT(actualLength != bufferLength); // on success, it should be bufferLength - 1
[-] 			return err::failWithLastSystemError (NULL);
[+] 			return err::failWithLastSystemError(NULL);
[-] 			return sl::String (filePath, actualLength);
[+] 			return sl::String(filePath, actualLength);
[-] 	char fullPath [PATH_MAX] = { 0 };
[+] 	char fullPath[PATH_MAX] = { 0 };
[-] 	::realpath (fileName.sz (), fullPath);
[+] 	::realpath(fileName.sz(), fullPath);
[-] getDir (const sl::StringRef& filePath)
[+] getDir(const sl::StringRef& filePath)
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String_w filePath_w (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String_w filePath_w(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	wchar_t drive [4] = { 0 };
[+] 	wchar_t drive[4] = { 0 };
[-] 	wchar_t dir [1024] = { 0 };
[+] 	wchar_t dir[1024] = { 0 };
[-] 	_wsplitpath_s (
[+] 	_wsplitpath_s(
[-] 		drive, countof (drive) - 1,
[+] 		drive, countof(drive) - 1,
[-] 		dir, countof (dir) - 1,
[+] 		dir, countof(dir) - 1,
[-] 	string.append (dir);
[+] 	string.append(dir);
[-] 	size_t i = filePath.reverseFind ('/');
[+] 	size_t i = filePath.reverseFind('/');
[-] 	return i != -1 ? filePath.getLeftSubString (i + 1) : NULL;
[+] 	return i != -1 ? filePath.getLeftSubString(i + 1) : NULL;
[-] getFileName (const sl::StringRef& filePath)
[+] getFileName(const sl::StringRef& filePath)
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String_w filePath_w (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String_w filePath_w(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	wchar_t fileName [1024] = { 0 };
[+] 	wchar_t fileName[1024] = { 0 };
[-] 	wchar_t extension [1024] = { 0 };
[+] 	wchar_t extension[1024] = { 0 };
[-] 	_wsplitpath_s (
[+] 	_wsplitpath_s(
[-] 		fileName, countof (fileName) - 1,
[+] 		fileName, countof(fileName) - 1,
[-] 		extension, countof (extension) - 1
[+] 		extension, countof(extension) - 1
[-] 	string.append (extension);
[+] 	string.append(extension);
[-] 	size_t i = filePath.reverseFind ('/');
[+] 	size_t i = filePath.reverseFind('/');
[-] 	return i != -1 ? filePath.getSubString (i + 1) : filePath;
[+] 	return i != -1 ? filePath.getSubString(i + 1) : filePath;
[-] getExtension (const sl::StringRef& filePath)
[+] getExtension(const sl::StringRef& filePath)
[-] 	size_t i = filePath.find ('.');
[+] 	size_t i = filePath.find('.');
[-] 	return i != -1 ? filePath.getSubString (i) : NULL;
[+] 	return i != -1 ? filePath.getSubString(i) : NULL;
[-] concatFilePath (
[+] concatFilePath(
[-] 	if (filePath->isEmpty ())
[+] 	if (filePath->isEmpty())
[-] 	char last = (*filePath) [filePath->getLength () - 1];
[+] 	char last = (*filePath) [filePath->getLength() - 1];
[-] 		filePath->append ('\\');
[+] 		filePath->append('\\');
[-] 		filePath->append ('/');
[+] 		filePath->append('/');
[-] 	filePath->append (fileName);
[+] 	filePath->append(fileName);
[-] findFilePath (
[+] findFilePath(
[-] 	const sl::BoxList <sl::String>* dirList,
[+] 	const sl::BoxList<sl::String>* dirList,
[-] 	if (!firstDir.isEmpty ())
[+] 	if (!firstDir.isEmpty())
[-] 		filePath = concatFilePath (firstDir, fileName);
[+] 		filePath = concatFilePath(firstDir, fileName);
[-] 		if (doesFileExist (filePath))
[+] 		if (doesFileExist(filePath))
[-] 			return getFullFilePath (filePath);
[+] 			return getFullFilePath(filePath);
[-] 		if (doesFileExist (fileName))
[+] 		if (doesFileExist(fileName))
[-] 			return getFullFilePath (fileName);
[+] 			return getFullFilePath(fileName);
[-] 		sl::ConstBoxIterator <sl::String> dir = dirList->getHead ();
[+] 		sl::ConstBoxIterator<sl::String> dir = dirList->getHead();
[-] 			filePath.forceCopy (*dir);
[+] 			filePath.forceCopy(*dir);
[-] 			concatFilePath (&filePath, fileName);
[+] 			concatFilePath(&filePath, fileName);
[-] 			if (doesFileExist (filePath))
[+] 			if (doesFileExist(filePath))
[-] 				return getFullFilePath (filePath);
[+] 				return getFullFilePath(filePath);
[-] 	return sl::String ();
[+] 	return sl::String();
[-] getSymbolicLinkTarget (
[+] getSymbolicLinkTarget(
[-] 	uniLinkName.Buffer = linkName_w.p ();
[+] 	uniLinkName.Buffer = linkName_w.p();
[-] 	uniLinkName.Length = linkName_w.getLength () * sizeof (WCHAR);
[+] 	uniLinkName.Length = linkName_w.getLength() * sizeof(WCHAR);
[-] 	uniLinkName.MaximumLength = linkName_w.getHdr ()->m_bufferSize;
[+] 	uniLinkName.MaximumLength = linkName_w.getHdr()->m_bufferSize;
[-] 	oa.Length = sizeof (oa);
[+] 	oa.Length = sizeof(oa);
[-] 	status = ntOpenSymbolicLinkObject (
[+] 	status = ntOpenSymbolicLinkObject(
[-] 		link.p (),
[+] 		link.p(),
[-] 		err::setError (sys::win::NtStatus (status));
[+] 		err::setError(sys::win::NtStatus(status));
[-] 	status = ntQuerySymbolicLinkObject (link, &uniTarget, &bufferSize);
[+] 	status = ntQuerySymbolicLinkObject(link, &uniTarget, &bufferSize);
[-] 		err::setError (sys::win::NtStatus (status));
[+] 		err::setError(sys::win::NtStatus(status));
[-] 	wchar_t* p = targetName_w.createBuffer (bufferSize / sizeof (WCHAR));
[+] 	wchar_t* p = targetName_w.createBuffer(bufferSize / sizeof(WCHAR));
[-] 	uniTarget.MaximumLength = (USHORT) bufferSize;
[+] 	uniTarget.MaximumLength = (USHORT)bufferSize;
[-] 	status = ntQuerySymbolicLinkObject (link, &uniTarget, &bufferSize);
[+] 	status = ntQuerySymbolicLinkObject(link, &uniTarget, &bufferSize);
[-] 		err::setError (sys::win::NtStatus (status));
[+] 		err::setError(sys::win::NtStatus(status));
[-] 	ASSERT (uniTarget.Length <= uniTarget.MaximumLength);
[+] 	ASSERT(uniTarget.Length <= uniTarget.MaximumLength);
[-] 	targetName_w.setReducedLength (uniTarget.Length / sizeof (WCHAR));
[+] 	targetName_w.setReducedLength(uniTarget.Length / sizeof(WCHAR));
[-] getSymbolicLinkTarget (
[+] getSymbolicLinkTarget(
[-] 	int result = ::lstat (linkName.sz (), &linkStat);
[+] 	int result = ::lstat(linkName.sz(), &linkStat);
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] 	if (!S_ISLNK (linkStat.st_mode))
[+] 	if (!S_ISLNK(linkStat.st_mode))
[-] 		return err::fail (EINVAL);
[+] 		return err::fail(EINVAL);
[-] 	char* p = targetName->createBuffer (bufferLength);
[+] 	char* p = targetName->createBuffer(bufferLength);
[-] 	result = readlink (linkName.sz (), p, bufferLength);
[+] 	result = readlink(linkName.sz(), p, bufferLength);
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] 	ASSERT (result <= bufferLength);
[+] 	ASSERT(result <= bufferLength);
[-] 	targetName->setReducedLength (result);
[+] 	targetName->setReducedLength(result);
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_lnx_SerialPortEnumerator.cpp
----------------------
[-] 	createPortList (sl::List <SerialPortDesc>* portList);
[+] 	createPortList(sl::List<SerialPortDesc>* portList);
[-] SerialPortEnumerator::createPortList (sl::List <SerialPortDesc>* portList)
[+] SerialPortEnumerator::createPortList(sl::List<SerialPortDesc>* portList)
[-] 	portList->clear ();
[+] 	portList->clear();
[-] 	sys::lnx::UdevEnumerator enumerator = udev.createEnumerator ();
[+] 	sys::lnx::UdevEnumerator enumerator = udev.createEnumerator();
[-] 		enumerator.addMatchSubsystem ("tty") &&
[+] 		enumerator.addMatchSubsystem("tty") &&
[-] 		enumerator.scanDevices ();
[+] 		enumerator.scanDevices();
[-] 	sys::lnx::UdevListEntry it = enumerator.getListEntry ();
[+] 	sys::lnx::UdevListEntry it = enumerator.getListEntry();
[-] 		sl::StringRef path = it.getName ();
[+] 		sl::StringRef path = it.getName();
[-] 		sys::lnx::UdevDevice device = udev.getDeviceFromSysPath (path);
[+] 		sys::lnx::UdevDevice device = udev.getDeviceFromSysPath(path);
[-] 		sys::lnx::UdevDevice parentDevice = device.getParent ();
[+] 		sys::lnx::UdevDevice parentDevice = device.getParent();
[-] 		parentDevice.addRef (); // getParent does not add ref
[+] 		parentDevice.addRef(); // getParent does not add ref
[-] 		sl::StringRef name = device.getDevNode ();
[+] 		sl::StringRef name = device.getDevNode();
[-] 		sl::StringRef driver = parentDevice.getDriver ();
[+] 		sl::StringRef driver = parentDevice.getDriver();
[-] 				file.open (name, O_RDWR | O_NONBLOCK | O_NOCTTY) &&
[+] 				file.open(name, O_RDWR | O_NONBLOCK | O_NOCTTY) &&
[-] 				file.ioctl (TIOCGSERIAL, &serialInfo);
[+] 				file.ioctl(TIOCGSERIAL, &serialInfo);
[-] 		sl::StringRef description = device.getPropertyValue ("ID_MODEL_FROM_DATABASE");
[+] 		sl::StringRef description = device.getPropertyValue("ID_MODEL_FROM_DATABASE");
[-] 		if (description.isEmpty ())
[+] 		if (description.isEmpty())
[-] 			description = device.getPropertyValue ("ID_MODEL");
[+] 			description = device.getPropertyValue("ID_MODEL");
[-] 		if (description.isEmpty ())
[+] 		if (description.isEmpty())
[-] 		SerialPortDesc* portDesc = AXL_MEM_NEW (SerialPortDesc);
[+] 		SerialPortDesc* portDesc = AXL_MEM_NEW(SerialPortDesc);
[-] 		portList->insertTail (portDesc);
[+] 		portList->insertTail(portDesc);
[-] 	static const char* deviceNameTable [] [2] =
[+] 	static const char* deviceNameTable[] [2] =
[-] 	for (size_t i = 0; i < countof (deviceNameTable); i++)
[+] 	for (size_t i = 0; i < countof(deviceNameTable); i++)
[-] 		SerialPortDesc* portDesc = AXL_MEM_NEW (SerialPortDesc);
[+] 		SerialPortDesc* portDesc = AXL_MEM_NEW(SerialPortDesc);
[-] 		portDesc->m_deviceName = deviceNameTable [i] [0];
[+] 		portDesc->m_deviceName = deviceNameTable[i] [0];
[-] 		portDesc->m_description = deviceNameTable [i] [1];
[+] 		portDesc->m_description = deviceNameTable[i] [1];
[-] 		portList->insertTail (portDesc);
[+] 		portList->insertTail(portDesc);
[-] 	return portList->getCount ();
[+] 	return portList->getCount();
[-] createSerialPortDescList (sl::List <SerialPortDesc>* portList)
[+] createSerialPortDescList(sl::List<SerialPortDesc>* portList)
[-] 	return SerialPortEnumerator::createPortList (portList);
[+] 	return SerialPortEnumerator::createPortList(portList);
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_MappedFile.cpp
----------------------
[-] MappedViewMgr::find (
[+] MappedViewMgr::find(
[-] 	ViewEntry* viewEntry = *m_viewList.getHead ();
[+] 	ViewEntry* viewEntry = *m_viewList.getHead();
[-] 		return (char*) (void*) viewEntry->m_view + begin - viewEntry->m_begin;
[+] 		return (char*)(void*)viewEntry->m_view + begin - viewEntry->m_begin;
[-] 	ViewMap::Iterator it = m_viewMap.find (begin, sl::BinTreeFindRelOp_Le);
[+] 	ViewMap::Iterator it = m_viewMap.find(begin, sl::BinTreeFindRelOp_Le);
[-] 	m_viewList.moveToHead (viewEntry);
[+] 	m_viewList.moveToHead(viewEntry);
[-] 	return (char*) (void*) viewEntry->m_view + begin - viewEntry->m_begin;
[+] 	return (char*)(void*)viewEntry->m_view + begin - viewEntry->m_begin;
[-] MappedViewMgr::view (
[+] MappedViewMgr::view(
[-] 	ViewEntry* viewEntry = AXL_MEM_NEW (ViewEntry);
[+] 	ViewEntry* viewEntry = AXL_MEM_NEW(ViewEntry);
[-] 	MappedFile* mappedFile = getMappedFile ();
[+] 	MappedFile* mappedFile = getMappedFile();
[-] 	size_t size = (size_t) (end - begin);
[+] 	size_t size = (size_t)(end - begin);
[-] 	p = viewEntry->m_view.view (mappedFile->m_mapping, access, begin, size);
[+] 	p = viewEntry->m_view.view(mappedFile->m_mapping, access, begin, size);
[-] 	p = viewEntry->m_view.map (
[+] 	p = viewEntry->m_view.map(
[-] 		AXL_MEM_DELETE (viewEntry);
[+] 		AXL_MEM_DELETE(viewEntry);
[-] 	m_viewList.insertHead (viewEntry);
[+] 	m_viewList.insertHead(viewEntry);
[-] 	ViewMap::Iterator it = m_viewMap.visit (begin);
[+] 	ViewMap::Iterator it = m_viewMap.visit(begin);
[-] 		ASSERT (oldViewEntry->m_mapIt == it);
[+] 		ASSERT(oldViewEntry->m_mapIt == it);
[-] 		ASSERT (oldViewEntry->m_end < end); // otherwise, we should have just used this view!
[+] 		ASSERT(oldViewEntry->m_end < end); // otherwise, we should have just used this view!
[-] 		ASSERT (oldViewEntry->m_mapIt == it);
[+] 		ASSERT(oldViewEntry->m_mapIt == it);
[-] 		ViewMap::Iterator next = it.getInc (1);
[+] 		ViewMap::Iterator next = it.getInc(1);
[-] 		m_viewMap.erase (it);
[+] 		m_viewMap.erase(it);
[-] MappedViewMgr::limitViewCount (size_t maxViewCount)
[+] MappedViewMgr::limitViewCount(size_t maxViewCount)
[-] 	while (m_viewList.getCount () > maxViewCount)
[+] 	while (m_viewList.getCount() > maxViewCount)
[-] 		ViewEntry* view = m_viewList.removeTail ();
[+] 		ViewEntry* view = m_viewList.removeTail();
[-] 			m_viewMap.erase (view->m_mapIt);
[+] 			m_viewMap.erase(view->m_mapIt);
[-] 		AXL_MEM_DELETE (view);
[+] 		AXL_MEM_DELETE(view);
[-] MappedFile::MappedFile ():
[+] MappedFile::MappedFile():
[-] 	m_dynamicViewMgr (offsetof (MappedFile, m_dynamicViewMgr)),
[+] 	m_dynamicViewMgr(offsetof(MappedFile, m_dynamicViewMgr)),
[-] 	m_permanentViewMgr (offsetof (MappedFile, m_permanentViewMgr))
[+] 	m_permanentViewMgr(offsetof(MappedFile, m_permanentViewMgr))
[-] MappedFile::close ()
[+] MappedFile::close()
[-] 	if (!isOpen ())
[+] 	if (!isOpen())
[-] 	unmapAllViews ();
[+] 	unmapAllViews();
[-] 	m_file.close ();
[+] 	m_file.close();
[-] MappedFile::open (
[+] MappedFile::open(
[-] 	close ();
[+] 	close();
[-] 	bool result = m_file.open (fileName, flags);
[+] 	bool result = m_file.open(fileName, flags);
[-] MappedFile::duplicate (
[+] MappedFile::duplicate(
[-] 	close ();
[+] 	close();
[-] 	bool result = m_file.duplicate (fileHandle);
[+] 	bool result = m_file.duplicate(fileHandle);
[-] MappedFile::attach (
[+] MappedFile::attach(
[-] 	close ();
[+] 	close();
[-] 	m_file.m_file.attach (fileHandle);
[+] 	m_file.m_file.attach(fileHandle);
[-] MappedFile::detach ()
[+] MappedFile::detach()
[-] 	if (!isOpen ())
[+] 	if (!isOpen())
[-] 		return File::getInvalidHandle ();
[+] 		return File::getInvalidHandle();
[-] 	unmapAllViews ();
[+] 	unmapAllViews();
[-] 	return m_file.m_file.detach ();
[+] 	return m_file.m_file.detach();
[-] MappedFile::setSize (uint64_t size)
[+] MappedFile::setSize(uint64_t size)
[-] 	if (!m_permanentViewMgr.isEmpty () ||
[+] 	if (!m_permanentViewMgr.isEmpty() ||
[-] 		!m_dynamicViewMgr.isEmpty ())
[+] 		!m_dynamicViewMgr.isEmpty())
[-] 		err::setError (err::SystemErrorCode_InvalidDeviceState);
[+] 		err::setError(err::SystemErrorCode_InvalidDeviceState);
[-] 	return m_file.setSize (size);
[+] 	return m_file.setSize(size);
[-] MappedFile::setup (
[+] MappedFile::setup(
[-] 		return err::fail (err::SystemErrorCode_InvalidParameter);
[+] 		return err::fail(err::SystemErrorCode_InvalidParameter);
[-] 	m_dynamicViewMgr.limitViewCount (maxDynamicViewCount);
[+] 	m_dynamicViewMgr.limitViewCount(maxDynamicViewCount);
[-] MappedFile::view (
[+] MappedFile::view(
[-] 	uint64_t end = size ? offset + size : m_file.getSize ();
[+] 	uint64_t end = size ? offset + size : m_file.getSize();
[-] 	void* p = viewImpl (offset, end, &actualEnd, isPermanent);
[+] 	void* p = viewImpl(offset, end, &actualEnd, isPermanent);
[-] 		*actualSize = (size_t) (actualEnd - offset);
[+] 		*actualSize = (size_t)(actualEnd - offset);
[-] MappedFile::viewImpl (
[+] MappedFile::viewImpl(
[-] 	if (!isOpen ())
[+] 	if (!isOpen())
[-] 	void* p = m_permanentViewMgr.find (offset, end, actualEnd);
[+] 	void* p = m_permanentViewMgr.find(offset, end, actualEnd);
[-] 		p = m_dynamicViewMgr.find (offset, end, actualEnd);
[+] 		p = m_dynamicViewMgr.find(offset, end, actualEnd);
[-] 	const g::SystemInfo* systemInfo = g::getModule ()->getSystemInfo ();
[+] 	const g::SystemInfo* systemInfo = g::getModule()->getSystemInfo();
[-] 	ASSERT (sl::isPowerOf2 (systemInfo->m_mappingAlignFactor));
[+] 	ASSERT(sl::isPowerOf2(systemInfo->m_mappingAlignFactor));
[-] 	uint64_t viewEnd = sl::align (end + m_readAheadSize, systemInfo->m_pageSize);
[+] 	uint64_t viewEnd = sl::align(end + m_readAheadSize, systemInfo->m_pageSize);
[-] 		uint64_t fileSize = m_file.getSize ();
[+] 		uint64_t fileSize = m_file.getSize();
[-] 			err::setError (err::SystemErrorCode_InvalidDeviceRequest);
[+] 			err::setError(err::SystemErrorCode_InvalidDeviceRequest);
[-] 	if (!m_mapping.isOpen () || viewEnd > m_mappingSize)
[+] 	if (!m_mapping.isOpen() || viewEnd > m_mappingSize)
[-] 		result = m_mapping.create (m_file.m_file, NULL, protection, viewEnd);
[+] 		result = m_mapping.create(m_file.m_file, NULL, protection, viewEnd);
[-] 	if (viewEnd > m_file.getSize ())
[+] 	if (viewEnd > m_file.getSize())
[-] 		result = m_file.setSize (viewEnd);
[+] 		result = m_file.setSize(viewEnd);
[-] 		p = m_permanentViewMgr.view (viewBegin, viewEnd, offset, end);
[+] 		p = m_permanentViewMgr.view(viewBegin, viewEnd, offset, end);
[-] 		p = m_dynamicViewMgr.view (viewBegin, viewEnd, offset, end);
[+] 		p = m_dynamicViewMgr.view(viewBegin, viewEnd, offset, end);
[-] 		m_dynamicViewMgr.limitViewCount (m_maxDynamicViewCount);
[+] 		m_dynamicViewMgr.limitViewCount(m_maxDynamicViewCount);
[-] 	return (uchar_t*) p + offset - viewBegin;
[+] 	return (uchar_t*)p + offset - viewBegin;
[-] MappedFile::unmapAllViews ()
[+] MappedFile::unmapAllViews()
[-] 	m_permanentViewMgr.clear ();
[+] 	m_permanentViewMgr.clear();
[-] 	m_dynamicViewMgr.clear ();
[+] 	m_dynamicViewMgr.clear();
[-] 	m_mapping.close ();
[+] 	m_mapping.close();
[-] SimpleMappedFile::open (
[+] SimpleMappedFile::open(
[-] 	close ();
[+] 	close();
[-] 	result = m_file.open (fileName, flags);
[+] 	result = m_file.open(fileName, flags);
[-] 	return !size || m_mapping.open (&m_file, offset, size, flags);
[+] 	return !size || m_mapping.open(&m_file, offset, size, flags);
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_Mapping.cpp
----------------------
[-] Mapping::open (
[+] Mapping::open(
[-] 	close ();
[+] 	close();
[-] 		size = (size_t) (file->getSize () - offset);
[+] 		size = (size_t)(file->getSize() - offset);
[-] 	const g::SystemInfo* systemInfo = g::getModule ()->getSystemInfo ();
[+] 	const g::SystemInfo* systemInfo = g::getModule()->getSystemInfo();
[-] 	bool result = m_mapping.create (file->m_file, NULL, protection, viewEnd);
[+] 	bool result = m_mapping.create(file->m_file, NULL, protection, viewEnd);
[-] 	p = m_view.view (m_mapping, access, viewBegin, (size_t) (viewEnd - viewBegin));
[+] 	p = m_view.view(m_mapping, access, viewBegin, (size_t)(viewEnd - viewBegin));
[-] 		m_mapping.close ();
[+] 		m_mapping.close();
[-] 	p = m_mapping.map (NULL, viewEnd - viewBegin, protection, MAP_SHARED, file->m_file, viewBegin);
[+] 	p = m_mapping.map(NULL, viewEnd - viewBegin, protection, MAP_SHARED, file->m_file, viewBegin);
[-] 	m_p = (char*) p + offset - viewBegin;
[+] 	m_p = (char*)p + offset - viewBegin;
[-] Mapping::open (
[+] Mapping::open(
[-] 	ASSERT (size != -1);
[+] 	ASSERT(size != -1);
[-] 	close ();
[+] 	close();
[-] 		m_mapping.open (access, false, name_w):
[+] 		m_mapping.open(access, false, name_w):
[-] 		m_mapping.create (INVALID_HANDLE_VALUE, NULL, protection, size, name_w);
[+] 		m_mapping.create(INVALID_HANDLE_VALUE, NULL, protection, size, name_w);
[-] 	p = m_view.view (m_mapping, access, 0, size);
[+] 	p = m_view.view(m_mapping, access, 0, size);
[-] 		m_mapping.close ();
[+] 		m_mapping.close();
[-] 	bool result = m_sharedMemory.open (name, shmFlags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
[+] 	bool result = m_sharedMemory.open(name, shmFlags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
[-] 	if (!(flags & FileFlag_OpenExisting) && m_sharedMemory.getSize () < size)
[+] 	if (!(flags & FileFlag_OpenExisting) && m_sharedMemory.getSize() < size)
[-] 		result = m_sharedMemory.setSize (size);
[+] 		result = m_sharedMemory.setSize(size);
[-] 				psx::SharedMemory::unlink (name);
[+] 				psx::SharedMemory::unlink(name);
[-] 	p = m_mapping.map (NULL, size, protection, MAP_SHARED, m_sharedMemory, 0);
[+] 	p = m_mapping.map(NULL, size, protection, MAP_SHARED, m_sharedMemory, 0);
[-] 			psx::SharedMemory::unlink (name);
[+] 			psx::SharedMemory::unlink(name);
[-] Mapping::close ()
[+] Mapping::close()
[-] 	m_mapping.close ();
[+] 	m_mapping.close();
[-] 	m_view.close ();
[+] 	m_view.close();
[-] 	m_sharedMemory.close ();
[+] 	m_sharedMemory.close();
[-] 	m_mapping.close ();
[+] 	m_mapping.close();
[-] 		psx::SharedMemory::unlink (m_sharedMemoryName);
[+] 		psx::SharedMemory::unlink(m_sharedMemoryName);
[-] 		m_sharedMemoryName.clear ();
[+] 		m_sharedMemoryName.clear();
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_NetworkAdapter.cpp
----------------------
[-] getNetworkAdapterTypeString (NetworkAdapterType adapterKind)
[+] getNetworkAdapterTypeString(NetworkAdapterType adapterKind)
[-] 	static const char* stringTable [NetworkAdapterType__Count] =
[+] 	static const char* stringTable[NetworkAdapterType__Count] =
[-] 	return (size_t) adapterKind < countof (stringTable) ?
[+] 	return (size_t)adapterKind < countof(stringTable) ?
[-] 		stringTable [adapterKind] :
[+] 		stringTable[adapterKind] :
[-] 		stringTable [NetworkAdapterType_Unknown];
[+] 		stringTable[NetworkAdapterType_Unknown];
[-] getNetworkAdapterFlagString (NetworkAdapterFlag flag)
[+] getNetworkAdapterFlagString(NetworkAdapterFlag flag)
[-] 	static const char* stringTable [] =
[+] 	static const char* stringTable[] =
[-] 	size_t i = sl::getLoBitIdx32 (flag);
[+] 	size_t i = sl::getLoBitIdx32(flag);
[-] 	return i < countof (stringTable) ?
[+] 	return i < countof(stringTable) ?
[-] 		stringTable [i] :
[+] 		stringTable[i] :
[-] getNetworkAdapterFlagString (uint_t flags)
[+] getNetworkAdapterFlagString(uint_t flags)
[-] 		return sl::String ();
[+] 		return sl::String();
[-] 	NetworkAdapterFlag flag = getFirstNetworkAdapterFlag (flags);
[+] 	NetworkAdapterFlag flag = getFirstNetworkAdapterFlag(flags);
[-] 	sl::String string = getNetworkAdapterFlagString (flag);
[+] 	sl::String string = getNetworkAdapterFlagString(flag);
[-] 		flag = getFirstNetworkAdapterFlag (flags);
[+] 		flag = getFirstNetworkAdapterFlag(flags);
[-] 		string += getNetworkAdapterFlagString (flag);
[+] 		string += getNetworkAdapterFlagString(flag);
[-] NetworkAdapterDesc::NetworkAdapterDesc ()
[+] NetworkAdapterDesc::NetworkAdapterDesc()
[-] 	memset (m_mac, 0, sizeof (m_mac));
[+] 	memset(m_mac, 0, sizeof(m_mac));
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_Pcap.cpp
----------------------
[-] Pcap::openDevice (
[+] Pcap::openDevice(
[-] 	close ();
[+] 	close();
[-] 	char errorBuffer [PCAP_ERRBUF_SIZE];
[+] 	char errorBuffer[PCAP_ERRBUF_SIZE];
[-] 	m_h = pcap_open_live (
[+] 	m_h = pcap_open_live(
[-] 		device.sz (),
[+] 		device.sz(),
[-] 		err::setError (errorBuffer);
[+] 		err::setError(errorBuffer);
[-] Pcap::openFile (const sl::StringRef& fileName)
[+] Pcap::openFile(const sl::StringRef& fileName)
[-] 	close ();
[+] 	close();
[-] 	char errorBuffer [PCAP_ERRBUF_SIZE];
[+] 	char errorBuffer[PCAP_ERRBUF_SIZE];
[-] 	m_h = pcap_open_offline (fileName.sz (), errorBuffer);
[+] 	m_h = pcap_open_offline(fileName.sz(), errorBuffer);
[-] 		err::setError (errorBuffer);
[+] 		err::setError(errorBuffer);
[-] Pcap::setFilter (const sl::StringRef& filter)
[+] Pcap::setFilter(const sl::StringRef& filter)
[-] 	int result = pcap_compile (m_h, &program, (char*) (const char*) filter.sz (), true, 0);
[+] 	int result = pcap_compile(m_h, &program, (char*)(const char*) filter.sz(), true, 0);
[-] 		err::setError (pcap_geterr (m_h));
[+] 		err::setError(pcap_geterr(m_h));
[-] 	result = pcap_setfilter (m_h, &program);
[+] 	result = pcap_setfilter(m_h, &program);
[-] 	pcap_freecode (&program);
[+] 	pcap_freecode(&program);
[-] Pcap::setBlockingMode (bool isBlocking)
[+] Pcap::setBlockingMode(bool isBlocking)
[-] 	char errorBuffer [PCAP_ERRBUF_SIZE];
[+] 	char errorBuffer[PCAP_ERRBUF_SIZE];
[-] 	int result = pcap_setnonblock (m_h, !isBlocking, errorBuffer);
[+] 	int result = pcap_setnonblock(m_h, !isBlocking, errorBuffer);
[-] 		err::setError (errorBuffer);
[+] 		err::setError(errorBuffer);
[-] Pcap::read (
[+] Pcap::read(
[-] 	int result = pcap_next_ex (m_h, &hdr, &data);
[+] 	int result = pcap_next_ex(m_h, &hdr, &data);
[-] 		err::setError (pcap_geterr (m_h));
[+] 		err::setError(pcap_geterr(m_h));
[-] 	size_t copySize = AXL_MIN (hdr->caplen, size);
[+] 	size_t copySize = AXL_MIN(hdr->caplen, size);
[-] 	memcpy (p, data, copySize);
[+] 	memcpy(p, data, copySize);
[-] 		*timestamp = sys::getTimestampFromTimeval (&hdr->ts);
[+] 		*timestamp = sys::getTimestampFromTimeval(&hdr->ts);
[-] Pcap::write (
[+] Pcap::write(
[-] 	int result = pcap_sendpacket (m_h, (const u_char*) p, (int) size);
[+] 	int result = pcap_sendpacket(m_h, (const u_char*) p, (int)size);
[-] 	int result = pcap_inject (m_h, p, (int) size);
[+] 	int result = pcap_inject(m_h, p, (int)size);
[-] 		err::setError (pcap_geterr (m_h));
[+] 		err::setError(pcap_geterr(m_h));
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_psx_File.cpp
----------------------
[-] File::open (
[+] File::open(
[-] 	close ();
[+] 	close();
[-] 	m_h = ::open (fileName.sz (), openFlags, mode);
[+] 	m_h = ::open(fileName.sz(), openFlags, mode);
[-] 	return err::complete (m_h != -1);
[+] 	return err::complete(m_h != -1);
[-] File::duplicate (int fd)
[+] File::duplicate(int fd)
[-] 	close ();
[+] 	close();
[-] 	m_h = ::dup (fd);
[+] 	m_h = ::dup(fd);
[-] 	return err::complete (m_h != -1);
[+] 	return err::complete(m_h != -1);
[-] File::setBlockingMode (bool isBlocking)
[+] File::setBlockingMode(bool isBlocking)
[-] 	int result = ::fcntl (m_h, F_GETFL, 0);
[+] 	int result = ::fcntl(m_h, F_GETFL, 0);
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] 	result = ::fcntl (m_h, F_SETFL, flags);
[+] 	result = ::fcntl(m_h, F_SETFL, flags);
[-] 	return err::complete (result != -1);
[+] 	return err::complete(result != -1);
[-] File::getSize () const
[+] File::getSize() const
[-] 	int result = ::fstat (m_h, &stat);
[+] 	int result = ::fstat(m_h, &stat);
[-] 	int result = ::fstat64 (m_h, &stat);
[+] 	int result = ::fstat64(m_h, &stat);
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
[-] File::getPosition () const
[+] File::getPosition() const
[-] 	uint64_t offset = ::lseek (m_h, 0, SEEK_CUR);
[+] 	uint64_t offset = ::lseek(m_h, 0, SEEK_CUR);
[-] 	uint64_t offset = ::lseek64 (m_h, 0, SEEK_CUR);
[+] 	uint64_t offset = ::lseek64(m_h, 0, SEEK_CUR);
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
[-] File::getIncomingDataSize ()
[+] File::getIncomingDataSize()
[-] 	int result = ::ioctl (m_h, FIONREAD, &value);
[+] 	int result = ::ioctl(m_h, FIONREAD, &value);
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
[-] File::read (
[+] File::read(
[-] 	size_t actualSize = ::read (m_h, p, size);
[+] 	size_t actualSize = ::read(m_h, p, size);
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
[-] File::write (
[+] File::write(
[-] 	size_t actualSize = ::write (m_h, p, size);
[+] 	size_t actualSize = ::write(m_h, p, size);
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_psx_Mapping.cpp
----------------------
[-] Mapping::map (
[+] Mapping::map(
[-] 	close ();
[+] 	close();
[-] 	m_p = ::mmap (addrHint, size, protection, flags, fd, offset);
[+] 	m_p = ::mmap(addrHint, size, protection, flags, fd, offset);
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
[-] Mapping::unmap (size_t size)
[+] Mapping::unmap(size_t size)
[-] 	if (!isOpen ())
[+] 	if (!isOpen())
[-] 	::munmap (m_p, size);
[+] 	::munmap(m_p, size);
[-] SharedMemory::open (
[+] SharedMemory::open(
[-] 	close ();
[+] 	close();
[-] 	m_h = ::shm_open (name.sz (), flags, mode);
[+] 	m_h = ::shm_open(name.sz(), flags, mode);
[-] 	return err::complete (m_h != -1);
[+] 	return err::complete(m_h != -1);
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_psx_NetworkAdapterEnumerator.cpp
----------------------
[-] 	createAdapterList (sl::List <NetworkAdapterDesc>* adapterList);
[+] 	createAdapterList(sl::List<NetworkAdapterDesc>* adapterList);
[-] 	setupAdapter (
[+] 	setupAdapter(
[-] 	addAdapterAddress (
[+] 	addAdapterAddress(
[-] NetworkAdapterEnumerator::createAdapterList (sl::List <NetworkAdapterDesc>* adapterList)
[+] NetworkAdapterEnumerator::createAdapterList(sl::List<NetworkAdapterDesc>* adapterList)
[-] 	adapterList->clear ();
[+] 	adapterList->clear();
[-] 	int result = getifaddrs (&ifaceAddressList);
[+] 	int result = getifaddrs(&ifaceAddressList);
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
[-] 	sl::StringHashTable <NetworkAdapterDesc*> adapterMap;
[+] 	sl::StringHashTable<NetworkAdapterDesc*> adapterMap;
[-] 		sl::StringHashTableIterator <NetworkAdapterDesc*> it = adapterMap.visit (iface->ifa_name);
[+] 		sl::StringHashTableIterator<NetworkAdapterDesc*> it = adapterMap.visit(iface->ifa_name);
[-] 				addAdapterAddress (it->m_value, iface->ifa_addr, iface->ifa_netmask);
[+] 				addAdapterAddress(it->m_value, iface->ifa_addr, iface->ifa_netmask);
[-] 		NetworkAdapterDesc* adapter = AXL_MEM_NEW (NetworkAdapterDesc);
[+] 		NetworkAdapterDesc* adapter = AXL_MEM_NEW(NetworkAdapterDesc);
[-] 		setupAdapter (adapter, iface);
[+] 		setupAdapter(adapter, iface);
[-] 		adapterList->insertTail (adapter);
[+] 		adapterList->insertTail(adapter);
[-] 	freeifaddrs (ifaceAddressList);
[+] 	freeifaddrs(ifaceAddressList);
[-] 	return adapterList->getCount ();
[+] 	return adapterList->getCount();
[-] NetworkAdapterEnumerator::setupAdapter (
[+] NetworkAdapterEnumerator::setupAdapter(
[-] NetworkAdapterEnumerator::addAdapterAddress (
[+] NetworkAdapterEnumerator::addAdapterAddress(
[-] 	NetworkAdapterAddress* address = AXL_MEM_NEW (NetworkAdapterAddress);
[+] 	NetworkAdapterAddress* address = AXL_MEM_NEW(NetworkAdapterAddress);
[-] 	address->m_address.setup (addr);
[+] 	address->m_address.setup(addr);
[-] 	address->m_netMaskBitCount = netMask ? getSockAddrNetMaskBitCount (netMask) : 0;
[+] 	address->m_netMaskBitCount = netMask ? getSockAddrNetMaskBitCount(netMask) : 0;
[-] 	adapter->m_addressList.insertTail (address);
[+] 	adapter->m_addressList.insertTail(address);
[-] createNetworkAdapterDescList (sl::List <NetworkAdapterDesc>* adapterList)
[+] createNetworkAdapterDescList(sl::List<NetworkAdapterDesc>* adapterList)
[-] 	return NetworkAdapterEnumerator::createAdapterList (adapterList);
[+] 	return NetworkAdapterEnumerator::createAdapterList(adapterList);
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_psx_Pipe.cpp
----------------------
[-] Pipe::create ()
[+] Pipe::create()
[-] 	close ();
[+] 	close();
[-] 	int fd [2];
[+] 	int fd[2];
[-] 	int result = ::pipe (fd);
[+] 	int result = ::pipe(fd);
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] 	m_readFile.attach (fd [0]);
[+] 	m_readFile.attach(fd[0]);
[-] 	m_writeFile.attach (fd [1]);
[+] 	m_writeFile.attach(fd[1]);
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_psx_Serial.cpp
----------------------
[-] Serial::getStatusLines () const
[+] Serial::getStatusLines() const
[-] 	int result = ::ioctl (m_h, TIOCMGET, &lines);
[+] 	int result = ::ioctl(m_h, TIOCMGET, &lines);
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
[-] Serial::setDtr (bool isSet)
[+] Serial::setDtr(bool isSet)
[-] 	int result = ::ioctl (m_h, isSet ? TIOCMBIS : TIOCMBIC, &lines);
[+] 	int result = ::ioctl(m_h, isSet ? TIOCMBIS : TIOCMBIC, &lines);
[-] 	return err::complete (result != -1);
[+] 	return err::complete(result != -1);
[-] Serial::setRts (bool isSet)
[+] Serial::setRts(bool isSet)
[-] 	int result = ::ioctl (m_h, isSet ? TIOCMBIS : TIOCMBIC, &lines);
[+] 	int result = ::ioctl(m_h, isSet ? TIOCMBIS : TIOCMBIC, &lines);
[-] 	return err::complete (result != -1);
[+] 	return err::complete(result != -1);
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_psx_Socket.cpp
----------------------
[-] Socket::open (
[+] Socket::open(
[-] 	close ();
[+] 	close();
[-] 	m_h = ::socket (addressFamily, sockKind, protocol);
[+] 	m_h = ::socket(addressFamily, sockKind, protocol);
[-] 	return err::complete (m_h != -1);
[+] 	return err::complete(m_h != -1);
[-] Socket::getError ()
[+] Socket::getError()
[-] 	getOption (SOL_SOCKET, SO_ERROR, &error, sizeof (int));
[+] 	getOption(SOL_SOCKET, SO_ERROR, &error, sizeof(int));
[-] Socket::setBlockingMode (bool isBlocking)
[+] Socket::setBlockingMode(bool isBlocking)
[-] 	int result = ::ioctl (m_h, FIONBIO, &value);
[+] 	int result = ::ioctl(m_h, FIONBIO, &value);
[-] 	return err::complete (result != -1);
[+] 	return err::complete(result != -1);
[-] Socket::getAddress (SockAddr* addr)
[+] Socket::getAddress(SockAddr* addr)
[-] 	socklen_t size = sizeof (SockAddr);
[+] 	socklen_t size = sizeof(SockAddr);
[-] 	int result = ::getsockname (m_h, (sockaddr*) addr, &size);
[+] 	int result = ::getsockname(m_h, (sockaddr*)addr, &size);
[-] 	return err::complete (result != -1);
[+] 	return err::complete(result != -1);
[-] Socket::getPeerAddress (SockAddr* addr)
[+] Socket::getPeerAddress(SockAddr* addr)
[-] 	socklen_t size = sizeof (SockAddr);
[+] 	socklen_t size = sizeof(SockAddr);
[-] 	int result = ::getpeername (m_h, (sockaddr*) addr, &size);
[+] 	int result = ::getpeername(m_h, (sockaddr*)addr, &size);
[-] 	return err::complete (result != -1);
[+] 	return err::complete(result != -1);
[-] Socket::connect (const sockaddr* addr)
[+] Socket::connect(const sockaddr* addr)
[-] 	int result = ::connect (m_h, addr, getSockAddrSize (addr));
[+] 	int result = ::connect(m_h, addr, getSockAddrSize(addr));
[-] 		err::setError (errno);
[+] 		err::setError(errno);
[-] Socket::accept (SockAddr* addr)
[+] Socket::accept(SockAddr* addr)
[-] 	socklen_t addrSize = sizeof (SockAddr);
[+] 	socklen_t addrSize = sizeof(SockAddr);
[-] 	int socket = ::accept (
[+] 	int socket = ::accept(
[-] 		(sockaddr*) addr,
[+] 		(sockaddr*)addr,
[-] 	return err::complete (socket, -1);
[+] 	return err::complete(socket, -1);
[-] Socket::recvFrom (
[+] Socket::recvFrom(
[-] 	socklen_t addrSize = sizeof (SockAddr);
[+] 	socklen_t addrSize = sizeof(SockAddr);
[-] 	int result = ::recvfrom (
[+] 	int result = ::recvfrom(
[-] 		(sockaddr*) addr,
[+] 		(sockaddr*)addr,
[-] 	return err::complete (result, -1);
[+] 	return err::complete(result, -1);
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_Serial.cpp
----------------------
[-] Serial::open (
[+] Serial::open(
[-] 	return m_serial.open (name, accessMode, flagsAttributes);
[+] 	return m_serial.open(name, accessMode, flagsAttributes);
[-] Serial::setSettings (
[+] Serial::setSettings(
[-] 	dcb.DCBlength = sizeof (dcb);
[+] 	dcb.DCBlength = sizeof(dcb);
[-] 	bool result = m_serial.getSettings (&dcb);
[+] 	bool result = m_serial.getSettings(&dcb);
[-] 		switch (settings->m_flowControl)
[+] 		switch(settings->m_flowControl)
[-] 		return m_serial.setSettings (&dcb);
[+] 		return m_serial.setSettings(&dcb);
[-] 		m_serial.setSettings (&dcb) &&
[+] 		m_serial.setSettings(&dcb) &&
[-] 		m_serial.setTimeouts (&timeouts);
[+] 		m_serial.setTimeouts(&timeouts);
[-] Serial::getSettings (SerialSettings* settings)
[+] Serial::getSettings(SerialSettings* settings)
[-] 	dcb.DCBlength = sizeof (dcb);
[+] 	dcb.DCBlength = sizeof(dcb);
[-] 	bool result = m_serial.getSettings (&dcb);
[+] 	bool result = m_serial.getSettings(&dcb);
[-] 	settings->setDcb (&dcb);
[+] 	settings->setDcb(&dcb);
[-] Serial::getStatusLines ()
[+] Serial::getStatusLines()
[-] 	uint_t lines = m_serial.getStatusLines ();
[+] 	uint_t lines = m_serial.getStatusLines();
[-] Serial::open (
[+] Serial::open(
[-] 	return m_serial.open (name, posixFlags);
[+] 	return m_serial.open(name, posixFlags);
[-] Serial::setSettings (
[+] Serial::setSettings(
[-] 	bool result = m_serial.getAttr (&attr);
[+] 	bool result = m_serial.getAttr(&attr);
[-] 		switch (settings->m_baudRate)
[+] 		switch(settings->m_baudRate)
[-] 		cfsetispeed (&attr, speed);
[+] 		cfsetispeed(&attr, speed);
[-] 		cfsetospeed (&attr, speed);
[+] 		cfsetospeed(&attr, speed);
[-] 		switch (settings->m_dataBits)
[+] 		switch(settings->m_dataBits)
[-] 		switch (settings->m_parity)
[+] 		switch(settings->m_parity)
[-] 		switch (settings->m_flowControl)
[+] 		switch(settings->m_flowControl)
[-] 	for (size_t i = 0; i < countof (attr.c_cc); i++)
[+] 	for (size_t i = 0; i < countof(attr.c_cc); i++)
[-] 		attr.c_cc [i] = _POSIX_VDISABLE;
[+] 		attr.c_cc[i] = _POSIX_VDISABLE;
[-] 	attr.c_cc [VTIME] = settings->m_readInterval / 100; // milliseconds -> deciseconds
[+] 	attr.c_cc[VTIME] = settings->m_readInterval / 100; // milliseconds -> deciseconds
[-] 	attr.c_cc [VMIN]  = 1;
[+] 	attr.c_cc[VMIN]  = 1;
[-] 	result = m_serial.setAttr (&attr);
[+] 	result = m_serial.setAttr(&attr);
[-] 		result = m_serial.setDtr (settings->m_dtr);
[+] 		result = m_serial.setDtr(settings->m_dtr);
[-] 			result = m_serial.setRts (settings->m_rts);
[+] 			result = m_serial.setRts(settings->m_rts);
[-] Serial::getSettings (SerialSettings* settings)
[+] Serial::getSettings(SerialSettings* settings)
[-] 	bool result = m_serial.getAttr (&attr);
[+] 	bool result = m_serial.getAttr(&attr);
[-] 	settings->setAttr (&attr);
[+] 	settings->setAttr(&attr);
[-] Serial::getStatusLines ()
[+] Serial::getStatusLines()
[-] 	uint_t result = m_serial.getStatusLines ();
[+] 	uint_t result = m_serial.getStatusLines();
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_SerialSettings.cpp
----------------------
[-] SerialSettings::setup (
[+] SerialSettings::setup(
[-] SerialSettings::setDcb (const DCB* dcb)
[+] SerialSettings::setDcb(const DCB* dcb)
[-] 	m_stopBits = (SerialStopBits) dcb->StopBits;
[+] 	m_stopBits = (SerialStopBits)dcb->StopBits;
[-] 	m_parity   = (SerialParity) dcb->Parity;
[+] 	m_parity   = (SerialParity)dcb->Parity;
[-] SerialSettings::setAttr (const termios* attr)
[+] SerialSettings::setAttr(const termios* attr)
[-] 	speed_t speed = cfgetispeed (attr);
[+] 	speed_t speed = cfgetispeed(attr);
[-] 	switch (speed)
[+] 	switch(speed)
[-] 	switch (byteSize)
[+] 	switch(byteSize)
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_SharedMemoryTransport.cpp
----------------------
[-] SharedMemoryTransportBase::SharedMemoryTransportBase ()
[+] SharedMemoryTransportBase::SharedMemoryTransportBase()
[-] SharedMemoryTransportBase::open (
[+] SharedMemoryTransportBase::open(
[-] 	bool result = file.open (fileName, flags | io::FileFlag_ShareWrite);
[+] 	bool result = file.open(fileName, flags | io::FileFlag_ShareWrite);
[-] 	return attach (
[+] 	return attach(
[-] 		file.m_file.detach (),
[+] 		file.m_file.detach(),
[-] SharedMemoryTransportBase::attach (
[+] SharedMemoryTransportBase::attach(
[-] 	close ();
[+] 	close();
[-] 	m_file.m_file.attach (fileHandle);
[+] 	m_file.m_file.attach(fileHandle);
[-] 		result = initializeMapping (SharedMemoryTransportConst_DefMappingSize, true);
[+] 		result = initializeMapping(SharedMemoryTransportConst_DefMappingSize, true);
[-] 			closeImpl ();
[+] 			closeImpl();
[-] 			m_readSemaphore.create (readSemaphoreName) &&
[+] 			m_readSemaphore.create(readSemaphoreName) &&
[-] 			m_writeSemaphore.create (writeSemaphoreName);
[+] 			m_writeSemaphore.create(writeSemaphoreName);
[-] 		result = initializeMapping (sizeof (SharedMemoryTransportHdr), false);
[+] 		result = initializeMapping(sizeof(SharedMemoryTransportHdr), false);
[-] 			closeImpl ();
[+] 			closeImpl();
[-] 			err::setError (err::SystemErrorCode_InvalidParameter);
[+] 			err::setError(err::SystemErrorCode_InvalidParameter);
[-] 			closeImpl ();
[+] 			closeImpl();
[-] 		sys::atomicLock (&m_hdr->m_lock);
[+] 		sys::atomicLock(&m_hdr->m_lock);
[-] 			sys::atomicUnlock (&m_hdr->m_lock);
[+] 			sys::atomicUnlock(&m_hdr->m_lock);
[-] 			err::setError (err::SystemErrorCode_InvalidDeviceState);
[+] 			err::setError(err::SystemErrorCode_InvalidDeviceState);
[-] 			closeImpl ();
[+] 			closeImpl();
[-] 		sys::atomicUnlock (&m_hdr->m_lock);
[+] 		sys::atomicUnlock(&m_hdr->m_lock);
[-] 			m_readSemaphore.open (readSemaphoreName) &&
[+] 			m_readSemaphore.open(readSemaphoreName) &&
[-] 			m_writeSemaphore.open (writeSemaphoreName);
[+] 			m_writeSemaphore.open(writeSemaphoreName);
[-] 		closeImpl ();
[+] 		closeImpl();
[-] SharedMemoryTransportBase::close ()
[+] SharedMemoryTransportBase::close()
[-] 	if (!isOpen ())
[+] 	if (!isOpen())
[-] 	disconnect ();
[+] 	disconnect();
[-] 	closeImpl ();
[+] 	closeImpl();
[-] SharedMemoryTransportBase::closeImpl ()
[+] SharedMemoryTransportBase::closeImpl()
[-] 	m_file.close ();
[+] 	m_file.close();
[-] 	m_readSemaphore.close ();
[+] 	m_readSemaphore.close();
[-] 	m_writeSemaphore.close ();
[+] 	m_writeSemaphore.close();
[-] SharedMemoryTransportBase::disconnect ()
[+] SharedMemoryTransportBase::disconnect()
[-] 	sys::atomicLock (&m_hdr->m_lock);
[+] 	sys::atomicLock(&m_hdr->m_lock);
[-] 		m_readSemaphore.signal (m_hdr->m_readSemaphoreWaitCount);
[+] 		m_readSemaphore.signal(m_hdr->m_readSemaphoreWaitCount);
[-] 		m_writeSemaphore.signal (m_hdr->m_writeSemaphoreWaitCount);
[+] 		m_writeSemaphore.signal(m_hdr->m_writeSemaphoreWaitCount);
[-] 	sys::atomicUnlock (&m_hdr->m_lock);
[+] 	sys::atomicUnlock(&m_hdr->m_lock);
[-] SharedMemoryTransportBase::initializeMapping (
[+] SharedMemoryTransportBase::initializeMapping(
[-] 	const g::SystemInfo* systemInfo = g::getModule ()->getSystemInfo ();
[+] 	const g::SystemInfo* systemInfo = g::getModule()->getSystemInfo();
[-] 		bool result = m_file.setSize (size);
[+] 		bool result = m_file.setSize(size);
[-] 		uint64_t fileSize = m_file.getSize ();
[+] 		uint64_t fileSize = m_file.getSize();
[-] 			err::setError (err::SystemErrorCode_InvalidParameter);
[+] 			err::setError(err::SystemErrorCode_InvalidParameter);
[-] 	void* p = m_mapping.open (&m_file, 0, size);
[+] 	void* p = m_mapping.open(&m_file, 0, size);
[-] 	m_hdr = (SharedMemoryTransportHdr*) p;
[+] 	m_hdr = (SharedMemoryTransportHdr*)p;
[-] 	m_data = (char*) (m_hdr + 1);
[+] 	m_data = (char*)(m_hdr + 1);
[-] SharedMemoryTransportBase::ensureMappingSize (size_t size)
[+] SharedMemoryTransportBase::ensureMappingSize(size_t size)
[-] 	if (size <= m_mapping.getSize ())
[+] 	if (size <= m_mapping.getSize())
[-] 	const g::SystemInfo* systemInfo = g::getModule ()->getSystemInfo ();
[+] 	const g::SystemInfo* systemInfo = g::getModule()->getSystemInfo();
[-] 	size = sl::align (size, systemInfo->m_pageSize);
[+] 	size = sl::align(size, systemInfo->m_pageSize);
[-] 	sys::atomicLock (&m_hdr->m_lock);
[+] 	sys::atomicLock(&m_hdr->m_lock);
[-] 	if (size <= m_file.getSize ())
[+] 	if (size <= m_file.getSize())
[-] 		sys::atomicUnlock (&m_hdr->m_lock);
[+] 		sys::atomicUnlock(&m_hdr->m_lock);
[-] 		bool result = m_file.setSize (size);
[+] 		bool result = m_file.setSize(size);
[-] 		sys::atomicUnlock (&m_hdr->m_lock);
[+] 		sys::atomicUnlock(&m_hdr->m_lock);
[-] 	void* p = m_mapping.open (&m_file, 0, size);
[+] 	void* p = m_mapping.open(&m_file, 0, size);
[-] 	m_hdr = (SharedMemoryTransportHdr*) p;
[+] 	m_hdr = (SharedMemoryTransportHdr*)p;
[-] 	m_data = (char*) (m_hdr + 1);
[+] 	m_data = (char*)(m_hdr + 1);
[-] SharedMemoryReader::read (sl::Array <char>* buffer)
[+] SharedMemoryReader::read(sl::Array<char>* buffer)
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 	sys::atomicLock (&m_hdr->m_lock);
[+] 	sys::atomicLock(&m_hdr->m_lock);
[-] 			sys::atomicUnlock (&m_hdr->m_lock);
[+] 			sys::atomicUnlock(&m_hdr->m_lock);
[-] 			m_writeSemaphore.wait ();
[+] 			m_writeSemaphore.wait();
[-] 			sys::atomicLock (&m_hdr->m_lock);
[+] 			sys::atomicLock(&m_hdr->m_lock);
[-] 			ASSERT (m_hdr->m_state & SharedMemoryTransportState_Disconnected);
[+] 			ASSERT(m_hdr->m_state & SharedMemoryTransportState_Disconnected);
[-] 			sys::atomicUnlock (&m_hdr->m_lock);
[+] 			sys::atomicUnlock(&m_hdr->m_lock);
[-] 			err::setError (err::SystemErrorCode_InvalidDeviceState);
[+] 			err::setError(err::SystemErrorCode_InvalidDeviceState);
[-] 	sys::atomicUnlock (&m_hdr->m_lock);
[+] 	sys::atomicUnlock(&m_hdr->m_lock);
[-] 	bool result = ensureOffsetMapped (endOffset);
[+] 	bool result = ensureOffsetMapped(endOffset);
[-] 		SharedMemoryTransportMessageHdr* msgHdr = (SharedMemoryTransportMessageHdr*) (m_data + readOffset);
[+] 		SharedMemoryTransportMessageHdr* msgHdr = (SharedMemoryTransportMessageHdr*)(m_data + readOffset);
[-] 		size_t readEndOffset = readOffset + sizeof (SharedMemoryTransportMessageHdr) + msgHdr->m_size;
[+] 		size_t readEndOffset = readOffset + sizeof(SharedMemoryTransportMessageHdr) + msgHdr->m_size;
[-] 		ASSERT (sl::isAligned <AXL_PTR_SIZE> (readOffset));
[+] 		ASSERT(sl::isAligned<AXL_PTR_SIZE> (readOffset));
[-] 		readEndOffset = sl::align <AXL_PTR_SIZE> (readEndOffset);
[+] 		readEndOffset = sl::align<AXL_PTR_SIZE> (readEndOffset);
[-] 			err::setError (err::SystemErrorCode_InvalidParameter);
[+] 			err::setError(err::SystemErrorCode_InvalidParameter);
[-] 		buffer->copy ((const char*) (msgHdr + 1), readSize);
[+] 		buffer->copy((const char*) (msgHdr + 1), readSize);
[-] 		sys::atomicLock (&m_hdr->m_lock);
[+] 		sys::atomicLock(&m_hdr->m_lock);
[-] 		ASSERT (readEndOffset <= m_hdr->m_endOffset);
[+] 		ASSERT(readEndOffset <= m_hdr->m_endOffset);
[-] 			buffer->copy (m_data + readOffset, readSize);
[+] 			buffer->copy(m_data + readOffset, readSize);
[-] 			buffer->setCount (readSize);
[+] 			buffer->setCount(readSize);
[-] 				memcpy (*buffer, m_data + readOffset, size1);
[+] 				memcpy(*buffer, m_data + readOffset, size1);
[-] 				memcpy (*buffer + size1, m_data + 1, size2);
[+] 				memcpy(*buffer + size1, m_data + 1, size2);
[-] 		sys::atomicLock (&m_hdr->m_lock);
[+] 		sys::atomicLock(&m_hdr->m_lock);
[-] 		m_readSemaphore.signal (m_hdr->m_readSemaphoreWaitCount);
[+] 		m_readSemaphore.signal(m_hdr->m_readSemaphoreWaitCount);
[-] 	sys::atomicUnlock (&m_hdr->m_lock);
[+] 	sys::atomicUnlock(&m_hdr->m_lock);
[-] SharedMemoryWriter::open (
[+] SharedMemoryWriter::open(
[-] 	bool result = SharedMemoryTransportBase::open (fileName, readEventName, writeEventName, flags);
[+] 	bool result = SharedMemoryTransportBase::open(fileName, readEventName, writeEventName, flags);
[-] SharedMemoryWriter::attach (
[+] SharedMemoryWriter::attach(
[-] 	bool result = SharedMemoryTransportBase::attach (fileHandle, readEventName, writeEventName, flags);
[+] 	bool result = SharedMemoryTransportBase::attach(fileHandle, readEventName, writeEventName, flags);
[-] SharedMemoryWriter::write (
[+] SharedMemoryWriter::write(
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 		chainSize += sizeArray [i];
[+] 		chainSize += sizeArray[i];
[-] 		writeSize += sizeof (SharedMemoryTransportMessageHdr);
[+] 		writeSize += sizeof(SharedMemoryTransportMessageHdr);
[-] 		writeSize = sl::align <AXL_PTR_SIZE> (writeSize);
[+] 		writeSize = sl::align<AXL_PTR_SIZE> (writeSize);
[-] 	sys::ScopeLock scopeLock (&m_writeLock); // ensure atomic write
[+] 	sys::ScopeLock scopeLock(&m_writeLock); // ensure atomic write
[-] 	sys::atomicLock (&m_hdr->m_lock);
[+] 	sys::atomicLock(&m_hdr->m_lock);
[-] 			sys::atomicUnlock (&m_hdr->m_lock);
[+] 			sys::atomicUnlock(&m_hdr->m_lock);
[-] 			m_readSemaphore.wait ();
[+] 			m_readSemaphore.wait();
[-] 			sys::atomicLock (&m_hdr->m_lock);
[+] 			sys::atomicLock(&m_hdr->m_lock);
[-] 			sys::atomicUnlock (&m_hdr->m_lock);
[+] 			sys::atomicUnlock(&m_hdr->m_lock);
[-] 			err::setError (err::SystemErrorCode_InvalidDeviceState);
[+] 			err::setError(err::SystemErrorCode_InvalidDeviceState);
[-] 	sys::atomicUnlock (&m_hdr->m_lock);
[+] 	sys::atomicUnlock(&m_hdr->m_lock);
[-] 	result = ensureOffsetMapped (writeEndOffset);
[+] 	result = ensureOffsetMapped(writeEndOffset);
[-] 		ASSERT (sl::isAligned <AXL_PTR_SIZE> (writeOffset));
[+] 		ASSERT(sl::isAligned<AXL_PTR_SIZE> (writeOffset));
[-] 		SharedMemoryTransportMessageHdr* msgHdr = (SharedMemoryTransportMessageHdr*) (m_data + writeOffset);
[+] 		SharedMemoryTransportMessageHdr* msgHdr = (SharedMemoryTransportMessageHdr*)(m_data + writeOffset);
[-] 		copyWriteChain (msgHdr + 1, blockArray, sizeArray, count);
[+] 		copyWriteChain(msgHdr + 1, blockArray, sizeArray, count);
[-] 		copyWriteChain (m_data + writeOffset, blockArray, sizeArray, count);
[+] 		copyWriteChain(m_data + writeOffset, blockArray, sizeArray, count);
[-] 	sys::atomicLock (&m_hdr->m_lock);
[+] 	sys::atomicLock(&m_hdr->m_lock);
[-] 		m_writeSemaphore.signal (m_hdr->m_writeSemaphoreWaitCount);
[+] 		m_writeSemaphore.signal(m_hdr->m_writeSemaphoreWaitCount);
[-] 	sys::atomicUnlock (&m_hdr->m_lock);
[+] 	sys::atomicUnlock(&m_hdr->m_lock);
[-] SharedMemoryWriter::copyWriteChain (
[+] SharedMemoryWriter::copyWriteChain(
[-] 	char* dst = (char*) _pDst;
[+] 	char* dst = (char*)_pDst;
[-] 		const void* src = blockArray [i];
[+] 		const void* src = blockArray[i];
[-] 		size_t size = sizeArray [i];
[+] 		size_t size = sizeArray[i];
[-] 		memcpy (dst, src, size);
[+] 		memcpy(dst, src, size);
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_SockAddr.cpp
----------------------
[-] getSockAddrFamilyString (uint_t family)
[+] getSockAddrFamilyString(uint_t family)
[-] 	switch (family)
[+] 	switch(family)
[-] getSockAddrFamilySize (uint_t family)
[+] getSockAddrFamilySize(uint_t family)
[-] 	switch (family)
[+] 	switch(family)
[-] 		return sizeof (sockaddr_in);
[+] 		return sizeof(sockaddr_in);
[-] 		return sizeof (sockaddr_in6);
[+] 		return sizeof(sockaddr_in6);
[-] 		return sizeof (sockaddr);
[+] 		return sizeof(sockaddr);
[-] getSockProtoString (uint_t proto)
[+] getSockProtoString(uint_t proto)
[-] 	switch (proto)
[+] 	switch(proto)
[-] getSockAddrNetMaskBitCount_ip4 (const sockaddr_in* addr)
[+] getSockAddrNetMaskBitCount_ip4(const sockaddr_in* addr)
[-] 	size_t bitIdx = sl::findBit ((size_t*) &addr->sin_addr, 1, 0, false);
[+] 	size_t bitIdx = sl::findBit((size_t*) &addr->sin_addr, 1, 0, false);
[-] 	return AXL_MIN (bitIdx, 32);
[+] 	return AXL_MIN(bitIdx, 32);
[-] getSockAddrNetMaskBitCount_ip6 (const sockaddr_in6* addr)
[+] getSockAddrNetMaskBitCount_ip6(const sockaddr_in6* addr)
[-] 	size_t bitIdx = sl::findBit (
[+] 	size_t bitIdx = sl::findBit(
[-] 		sizeof (addr->sin6_addr) / sizeof (size_t),
[+] 		sizeof(addr->sin6_addr) / sizeof(size_t),
[-] 	return AXL_MIN (bitIdx, 128);
[+] 	return AXL_MIN(bitIdx, 128);
[-] getSockAddrNetMaskBitCount (const sockaddr* addr)
[+] getSockAddrNetMaskBitCount(const sockaddr* addr)
[-] 	switch (addr->sa_family)
[+] 	switch(addr->sa_family)
[-] 		return getSockAddrNetMaskBitCount_ip4 ((const sockaddr_in*) addr);
[+] 		return getSockAddrNetMaskBitCount_ip4((const sockaddr_in*) addr);
[-] 		return getSockAddrNetMaskBitCount_ip6 ((const sockaddr_in6*) addr);
[+] 		return getSockAddrNetMaskBitCount_ip6((const sockaddr_in6*) addr);
[-] createSockAddrNetMask_ip4 (
[+] createSockAddrNetMask_ip4(
[-] 	memset (addr, 0, sizeof (sockaddr_in));
[+] 	memset(addr, 0, sizeof(sockaddr_in));
[-] 	size_t maxBitCount = sizeof (addr->sin_addr) * 8;
[+] 	size_t maxBitCount = sizeof(addr->sin_addr) * 8;
[-] 	sl::setBitRange ((size_t*) &addr->sin_addr, 1, 0, bitCount);
[+] 	sl::setBitRange((size_t*) &addr->sin_addr, 1, 0, bitCount);
[-] createSockAddrNetMask_ip6 (
[+] createSockAddrNetMask_ip6(
[-] 	memset (addr, 0, sizeof (sockaddr_in6));
[+] 	memset(addr, 0, sizeof(sockaddr_in6));
[-] 	size_t maxBitCount = sizeof (addr->sin6_addr) * 8;
[+] 	size_t maxBitCount = sizeof(addr->sin6_addr) * 8;
[-] 	sl::setBitRange (
[+] 	sl::setBitRange(
[-] 		sizeof (addr->sin6_addr) / sizeof (size_t),
[+] 		sizeof(addr->sin6_addr) / sizeof(size_t),
[-] isSockAddrEqual_ip4 (
[+] isSockAddrEqual_ip4(
[-] isSockAddrEqual_ip6 (
[+] isSockAddrEqual_ip6(
[-] 		memcmp (&addr1->sin6_addr, &addr2->sin6_addr, sizeof (addr1->sin6_addr)) == 0;
[+] 		memcmp(&addr1->sin6_addr, &addr2->sin6_addr, sizeof(addr1->sin6_addr)) == 0;
[-] isSockAddrEqual (
[+] isSockAddrEqual(
[-] 	switch (addr1->sa_family)
[+] 	switch(addr1->sa_family)
[-] 		return isSockAddrEqual_ip4 ((const sockaddr_in*) addr1, (const sockaddr_in*) addr2);
[+] 		return isSockAddrEqual_ip4((const sockaddr_in*) addr1, (const sockaddr_in*) addr2);
[-] 		return isSockAddrEqual_ip6 ((const sockaddr_in6*) addr1, (const sockaddr_in6*) addr2);
[+] 		return isSockAddrEqual_ip6((const sockaddr_in6*) addr1, (const sockaddr_in6*) addr2);
[-] isSockAddrMatch_ip4 (
[+] isSockAddrMatch_ip4(
[-] isSockAddrMatch_ip6 (
[+] isSockAddrMatch_ip6(
[-] 		(memcmp (&filterAddr->sin6_addr, &addrAny, sizeof (addrAny)) == 0 ||
[+] 		(memcmp(&filterAddr->sin6_addr, &addrAny, sizeof(addrAny)) == 0 ||
[-] 		memcmp (&addr->sin6_addr, &filterAddr->sin6_addr, sizeof (addr->sin6_addr)) == 0);
[+] 		memcmp(&addr->sin6_addr, &filterAddr->sin6_addr, sizeof(addr->sin6_addr)) == 0);
[-] isSockAddrMatch (
[+] isSockAddrMatch(
[-] 	switch (filterAddr->sa_family)
[+] 	switch(filterAddr->sa_family)
[-] 			isSockAddrMatch_ip4 ((const sockaddr_in*) addr, (const sockaddr_in*) filterAddr);
[+] 			isSockAddrMatch_ip4((const sockaddr_in*) addr, (const sockaddr_in*) filterAddr);
[-] 			isSockAddrMatch_ip6 ((const sockaddr_in6*) addr, (const sockaddr_in6*) filterAddr);
[+] 			isSockAddrMatch_ip6((const sockaddr_in6*) addr, (const sockaddr_in6*) filterAddr);
[-] parseAddr_ip4 (
[+] parseAddr_ip4(
[-] 	return SockAddrParser (string).parse (addr);
[+] 	return SockAddrParser(string).parse(addr);
[-] parseAddr_ip6 (
[+] parseAddr_ip6(
[-] 	SockAddrParser parser (string);
[+] 	SockAddrParser parser(string);
[-] 	return parser.parse (addr);
[+] 	return parser.parse(addr);
[-] parseSockAddr_ip4 (
[+] parseSockAddr_ip4(
[-] 	SockAddrParser parser (string);
[+] 	SockAddrParser parser(string);
[-] 	return parser.parse (addr);
[+] 	return parser.parse(addr);
[-] parseSockAddr_ip6 (
[+] parseSockAddr_ip6(
[-] 	SockAddrParser parser (string);
[+] 	SockAddrParser parser(string);
[-] 	return parser.parse (addr);
[+] 	return parser.parse(addr);
[-] parseSockAddr (
[+] parseSockAddr(
[-] 	SockAddrParser parser (string);
[+] 	SockAddrParser parser(string);
[-] 	return parser.parse (addr, size);
[+] 	return parser.parse(addr, size);
[-] getAddrString_ip4 (
[+] getAddrString_ip4(
[-] 	return string->format ("%d.%d.%d.%d", ip [0], ip [1], ip [2], ip [3]);
[+] 	return string->format("%d.%d.%d.%d", ip [0], ip [1], ip [2], ip [3]);
[-] getAddrString_ip6 (
[+] getAddrString_ip6(
[-] 	string->clear ();
[+] 	string->clear();
[-] 			if (!ip [i])
[+] 			if (!ip[i])
[-] 			if (!ip [i])
[+] 			if (!ip[i])
[-] 		string->appendFormat ("%x", sl::swapByteOrder16 (ip [0]));
[+] 		string->appendFormat("%x", sl::swapByteOrder16 (ip [0]));
[-] 			string->appendFormat (":%x", sl::swapByteOrder16 (ip [i]));
[+] 			string->appendFormat(":%x", sl::swapByteOrder16 (ip [i]));
[-] 			if (maxZeroRunLength == 6 && ip [6] != 0)
[+] 			if (maxZeroRunLength == 6 && ip[6] != 0)
[-] 				string->append ("::", 2);
[+] 				string->append("::", 2);
[-] 			else if (maxZeroRunLength == 5 && ip [5] == 0xffff && ip [6] != 0)
[+] 			else if (maxZeroRunLength == 5 && ip[5] == 0xffff && ip[6] != 0)
[-] 			else if (maxZeroRunLength == 5 && ip [5] == 0xffff)
[+] 			else if (maxZeroRunLength == 5 && ip[5] == 0xffff)
[-] 				string->append ("::ffff:", 7);
[+] 				string->append("::ffff:", 7);
[-] 				string->append (':');
[+] 				string->append(':');
[-] 				string->appendFormat ("%x:", sl::swapByteOrder16 (ip [i]));
[+] 				string->appendFormat("%x:", sl::swapByteOrder16 (ip [i]));
[-] 			string->appendFormat (
[+] 			string->appendFormat(
[-] 				ip [6] & 0xff,
[+] 				ip[6] & 0xff,
[-] 				(ip [6] >> 8) & 0xff,
[+] 				(ip[6] >> 8) & 0xff,
[-] 				ip [7] & 0xff,
[+] 				ip[7] & 0xff,
[-] 				(ip [7] >> 8) & 0xff
[+] 				(ip[7] >> 8) & 0xff
[-] 				string->append (':');
[+] 				string->append(':');
[-] 					string->appendFormat (":%x", sl::swapByteOrder16 (ip [i]));
[+] 					string->appendFormat(":%x", sl::swapByteOrder16 (ip [i]));
[-] 	return string->getLength ();
[+] 	return string->getLength();
[-] getSockAddrString_ip4 (
[+] getSockAddrString_ip4(
[-] 		getAddrString_ip4 (string, &addr->sin_addr);
[+] 		getAddrString_ip4(string, &addr->sin_addr);
[-] 		getAddrString_ip4 (string, &addr->sin_addr);
[+] 		getAddrString_ip4(string, &addr->sin_addr);
[-] 		string->appendFormat (":%d", sl::swapByteOrder16 (addr->sin_port));
[+] 		string->appendFormat(":%d", sl::swapByteOrder16 (addr->sin_port));
[-] 		string->format ("%d", sl::swapByteOrder16 (addr->sin_port));
[+] 		string->format("%d", sl::swapByteOrder16 (addr->sin_port));
[-] 	return string->getLength ();
[+] 	return string->getLength();
[-] getSockAddrString_ip6 (
[+] getSockAddrString_ip6(
[-] 	getAddrString_ip6 (string, &addr->sin6_addr);
[+] 	getAddrString_ip6(string, &addr->sin6_addr);
[-] 		string->appendFormat ("%%%d", addr->sin6_scope_id);
[+] 		string->appendFormat("%%%d", addr->sin6_scope_id);
[-] 		string->insert (0, '[');
[+] 		string->insert(0, '[');
[-] 		string->appendFormat ("]:%d", sl::swapByteOrder16 (addr->sin6_port));
[+] 		string->appendFormat("]:%d", sl::swapByteOrder16 (addr->sin6_port));
[-] 	return string->getLength ();
[+] 	return string->getLength();
[-] getSockAddrString (
[+] getSockAddrString(
[-] 	switch (addr->sa_family)
[+] 	switch(addr->sa_family)
[-] 		return getSockAddrString_ip4 (string, (const sockaddr_in*) addr);
[+] 		return getSockAddrString_ip4(string, (const sockaddr_in*) addr);
[-] 		return getSockAddrString_ip6 (string, (const sockaddr_in6*) addr);
[+] 		return getSockAddrString_ip6(string, (const sockaddr_in6*) addr);
[-] 		string->clear ();
[+] 		string->clear();
[-] SockAddr::setup (const sockaddr* addr)
[+] SockAddr::setup(const sockaddr* addr)
[-] 	switch (addr->sa_family)
[+] 	switch(addr->sa_family)
[-] 		m_addr_ip4 = *(sockaddr_in*) addr;
[+] 		m_addr_ip4 = *(sockaddr_in*)addr;
[-] 		m_addr_ip6 = *(sockaddr_in6*) addr;
[+] 		m_addr_ip6 = *(sockaddr_in6*)addr;
[-] SockAddr::setup (
[+] SockAddr::setup(
[-] 	switch (family)
[+] 	switch(family)
[-] 		if (size >= sizeof (in_addr))
[+] 		if (size >= sizeof(in_addr))
[-] 			setup_ip4 ((const in_addr*) addr);
[+] 			setup_ip4((const in_addr*) addr);
[-] 		if (size >= sizeof (in6_addr))
[+] 		if (size >= sizeof(in6_addr))
[-] 			setup_ip6 ((const in6_addr*) addr);
[+] 			setup_ip6((const in6_addr*) addr);
[-] SockAddr::setup_ip4 (
[+] SockAddr::setup_ip4(
[-] 	m_addr_ip4.sin_port = sl::swapByteOrder16 (port);
[+] 	m_addr_ip4.sin_port = sl::swapByteOrder16(port);
[-] 	memset (m_addr_ip4.sin_zero, 0, sizeof (m_addr_ip4.sin_zero));
[+] 	memset(m_addr_ip4.sin_zero, 0, sizeof(m_addr_ip4.sin_zero));
[-] SockAddr::setup_ip6 (
[+] SockAddr::setup_ip6(
[-] 	m_addr_ip6.sin6_port = sl::swapByteOrder16 (port);
[+] 	m_addr_ip6.sin6_port = sl::swapByteOrder16(port);
[-] SockAddr::createNetMask (
[+] SockAddr::createNetMask(
[-] 	switch (family)
[+] 	switch(family)
[-] 		createNetMask_ip4 (bitCount);
[+] 		createNetMask_ip4(bitCount);
[-] 		createNetMask_ip6 (bitCount);
[+] 		createNetMask_ip6(bitCount);
[-] 		clear ();
[+] 		clear();
[-] resolveHostName (
[+] resolveHostName(
[-] 	sl::Array <SockAddr>* addrArray,
[+] 	sl::Array<SockAddr>* addrArray,
[-] 	addrArray->clear ();
[+] 	addrArray->clear();
[-] 	int result = getaddrinfo (name.sz (), NULL, &hintAddrInfo, &addrInfoList);
[+] 	int result = getaddrinfo(name.sz(), NULL, &hintAddrInfo, &addrInfoList);
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
[-] 		err::setError (gai_strerror (result));
[+] 		err::setError(gai_strerror(result));
[-] 		err::setError (err::SystemErrorCode_InvalidParameter);
[+] 		err::setError(err::SystemErrorCode_InvalidParameter);
[-] 	addrArray->reserve (addrInfo->ai_next ? 4 : 1);
[+] 	addrArray->reserve(addrInfo->ai_next ? 4 : 1);
[-] 		addrArray->append (addrInfo->ai_addr);
[+] 		addrArray->append(addrInfo->ai_addr);
[-] 	freeaddrinfo (addrInfoList);
[+] 	freeaddrinfo(addrInfoList);
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_SockAddrParser.cpp
----------------------
[-] SockAddrParser::parse (in_addr* addr)
[+] SockAddrParser::parse(in_addr* addr)
[-] 	uchar_t* ip = (uchar_t*) addr;
[+] 	uchar_t* ip = (uchar_t*)addr;
[-] 		result = parseInt (&octet, 10);
[+] 		result = parseInt(&octet, 10);
[-] 		ip [i] = octet;
[+] 		ip[i] = octet;
[-] 		result = expectChar ('.');
[+] 		result = expectChar('.');
[-] SockAddrParser::parse (sockaddr_in* addr)
[+] SockAddrParser::parse(sockaddr_in* addr)
[-] 	memset (addr, 0, sizeof (sockaddr_in));
[+] 	memset(addr, 0, sizeof(sockaddr_in));
[-] 	result = parse (&addr->sin_addr);
[+] 	result = parse(&addr->sin_addr);
[-] 		result = parseInt (&port, 10);
[+] 		result = parseInt(&port, 10);
[-] 		skipWhiteSpace ();
[+] 		skipWhiteSpace();
[-] 			err::setError (err::SystemErrorCode_InvalidAddress);
[+] 			err::setError(err::SystemErrorCode_InvalidAddress);
[-] 		addr->sin_port = sl::swapByteOrder16 ((uint16_t) port);
[+] 		addr->sin_port = sl::swapByteOrder16((uint16_t)port);
[-] 	result = tryChar (':');
[+] 	result = tryChar(':');
[-] 		result = parseInt (&port, 10);
[+] 		result = parseInt(&port, 10);
[-] 		addr->sin_port = sl::swapByteOrder16 ((uint16_t) port);
[+] 		addr->sin_port = sl::swapByteOrder16((uint16_t)port);
[-] SockAddrParser::parse (in6_addr* addr)
[+] SockAddrParser::parse(in6_addr* addr)
[-] 	uint16_t* ip = (uint16_t*) addr;
[+] 	uint16_t* ip = (uint16_t*)addr;
[-] 	uchar_t ip4 [4];
[+] 	uchar_t ip4[4];
[-] 	tryChar (':');
[+] 	tryChar(':');
[-] 		result = tryChar (':');
[+] 		result = tryChar(':');
[-] 		skipWhiteSpace ();
[+] 		skipWhiteSpace();
[-] 		if (m_p >= m_end || !isxdigit (*m_p))
[+] 		if (m_p >= m_end || !isxdigit(*m_p))
[-] 		result = parseInt (&word, 16);
[+] 		result = parseInt(&word, 16);
[-] 		result = tryChar (':');
[+] 		result = tryChar(':');
[-] 			result = tryChar ('.');
[+] 			result = tryChar('.');
[-] 					err::setError (err::SystemErrorCode_InvalidAddress);
[+] 					err::setError(err::SystemErrorCode_InvalidAddress);
[-] 				ip4 [0] = (uchar_t)
[+] 				ip4[0] = (uchar_t)
[-] 		ip [i] = sl::swapByteOrder16 ((uint16_t) word);
[+] 		ip[i] = sl::swapByteOrder16((uint16_t)word);
[-] 			result = parseInt (&octet, 10);
[+] 			result = parseInt(&octet, 10);
[-] 			ip4 [j] = (uchar_t) octet;
[+] 			ip4[j] = (uchar_t)octet;
[-] 			result = expectChar ('.');
[+] 			result = expectChar('.');
[-] 		ASSERT (i <= 6);
[+] 		ASSERT(i <= 6);
[-] 		ip [i] = ip4 [0] + (ip4 [1] << 8);
[+] 		ip[i] = ip4[0] + (ip4[1] << 8);
[-] 		ip [i + 1] = ip4 [2] + (ip4 [3] << 8);
[+] 		ip[i + 1] = ip4[2] + (ip4[3] << 8);
[-] 		ASSERT (i <= 8 && zeroRunIdx <= i);
[+] 		ASSERT(i <= 8 && zeroRunIdx <= i);
[-] 			memmove (&ip [zeroRunIdx + zeroRunLength], &ip [zeroRunIdx], (i - zeroRunIdx) * sizeof (uint16_t));
[+] 			memmove(&ip[zeroRunIdx + zeroRunLength], &ip[zeroRunIdx], (i - zeroRunIdx) * sizeof(uint16_t));
[-] 			memset (&ip [zeroRunIdx], 0, zeroRunLength * sizeof (uint16_t));
[+] 			memset(&ip[zeroRunIdx], 0, zeroRunLength * sizeof(uint16_t));
[-] 		err::setError (err::SystemErrorCode_InvalidAddress);
[+] 		err::setError(err::SystemErrorCode_InvalidAddress);
[-] SockAddrParser::parse (sockaddr_in6* addr)
[+] SockAddrParser::parse(sockaddr_in6* addr)
[-] 	memset (addr, 0, sizeof (sockaddr_in6));
[+] 	memset(addr, 0, sizeof(sockaddr_in6));
[-] 	bool hasBrackets = tryChar ('[');
[+] 	bool hasBrackets = tryChar('[');
[-] 	result = parse (&addr->sin6_addr);
[+] 	result = parse(&addr->sin6_addr);
[-] 	result = tryChar ('%');
[+] 	result = tryChar('%');
[-] 		result = parseInt (&scope, 10);
[+] 		result = parseInt(&scope, 10);
[-] 		result = expectChar (']');
[+] 		result = expectChar(']');
[-] 		result = tryChar (':');
[+] 		result = tryChar(':');
[-] 			result = parseInt (&port, 10);
[+] 			result = parseInt(&port, 10);
[-] 			addr->sin6_port = sl::swapByteOrder16 ((uint16_t) port);
[+] 			addr->sin6_port = sl::swapByteOrder16((uint16_t)port);
[-] SockAddrParser::parse (
[+] SockAddrParser::parse(
[-] 	skipWhiteSpace ();
[+] 	skipWhiteSpace();
[-] 		memset (addr, 0, sizeof (sockaddr_in));
[+] 		memset(addr, 0, sizeof(sockaddr_in));
[-] 		((sockaddr_in*) addr)->sin_family = AF_INET;
[+] 		((sockaddr_in*)addr)->sin_family = AF_INET;
[-] 	if (trySockAddr_ip4 ())
[+] 	if (trySockAddr_ip4())
[-] 		if (size < sizeof (sockaddr_in))
[+] 		if (size < sizeof(sockaddr_in))
[-] 			err::setError (err::SystemErrorCode_BufferTooSmall);
[+] 			err::setError(err::SystemErrorCode_BufferTooSmall);
[-] 		return parse ((sockaddr_in*) addr);
[+] 		return parse((sockaddr_in*)addr);
[-] 	if (trySockAddr_ip6 ())
[+] 	if (trySockAddr_ip6())
[-] 		if (size < sizeof (sockaddr_in6))
[+] 		if (size < sizeof(sockaddr_in6))
[-] 			err::setError (err::SystemErrorCode_BufferTooSmall);
[+] 			err::setError(err::SystemErrorCode_BufferTooSmall);
[-] 		return parse ((sockaddr_in6*) addr);
[+] 		return parse((sockaddr_in6*)addr);
[-] 	err::setError (err::SystemErrorCode_InvalidAddress);
[+] 	err::setError(err::SystemErrorCode_InvalidAddress);
[-] SockAddrParser::tryAddr_ip4 ()
[+] SockAddrParser::tryAddr_ip4()
[-] 		result = tryInt (10);
[+] 		result = tryInt(10);
[-] 		result = tryChar ('.');
[+] 		result = tryChar('.');
[-] SockAddrParser::tryAddr_ip6 ()
[+] SockAddrParser::tryAddr_ip6()
[-] 	tryChar (':');
[+] 	tryChar(':');
[-] 		result = tryChar (':');
[+] 		result = tryChar(':');
[-] 		skipWhiteSpace ();
[+] 		skipWhiteSpace();
[-] 		if (m_p >= m_end || !isxdigit (*m_p))
[+] 		if (m_p >= m_end || !isxdigit(*m_p))
[-] 		result = tryInt (16);
[+] 		result = tryInt(16);
[-] 		result = tryChar (':');
[+] 		result = tryChar(':');
[-] 			result = tryChar ('.');
[+] 			result = tryChar('.');
[-] 			result = tryInt (10);
[+] 			result = tryInt(10);
[-] 			result = tryChar ('.');
[+] 			result = tryChar('.');
[-] SockAddrParser::trySockAddr_ip4 ()
[+] SockAddrParser::trySockAddr_ip4()
[-] 	bool result = tryAddr_ip4 ();
[+] 	bool result = tryAddr_ip4();
[-] 		result = tryInt (10);
[+] 		result = tryInt(10);
[-] 		skipWhiteSpace ();
[+] 		skipWhiteSpace();
[-] 	result = tryChar (':');
[+] 	result = tryChar(':');
[-] 		result = tryInt (10);
[+] 		result = tryInt(10);
[-] SockAddrParser::trySockAddr_ip6 ()
[+] SockAddrParser::trySockAddr_ip6()
[-] 	bool hasBrackets = tryChar ('[');
[+] 	bool hasBrackets = tryChar('[');
[-] 	result = tryAddr_ip6 ();
[+] 	result = tryAddr_ip6();
[-] 	result = tryChar ('%');
[+] 	result = tryChar('%');
[-] 		result = tryInt (10);
[+] 		result = tryInt(10);
[-] 		result = tryChar (']');
[+] 		result = tryChar(']');
[-] 		result = tryChar (':');
[+] 		result = tryChar(':');
[-] 			result = tryInt (10);
[+] 			result = tryInt(10);
[-] SockAddrParser::skipWhiteSpace ()
[+] SockAddrParser::skipWhiteSpace()
[-] 	while (m_p < m_end && isspace (*m_p))
[+] 	while (m_p < m_end && isspace(*m_p))
[-] SockAddrParser::parseInt (
[+] SockAddrParser::parseInt(
[-] 	skipWhiteSpace ();
[+] 	skipWhiteSpace();
[-] 	*p = (uint_t) strtoul (m_p, &end, radix);
[+] 	*p = (uint_t)strtoul(m_p, &end, radix);
[-] 		err::setError (err::SystemErrorCode_InvalidAddress);
[+] 		err::setError(err::SystemErrorCode_InvalidAddress);
[-] SockAddrParser::tryInt (int radix)
[+] SockAddrParser::tryInt(int radix)
[-] 	skipWhiteSpace ();
[+] 	skipWhiteSpace();
[-] 		while (p < m_end && isxdigit (*p))
[+] 		while (p < m_end && isxdigit(*p))
[-] 		while (p < m_end && isdigit (*p))
[+] 		while (p < m_end && isdigit(*p))
[-] SockAddrParser::expectChar (char c)
[+] SockAddrParser::expectChar(char c)
[-] 	bool result = tryChar (c);
[+] 	bool result = tryChar(c);
[-] 		err::setError (err::SystemErrorCode_InvalidAddress);
[+] 		err::setError(err::SystemErrorCode_InvalidAddress);
[-] SockAddrParser::tryChar (char c)
[+] SockAddrParser::tryChar(char c)
[-] 	skipWhiteSpace ();
[+] 	skipWhiteSpace();
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_Socket.cpp
----------------------
[-] Socket::accept (
[+] Socket::accept(
[-] 	SOCKET h = m_socket.accept (addr);
[+] 	SOCKET h = m_socket.accept(addr);
[-] 	int h = m_socket.accept (addr);
[+] 	int h = m_socket.accept(addr);
[-] 	socket->m_socket.attach (h);
[+] 	socket->m_socket.attach(h);
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_UsbContext.cpp
----------------------
[-] UsbContext::create ()
[+] UsbContext::create()
[-] 	close ();
[+] 	close();
[-] 	int result = libusb_init (&m_h);
[+] 	int result = libusb_init(&m_h);
[-] 	return result == 0 ? true : err::fail (UsbError ((int) result));
[+] 	return result == 0 ? true : err::fail(UsbError((int)result));
[-] UsbContext::createDefault ()
[+] UsbContext::createDefault()
[-] 	close ();
[+] 	close();
[-] 	int result = libusb_init (NULL);
[+] 	int result = libusb_init(NULL);
[-] 		return err::fail (UsbError ((int) result));
[+] 		return err::fail(UsbError((int)result));
[-] UsbContext::handleEvents (uint_t timeout)
[+] UsbContext::handleEvents(uint_t timeout)
[-] 		return handleEvents ();
[+] 		return handleEvents();
[-] 	int result = libusb_handle_events_timeout (m_h, &tv);
[+] 	int result = libusb_handle_events_timeout(m_h, &tv);
[-] 	return result == 0 ? true : err::fail (UsbError ((int) result));
[+] 	return result == 0 ? true : err::fail(UsbError((int)result));
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_UsbDevice.cpp
----------------------
[-] getUsbSpeedString (libusb_speed speed)
[+] getUsbSpeedString(libusb_speed speed)
[-] 	static const char* stringTable [] =
[+] 	static const char* stringTable[] =
[-] 	return (size_t) speed < countof (stringTable) ?
[+] 	return (size_t)speed < countof(stringTable) ?
[-] 		stringTable [speed] :
[+] 		stringTable[speed] :
[-] 		stringTable [LIBUSB_SPEED_UNKNOWN];
[+] 		stringTable[LIBUSB_SPEED_UNKNOWN];
[-] getUsbClassCodeString (libusb_class_code classCode)
[+] getUsbClassCodeString(libusb_class_code classCode)
[-] 	static const char* stringTable [] =
[+] 	static const char* stringTable[] =
[-] 	if ((size_t) classCode < countof (stringTable))
[+] 	if ((size_t)classCode < countof(stringTable))
[-] 		return stringTable [classCode];
[+] 		return stringTable[classCode];
[-] 	switch (classCode)
[+] 	switch(classCode)
[-] getUsbTransferTypeString (libusb_transfer_type transferType)
[+] getUsbTransferTypeString(libusb_transfer_type transferType)
[-] 	static const char* stringTable [] =
[+] 	static const char* stringTable[] =
[-] 	return (size_t) transferType < countof (stringTable) ?
[+] 	return (size_t)transferType < countof(stringTable) ?
[-] 		stringTable [transferType] :
[+] 		stringTable[transferType] :
[-] findUsbInterfaceDescriptor (
[+] findUsbInterfaceDescriptor(
[-] 	const libusb_interface* iface = &configDesc->interface [interfaceId];
[+] 	const libusb_interface* iface = &configDesc->interface[interfaceId];
[-] 	return altSettingId < (uint_t) iface->num_altsetting ?
[+] 	return altSettingId < (uint_t)iface->num_altsetting ?
[-] 		&iface->altsetting [altSettingId] :
[+] 		&iface->altsetting[altSettingId] :
[-] findUsbEndpointDescriptor (
[+] findUsbEndpointDescriptor(
[-] 		const libusb_endpoint_descriptor* endpointDesc = &ifaceDesc->endpoint [k];
[+] 		const libusb_endpoint_descriptor* endpointDesc = &ifaceDesc->endpoint[k];
[-] UsbDeviceList::enumerateDevices (libusb_context* context)
[+] UsbDeviceList::enumerateDevices(libusb_context* context)
[-] 	close ();
[+] 	close();
[-] 	ssize_t result = libusb_get_device_list (context, &m_h);
[+] 	ssize_t result = libusb_get_device_list(context, &m_h);
[-] 	return result >= 0 ? result : err::fail <size_t> (-1, UsbError ((int) result));
[+] 	return result >= 0 ? result : err::fail<size_t> (-1, UsbError((int)result));
[-] UsbDevice::getMaxPacketSize (uint_t endpointId)
[+] UsbDevice::getMaxPacketSize(uint_t endpointId)
[-] 	ASSERT (m_device);
[+] 	ASSERT(m_device);
[-] 	int result = libusb_get_max_packet_size (m_device, (uchar_t) endpointId);
[+] 	int result = libusb_get_max_packet_size(m_device, (uchar_t)endpointId);
[-] 	return result >= 0 ? result : err::fail <size_t> (-1, UsbError (result));
[+] 	return result >= 0 ? result : err::fail<size_t> (-1, UsbError(result));
[-] UsbDevice::getPortPath (
[+] UsbDevice::getPortPath(
[-] 	ASSERT (m_device);
[+] 	ASSERT(m_device);
[-] 	int result = libusb_get_port_numbers (m_device, path, maxLength);
[+] 	int result = libusb_get_port_numbers(m_device, path, maxLength);
[-] 	return result >= 0 ? result : err::fail <size_t> (-1, UsbError (result));
[+] 	return result >= 0 ? result : err::fail<size_t> (-1, UsbError(result));
[-] UsbDevice::getMaxIsoPacketSize (uint_t endpointId)
[+] UsbDevice::getMaxIsoPacketSize(uint_t endpointId)
[-] 	ASSERT (m_device);
[+] 	ASSERT(m_device);
[-] 	int result = libusb_get_max_iso_packet_size (m_device, (uchar_t) endpointId);
[+] 	int result = libusb_get_max_iso_packet_size(m_device, (uchar_t)endpointId);
[-] 	return result >= 0 ? result : err::fail <size_t> (-1, UsbError (result));
[+] 	return result >= 0 ? result : err::fail<size_t> (-1, UsbError(result));
[-] UsbDevice::setDevice (libusb_device* device)
[+] UsbDevice::setDevice(libusb_device* device)
[-] 	close ();
[+] 	close();
[-] 		libusb_ref_device (device);
[+] 		libusb_ref_device(device);
[-] 		libusb_unref_device (m_device);
[+] 		libusb_unref_device(m_device);
[-] UsbDevice::close ()
[+] UsbDevice::close()
[-] 	libusb_close (m_openHandle);
[+] 	libusb_close(m_openHandle);
[-] UsbDevice::open ()
[+] UsbDevice::open()
[-] 	ASSERT (m_device);
[+] 	ASSERT(m_device);
[-] 	close ();
[+] 	close();
[-] 	int result = libusb_open (m_device, &m_openHandle);
[+] 	int result = libusb_open(m_device, &m_openHandle);
[-] 	return result == 0 ? true : err::fail (UsbError (result));
[+] 	return result == 0 ? true : err::fail(UsbError(result));
[-] UsbDevice::open (
[+] UsbDevice::open(
[-] 	close ();
[+] 	close();
[-] 	m_openHandle = libusb_open_device_with_vid_pid (context, (uint16_t) vendorId, (uint16_t) productId);
[+] 	m_openHandle = libusb_open_device_with_vid_pid(context, (uint16_t)vendorId, (uint16_t)productId);
[-] 		return err::fail (err::Error (err::SystemErrorCode_ObjectNameNotFound));
[+] 		return err::fail(err::Error(err::SystemErrorCode_ObjectNameNotFound));
[-] 	m_device = libusb_get_device (m_openHandle);
[+] 	m_device = libusb_get_device(m_openHandle);
[-] 	ASSERT (m_device);
[+] 	ASSERT(m_device);
[-] 	libusb_ref_device (m_device);
[+] 	libusb_ref_device(m_device);
[-] UsbDevice::getConfiguration ()
[+] UsbDevice::getConfiguration()
[-] 	ASSERT (m_openHandle);
[+] 	ASSERT(m_openHandle);
[-] 	int result = libusb_get_configuration (m_openHandle, &configurationId);
[+] 	int result = libusb_get_configuration(m_openHandle, &configurationId);
[-] 	return result == 0 ? configurationId : err::fail <uint_t> (-1, UsbError (result));
[+] 	return result == 0 ? configurationId : err::fail<uint_t> (-1, UsbError(result));
[-] UsbDevice::setConfiguration (uint_t configurationId)
[+] UsbDevice::setConfiguration(uint_t configurationId)
[-] 	ASSERT (m_openHandle);
[+] 	ASSERT(m_openHandle);
[-] 	int result = libusb_set_configuration (m_openHandle, configurationId);
[+] 	int result = libusb_set_configuration(m_openHandle, configurationId);
[-] 	return result == 0 ? true : err::fail (UsbError (result));
[+] 	return result == 0 ? true : err::fail(UsbError(result));
[-] UsbDevice::claimInterface (uint_t ifaceId)
[+] UsbDevice::claimInterface(uint_t ifaceId)
[-] 	ASSERT (m_openHandle);
[+] 	ASSERT(m_openHandle);
[-] 	int result = libusb_claim_interface (m_openHandle, ifaceId);
[+] 	int result = libusb_claim_interface(m_openHandle, ifaceId);
[-] 	return result == 0 ? true : err::fail (UsbError (result));
[+] 	return result == 0 ? true : err::fail(UsbError(result));
[-] UsbDevice::releaseInterface (uint_t ifaceId)
[+] UsbDevice::releaseInterface(uint_t ifaceId)
[-] 	ASSERT (m_openHandle);
[+] 	ASSERT(m_openHandle);
[-] 	int result = libusb_release_interface (m_openHandle, ifaceId);
[+] 	int result = libusb_release_interface(m_openHandle, ifaceId);
[-] 	return result == 0 ? true : err::fail (UsbError (result));
[+] 	return result == 0 ? true : err::fail(UsbError(result));
[-] UsbDevice::setInterfaceAltSetting (
[+] UsbDevice::setInterfaceAltSetting(
[-] 	ASSERT (m_openHandle);
[+] 	ASSERT(m_openHandle);
[-] 	int result = libusb_set_interface_alt_setting (m_openHandle, ifaceId, altSettingId);
[+] 	int result = libusb_set_interface_alt_setting(m_openHandle, ifaceId, altSettingId);
[-] 	return result == 0 ? true : err::fail (UsbError (result));
[+] 	return result == 0 ? true : err::fail(UsbError(result));
[-] UsbDevice::clearHalt (uint_t endpointId)
[+] UsbDevice::clearHalt(uint_t endpointId)
[-] 	ASSERT (m_openHandle);
[+] 	ASSERT(m_openHandle);
[-] 	int result = libusb_clear_halt (m_openHandle, (uchar_t) endpointId);
[+] 	int result = libusb_clear_halt(m_openHandle, (uchar_t)endpointId);
[-] 	return result == 0 ? true : err::fail (UsbError (result));
[+] 	return result == 0 ? true : err::fail(UsbError(result));
[-] UsbDevice::resetDevice ()
[+] UsbDevice::resetDevice()
[-] 	ASSERT (m_openHandle);
[+] 	ASSERT(m_openHandle);
[-] 	int result = libusb_reset_device (m_openHandle);
[+] 	int result = libusb_reset_device(m_openHandle);
[-] 	return result == 0 ? true : err::fail (UsbError (result));
[+] 	return result == 0 ? true : err::fail(UsbError(result));
[-] UsbDevice::isKernelDriverActive (uint_t ifaceId)
[+] UsbDevice::isKernelDriverActive(uint_t ifaceId)
[-] 	ASSERT (m_openHandle);
[+] 	ASSERT(m_openHandle);
[-] 	int result = libusb_kernel_driver_active (m_openHandle, ifaceId);
[+] 	int result = libusb_kernel_driver_active(m_openHandle, ifaceId);
[-] UsbDevice::attachKernelDriver (uint_t ifaceId)
[+] UsbDevice::attachKernelDriver(uint_t ifaceId)
[-] 	ASSERT (m_openHandle);
[+] 	ASSERT(m_openHandle);
[-] 	int result = libusb_attach_kernel_driver (m_openHandle, ifaceId);
[+] 	int result = libusb_attach_kernel_driver(m_openHandle, ifaceId);
[-] 	return result == 0 ? true : err::fail (UsbError (result));
[+] 	return result == 0 ? true : err::fail(UsbError(result));
[-] UsbDevice::detachKernelDriver (uint_t ifaceId)
[+] UsbDevice::detachKernelDriver(uint_t ifaceId)
[-] 	ASSERT (m_openHandle);
[+] 	ASSERT(m_openHandle);
[-] 	int result = libusb_detach_kernel_driver (m_openHandle, ifaceId);
[+] 	int result = libusb_detach_kernel_driver(m_openHandle, ifaceId);
[-] 	return result == 0 ? true : err::fail (UsbError (result));
[+] 	return result == 0 ? true : err::fail(UsbError(result));
[-] UsbDevice::setAutoDetachKernelDriver (bool isAutoDetach)
[+] UsbDevice::setAutoDetachKernelDriver(bool isAutoDetach)
[-] 	ASSERT (m_openHandle);
[+] 	ASSERT(m_openHandle);
[-] 	int result = libusb_set_auto_detach_kernel_driver (m_openHandle, isAutoDetach);
[+] 	int result = libusb_set_auto_detach_kernel_driver(m_openHandle, isAutoDetach);
[-] 	return result == 0 ? true : err::fail (UsbError (result));
[+] 	return result == 0 ? true : err::fail(UsbError(result));
[-] UsbDevice::getDescriptor (
[+] UsbDevice::getDescriptor(
[-] 	sl::Array <char>* descriptor
[+] 	sl::Array<char>* descriptor
[-] 	ASSERT (m_openHandle);
[+] 	ASSERT(m_openHandle);
[-] 	size_t size = descriptor->getCount ();
[+] 	size_t size = descriptor->getCount();
[-] 	size = size < Def_BufferSize ? Def_BufferSize : sl::getAllocSize (size);
[+] 	size = size < Def_BufferSize ? Def_BufferSize : sl::getAllocSize(size);
[-] 	descriptor->setCount (size);
[+] 	descriptor->setCount(size);
[-] 		int result = libusb_get_descriptor (
[+] 		int result = libusb_get_descriptor(
[-] 			(uint8_t) descriptorType,
[+] 			(uint8_t)descriptorType,
[-] 			(uint8_t) descriptorId,
[+] 			(uint8_t)descriptorId,
[-] 			(uchar_t*) descriptor->p (),
[+] 			(uchar_t*)descriptor->p(),
[-] 			return err::fail (UsbError (result));
[+] 			return err::fail(UsbError(result));
[-] 		descriptor->setCount (size);
[+] 		descriptor->setCount(size);
[-] 	descriptor->setCount (size);
[+] 	descriptor->setCount(size);
[-] UsbDevice::getDeviceDescriptor (libusb_device_descriptor* descriptor)
[+] UsbDevice::getDeviceDescriptor(libusb_device_descriptor* descriptor)
[-] 	ASSERT (m_device);
[+] 	ASSERT(m_device);
[-] 	int result = libusb_get_device_descriptor (m_device, descriptor);
[+] 	int result = libusb_get_device_descriptor(m_device, descriptor);
[-] 	return result == 0 ? true : err::fail (UsbError (result));
[+] 	return result == 0 ? true : err::fail(UsbError(result));
[-] UsbDevice::getConfigDescriptor (
[+] UsbDevice::getConfigDescriptor(
[-] 	ASSERT (m_device);
[+] 	ASSERT(m_device);
[-] 	int result = libusb_get_config_descriptor (m_device, configurationId, &buffer);
[+] 	int result = libusb_get_config_descriptor(m_device, configurationId, &buffer);
[-] 		return err::fail (UsbError (result));
[+] 		return err::fail(UsbError(result));
[-] 	desc->attach (buffer);
[+] 	desc->attach(buffer);
[-] UsbDevice::getActiveConfigDescriptor (UsbConfigDescriptor* desc)
[+] UsbDevice::getActiveConfigDescriptor(UsbConfigDescriptor* desc)
[-] 	ASSERT (m_device);
[+] 	ASSERT(m_device);
[-] 	int result = libusb_get_active_config_descriptor (m_device, &buffer);
[+] 	int result = libusb_get_active_config_descriptor(m_device, &buffer);
[-] 		return err::fail (UsbError (result));
[+] 		return err::fail(UsbError(result));
[-] 	desc->attach (buffer);
[+] 	desc->attach(buffer);
[-] UsbDevice::getStringDesrciptor (
[+] UsbDevice::getStringDesrciptor(
[-] 	ASSERT (m_openHandle);
[+] 	ASSERT(m_openHandle);
[-] 	char* p = string->getBuffer (&length);
[+] 	char* p = string->getBuffer(&length);
[-] 		p = string->createBuffer (length - 1);
[+] 		p = string->createBuffer(length - 1);
[-] 		int result = libusb_get_string_descriptor (
[+] 		int result = libusb_get_string_descriptor(
[-] 			(uint8_t) stringId,
[+] 			(uint8_t)stringId,
[-] 			(uint16_t) langId,
[+] 			(uint16_t)langId,
[-] 			(uchar_t*) p,
[+] 			(uchar_t*)p,
[-] 			return err::fail (UsbError (result));
[+] 			return err::fail(UsbError(result));
[-] 		p = string->createBuffer (length - 1);
[+] 		p = string->createBuffer(length - 1);
[-] 	string->setReducedLength (length);
[+] 	string->setReducedLength(length);
[-] UsbDevice::getStringDesrciptor (
[+] UsbDevice::getStringDesrciptor(
[-] 	ASSERT (m_openHandle);
[+] 	ASSERT(m_openHandle);
[-] 	char* p = string->getBuffer (&length);
[+] 	char* p = string->getBuffer(&length);
[-] 		p = string->createBuffer (length - 1);
[+] 		p = string->createBuffer(length - 1);
[-] 		int result = libusb_get_string_descriptor_ascii (
[+] 		int result = libusb_get_string_descriptor_ascii(
[-] 			(uint8_t) stringId,
[+] 			(uint8_t)stringId,
[-] 			(uchar_t*) p,
[+] 			(uchar_t*)p,
[-] 			return err::fail (UsbError (result));
[+] 			return err::fail(UsbError(result));
[-] 		p = string->createBuffer (length - 1);
[+] 		p = string->createBuffer(length - 1);
[-] 	string->setReducedLength (length);
[+] 	string->setReducedLength(length);
[-] UsbDevice::controlTransfer (
[+] UsbDevice::controlTransfer(
[-] 	ASSERT (m_openHandle);
[+] 	ASSERT(m_openHandle);
[-] 	int result = libusb_control_transfer (
[+] 	int result = libusb_control_transfer(
[-] 		(uint8_t) requestType,
[+] 		(uint8_t)requestType,
[-] 		(uint8_t) requestCode,
[+] 		(uint8_t)requestCode,
[-] 		(uint16_t) value,
[+] 		(uint16_t)value,
[-] 		(uint16_t) index,
[+] 		(uint16_t)index,
[-] 		(uchar_t*) p,
[+] 		(uchar_t*)p,
[-] 		(uint16_t) size,
[+] 		(uint16_t)size,
[-] 	return result >= 0 ? result : err::fail <size_t> (-1, UsbError (result));
[+] 	return result >= 0 ? result : err::fail<size_t> (-1, UsbError(result));
[-] UsbDevice::bulkTransfer (
[+] UsbDevice::bulkTransfer(
[-] 	ASSERT (m_openHandle);
[+] 	ASSERT(m_openHandle);
[-] 	int result = libusb_bulk_transfer (
[+] 	int result = libusb_bulk_transfer(
[-] 		(uchar_t) endpointId,
[+] 		(uchar_t)endpointId,
[-] 		(uchar_t*) p,
[+] 		(uchar_t*)p,
[-] 		(int) size,
[+] 		(int)size,
[-] 	return result == 0 ? actualSize : err::fail <size_t> (-1, UsbError (result));
[+] 	return result == 0 ? actualSize : err::fail<size_t> (-1, UsbError(result));
[-] UsbDevice::interruptTransfer (
[+] UsbDevice::interruptTransfer(
[-] 	ASSERT (m_openHandle);
[+] 	ASSERT(m_openHandle);
[-] 	int result = libusb_interrupt_transfer (
[+] 	int result = libusb_interrupt_transfer(
[-] 		(uchar_t) endpointId,
[+] 		(uchar_t)endpointId,
[-] 		(uchar_t*) p,
[+] 		(uchar_t*)p,
[-] 		(int) size,
[+] 		(int)size,
[-] 	return result == 0 ? actualSize : err::fail <size_t> (-1, UsbError (result));
[+] 	return result == 0 ? actualSize : err::fail<size_t> (-1, UsbError(result));
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_UsbError.cpp
----------------------
[-] UsbError::create (int code)
[+] UsbError::create(int code)
[-] 	err::ErrorHdr* error = createBuffer (sizeof (err::ErrorHdr));
[+] 	err::ErrorHdr* error = createBuffer(sizeof(err::ErrorHdr));
[-] 	error->m_size = sizeof (err::ErrorHdr);
[+] 	error->m_size = sizeof(err::ErrorHdr);
[-] 	return sizeof (err::ErrorHdr);
[+] 	return sizeof(err::ErrorHdr);
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_UsbEventThread.cpp
----------------------
[-] UsbEventThread::start (libusb_context* context)
[+] UsbEventThread::start(libusb_context* context)
[-] 	stop ();
[+] 	stop();
[-] 	return ThreadImpl <UsbEventThread>::start ();
[+] 	return ThreadImpl<UsbEventThread>::start();
[-] UsbEventThread::threadFunc ()
[+] UsbEventThread::threadFunc()
[-] 	context.attach (m_context);
[+] 	context.attach(m_context);
[-] 		context.handleEvents (TimerGranularity);
[+] 		context.handleEvents(TimerGranularity);
[-] 	context.detach ();
[+] 	context.detach();
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_UsbTransfer.cpp
----------------------
[-] getUsbTransferStatusString (libusb_transfer_status status)
[+] getUsbTransferStatusString(libusb_transfer_status status)
[-] 	const char* stringTable [] =
[+] 	const char* stringTable[] =
[-] 	return (size_t) status < countof (stringTable) ?
[+] 	return (size_t)status < countof(stringTable) ?
[-] 		stringTable [(size_t) status] :
[+] 		stringTable[(size_t)status] :
[-] UsbTransfer::create (size_t isochronousPacketCount)
[+] UsbTransfer::create(size_t isochronousPacketCount)
[-] 	close ();
[+] 	close();
[-] 	m_h = libusb_alloc_transfer (isochronousPacketCount);
[+] 	m_h = libusb_alloc_transfer(isochronousPacketCount);
[-] 		err::setError (err::SystemErrorCode_InsufficientResources);
[+] 		err::setError(err::SystemErrorCode_InsufficientResources);
[-] UsbTransfer::submit ()
[+] UsbTransfer::submit()
[-] 	ASSERT (m_h);
[+] 	ASSERT(m_h);
[-] 	int result = libusb_submit_transfer (m_h);
[+] 	int result = libusb_submit_transfer(m_h);
[-] 	return result == 0 ? true : err::fail (UsbError (result));
[+] 	return result == 0 ? true : err::fail(UsbError(result));
[-] UsbTransfer::cancel ()
[+] UsbTransfer::cancel()
[-] 	ASSERT (m_h);
[+] 	ASSERT(m_h);
[-] 	int result = libusb_cancel_transfer (m_h);
[+] 	int result = libusb_cancel_transfer(m_h);
[-] 	return result == 0 ? true : err::fail (UsbError (result));
[+] 	return result == 0 ? true : err::fail(UsbError(result));
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_win_File.cpp
----------------------
[-] File::create (
[+] File::create(
[-] 	close ();
[+] 	close();
[-] 	m_h = ::CreateFileW (
[+] 	m_h = ::CreateFileW(
[-] 		fileName.sz (),
[+] 		fileName.sz(),
[-] 	return err::complete (m_h != INVALID_HANDLE_VALUE);
[+] 	return err::complete(m_h != INVALID_HANDLE_VALUE);
[-] File::duplicate (
[+] File::duplicate(
[-] 	close ();
[+] 	close();
[-] 	bool_t result = ::DuplicateHandle (
[+] 	bool_t result = ::DuplicateHandle(
[-] 	return err::complete (result);
[+] 	return err::complete(result);
[-] File::getSize () const
[+] File::getSize() const
[-] 	size.LowPart = ::GetFileSize (m_h, &size.HighPart);
[+] 	size.LowPart = ::GetFileSize(m_h, &size.HighPart);
[-] 		return err::failWithLastSystemError (-1);
[+] 		return err::failWithLastSystemError(-1);
[-] File::setSize (uint64_t size)
[+] File::setSize(uint64_t size)
[-] 	uint64_t position = getPosition ();
[+] 	uint64_t position = getPosition();
[-] 	bool_t result = setPosition (size);
[+] 	bool_t result = setPosition(size);
[-] 	result = ::SetEndOfFile (m_h);
[+] 	result = ::SetEndOfFile(m_h);
[-] 		return err::failWithLastSystemError ();
[+] 		return err::failWithLastSystemError();
[-] 	setPosition (position);
[+] 	setPosition(position);
[-] File::getPosition () const
[+] File::getPosition() const
[-] 	offset.LowPart = ::SetFilePointer (m_h, 0, &offset.HighPart, FILE_CURRENT);
[+] 	offset.LowPart = ::SetFilePointer(m_h, 0, &offset.HighPart, FILE_CURRENT);
[-] 		return err::failWithLastSystemError <uint64_t> (-1);
[+] 		return err::failWithLastSystemError<uint64_t> (-1);
[-] File::setPosition (uint64_t _Offset) const
[+] File::setPosition(uint64_t _Offset) const
[-] 	dword_t result = ::SetFilePointer (m_h, offset.LowPart, &offset.HighPart, FILE_BEGIN);
[+] 	dword_t result = ::SetFilePointer(m_h, offset.LowPart, &offset.HighPart, FILE_BEGIN);
[-] 	return err::complete (result != INVALID_SET_FILE_POINTER);
[+] 	return err::complete(result != INVALID_SET_FILE_POINTER);
[-] File::read (
[+] File::read(
[-] 	bool result = read (p, (dword_t) size, &actualSize);
[+] 	bool result = read(p, (dword_t)size, &actualSize);
[-] 	return result ? (size_t) actualSize : -1;
[+] 	return result ? (size_t)actualSize : -1;
[-] File::write (
[+] File::write(
[-] 	bool result = write (p, (dword_t) size, &actualSize);
[+] 	bool result = write(p, (dword_t)size, &actualSize);
[-] 	return result ? (size_t) actualSize : -1;
[+] 	return result ? (size_t)actualSize : -1;
[-] File::overlappedRead (
[+] File::overlappedRead(
[-] 	bool result = overlappedRead (p, (dword_t) size, &actualSize);
[+] 	bool result = overlappedRead(p, (dword_t)size, &actualSize);
[-] 	return result ? (size_t) actualSize : -1;
[+] 	return result ? (size_t)actualSize : -1;
[-] File::overlappedWrite (
[+] File::overlappedWrite(
[-] 	bool result = overlappedWrite (p, (dword_t) size, &actualSize);
[+] 	bool result = overlappedWrite(p, (dword_t)size, &actualSize);
[-] 	return result ? (size_t) actualSize : -1;
[+] 	return result ? (size_t)actualSize : -1;
[-] File::overlappedRead (
[+] File::overlappedRead(
[-] 	bool result = overlappedRead (p, size, &overlapped);
[+] 	bool result = overlappedRead(p, size, &overlapped);
[-] 	return result ? getOverlappedResult (&overlapped, actualSize) : false;
[+] 	return result ? getOverlappedResult(&overlapped, actualSize) : false;
[-] File::overlappedWrite (
[+] File::overlappedWrite(
[-] 	bool result = overlappedWrite (p, size, &overlapped);
[+] 	bool result = overlappedWrite(p, size, &overlapped);
[-] 	return result ? getOverlappedResult (&overlapped, actualSize) : false;
[+] 	return result ? getOverlappedResult(&overlapped, actualSize) : false;
[-] File::overlappedIoctl (
[+] File::overlappedIoctl(
[-] 	bool result = overlappedIoctl (code, inData, inDataSize, outData, outDataSize, &overlapped);
[+] 	bool result = overlappedIoctl(code, inData, inDataSize, outData, outDataSize, &overlapped);
[-] 	return result ? getOverlappedResult (&overlapped, actualSize) : false;
[+] 	return result ? getOverlappedResult(&overlapped, actualSize) : false;
[-] File::completeOverlappedRequest (bool_t result)
[+] File::completeOverlappedRequest(bool_t result)
[-] 	dword_t error = ::GetLastError ();
[+] 	dword_t error = ::GetLastError();
[-] 		err::setError (error);
[+] 		err::setError(error);
[-] File::getOverlappedResult (
[+] File::getOverlappedResult(
[-] 	bool_t result = ::GetOverlappedResult (m_h, overlapped, actualSize, true);
[+] 	bool_t result = ::GetOverlappedResult(m_h, overlapped, actualSize, true);
[-] 		DWORD error = ::GetLastError ();
[+] 		DWORD error = ::GetLastError();
[-] 			err::setError (error);
[+] 			err::setError(error);
[-] File::getOverlappedResult (OVERLAPPED* overlapped) const
[+] File::getOverlappedResult(OVERLAPPED* overlapped) const
[-] 	bool result = getOverlappedResult (overlapped, &actualSize);
[+] 	bool result = getOverlappedResult(overlapped, &actualSize);
[-] 	return result ? (size_t) actualSize : -1;
[+] 	return result ? (size_t)actualSize : -1;
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_win_Iocp.cpp
----------------------
[-] Iocp::create (dword_t threadCount)
[+] Iocp::create(dword_t threadCount)
[-] 	close ();
[+] 	close();
[-] 	m_h = ::CreateIoCompletionPort (INVALID_HANDLE_VALUE, NULL, 0, threadCount);
[+] 	m_h = ::CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, threadCount);
[-] 	return err::complete (m_h != NULL);
[+] 	return err::complete(m_h != NULL);
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_win_Mapping.cpp
----------------------
[-] Mapping::create (
[+] Mapping::create(
[-] 	close ();
[+] 	close();
[-] 	m_h = ::CreateFileMappingW (
[+] 	m_h = ::CreateFileMappingW(
[-] 		name.sz ()
[+] 		name.sz()
[-] 	return err::complete (m_h != NULL);
[+] 	return err::complete(m_h != NULL);
[-] Mapping::open (
[+] Mapping::open(
[-] 	close ();
[+] 	close();
[-] 	m_h = ::OpenFileMappingW (access, doInheritHandle, name.sz ());
[+] 	m_h = ::OpenFileMappingW(access, doInheritHandle, name.sz());
[-] 	return err::complete (m_h != NULL);
[+] 	return err::complete(m_h != NULL);
[-] MappedView::view (
[+] MappedView::view(
[-] 	close ();
[+] 	close();
[-] 	m_h = ::MapViewOfFile (hMapping, access, offset.HighPart, offset.LowPart, size);
[+] 	m_h = ::MapViewOfFile(hMapping, access, offset.HighPart, offset.LowPart, size);
[-] 		err::failWithLastSystemError ();
[+] 		err::failWithLastSystemError();
----------------------
27/02/2019 18:01:50 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_win_NamedPipe.cpp
----------------------
[-] NamedPipe::create (
[+] NamedPipe::create(
[-] 	close ();
[+] 	close();
[-] 	m_h = ::CreateNamedPipeW (
[+] 	m_h = ::CreateNamedPipeW(
[-] 		name.sz (),
[+] 		name.sz(),
[-] 	return err::complete (m_h != INVALID_HANDLE_VALUE);
[+] 	return err::complete(m_h != INVALID_HANDLE_VALUE);
[-] NamedPipe::open (
[+] NamedPipe::open(
[-] 	close ();
[+] 	close();
[-] 	m_h = ::CreateFileW (name.sz (), access, 0, NULL, OPEN_EXISTING, flags, NULL);
[+] 	m_h = ::CreateFileW(name.sz(), access, 0, NULL, OPEN_EXISTING, flags, NULL);
[-] 	return err::complete (m_h != INVALID_HANDLE_VALUE);
[+] 	return err::complete(m_h != INVALID_HANDLE_VALUE);
[-] NamedPipe::overlappedConnect ()
[+] NamedPipe::overlappedConnect()
[-] 	bool result = overlappedConnect (&overlapped);
[+] 	bool result = overlappedConnect(&overlapped);
[-] 	return result ? getOverlappedResult (&overlapped, &actualSize) : false;
[+] 	return result ? getOverlappedResult(&overlapped, &actualSize) : false;
----------------------
27/02/2019 18:01:51 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_win_NetworkAdapterEnumerator.cpp
----------------------
[-] 	createAdapterList (sl::List <NetworkAdapterDesc>* adapterList);
[+] 	createAdapterList(sl::List<NetworkAdapterDesc>* adapterList);
[-] 	setupAdapter (
[+] 	setupAdapter(
[-] NetworkAdapterEnumerator::createAdapterList (sl::List <NetworkAdapterDesc>* adapterList)
[+] NetworkAdapterEnumerator::createAdapterList(sl::List<NetworkAdapterDesc>* adapterList)
[-] 	adapterList->clear ();
[+] 	adapterList->clear();
[-] 	sl::Array <char> buffer;
[+] 	sl::Array<char> buffer;
[-] 	buffer.setCount (size);
[+] 	buffer.setCount(size);
[-] 	IP_ADAPTER_ADDRESSES* srcAdapter = (IP_ADAPTER_ADDRESSES*) buffer.p ();
[+] 	IP_ADAPTER_ADDRESSES* srcAdapter = (IP_ADAPTER_ADDRESSES*)buffer.p();
[-] 		ulong_t error = ::GetAdaptersAddresses (AF_UNSPEC, flags, NULL, srcAdapter, &size);
[+] 		ulong_t error = ::GetAdaptersAddresses(AF_UNSPEC, flags, NULL, srcAdapter, &size);
[-] 			err::setError (error);
[+] 			err::setError(error);
[-] 		NetworkAdapterDesc* adapter = AXL_MEM_NEW (NetworkAdapterDesc);
[+] 		NetworkAdapterDesc* adapter = AXL_MEM_NEW(NetworkAdapterDesc);
[-] 		setupAdapter (adapter, srcAdapter);
[+] 		setupAdapter(adapter, srcAdapter);
[-] 		adapterList->insertTail (adapter);
[+] 		adapterList->insertTail(adapter);
[-] 	return adapterList->getCount ();
[+] 	return adapterList->getCount();
[-] NetworkAdapterEnumerator::setupAdapter (
[+] NetworkAdapterEnumerator::setupAdapter(
[-] 	switch (srcAdapter->IfType)
[+] 	switch(srcAdapter->IfType)
[-] 	memcpy (adapter->m_mac, srcAdapter->PhysicalAddress, 6);
[+] 	memcpy(adapter->m_mac, srcAdapter->PhysicalAddress, 6);
[-] 		if (!srcAddress->Address.lpSockaddr || srcAddress->Address.iSockaddrLength > sizeof (io::SockAddr))
[+] 		if (!srcAddress->Address.lpSockaddr || srcAddress->Address.iSockaddrLength > sizeof(io::SockAddr))
[-] 		NetworkAdapterAddress* address = AXL_MEM_NEW (NetworkAdapterAddress);
[+] 		NetworkAdapterAddress* address = AXL_MEM_NEW(NetworkAdapterAddress);
[-] 		memcpy (&address->m_address, srcAddress->Address.lpSockaddr, srcAddress->Address.iSockaddrLength);
[+] 		memcpy(&address->m_address, srcAddress->Address.lpSockaddr, srcAddress->Address.iSockaddrLength);
[-] 		if (srcAddress->Length >= sizeof (IP_ADAPTER_UNICAST_ADDRESS))
[+] 		if (srcAddress->Length >= sizeof(IP_ADAPTER_UNICAST_ADDRESS))
[-] 		adapter->m_addressList.insertTail (address);
[+] 		adapter->m_addressList.insertTail(address);
[-] createNetworkAdapterDescList (sl::List <NetworkAdapterDesc>* adapterList)
[+] createNetworkAdapterDescList(sl::List<NetworkAdapterDesc>* adapterList)
[-] 	return NetworkAdapterEnumerator::createAdapterList (adapterList);
[+] 	return NetworkAdapterEnumerator::createAdapterList(adapterList);
----------------------
27/02/2019 18:01:51 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_win_Serial.cpp
----------------------
[-] Serial::open (
[+] Serial::open(
[-] 	close ();
[+] 	close();
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::String_w deviceName (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::String_w deviceName(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	if (name.isPrefix ("\\\\.\\"))
[+] 	if (name.isPrefix("\\\\.\\"))
[-] 		deviceName += name.getSubString (4);
[+] 		deviceName += name.getSubString(4);
[-] 	m_h = ::CreateFileW (
[+] 	m_h = ::CreateFileW(
[-] 	return err::complete (m_h != INVALID_HANDLE_VALUE);
[+] 	return err::complete(m_h != INVALID_HANDLE_VALUE);
[-] Serial::getStatusLines ()
[+] Serial::getStatusLines()
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 	bool_t result = ::GetCommModemStatus (m_h, &lines);
[+] 	bool_t result = ::GetCommModemStatus(m_h, &lines);
[-] 		return err::failWithLastSystemError (-1);
[+] 		return err::failWithLastSystemError(-1);
[-] Serial::getWaitMask ()
[+] Serial::getWaitMask()
[-] 	bool_t result = ::GetCommMask (m_h, &mask);
[+] 	bool_t result = ::GetCommMask(m_h, &mask);
[-] 		return err::failWithLastSystemError (-1);
[+] 		return err::failWithLastSystemError(-1);
[-] Serial::overlappedWait (dword_t* events)
[+] Serial::overlappedWait(dword_t* events)
[-] 	bool result = overlappedWait (events, &overlapped);
[+] 	bool result = overlappedWait(events, &overlapped);
[-] 	return result ? getOverlappedResult (&overlapped, &actualSize) : false;
[+] 	return result ? getOverlappedResult(&overlapped, &actualSize) : false;
----------------------
27/02/2019 18:01:51 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_win_SerialPortEnumerator.cpp
----------------------
[-] 	createPortList (sl::List <SerialPortDesc>* portList);
[+] 	createPortList(sl::List<SerialPortDesc>* portList);
[-] 	createPortDesc (sys::win::DeviceInfo* deviceInfo);
[+] 	createPortDesc(sys::win::DeviceInfo* deviceInfo);
[-] SerialPortEnumerator::createPortList (sl::List <SerialPortDesc>* portList)
[+] SerialPortEnumerator::createPortList(sl::List<SerialPortDesc>* portList)
[-] 	portList->clear ();
[+] 	portList->clear();
[-] 	result = deviceInfoSet.create (GUID_DEVCLASS_PORTS, DIGCF_PRESENT);
[+] 	result = deviceInfoSet.create(GUID_DEVCLASS_PORTS, DIGCF_PRESENT);
[-] 	result = deviceInfoSet.create (GUID_DEVINTERFACE_COMPORT, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
[+] 	result = deviceInfoSet.create(GUID_DEVINTERFACE_COMPORT, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
[-] 		result = deviceInfoSet.getDeviceInfo (i, &deviceInfo);
[+] 		result = deviceInfoSet.getDeviceInfo(i, &deviceInfo);
[-] 		SerialPortDesc* portDesc = createPortDesc (&deviceInfo);
[+] 		SerialPortDesc* portDesc = createPortDesc(&deviceInfo);
[-] 			portList->insertTail (portDesc);
[+] 			portList->insertTail(portDesc);
[-] 	return portList->getCount ();
[+] 	return portList->getCount();
[-] SerialPortEnumerator::createPortDesc (sys::win::DeviceInfo* deviceInfo)
[+] SerialPortEnumerator::createPortDesc(sys::win::DeviceInfo* deviceInfo)
[-] 	sys::win::RegKeyHandle devRegKey = deviceInfo->openDeviceRegistryKey (KEY_QUERY_VALUE);
[+] 	sys::win::RegKeyHandle devRegKey = deviceInfo->openDeviceRegistryKey(KEY_QUERY_VALUE);
[-] 	result = ::RegQueryValueExA (devRegKey, "PortName", NULL, &type, NULL, &size);
[+] 	result = ::RegQueryValueExA(devRegKey, "PortName", NULL, &type, NULL, &size);
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <char> bufferString (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<char> bufferString(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	bufferString.setCount (size);
[+] 	bufferString.setCount(size);
[-] 	result = ::RegQueryValueExA (
[+] 	result = ::RegQueryValueExA(
[-] 		(byte_t*) bufferString.p (),
[+] 		(byte_t*)bufferString.p(),
[-] 	SerialPortDesc* portDesc = AXL_MEM_NEW (SerialPortDesc);
[+] 	SerialPortDesc* portDesc = AXL_MEM_NEW(SerialPortDesc);
[-] 	deviceInfo->getDeviceRegistryProperty (SPDRP_FRIENDLYNAME, &portDesc->m_description);
[+] 	deviceInfo->getDeviceRegistryProperty(SPDRP_FRIENDLYNAME, &portDesc->m_description);
[-] 	if (portDesc->m_description.isEmpty ()) // try another property
[+] 	if (portDesc->m_description.isEmpty()) // try another property
[-] 		deviceInfo->getDeviceRegistryProperty (SPDRP_DEVICEDESC, &portDesc->m_description);
[+] 		deviceInfo->getDeviceRegistryProperty(SPDRP_DEVICEDESC, &portDesc->m_description);
[-] createSerialPortDescList (sl::List <SerialPortDesc>* portList)
[+] createSerialPortDescList(sl::List<SerialPortDesc>* portList)
[-] 	return SerialPortEnumerator::createPortList (portList);
[+] 	return SerialPortEnumerator::createPortList(portList);
----------------------
27/02/2019 18:01:51 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_win_Socket.cpp
----------------------
[-] Socket::open (
[+] Socket::open(
[-] 	close ();
[+] 	close();
[-] 	m_h = ::socket (addressFamily, sockKind, protocol);
[+] 	m_h = ::socket(addressFamily, sockKind, protocol);
[-] 	return complete (m_h != INVALID_SOCKET);
[+] 	return complete(m_h != INVALID_SOCKET);
[-] Socket::getError ()
[+] Socket::getError()
[-] 	getOption (SOL_SOCKET, SO_ERROR, &error, sizeof (int));
[+] 	getOption(SOL_SOCKET, SO_ERROR, &error, sizeof(int));
[-] Socket::setBlockingMode (bool isBlocking)
[+] Socket::setBlockingMode(bool isBlocking)
[-] 	int result = ::ioctlsocket (m_h, FIONBIO, &value);
[+] 	int result = ::ioctlsocket(m_h, FIONBIO, &value);
[-] 	return complete (m_h != -1);
[+] 	return complete(m_h != -1);
[-] Socket::getIncomingDataSize ()
[+] Socket::getIncomingDataSize()
[-] 	int result = ::ioctlsocket (m_h, FIONREAD, &value);
[+] 	int result = ::ioctlsocket(m_h, FIONREAD, &value);
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
[-] Socket::getAddress (SockAddr* addr)
[+] Socket::getAddress(SockAddr* addr)
[-] 	int size = sizeof (SockAddr);
[+] 	int size = sizeof(SockAddr);
[-] 	int result = ::getsockname (m_h, (sockaddr*) addr, &size);
[+] 	int result = ::getsockname(m_h, (sockaddr*)addr, &size);
[-] 	return complete (result != SOCKET_ERROR);
[+] 	return complete(result != SOCKET_ERROR);
[-] Socket::getPeerAddress (SockAddr* addr)
[+] Socket::getPeerAddress(SockAddr* addr)
[-] 	int size = sizeof (SockAddr);
[+] 	int size = sizeof(SockAddr);
[-] 	int result = ::getpeername (m_h, (sockaddr*) addr, &size);
[+] 	int result = ::getpeername(m_h, (sockaddr*)addr, &size);
[-] 	return complete (result != SOCKET_ERROR);
[+] 	return complete(result != SOCKET_ERROR);
[-] Socket::accept (SockAddr* addr)
[+] Socket::accept(SockAddr* addr)
[-] 	int size = sizeof (SockAddr);
[+] 	int size = sizeof(SockAddr);
[-] 	SOCKET socket = ::accept (
[+] 	SOCKET socket = ::accept(
[-] 		(sockaddr*) addr,
[+] 		(sockaddr*)addr,
[-] 	return complete (socket, INVALID_SOCKET);
[+] 	return complete(socket, INVALID_SOCKET);
[-] Socket::recvFrom (
[+] Socket::recvFrom(
[-] 	int addrSize = sizeof (SockAddr);
[+] 	int addrSize = sizeof(SockAddr);
[-] 	int result = ::recvfrom (
[+] 	int result = ::recvfrom(
[-] 		(char*) p,
[+] 		(char*)p,
[-] 		(int) size,
[+] 		(int)size,
[-] 		(sockaddr*) addr,
[+] 		(sockaddr*)addr,
[-] 	return complete (result, SOCKET_ERROR);
[+] 	return complete(result, SOCKET_ERROR);
[-] Socket::completeAsyncRequest (
[+] Socket::completeAsyncRequest(
[-] 	dword_t error = WSAGetLastError ();
[+] 	dword_t error = WSAGetLastError();
[-] 		err::setError (error);
[+] 		err::setError(error);
[-] Socket::wsaOpen (
[+] Socket::wsaOpen(
[-] 	close ();
[+] 	close();
[-] 	m_h = ::WSASocket (addressFamily, sockKind, protocol, NULL, 0, flags);
[+] 	m_h = ::WSASocket(addressFamily, sockKind, protocol, NULL, 0, flags);
[-] 	return complete (m_h != INVALID_SOCKET);
[+] 	return complete(m_h != INVALID_SOCKET);
[-] Socket::wsaAccept (SockAddr* addr)
[+] Socket::wsaAccept(SockAddr* addr)
[-] 	int addrSize = sizeof (SockAddr);
[+] 	int addrSize = sizeof(SockAddr);
[-] 	SOCKET s = ::WSAAccept (
[+] 	SOCKET s = ::WSAAccept(
[-] 		(sockaddr*) addr,
[+] 		(sockaddr*)addr,
[-] 	return complete (s, INVALID_SOCKET);
[+] 	return complete(s, INVALID_SOCKET);
[-] Socket::wsaSend (
[+] Socket::wsaSend(
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 	buf.buf = (char*) p;
[+] 	buf.buf = (char*)p;
[-] 	int result = ::WSASend (m_h, &buf, 1, actualSize, 0, overlapped, completionFunc);
[+] 	int result = ::WSASend(m_h, &buf, 1, actualSize, 0, overlapped, completionFunc);
[-] 	return completeAsyncRequest (result, WSA_IO_PENDING);
[+] 	return completeAsyncRequest(result, WSA_IO_PENDING);
[-] Socket::wsaRecv (
[+] Socket::wsaRecv(
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 	buf.buf = (char*) p;
[+] 	buf.buf = (char*)p;
[-] 	int result = ::WSARecv (m_h, &buf, 1, actualSize, flags, overlapped, completionFunc);
[+] 	int result = ::WSARecv(m_h, &buf, 1, actualSize, flags, overlapped, completionFunc);
[-] 	return completeAsyncRequest (result, WSA_IO_PENDING);
[+] 	return completeAsyncRequest(result, WSA_IO_PENDING);
[-] Socket::wsaSendTo (
[+] Socket::wsaSendTo(
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 	buf.buf = (char*) p;
[+] 	buf.buf = (char*)p;
[-] 	int result = ::WSASendTo (
[+] 	int result = ::WSASendTo(
[-] 		getSockAddrSize (addr),
[+] 		getSockAddrSize(addr),
[-] 	return completeAsyncRequest (result, WSA_IO_PENDING);
[+] 	return completeAsyncRequest(result, WSA_IO_PENDING);
[-] Socket::wsaRecvFrom (
[+] Socket::wsaRecvFrom(
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 	buf.buf = (char*) p;
[+] 	buf.buf = (char*)p;
[-] 	int result = ::WSARecvFrom (
[+] 	int result = ::WSARecvFrom(
[-] 		(sockaddr*) addr,
[+] 		(sockaddr*)addr,
[-] 	return completeAsyncRequest (result, WSA_IO_PENDING);
[+] 	return completeAsyncRequest(result, WSA_IO_PENDING);
[-] Socket::wsaIoctl (
[+] Socket::wsaIoctl(
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 	int result = ::WSAIoctl (
[+] 	int result = ::WSAIoctl(
[-] 		(void*) inBuffer,
[+] 		(void*)inBuffer,
[-] 	return completeAsyncRequest (result, WSA_IO_PENDING);
[+] 	return completeAsyncRequest(result, WSA_IO_PENDING);
[-] Socket::wsaGetOverlappedResult (
[+] Socket::wsaGetOverlappedResult(
[-] 	bool_t result = ::WSAGetOverlappedResult (m_h, overlapped, actualSize, true, flags ? flags : &unused);
[+] 	bool_t result = ::WSAGetOverlappedResult(m_h, overlapped, actualSize, true, flags ? flags : &unused);
[-] 	return complete (result);
[+] 	return complete(result);
[-] Socket::wsaGetOverlappedResult (WSAOVERLAPPED* overlapped) const
[+] Socket::wsaGetOverlappedResult(WSAOVERLAPPED* overlapped) const
[-] 	bool result = wsaGetOverlappedResult (overlapped, &actualSize);
[+] 	bool result = wsaGetOverlappedResult(overlapped, &actualSize);
[-] 	return result ? (size_t) actualSize : -1;
[+] 	return result ? (size_t)actualSize : -1;
----------------------
27/02/2019 18:01:51 - C:\Projects\repos\ioninja\axl\src\axl_io\axl_io_SockAddrParser.h
----------------------
[-] 	SockAddrParser ()
[+] 	SockAddrParser()
[-] 	SockAddrParser (const sl::StringRef& source)
[+] 	SockAddrParser(const sl::StringRef& source)
[-] 		create (source);
[+] 		create(source);
[-] 	create (const sl::StringRef& source)
[+] 	create(const sl::StringRef& source)
[-] 		m_p = source.cp ();
[+] 		m_p = source.cp();
[-] 		m_end = source.getEnd ();
[+] 		m_end = source.getEnd();
[-] 	parse (in_addr* addr);
[+] 	parse(in_addr* addr);
[-] 	parse (in6_addr* addr);
[+] 	parse(in6_addr* addr);
[-] 	parse (sockaddr_in* addr);
[+] 	parse(sockaddr_in* addr);
[-] 	parse (sockaddr_in6* addr);
[+] 	parse(sockaddr_in6* addr);
[-] 	parse (
[+] 	parse(
[-] 	tryAddr_ip4 ();
[+] 	tryAddr_ip4();
[-] 	tryAddr_ip6 ();
[+] 	tryAddr_ip6();
[-] 	trySockAddr_ip4 ();
[+] 	trySockAddr_ip4();
[-] 	trySockAddr_ip6 ();
[+] 	trySockAddr_ip6();
[-] 	skipWhiteSpace ();
[+] 	skipWhiteSpace();
[-] 	parseInt (
[+] 	parseInt(
[-] 	tryInt (int radix);
[+] 	tryInt(int radix);
[-] 	expectChar (char c);
[+] 	expectChar(char c);
[-] 	tryChar (char c);
[+] 	tryChar(char c);
[-] 	setParseError ();
[+] 	setParseError();
----------------------
27/02/2019 18:01:51 - C:\Projects\repos\ioninja\axl\src\axl_iok\axl_iok_Iterator.cpp
----------------------
[-] Iterator::next ()
[+] Iterator::next()
[-] 	io_object_t p = ::IOIteratorNext (m_p);
[+] 	io_object_t p = ::IOIteratorNext(m_p);
[-] 	object.attach (p);
[+] 	object.attach(p);
----------------------
27/02/2019 18:01:51 - C:\Projects\repos\ioninja\axl\src\axl_iok\axl_iok_RegistryEntry.cpp
----------------------
[-] RegistryEntry::getName () const
[+] RegistryEntry::getName() const
[-] 	::IORegistryEntryGetName (m_p, buffer);
[+] 	::IORegistryEntryGetName(m_p, buffer);
[-] RegistryEntry::getNameInPlane (const char* plane) const
[+] RegistryEntry::getNameInPlane(const char* plane) const
[-] 	::IORegistryEntryGetNameInPlane (m_p, plane, buffer);
[+] 	::IORegistryEntryGetNameInPlane(m_p, plane, buffer);
[-] RegistryEntry::getPath (const char* plane) const
[+] RegistryEntry::getPath(const char* plane) const
[-] 	::IORegistryEntryGetPath (m_p, plane, buffer);
[+] 	::IORegistryEntryGetPath(m_p, plane, buffer);
[-] RegistryEntry::getAllProperties () const
[+] RegistryEntry::getAllProperties() const
[-] 	::IORegistryEntryCreateCFProperties (m_p, &p, kCFAllocatorDefault, 0);
[+] 	::IORegistryEntryCreateCFProperties(m_p, &p, kCFAllocatorDefault, 0);
[-] 	return cf::MutableDictionaryRef (p, true);
[+] 	return cf::MutableDictionaryRef(p, true);
[-] RegistryEntry::getParentEntry (const char* plane) const
[+] RegistryEntry::getParentEntry(const char* plane) const
[-] 	::IORegistryEntryGetParentEntry (m_p, plane, &p);
[+] 	::IORegistryEntryGetParentEntry(m_p, plane, &p);
[-] 	return RegistryEntry (p, true);
[+] 	return RegistryEntry(p, true);
[-] RegistryEntry::getChildEntry (const char* plane) const
[+] RegistryEntry::getChildEntry(const char* plane) const
[-] 	::IORegistryEntryGetChildEntry (m_p, plane, &p);
[+] 	::IORegistryEntryGetChildEntry(m_p, plane, &p);
[-] 	return RegistryEntry (p, true);
[+] 	return RegistryEntry(p, true);
[-] findMatchingServices (CFMutableDictionaryRef dict)
[+] findMatchingServices(CFMutableDictionaryRef dict)
[-] 	::CFRetain (dict);
[+] 	::CFRetain(dict);
[-] 	kern_return_t result = ::IOServiceGetMatchingServices (kIOMasterPortDefault, dict, &p);
[+] 	kern_return_t result = ::IOServiceGetMatchingServices(kIOMasterPortDefault, dict, &p);
[-] 		::CFRelease (dict);
[+] 		::CFRelease(dict);
[-] 		return Iterator ();
[+] 		return Iterator();
[-] 	return Iterator (p, true);
[+] 	return Iterator(p, true);
----------------------
27/02/2019 18:01:51 - C:\Projects\repos\ioninja\axl\src\axl_lex\axl_lex_ParseError.cpp
----------------------
[-] decodeSrcPosError (
[+] decodeSrcPosError(
[-] 	ASSERT (isSrcPosError (error));
[+] 	ASSERT(isSrcPosError(error));
[-] 	sl::Unpacker unpacker (error + 2, error [1].m_size - sizeof (err::ErrorHdr));
[+] 	sl::Unpacker unpacker(error + 2, error[1].m_size - sizeof(err::ErrorHdr));
[-] 	unpacker.unpack (&filePath);
[+] 	unpacker.unpack(&filePath);
[-] 	unpacker.unpack (&lineCol->m_line);
[+] 	unpacker.unpack(&lineCol->m_line);
[-] 	unpacker.unpack (&lineCol->m_col);
[+] 	unpacker.unpack(&lineCol->m_col);
[-] ParseErrorProvider::getErrorDescription (const err::ErrorRef& error)
[+] ParseErrorProvider::getErrorDescription(const err::ErrorRef& error)
[-] 	sl::Unpacker unpacker (error + 1, error->m_size - sizeof (err::ErrorHdr));
[+] 	sl::Unpacker unpacker(error + 1, error->m_size - sizeof(err::ErrorHdr));
[-] 	switch (error->m_code)
[+] 	switch(error->m_code)
[-] 		unpacker.unpack (&filePath);
[+] 		unpacker.unpack(&filePath);
[-] 		unpacker.unpack (&line);
[+] 		unpacker.unpack(&line);
[-] 		unpacker.unpack (&col);
[+] 		unpacker.unpack(&col);
[-] 		return sl::formatString ("%s(%d,%d)", filePath, line + 1, col + 1);
[+] 		return sl::formatString("%s(%d,%d)", filePath, line + 1, col + 1);
[-] 		unpacker.unpack (&location);
[+] 		unpacker.unpack(&location);
[-] 		return sl::formatString ("invalid syntax in '%s'", location);
[+] 		return sl::formatString("invalid syntax in '%s'", location);
[-] 		unpacker.unpack (&expectedToken);
[+] 		unpacker.unpack(&expectedToken);
[-] 		unpacker.unpack (&actualToken);
[+] 		unpacker.unpack(&actualToken);
[-] 		return sl::formatString ("expected '%s' before '%s'", expectedToken, actualToken);
[+] 		return sl::formatString("expected '%s' before '%s'", expectedToken, actualToken);
[-] 		unpacker.unpack (&token);
[+] 		unpacker.unpack(&token);
[-] 		return sl::formatString ("unexpected '%s'", token);
[+] 		return sl::formatString("unexpected '%s'", token);
[-] 		unpacker.unpack (&token);
[+] 		unpacker.unpack(&token);
[-] 		unpacker.unpack (&location);
[+] 		unpacker.unpack(&location);
[-] 		return sl::formatString ("unexpected '%s' in '%s'", token, location);
[+] 		return sl::formatString("unexpected '%s' in '%s'", token, location);
----------------------
27/02/2019 18:01:51 - C:\Projects\repos\ioninja\axl\src\axl_lex\axl_lex_Token.cpp
----------------------
[-] LineCol::incrementalCount (const sl::StringRef& string)
[+] LineCol::incrementalCount(const sl::StringRef& string)
[-] 	const char* p = string.cp ();
[+] 	const char* p = string.cp();
[-] 	const char* end = string.getEnd ();
[+] 	const char* end = string.getEnd();
[-] 	m_col = (int) (p - line);
[+] 	m_col = (int)(p - line);
----------------------
27/02/2019 18:01:51 - C:\Projects\repos\ioninja\axl\src\axl_lua\axl_lua_LuaState.cpp
----------------------
[-] LuaState::create ()
[+] LuaState::create()
[-] 	close ();
[+] 	close();
[-] 	m_h = luaL_newstate ();
[+] 	m_h = luaL_newstate();
[-] 		err::setError (err::SystemErrorCode_InsufficientResources);
[+] 		err::setError(err::SystemErrorCode_InsufficientResources);
[-] LuaState::complete (int result)
[+] LuaState::complete(int result)
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 	err::setError (popString ());
[+] 	err::setError(popString());
[-] LuaState::load (
[+] LuaState::load(
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 	int result = luaL_loadbuffer (m_h, source.cp (), source.getLength (), name.sz ());
[+] 	int result = luaL_loadbuffer(m_h, source.cp(), source.getLength(), name.sz());
[-] 	return complete (result);
[+] 	return complete(result);
[-] LuaState::trace ()
[+] LuaState::trace()
[-] 	int top = getTop ();
[+] 	int top = getTop();
[-] 		int type = getType (i);
[+] 		int type = getType(i);
[-] 		const void* p = lua_topointer (m_h, i);
[+] 		const void* p = lua_topointer(m_h, i);
[-] 		switch (type)
[+] 		switch(type)
[-] 			TRACE ("%08x %s\n", p, getString (i).sz ());
[+] 			TRACE("%08x %s\n", p, getString (i).sz ());
[-] 			TRACE ("%08x %s\n", p, getBoolean (i) ? "true" : "false");
[+] 			TRACE("%08x %s\n", p, getBoolean (i) ? "true" : "false");
[-] 			TRACE ("%08x %g\n", p, getNumber (i));
[+] 			TRACE("%08x %g\n", p, getNumber (i));
[-] 			TRACE ("%08x %s\n", p, getTypeName (type).sz ());
[+] 			TRACE("%08x %s\n", p, getTypeName (type).sz ());
[-] LuaState::prepareErrorString (const sl::StringRef& string)
[+] LuaState::prepareErrorString(const sl::StringRef& string)
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 	int result = lua_checkstack (m_h, 2);
[+] 	int result = lua_checkstack(m_h, 2);
[-] 	ASSERT (result);
[+] 	ASSERT(result);
[-] 	where ();
[+] 	where();
[-] 	pushString (string);
[+] 	pushString(string);
[-] 	concatenate ();
[+] 	concatenate();
[-] LuaState::tryCheckStack (int extraSlotCount)
[+] LuaState::tryCheckStack(int extraSlotCount)
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 	int result = lua_checkstack (m_h, extraSlotCount);
[+] 	int result = lua_checkstack(m_h, extraSlotCount);
[-] 		err::setError (err::SystemErrorCode_InsufficientResources);
[+] 		err::setError(err::SystemErrorCode_InsufficientResources);
[-] LuaState::checkStack (int extraSlotCount)
[+] LuaState::checkStack(int extraSlotCount)
[-] 	bool result = tryCheckStack (extraSlotCount);
[+] 	bool result = tryCheckStack(extraSlotCount);
[-] 		prepareLastErrorString ();
[+] 		prepareLastErrorString();
[-] 		error ();
[+] 		error();
[-] LuaState::tryCreateTable (
[+] LuaState::tryCreateTable(
[-] 	bool result = tryCheckStack (extraStackSlotCount);
[+] 	bool result = tryCheckStack(extraStackSlotCount);
[-] 	lua_createtable (m_h, elementCount, memberCount);
[+] 	lua_createtable(m_h, elementCount, memberCount);
[-] LuaState::createTable (
[+] LuaState::createTable(
[-] 	bool result = tryCreateTable (elementCount, memberCount, extraStackSlotCount);
[+] 	bool result = tryCreateTable(elementCount, memberCount, extraStackSlotCount);
[-] 		prepareLastErrorString ();
[+] 		prepareLastErrorString();
[-] 		error ();
[+] 		error();
[-] LuaState::getGlobalArrayLen (const sl::StringRef& name)
[+] LuaState::getGlobalArrayLen(const sl::StringRef& name)
[-] 	getGlobal (name);
[+] 	getGlobal(name);
[-] 	size_t len = getRawLen ();
[+] 	size_t len = getRawLen();
[-] 	pop ();
[+] 	pop();
[-] LuaState::setGlobalArrayElement (
[+] LuaState::setGlobalArrayElement(
[-] 	getGlobal (name);
[+] 	getGlobal(name);
[-] 	swap ();
[+] 	swap();
[-] 	setArrayElement (index);
[+] 	setArrayElement(index);
[-] 	pop ();
[+] 	pop();
[-] LuaState::setGlobalMember (
[+] LuaState::setGlobalMember(
[-] 	getGlobal (name);
[+] 	getGlobal(name);
[-] 	swap ();
[+] 	swap();
[-] 	setMember (member);
[+] 	setMember(member);
[-] 	pop ();
[+] 	pop();
----------------------
27/02/2019 18:01:51 - C:\Projects\repos\ioninja\axl\src\axl_st\axl_st_LuaStringTemplate.cpp
----------------------
[-] LuaStringTemplate::close ()
[+] LuaStringTemplate::close()
[-] 	m_luaState.close ();
[+] 	m_luaState.close();
[-] 	StringTemplate <LuaStringTemplate>::clear ();
[+] 	StringTemplate<LuaStringTemplate>::clear();
[-] LuaStringTemplate::create ()
[+] LuaStringTemplate::create()
[-] 	close ();
[+] 	close();
[-] 	bool result = m_luaState.create ();
[+] 	bool result = m_luaState.create();
[-] 	m_luaState.openLibs ();
[+] 	m_luaState.openLibs();
[-] 	m_luaState.registerFunction ("getLine", getLine_lua, this);
[+] 	m_luaState.registerFunction("getLine", getLine_lua, this);
[-] 	m_luaState.registerFunction ("getCol", getCol_lua, this);
[+] 	m_luaState.registerFunction("getCol", getCol_lua, this);
[-] 	m_luaState.registerFunction ("emit", emit_lua, this);
[+] 	m_luaState.registerFunction("emit", emit_lua, this);
[-] 	m_luaState.registerFunction ("passthrough", passthrough_lua, this);
[+] 	m_luaState.registerFunction("passthrough", passthrough_lua, this);
[-] LuaStringTemplate::setArgCount (size_t count)
[+] LuaStringTemplate::setArgCount(size_t count)
[-] 	int top = m_luaState.getTop ();
[+] 	int top = m_luaState.getTop();
[-] 	if (count > (size_t) top)
[+] 	if (count > (size_t)top)
[-] 		err::setError (err::SystemErrorCode_InvalidParameter);
[+] 		err::setError(err::SystemErrorCode_InvalidParameter);
[-] LuaStringTemplate::runScript (
[+] LuaStringTemplate::runScript(
[-] 	int top = m_luaState.getTop ();
[+] 	int top = m_luaState.getTop();
[-] 	bool result = m_luaState.load (fileName, source);
[+] 	bool result = m_luaState.load(fileName, source);
[-] 		ASSERT (m_argCount <= (size_t) top);
[+] 		ASSERT(m_argCount <= (size_t)top);
[-] 			m_luaState.pushValue (i);
[+] 			m_luaState.pushValue(i);
[-] 	result = m_luaState.PCall (m_argCount, 0);
[+] 	result = m_luaState.PCall(m_argCount, 0);
[-] 	m_luaState.setTop (top);
[+] 	m_luaState.setTop(top);
[-] LuaStringTemplate::createEmitCall (
[+] LuaStringTemplate::createEmitCall(
[-] 	script->append ("emit (");
[+] 	script->append("emit (");
[-] 	script->append (value);
[+] 	script->append(value);
[-] 	script->append (");");
[+] 	script->append(");");
[-] LuaStringTemplate::getLine_lua (lua_State* h)
[+] LuaStringTemplate::getLine_lua(lua_State* h)
[-] 	lua::LuaNonOwnerState luaState (h);
[+] 	lua::LuaNonOwnerState luaState(h);
[-] 	LuaStringTemplate* self = (LuaStringTemplate*) luaState.getContext ();
[+] 	LuaStringTemplate* self = (LuaStringTemplate*)luaState.getContext();
[-] 	ASSERT (self->m_luaState == h && !self->m_emitContextStack.isEmpty ());
[+] 	ASSERT(self->m_luaState == h && !self->m_emitContextStack.isEmpty());
[-] 	EmitContext* context = *self->m_emitContextStack.getTail ();
[+] 	EmitContext* context = *self->m_emitContextStack.getTail();
[-] 	luaState.pushInteger (context->m_lineCol.m_line);
[+] 	luaState.pushInteger(context->m_lineCol.m_line);
[-] 	luaState.detach ();
[+] 	luaState.detach();
[-] LuaStringTemplate::getCol_lua (lua_State* h)
[+] LuaStringTemplate::getCol_lua(lua_State* h)
[-] 	lua::LuaNonOwnerState luaState (h);
[+] 	lua::LuaNonOwnerState luaState(h);
[-] 	LuaStringTemplate* self = (LuaStringTemplate*) luaState.getContext ();
[+] 	LuaStringTemplate* self = (LuaStringTemplate*)luaState.getContext();
[-] 	ASSERT (self->m_luaState == h && !self->m_emitContextStack.isEmpty ());
[+] 	ASSERT(self->m_luaState == h && !self->m_emitContextStack.isEmpty());
[-] 	EmitContext* context = *self->m_emitContextStack.getTail ();
[+] 	EmitContext* context = *self->m_emitContextStack.getTail();
[-] 	ASSERT (self->m_luaState == h);
[+] 	ASSERT(self->m_luaState == h);
[-] 	luaState.pushInteger (context->m_lineCol.m_col);
[+] 	luaState.pushInteger(context->m_lineCol.m_col);
[-] LuaStringTemplate::emit_lua (lua_State* h)
[+] LuaStringTemplate::emit_lua(lua_State* h)
[-] 	lua::LuaNonOwnerState luaState (h);
[+] 	lua::LuaNonOwnerState luaState(h);
[-] 	LuaStringTemplate* self = (LuaStringTemplate*) luaState.getContext ();
[+] 	LuaStringTemplate* self = (LuaStringTemplate*)luaState.getContext();
[-] 	ASSERT (self->m_luaState == h && !self->m_emitContextStack.isEmpty ());
[+] 	ASSERT(self->m_luaState == h && !self->m_emitContextStack.isEmpty());
[-] 	EmitContext* context = *self->m_emitContextStack.getTail ();
[+] 	EmitContext* context = *self->m_emitContextStack.getTail();
[-] 	size_t count = luaState.getTop ();
[+] 	size_t count = luaState.getTop();
[-] 		sl::StringRef string = luaState.getString (i);
[+] 		sl::StringRef string = luaState.getString(i);
[-] 		context->m_output->append (string);
[+] 		context->m_output->append(string);
[-] 		context->m_lineCol.incrementalCount (string);
[+] 		context->m_lineCol.incrementalCount(string);
[-] LuaStringTemplate::passthrough_lua (lua_State* h)
[+] LuaStringTemplate::passthrough_lua(lua_State* h)
[-] 	lua::LuaNonOwnerState luaState (h);
[+] 	lua::LuaNonOwnerState luaState(h);
[-] 	LuaStringTemplate* self = (LuaStringTemplate*) luaState.getContext ();
[+] 	LuaStringTemplate* self = (LuaStringTemplate*)luaState.getContext();
[-] 	ASSERT (self->m_luaState == h && !self->m_emitContextStack.isEmpty ());
[+] 	ASSERT(self->m_luaState == h && !self->m_emitContextStack.isEmpty());
[-] 	EmitContext* context = *self->m_emitContextStack.getTail ();
[+] 	EmitContext* context = *self->m_emitContextStack.getTail();
[-] 	size_t offset = (size_t) luaState.getInteger (1);
[+] 	size_t offset = (size_t)luaState.getInteger(1);
[-] 	size_t length = (size_t) luaState.getInteger (2);
[+] 	size_t length = (size_t)luaState.getInteger(2);
[-] 	sl::StringRef string = context->m_frame.getSubString (offset, length);
[+] 	sl::StringRef string = context->m_frame.getSubString(offset, length);
[-] 	context->m_output->append (string);
[+] 	context->m_output->append(string);
[-] 	context->m_lineCol.incrementalCount (string);
[+] 	context->m_lineCol.incrementalCount(string);
----------------------
27/02/2019 18:01:51 - C:\Projects\repos\ioninja\axl\src\axl_st\axl_st_StringTemplate.cpp
----------------------
[-] gotoEndOfScriptSnippet (
[+] gotoEndOfScriptSnippet(
[-] 	const Token* token = lexer->getToken ();
[+] 	const Token* token = lexer->getToken();
[-] 	switch (token->m_token)
[+] 	switch(token->m_token)
[-] 		ASSERT (token->m_token == TokenKind_OpenCode);
[+] 		ASSERT(token->m_token == TokenKind_OpenCode);
[-] 	lexer->gotoState (
[+] 	lexer->gotoState(
[-] 		Lexer::getMachineState (machine),
[+] 		Lexer::getMachineState(machine),
[-] 		token = lexer->getToken ();
[+] 		token = lexer->getToken();
[-] 			err::setFormatStringError ("invalid character '\\x%02x'", (uchar_t) token->m_data.m_integer);
[+] 			err::setFormatStringError("invalid character '\\x%02x'", (uchar_t) token->m_data.m_integer);
[-] 			lex::setUnexpectedTokenError ("eof", "user-code");
[+] 			lex::setUnexpectedTokenError("eof", "user-code");
[-] 		lexer->nextToken ();
[+] 		lexer->nextToken();
[-] 	lexer->gotoState (
[+] 	lexer->gotoState(
[-] 		Lexer::getMachineState (LexerMachineKind_Main),
[+] 		Lexer::getMachineState(LexerMachineKind_Main),
----------------------
27/02/2019 18:01:51 - C:\Projects\repos\ioninja\axl\src\axl_xml\axl_xml_ExpatError.cpp
----------------------
[-] ExpatError::create (XML_Error code)
[+] ExpatError::create(XML_Error code)
[-] 	err::ErrorHdr* error = createBuffer (sizeof (err::ErrorHdr));
[+] 	err::ErrorHdr* error = createBuffer(sizeof(err::ErrorHdr));
[-] 	error->m_size = sizeof (err::ErrorHdr);
[+] 	error->m_size = sizeof(err::ErrorHdr);
----------------------
27/02/2019 18:01:51 - C:\Projects\repos\ioninja\axl\src\axl_xml\axl_xml_ExpatParser.cpp
----------------------
[-] ExpatParserRoot::create (const sl::StringRef& encoding)
[+] ExpatParserRoot::create(const sl::StringRef& encoding)
[-] 	close ();
[+] 	close();
[-] 	m_h = XML_ParserCreate (encoding.szn ());
[+] 	m_h = XML_ParserCreate(encoding.szn());
[-] 	return err::completeWithSystemError (m_h != NULL, false, err::SystemErrorCode_InsufficientResources);
[+] 	return err::completeWithSystemError(m_h != NULL, false, err::SystemErrorCode_InsufficientResources);
[-] ExpatParserRoot::createNs (
[+] ExpatParserRoot::createNs(
[-] 	close ();
[+] 	close();
[-] 	m_h = XML_ParserCreateNS (encoding.szn (), separator);
[+] 	m_h = XML_ParserCreateNS(encoding.szn(), separator);
[-] 	return err::completeWithSystemError (m_h != NULL, false, err::SystemErrorCode_InsufficientResources);
[+] 	return err::completeWithSystemError(m_h != NULL, false, err::SystemErrorCode_InsufficientResources);
[-] ExpatParserRoot::parseFile (
[+] ExpatParserRoot::parseFile(
[-] 			mappedFile.open (fileName, io::FileFlag_ReadOnly) &&
[+] 			mappedFile.open(fileName, io::FileFlag_ReadOnly) &&
[-] 			parse (mappedFile.p (), (size_t) mappedFile.getFileSize (), true);
[+] 			parse(mappedFile.p(), (size_t)mappedFile.getFileSize(), true);
[-] 	size_t alignFactor = g::getModule ()->getSystemInfo ()->m_mappingAlignFactor;
[+] 	size_t alignFactor = g::getModule()->getSystemInfo()->m_mappingAlignFactor;
[-] 	result = mappedFile.open (fileName, 0, 0, io::FileFlag_ReadOnly);
[+] 	result = mappedFile.open(fileName, 0, 0, io::FileFlag_ReadOnly);
[-] 	uint64_t size = mappedFile.getFileSize ();
[+] 	uint64_t size = mappedFile.getFileSize();
[-] 			(p = mappedFile.view (offset, blockSize)) &&
[+] 			(p = mappedFile.view(offset, blockSize)) &&
[-] 			parse (p, blockSize, false);
[+] 			parse(p, blockSize, false);
[-] 	blockSize = (size_t) (size - offset);
[+] 	blockSize = (size_t)(size - offset);
[-] 		(p = mappedFile.view (offset, blockSize)) &&
[+] 		(p = mappedFile.view(offset, blockSize)) &&
[-] 		parse (p, blockSize, true);
[+] 		parse(p, blockSize, true);
----------------------
27/02/2019 18:01:51 - C:\Projects\repos\ioninja\axl\src\axl_zip\axl_zip_ZipReader.cpp
----------------------
[-] 	_wfopen_s(&file, axl::sl::String_w (fileName), axl::sl::String_w (mode));
[+] 	_wfopen_s(&file, axl::sl::String_w(fileName), axl::sl::String_w(mode));
[-] mz_freopen (
[+] mz_freopen(
[-] 	if (_wfreopen_s(&file, axl::sl::String_w (path), axl::sl::String_w (mode), stream))
[+] 	if (_wfreopen_s(&file, axl::sl::String_w(path), axl::sl::String_w(mode), stream))
[-] ZipReader::close ()
[+] ZipReader::close()
[-] 	mz_zip_reader_end (m_zip);
[+] 	mz_zip_reader_end(m_zip);
[-] 	AXL_MEM_FREE (m_zip);
[+] 	AXL_MEM_FREE(m_zip);
[-] ZipReader::openFile (const sl::StringRef& fileName)
[+] ZipReader::openFile(const sl::StringRef& fileName)
[-] 	close ();
[+] 	close();
[-] 	m_zip = AXL_MEM_ZERO_NEW (mz_zip_archive);
[+] 	m_zip = AXL_MEM_ZERO_NEW(mz_zip_archive);
[-] 	mz_bool result = mz_zip_reader_init_file (m_zip, fileName.sz (), MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY);
[+] 	mz_bool result = mz_zip_reader_init_file(m_zip, fileName.sz(), MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY);
[-] 	return result ? true : err::fail (err::SystemErrorCode_Unsuccessful);
[+] 	return result ? true : err::fail(err::SystemErrorCode_Unsuccessful);
[-] ZipReader::openMem (
[+] ZipReader::openMem(
[-] 	close ();
[+] 	close();
[-] 	m_zip = AXL_MEM_ZERO_NEW (mz_zip_archive);
[+] 	m_zip = AXL_MEM_ZERO_NEW(mz_zip_archive);
[-] 	mz_bool result = mz_zip_reader_init_mem (m_zip, p, size, MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY);
[+] 	mz_bool result = mz_zip_reader_init_mem(m_zip, p, size, MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY);
[-] 	return result ? true : err::fail (err::SystemErrorCode_Unsuccessful);
[+] 	return result ? true : err::fail(err::SystemErrorCode_Unsuccessful);
[-] ZipReader::getFileCount ()
[+] ZipReader::getFileCount()
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 	return mz_zip_reader_get_num_files (m_zip);
[+] 	return mz_zip_reader_get_num_files(m_zip);
[-] ZipReader::getFileName (size_t index)
[+] ZipReader::getFileName(size_t index)
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 	size_t size = mz_zip_reader_get_filename (m_zip, index, NULL, 0);
[+] 	size_t size = mz_zip_reader_get_filename(m_zip, index, NULL, 0);
[-] 	char* p = fileName.createBuffer (size);
[+] 	char* p = fileName.createBuffer(size);
[-] 	mz_zip_reader_get_filename (m_zip, index, p, size);
[+] 	mz_zip_reader_get_filename(m_zip, index, p, size);
[-] 	fileName.chop (1);
[+] 	fileName.chop(1);
[-] ZipReader::getFileInfo (
[+] ZipReader::getFileInfo(
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 	mz_bool result = mz_zip_reader_file_stat (m_zip, index, &stat);
[+] 	mz_bool result = mz_zip_reader_file_stat(m_zip, index, &stat);
[-] 		return err::fail (err::SystemErrorCode_Unsuccessful);
[+] 		return err::fail(err::SystemErrorCode_Unsuccessful);
[-] ZipReader::isDirectoryFile (size_t index)
[+] ZipReader::isDirectoryFile(size_t index)
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 	return mz_zip_reader_is_file_a_directory (m_zip, index) != 0;
[+] 	return mz_zip_reader_is_file_a_directory(m_zip, index) != 0;
[-] ZipReader::isFileEncrypted (size_t index)
[+] ZipReader::isFileEncrypted(size_t index)
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 	return mz_zip_reader_is_file_encrypted (m_zip, index) != 0;
[+] 	return mz_zip_reader_is_file_encrypted(m_zip, index) != 0;
[-] ZipReader::extractFileToMem (
[+] ZipReader::extractFileToMem(
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 	char readBuffer [1024];
[+] 	char readBuffer[1024];
[-] 	mz_bool result = mz_zip_reader_extract_to_mem_no_alloc (
[+] 	mz_bool result = mz_zip_reader_extract_to_mem_no_alloc(
[-] 		sizeof (readBuffer)
[+] 		sizeof(readBuffer)
[-] 	return result ? true : err::fail (err::SystemErrorCode_Unsuccessful);
[+] 	return result ? true : err::fail(err::SystemErrorCode_Unsuccessful);
[-] ZipReader::extractFileToMem (
[+] ZipReader::extractFileToMem(
[-] 	sl::Array <char>* buffer
[+] 	sl::Array<char>* buffer
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 		mz_zip_reader_file_stat (m_zip, index, &stat) &&
[+] 		mz_zip_reader_file_stat(m_zip, index, &stat) &&
[-] 		buffer->reserve ((size_t) stat.m_uncomp_size + 1);
[+] 		buffer->reserve((size_t)stat.m_uncomp_size + 1);
[-] 	buffer->p () [(size_t) stat.m_uncomp_size] = 0; // ensure zero termination
[+] 	buffer->p() [(size_t)stat.m_uncomp_size] = 0; // ensure zero termination
[-] 	buffer->setCount ((size_t) stat.m_uncomp_size);
[+] 	buffer->setCount((size_t)stat.m_uncomp_size);
[-] 	return extractFileToMem (index, buffer->p (), (size_t) stat.m_uncomp_size);
[+] 	return extractFileToMem(index, buffer->p(), (size_t)stat.m_uncomp_size);
[-] ZipReader::extractFileToFile (
[+] ZipReader::extractFileToFile(
[-] 	ASSERT (isOpen ());
[+] 	ASSERT(isOpen());
[-] 	mz_bool result = mz_zip_reader_extract_to_file (
[+] 	mz_bool result = mz_zip_reader_extract_to_file(
[-] 		fileName.sz (),
[+] 		fileName.sz(),
[-] 	return result ? true : err::fail (err::SystemErrorCode_Unsuccessful);
[+] 	return result ? true : err::fail(err::SystemErrorCode_Unsuccessful);
----------------------
27/02/2019 18:01:51 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\main.cpp
----------------------
[-] runTest (
[+] runTest(
[-] 	printf (
[+] 	printf(
[-] 		func ();
[+] 		func();
[-] 	catch (const char* message)
[+] 	catch(const char* message)
[-] 		printf ("%s\n", message);
[+] 		printf("%s\n", message);
[-] 	catch (...)
[+] 	catch(...)
[-] 	printf (result ? "\n>>> Passed\n\n" : "\n>>> FAILED\n\n");
[+] 	printf(result ? "\n>>> Passed\n\n" : "\n>>> FAILED\n\n");
[-] wmain (
[+] wmain(
[-] 	wchar_t* argv []
[+] 	wchar_t* argv[]
[-] main (
[+] main(
[-] 	char* argv []
[+] 	char* argv[]
[-] 	setvbuf (stdout, NULL, _IOLBF, 1024);
[+] 	setvbuf(stdout, NULL, _IOLBF, 1024);
[-] 	WORD versionRequested = MAKEWORD (2, 2);
[+] 	WORD versionRequested = MAKEWORD(2, 2);
[-] 	WSAStartup (versionRequested, &wsaData);
[+] 	WSAStartup(versionRequested, &wsaData);
[-] 	srand ((uint_t) sys::getTimestamp ());
[+] 	srand((uint_t)sys::getTimestamp());
[-] 	g::getModule ()->setTag ("axl_test_auto");
[+] 	g::getModule()->setTag("axl_test_auto");
[-] 	lex::registerParseErrorProvider ();
[+] 	lex::registerParseErrorProvider();
[-] 		total = getTestCaseSet ()->getCount ();
[+] 		total = getTestCaseSet()->getCount();
[-] 		sl::StringHashTableIterator <TestFunc*> it = getTestCaseSet ()->getHead ();
[+] 		sl::StringHashTableIterator<TestFunc*> it = getTestCaseSet()->getHead();
[-] 			passed += runTest (i, total, it->getKey (), it->m_value);
[+] 			passed += runTest(i, total, it->getKey(), it->m_value);
[-] 			name = argv [i];
[+] 			name = argv[i];
[-] 			sl::StringHashTableIterator <TestFunc*> it = getTestCaseSet ()->find (name);
[+] 			sl::StringHashTableIterator<TestFunc*> it = getTestCaseSet()->find(name);
[-] 				passed += runTest (i, total, it->getKey (), it->m_value);
[+] 				passed += runTest(i, total, it->getKey(), it->m_value);
[-] 				printf ("TEST NOT FOUND: %s\n", name.sz ());
[+] 				printf("TEST NOT FOUND: %s\n", name.sz ());
[-] 	printf ("%d%% tests passed, %d tests failed out of %d\n",
[+] 	printf("%d%% tests passed, %d tests failed out of %d\n",
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\test_BoyerMooreFind.cpp
----------------------
[-] void run ()
[+] void run()
[-] 	char haystack [] = "hui govno i muravei";
[+] 	char haystack[] = "hui govno i muravei";
[-] 	char needle [] = "muravei";
[+] 	char needle[] = "muravei";
[-] 	find.setPattern (sl::StringRef (needle, lengthof (needle)), flags);
[+] 	find.setPattern(sl::StringRef(needle, lengthof(needle)), flags);
[-] 	for (size_t i = 0; i < lengthof (haystack); i++)
[+] 	for (size_t i = 0; i < lengthof(haystack); i++)
[-] 		result = find.find (&incrementalContext, i, sl::StringRef (haystack + i, 1));
[+] 		result = find.find(&incrementalContext, i, sl::StringRef(haystack + i, 1));
[-] 		result = find.find (&incrementalContext, lengthof (haystack), sl::StringRef (" ", 1));
[+] 		result = find.find(&incrementalContext, lengthof(haystack), sl::StringRef(" ", 1));
[-] 	for (intptr_t i = lengthof (haystack) - 1; i >= 0; i--)
[+] 	for (intptr_t i = lengthof(haystack) - 1; i >= 0; i--)
[-] 		result = find.find (&incrementalContext, i, haystack + i, 1);
[+] 		result = find.find(&incrementalContext, i, haystack + i, 1);
[-] 		result = find.find (&incrementalContext, -1, " ", 1);
[+] 		result = find.find(&incrementalContext, -1, " ", 1);
[-] 	result = find.find (haystack, lengthof (haystack));
[+] 	result = find.find(haystack, lengthof(haystack));
[-] 	printf ("result = %d\n", result);
[+] 	printf("result = %d\n", result);
[-] 	result = find.find (sl::StringRef (haystack, lengthof (haystack)));
[+] 	result = find.find(sl::StringRef(haystack, lengthof(haystack)));
[-] 	printf ("result = %d\n", result);
[+] 	printf("result = %d\n", result);
[-] ADD_TEST_CASE ("test_BoyerMooreFind", run)
[+] ADD_TEST_CASE("test_BoyerMooreFind", run)
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\test_Bstr.cpp
----------------------
[-] void run ()
[+] void run()
[-] 	bstr = sl::StringRef ("i");
[+] 	bstr = sl::StringRef("i");
[-] 	bstr = sl::StringRef_w (L"muravei");
[+] 	bstr = sl::StringRef_w(L"muravei");
[-] 	bstr = sys::win::Bstr ("muravei");
[+] 	bstr = sys::win::Bstr("muravei");
[-] 	bstr = sys::win::Bstr (L"govno");
[+] 	bstr = sys::win::Bstr(L"govno");
[-] 	bstr = sys::win::Bstr (sl::StringRef ("i"));
[+] 	bstr = sys::win::Bstr(sl::StringRef("i"));
[-] 	bstr = sys::win::Bstr (sl::StringRef_w (L"hui"));
[+] 	bstr = sys::win::Bstr(sl::StringRef_w(L"hui"));
[-] ADD_TEST_CASE ("test_Bstr", run)
[+] ADD_TEST_CASE("test_Bstr", run)
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\test_CmdLineParser.cpp
----------------------
[-] AXL_SL_BEGIN_CMD_LINE_SWITCH_TABLE (MySwitchTable, MySwitchKind)
[+] AXL_SL_BEGIN_CMD_LINE_SWITCH_TABLE(MySwitchTable, MySwitchKind)
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (MySwitchKind_Help, "h", "help", NULL, "Display help")
[+] 	AXL_SL_CMD_LINE_SWITCH_2(MySwitchKind_Help, "h", "help", NULL, "Display help")
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (MySwitchKind_SessionProvider, "s", "session-provider", "<provider>", "Specify provider")
[+] 	AXL_SL_CMD_LINE_SWITCH_2(MySwitchKind_SessionProvider, "s", "session-provider", "<provider>", "Specify provider")
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (MySwitchKind_SessionFile, "f", "session-file", "<file>", "Specify session file")
[+] 	AXL_SL_CMD_LINE_SWITCH_2(MySwitchKind_SessionFile, "f", "session-file", "<file>", "Specify session file")
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (MySwitchKind_LogFile, "l", "log-file", "<file>", "Specify log file")
[+] 	AXL_SL_CMD_LINE_SWITCH_2(MySwitchKind_LogFile, "l", "log-file", "<file>", "Specify log file")
[-] AXL_SL_END_CMD_LINE_SWITCH_TABLE ()
[+] AXL_SL_END_CMD_LINE_SWITCH_TABLE()
[-] class MyParser: public sl::CmdLineParser <MyParser, MySwitchTable>
[+] class MyParser: public sl::CmdLineParser<MyParser, MySwitchTable>
[-] 	onValue (const sl::StringRef& value)
[+] 	onValue(const sl::StringRef& value)
[-] 		printf ("OnValue '%s'\n", value.sz ());
[+] 		printf("OnValue '%s'\n", value.sz ());
[-] 	onSwitch (
[+] 	onSwitch(
[-] 		printf ("OnSwitch #%d = '%s'\n", switchKind, value.sz ());
[+] 		printf("OnSwitch #%d = '%s'\n", switchKind, value.sz ());
[-] run ()
[+] run()
[-] 	const char* cmdLine [] =
[+] 	const char* cmdLine[] =
[-] 	parser.parse ((int) countof (cmdLine), cmdLine);
[+] 	parser.parse((int)countof(cmdLine), cmdLine);
[-] ADD_TEST_CASE ("test_CmdLineParser", run)
[+] ADD_TEST_CASE("test_CmdLineParser", run)
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\test_Crypto.cpp
----------------------
[-] void run ()
[+] void run()
[-] 	cry::EcKey key (NID_secp112r1);
[+] 	cry::EcKey key(NID_secp112r1);
[-] 	key.generateKey ();
[+] 	key.generateKey();
[-] 	cry::BigNum privateKey = key.getPrivateKey ();
[+] 	cry::BigNum privateKey = key.getPrivateKey();
[-] 	cry::EcPoint publicKey = key.getPublicKey ();
[+] 	cry::EcPoint publicKey = key.getPublicKey();
[-] 	printf ("private: %s\n", privateKey.getHexString ().sz ());
[+] 	printf("private: %s\n", privateKey.getHexString ().sz ());
[-] 	printf ("public:  %s\n", publicKey.getHexString (key.getGroup ()).sz ());
[+] 	printf("public:  %s\n", publicKey.getHexString (key.getGroup ()).sz ());
[-] 	sl::String productKey = generateEcProductKey (key, userName);
[+] 	sl::String productKey = generateEcProductKey(key, userName);
[-] 	printf ("user:    %s\n", userName);
[+] 	printf("user:    %s\n", userName);
[-] 	printf ("license: %s\n", productKey.sz ());
[+] 	printf("license: %s\n", productKey.sz ());
[-] 	bool result = verifyEcProductKey (key, userName, productKey);
[+] 	bool result = verifyEcProductKey(key, userName, productKey);
[-] 	printf ("verify:  %d\n", result);
[+] 	printf("verify:  %d\n", result);
[-] 	ASSERT (result);
[+] 	ASSERT(result);
[-] 	privateKey.detach ();
[+] 	privateKey.detach();
[-] 	publicKey.detach ();
[+] 	publicKey.detach();
[-] ADD_TEST_CASE ("test_Crypto", run)
[+] ADD_TEST_CASE("test_Crypto", run)
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\test_Error.cpp
----------------------
[-] run ()
[+] run()
[-] 	error.pack <sl::PackSeq_4 <
[+] 	error.pack<sl::PackSeq_4<
[-] 	sl::String s = enc::HexEncoding::encode (error.cp (), error.getSize ());
[+] 	sl::String s = enc::HexEncoding::encode(error.cp(), error.getSize());
[-] 	printf ("error: %s\n", s.sz ());
[+] 	printf("error: %s\n", s.sz ());
[-] 	error2.format (
[+] 	error2.format(
[-] 	s = enc::HexEncoding::encode (error.cp (), error.getSize ());
[+] 	s = enc::HexEncoding::encode(error.cp(), error.getSize());
[-] 	printf ("error: %s\n", s.sz ());
[+] 	printf("error: %s\n", s.sz ());
[-] ADD_TEST_CASE ("test_Error", run)
[+] ADD_TEST_CASE("test_Error", run)
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\test_Finalizer.cpp
----------------------
[-] 	MyFinalizer ()
[+] 	MyFinalizer()
[-] 		printf ("MyFinalizer::MyFinalizer (this = %p)\n", this);
[+] 		printf("MyFinalizer::MyFinalizer (this = %p)\n", this);
[-] 	~MyFinalizer ()
[+] 	~MyFinalizer()
[-] 		printf ("MyFinalizer::~MyFinalizer (this = %p)\n", this);
[+] 		printf("MyFinalizer::~MyFinalizer (this = %p)\n", this);
[-] 	finalize ()
[+] 	finalize()
[-] 		printf ("MyFinalizer::finalize (this = %p)\n", this);
[+] 		printf("MyFinalizer::finalize (this = %p)\n", this);
[-] run ()
[+] run()
[-] 	ref::Ptr <MyFinalizer> fin = AXL_REF_NEW (MyFinalizer);
[+] 	ref::Ptr<MyFinalizer> fin = AXL_REF_NEW(MyFinalizer);
[-] 	g::getModule ()->addFinalizer (fin);
[+] 	g::getModule()->addFinalizer(fin);
[-] ADD_TEST_CASE ("test_Finalizer", run)
[+] ADD_TEST_CASE("test_Finalizer", run)
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\test_HandleTable.cpp
----------------------
[-] run ()
[+] run()
[-] 	printf ("hui govno i muravei\n");
[+] 	printf("hui govno i muravei\n");
[-] 	sl::HandleTable <int> handleTable (0xffffffff);
[+] 	sl::HandleTable<int> handleTable(0xffffffff);
[-] 	uintptr_t h1 = handleTable.add (100);
[+] 	uintptr_t h1 = handleTable.add(100);
[-] 	uintptr_t h2 = handleTable.add (200);
[+] 	uintptr_t h2 = handleTable.add(200);
[-] 	uintptr_t h3 = handleTable.add (300);
[+] 	uintptr_t h3 = handleTable.add(300);
[-] 	uintptr_t h4 = handleTable.add (400);
[+] 	uintptr_t h4 = handleTable.add(400);
[-] 	sl::HandleTableIterator <int> it = handleTable.getHead ();
[+] 	sl::HandleTableIterator<int> it = handleTable.getHead();
[-] 		printf ("0x%p -> %d\n", it->getKey (), it->m_value);
[+] 		printf("0x%p -> %d\n", it->getKey (), it->m_value);
[-] ADD_TEST_CASE ("test_HandleTable", run)
[+] ADD_TEST_CASE("test_HandleTable", run)
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\test_HashTable.cpp
----------------------
[-] void test_IntHashTable ()
[+] void test_IntHashTable()
[-] 	sl::SimpleHashTable <int, int> map;
[+] 	sl::SimpleHashTable<int, int> map;
[-] 	sl::HashTableIterator <int, int> it;
[+] 	sl::HashTableIterator<int, int> it;
[-] 		int key = rand () % 50;
[+] 		int key = rand() % 50;
[-] 		it = map.visit (key);
[+] 		it = map.visit(key);
[-] 			ASSERT (it->m_value == key * 10);
[+] 			ASSERT(it->m_value == key * 10);
[-] 	it = map.getHead ();
[+] 	it = map.getHead();
[-] 		printf ("%d = %d\n", it->getKey (), it->m_value);
[+] 		printf("%d = %d\n", it->getKey (), it->m_value);
[-] 	printf (".........\n");
[+] 	printf(".........\n");
[-] 		int key = rand () % 50;
[+] 		int key = rand() % 50;
[-] 		it = map.find (key);
[+] 		it = map.find(key);
[-] 			printf ("%d not found\n", key);
[+] 			printf("%d not found\n", key);
[-] 			printf ("%d = %d\n", key, it->m_value);
[+] 			printf("%d = %d\n", key, it->m_value);
[-] 			ASSERT (it->m_value == key * 10);
[+] 			ASSERT(it->m_value == key * 10);
[-] 	printf (".........\n");
[+] 	printf(".........\n");
[-] void test_StringHashTableIgnoreCase ()
[+] void test_StringHashTableIgnoreCase()
[-] 	static char stringTable [] [80] =
[+] 	static char stringTable[] [80] =
[-] 	sl::StringHashTableIgnoreCase_pcu <int> map_pcu;
[+] 	sl::StringHashTableIgnoreCase_pcu<int> map_pcu;
[-] 	sl::StringHashTableIgnoreCase_pcp <int> map_pcp;
[+] 	sl::StringHashTableIgnoreCase_pcp<int> map_pcp;
[-] 	sl::StringHashTableIterator <int> it;
[+] 	sl::StringHashTableIterator<int> it;
[-] 	for (size_t i = 0; i < countof (stringTable); i++)
[+] 	for (size_t i = 0; i < countof(stringTable); i++)
[-] 		it = map_pcu.visit (stringTable [i]);
[+] 		it = map_pcu.visit(stringTable[i]);
[-] 		it->m_value = strlen (stringTable [i]);
[+] 		it->m_value = strlen(stringTable[i]);
[-] 		it = map_pcp.visit (stringTable [i]);
[+] 		it = map_pcp.visit(stringTable[i]);
[-] 		it->m_value = strlen (stringTable [i]);
[+] 		it->m_value = strlen(stringTable[i]);
[-] 	for (size_t i = 0; i < countof (stringTable); i++)
[+] 	for (size_t i = 0; i < countof(stringTable); i++)
[-] 		size_t length = strlen (stringTable [i]);
[+] 		size_t length = strlen(stringTable[i]);
[-] 			stringTable [i] [j] = (rand () & 1) ? tolower (stringTable [i] [j]) : toupper (stringTable [i] [j]);
[+] 			stringTable[i] [j] = (rand() & 1) ? tolower(stringTable[i] [j]) : toupper(stringTable[i] [j]);
[-] 		printf ("map_pcu: looking for %s...", stringTable [i]);
[+] 		printf("map_pcu: looking for %s...", stringTable [i]);
[-] 		it = map_pcu.find (stringTable [i]);
[+] 		it = map_pcu.find(stringTable[i]);
[-] 		ASSERT (it && it->m_value == length);
[+] 		ASSERT(it && it->m_value == length);
[-] 		printf ("found\n");
[+] 		printf("found\n");
[-] 		printf ("map_pcp: looking for %s...", stringTable [i]);
[+] 		printf("map_pcp: looking for %s...", stringTable [i]);
[-] 		it = map_pcp.find (stringTable [i]);
[+] 		it = map_pcp.find(stringTable[i]);
[-] 		ASSERT (it && it->m_value == length);
[+] 		ASSERT(it && it->m_value == length);
[-] 		printf ("found\n");
[+] 		printf("found\n");
[-] void run ()
[+] void run()
[-] 	test_IntHashTable ();
[+] 	test_IntHashTable();
[-] 	test_StringHashTableIgnoreCase ();
[+] 	test_StringHashTableIgnoreCase();
[-] ADD_TEST_CASE ("test_HashTable", run)
[+] ADD_TEST_CASE("test_HashTable", run)
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\test_IniParser.cpp
----------------------
[-] class MyParser: public ini::Parser <MyParser>
[+] class MyParser: public ini::Parser<MyParser>
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (SectionNameMap, SectionKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(SectionNameMap, SectionKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("session", SectionKind_Session)
[+] 		AXL_SL_HASH_TABLE_ENTRY("session", SectionKind_Session)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("scripts", SectionKind_Scripts)
[+] 		AXL_SL_HASH_TABLE_ENTRY("scripts", SectionKind_Scripts)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (KeyNameMap, KeyKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(KeyNameMap, KeyKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("name", KeyKind_Name)
[+] 		AXL_SL_HASH_TABLE_ENTRY("name", KeyKind_Name)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("description", KeyKind_Description)
[+] 		AXL_SL_HASH_TABLE_ENTRY("description", KeyKind_Description)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("guid", KeyKind_Guid)
[+] 		AXL_SL_HASH_TABLE_ENTRY("guid", KeyKind_Guid)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("icon", KeyKind_Icon)
[+] 		AXL_SL_HASH_TABLE_ENTRY("icon", KeyKind_Icon)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("session-class", KeyKind_SessionClass)
[+] 		AXL_SL_HASH_TABLE_ENTRY("session-class", KeyKind_SessionClass)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("log-representer-class", KeyKind_LogRepresenterClass)
[+] 		AXL_SL_HASH_TABLE_ENTRY("log-representer-class", KeyKind_LogRepresenterClass)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	onSection (const char* name)
[+] 	onSection(const char* name)
[-] 		SectionNameMap::Iterator it = SectionNameMap::find (name);
[+] 		SectionNameMap::Iterator it = SectionNameMap::find(name);
[-] 		printf ("OnSection '%s'\n", name);
[+] 		printf("OnSection '%s'\n", name);
[-] 	onKeyValue (
[+] 	onKeyValue(
[-] 		KeyNameMap::Iterator it = KeyNameMap::find (name);
[+] 		KeyNameMap::Iterator it = KeyNameMap::find(name);
[-] 		printf ("OnKeyValue '%s' = '%s'\n", name, value);
[+] 		printf("OnKeyValue '%s' = '%s'\n", name, value);
[-] run ()
[+] run()
[-] 	result = file.open (filePath, io::FileFlag_ReadOnly);
[+] 	result = file.open(filePath, io::FileFlag_ReadOnly);
[-] 		printf ("error opening file: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("error opening file: %s\n", err::getLastErrorDescription ().sz ());
[-] 	const char* p = (const char*) file.view ();
[+] 	const char* p = (const char*) file.view();
[-] 	uint64_t size = file.getSize ();
[+] 	uint64_t size = file.getSize();
[-] 	result = parser.parse (filePath, sl::StringRef (p, (size_t) size));
[+] 	result = parser.parse(filePath, sl::StringRef(p, (size_t)size));
[-] 		printf ("error parsing file: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("error parsing file: %s\n", err::getLastErrorDescription ().sz ());
[-] ADD_TEST_CASE ("test_IniParser", run)
[+] ADD_TEST_CASE("test_IniParser", run)
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\test_List.cpp
----------------------
[-] void run ()
[+] void run()
[-] 	sl::List <
[+] 	sl::List<
[-] 		sl::Offset <MyStruct, sl::ListLink, offsetof (MyStruct, m_Link1) >,
[+] 		sl::Offset<MyStruct, sl::ListLink, offsetof(MyStruct, m_Link1) >,
[-] 		mem::CppDelete <MyStruct>
[+] 		mem::CppDelete<MyStruct>
[-] 	sl::AuxList <
[+] 	sl::AuxList<
[-] 		sl::Offset <MyStruct, sl::ListLink, offsetof (MyStruct, m_Link2) >
[+] 		sl::Offset<MyStruct, sl::ListLink, offsetof(MyStruct, m_Link2) >
[-] 	list1.insertHead (p);
[+] 	list1.insertHead(p);
[-] 	list2.insertHead (p);
[+] 	list2.insertHead(p);
[-] 	list1.insertHead (p);
[+] 	list1.insertHead(p);
[-] 	list2.insertHead (p);
[+] 	list2.insertHead(p);
[-] 	sl::List <
[+] 	sl::List<
[-] 		sl::ExplicitCast <MyStruct2*, sl::ListLink*>,
[+] 		sl::ExplicitCast<MyStruct2*, sl::ListLink*>,
[-] 		mem::CppDelete <MyStruct2>
[+] 		mem::CppDelete<MyStruct2>
[-] 	list3.insertTail (p2);
[+] 	list3.insertTail(p2);
[-] 	sl::BoxList <int> boxList;
[+] 	sl::BoxList<int> boxList;
[-] 	boxList.insertTail (10);
[+] 	boxList.insertTail(10);
[-] 	boxList.insertHead (-10);
[+] 	boxList.insertHead(-10);
[-] 	boxList.insertTail (20);
[+] 	boxList.insertTail(20);
[-] 	boxList.insertHead (-20);
[+] 	boxList.insertHead(-20);
[-] 	boxList.removeHead ();
[+] 	boxList.removeHead();
[-] 	sl::BoxIterator <int> it = boxList.getHead ();
[+] 	sl::BoxIterator<int> it = boxList.getHead();
[-] 		printf ("%d\n", *it);
[+] 		printf("%d\n", *it);
[-] ADD_TEST_CASE ("test_List", run)
[+] ADD_TEST_CASE("test_List", run)
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\test_Packer.cpp
----------------------
[-] run ()
[+] run()
[-] 	ref::Ptr <mem::Block> package = sl::formatPackage(
[+] 	ref::Ptr<mem::Block> package = sl::formatPackage(
[-] 	sl::Unpacker unpacker (package->m_p, package->m_size);
[+] 	sl::Unpacker unpacker(package->m_p, package->m_size);
[-] 	unpacker.unpack (&s1);
[+] 	unpacker.unpack(&s1);
[-] 	unpacker.unpack (&l1);
[+] 	unpacker.unpack(&l1);
[-] 	unpacker.unpack (&s2);
[+] 	unpacker.unpack(&s2);
[-] 	unpacker.unpack (&l2);
[+] 	unpacker.unpack(&l2);
[-] 	printf ("%s %d %s %d\n", s1, l1, s2, l2);
[+] 	printf("%s %d %s %d\n", s1, l1, s2, l2);
[-] ADD_TEST_CASE ("test_Packer", run)
[+] ADD_TEST_CASE("test_Packer", run)
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\test_Packetizer.cpp
----------------------
[-] class MyPacketizer: public sl::Packetizer <MyPacketizer>
[+] class MyPacketizer: public sl::Packetizer<MyPacketizer>
[-] 	onPacket (
[+] 	onPacket(
[-] 		printf ("packet received: %s\n", p);
[+] 		printf("packet received: %s\n", p);
[-] run ()
[+] run()
[-] 	printf ("test_Packetizer::Run ()\n");
[+] 	printf("test_Packetizer::Run ()\n");
[-] 	char data [] = "papapaapak:\xf\0\0\0pizda ivanovna";
[+] 	char data[] = "papapaapak:\xf\0\0\0pizda ivanovna";
[-] 		size_t size = sizeof (data);
[+] 		size_t size = sizeof(data);
[-] 			size_t chunkSize = rand () % (sizeof (data) + 1);
[+] 			size_t chunkSize = rand() % (sizeof(data) + 1);
[-] 			packetizer.write (p, chunkSize);
[+] 			packetizer.write(p, chunkSize);
[-] 		printf ("complete (%d, %d chunks).\n", i, j);
[+] 		printf("complete (%d, %d chunks).\n", i, j);
[-] 	s.clear ();
[+] 	s.clear();
[-] 	printf ("done.\n");
[+] 	printf("done.\n");
[-] ADD_TEST_CASE ("test_Packetizer", run)
[+] ADD_TEST_CASE("test_Packetizer", run)
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\test_RbTree.cpp
----------------------
[-] class MapIteratorX: public sl::Iterator <sl::MapEntry <Key, Value> >
[+] class MapIteratorX: public sl::Iterator<sl::MapEntry<Key, Value> >
[-] 	MapIteratorX ()
[+] 	MapIteratorX()
[-] 	MapIteratorX (const sl::Iterator <T>& src)
[+] 	MapIteratorX(const sl::Iterator<T>& src)
[-] 		this->m_p = src.getEntry ();
[+] 		this->m_p = src.getEntry();
[-] run ()
[+] run()
[-] 	sl::Iterator <Derived> itDerived;
[+] 	sl::Iterator<Derived> itDerived;
[-] 	sl::Iterator <Base> itBase;
[+] 	sl::Iterator<Base> itBase;
[-] 	sl::RbTree <int, int> tree;
[+] 	sl::RbTree<int, int> tree;
[-] 	sl::RbTree <int, int>::Iterator it;
[+] 	sl::RbTree<int, int>::Iterator it;
[-] 	MapIteratorX <int, int> it2 = tree.find (100);
[+] 	MapIteratorX<int, int> it2 = tree.find(100);
[-] 		tree.visit (rand () % 50);
[+] 		tree.visit(rand() % 50);
[-] 	it = tree.getHead ();
[+] 	it = tree.getHead();
[-] 		printf ("%d\n", it->getKey ());
[+] 		printf("%d\n", it->getKey ());
[-] 	printf (".........\n");
[+] 	printf(".........\n");
[-] 		tree.eraseKey (rand () % 50);
[+] 		tree.eraseKey(rand() % 50);
[-] 	it = tree.getHead ();
[+] 	it = tree.getHead();
[-] 		printf ("%d\n", it->getKey ());
[+] 		printf("%d\n", it->getKey ());
[-] 	printf (".........\n");
[+] 	printf(".........\n");
[-] ADD_TEST_CASE ("test_RbTree", run)
[+] ADD_TEST_CASE("test_RbTree", run)
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\test_Ref.cpp
----------------------
[-] 	MyClass ()
[+] 	MyClass()
[-] 		printf ("MyClass::MyClass ()\n");
[+] 		printf("MyClass::MyClass ()\n");
[-] 	MyClass (const MyClass& src)
[+] 	MyClass(const MyClass& src)
[-] 		printf ("MyClass::MyClass (const MyClass&)\n");
[+] 		printf("MyClass::MyClass (const MyClass&)\n");
[-] 	~MyClass ()
[+] 	~MyClass()
[-] 		printf ("MyClass::~MyClass ()\n");
[+] 		printf("MyClass::~MyClass ()\n");
[-] 		printf ("MyClass::operator = (const MyClass&)\n");
[+] 		printf("MyClass::operator = (const MyClass&)\n");
[-] 	Point ()
[+] 	Point()
[-] 		printf ("Point::Point ()\n");
[+] 		printf("Point::Point ()\n");
[-] 	~Point ()
[+] 	~Point()
[-] 		printf ("Point::~Point ()\n");
[+] 		printf("Point::~Point ()\n");
[-] typedef ref::Buf <Point> PointBuf;
[+] typedef ref::Buf<Point> PointBuf;
[-] run_Buf ()
[+] run_Buf()
[-] 	char x = s [10];
[+] 	char x = s[10];
[-] 	s.clear ();
[+] 	s.clear();
[-] 	sl::Array <uchar_t> arr;
[+] 	sl::Array<uchar_t> arr;
[-] 	arr.setCount (10);
[+] 	arr.setCount(10);
[-] 	sl::Array <uchar_t> arr2 = arr;
[+] 	sl::Array<uchar_t> arr2 = arr;
[-] 	arr2 [0] = 10;
[+] 	arr2[0] = 10;
[-] 	ref::Buf <DCB, DcbGetSize> dcb;
[+] 	ref::Buf<DCB, DcbGetSize> dcb;
[-] 	dcb.getBuffer ();
[+] 	dcb.getBuffer();
[-] 	ref::Buf <DCB, DcbGetSize> dcb2 = dcb;
[+] 	ref::Buf<DCB, DcbGetSize> dcb2 = dcb;
[-] 	dcb2.getBuffer ();
[+] 	dcb2.getBuffer();
[-] 	ref::Buf <MyClass> b1;
[+] 	ref::Buf<MyClass> b1;
[-] 	ref::Buf <MyClass> b2 = b1;
[+] 	ref::Buf<MyClass> b2 = b1;
[-] 	b1.getBuffer ();
[+] 	b1.getBuffer();
[-] 	b1.release ();
[+] 	b1.release();
[-] 	b2.release ();
[+] 	b2.release();
[-] 	size_t bufSize = sizeof (Point) + sizeof (ref::BufHdr);
[+] 	size_t bufSize = sizeof(Point) + sizeof(ref::BufHdr);
[-] 	PointBuf point (ref::BufKind_Stack, _alloca (bufSize), bufSize);
[+] 	PointBuf point(ref::BufKind_Stack, _alloca(bufSize), bufSize);
[-] 	point.createBuffer ();
[+] 	point.createBuffer();
[-] 	printf ("point: %p, %d, %d\n", point.cp (), point->x, point->y);
[+] 	printf("point: %p, %d, %d\n", point.cp (), point->x, point->y);
[-] 	printf ("point2: %p, %d, %d\n", point.cp (), point2->x, point2->y);
[+] 	printf("point2: %p, %d, %d\n", point.cp (), point2->x, point2->y);
[-] 	printf ("point: %d, %d\n", point->x, point->y);
[+] 	printf("point: %d, %d\n", point->x, point->y);
[-] 	printf ("point2: %d, %d\n", point2->x, point2->y);
[+] 	printf("point2: %d, %d\n", point2->x, point2->y);
[-] 	char buf [80];
[+] 	char buf[80];
[-] 	sl::String string (ref::BufKind_Stack, buf, sizeof (buf));
[+] 	sl::String string(ref::BufKind_Stack, buf, sizeof(buf));
[-] 	string.format ("hui %d %d %d", 1, 2, 3);
[+] 	string.format("hui %d %d %d", 1, 2, 3);
[-] 	string.append ("govno");
[+] 	string.append("govno");
[-] 	string.append ("muravei");
[+] 	string.append("muravei");
[-] 	MyClass2 ()
[+] 	MyClass2()
[-] 		printf ("MyClass2::MyClass2 ()\n");
[+] 		printf("MyClass2::MyClass2 ()\n");
[-] 	~MyClass2 ()
[+] 	~MyClass2()
[-] 		printf ("MyClass2::MyClass2 ()\n");
[+] 		printf("MyClass2::MyClass2 ()\n");
[-] run_WeakRef ()
[+] run_WeakRef()
[-] 	ref::Ptr <MyClass2> p = AXL_REF_NEW (MyClass2);
[+] 	ref::Ptr<MyClass2> p = AXL_REF_NEW(MyClass2);
[-] 	ref::WeakPtr <MyClass2> w = p;
[+] 	ref::WeakPtr<MyClass2> w = p;
[-] 	virtual ref::Ptr <IMyInterface> getChild (int i) = 0;
[+] 	virtual ref::Ptr<IMyInterface> getChild(int i) = 0;
[-] 	virtual void doSomething () = 0;
[+] 	virtual void doSomething() = 0;
[-] 	virtual void doSomethingElse () = 0;
[+] 	virtual void doSomethingElse() = 0;
[-] 	MyClass4 ()
[+] 	MyClass4()
[-] 		{ printf ("MyClass4::MyClass4 ()\n"); }
[+] 		{ printf("MyClass4::MyClass4 ()\n"); }
[-] 	~MyClass4 ()
[+] 	~MyClass4()
[-] 		{ printf ("MyClass4::~MyClass4 ()\n"); }
[+] 		{ printf("MyClass4::~MyClass4 ()\n"); }
[-] 	ref::Ptr <IMyInterface> getChild (int i)
[+] 	ref::Ptr<IMyInterface> getChild(int i)
[-] 	virtual void doSomething ()
[+] 	virtual void doSomething()
[-] 		{ printf ("MyClass4::doSomething ()\n"); }
[+] 		{ printf("MyClass4::doSomething ()\n"); }
[-] 	virtual void doSomethingElse ()
[+] 	virtual void doSomethingElse()
[-] 		{ printf ("MyClass4::doSomethingElse ()\n"); }
[+] 		{ printf("MyClass4::doSomethingElse ()\n"); }
[-] 	ref::Child <ref::Box <MyClass4> > m_child1;
[+] 	ref::Child<ref::Box<MyClass4> > m_child1;
[-] 	ref::Child <ref::Box <MyClass4> > m_child2;
[+] 	ref::Child<ref::Box<MyClass4> > m_child2;
[-] 	ref::Child <ref::Box <MyClass4> > m_child3;
[+] 	ref::Child<ref::Box<MyClass4> > m_child3;
[-] 	MyContainer () :
[+] 	MyContainer() :
[-] 		m_child1 (this),
[+] 		m_child1(this),
[-] 		m_child2 (this),
[+] 		m_child2(this),
[-] 		m_child3 (this)
[+] 		m_child3(this)
[-] 		{ printf ("MyContainer::MyContainer ()\n"); }
[+] 		{ printf("MyContainer::MyContainer ()\n"); }
[-] 	~MyContainer ()
[+] 	~MyContainer()
[-] 		{ printf ("MyContainer::~MyContainer ()\n"); }
[+] 		{ printf("MyContainer::~MyContainer ()\n"); }
[-] 	ref::Ptr <IMyInterface> getChild (int i)
[+] 	ref::Ptr<IMyInterface> getChild(int i)
[-] 		switch (i)
[+] 		switch(i)
[-] 	virtual void doSomething ()
[+] 	virtual void doSomething()
[-] 		{ printf ("MyContainer::doSomething ()\n"); }
[+] 		{ printf("MyContainer::doSomething ()\n"); }
[-] 	virtual void doSomethingElse ()
[+] 	virtual void doSomethingElse()
[-] 		{ printf ("MyContainer::doSomethingElse ()\n"); }
[+] 		{ printf("MyContainer::doSomethingElse ()\n"); }
[-] 	ref::Child <MyContainer> m_child1;
[+] 	ref::Child<MyContainer> m_child1;
[-] 	ref::Child <MyContainer> m_child2;
[+] 	ref::Child<MyContainer> m_child2;
[-] 	ref::Child <ref::Box <MyClass4> > m_child3;
[+] 	ref::Child<ref::Box<MyClass4> > m_child3;
[-] 	MySuperContainer () :
[+] 	MySuperContainer() :
[-] 		m_child1 (this),
[+] 		m_child1(this),
[-] 		m_child2 (this),
[+] 		m_child2(this),
[-] 		m_child3 (this)
[+] 		m_child3(this)
[-] 		{ printf ("MySuperContainer::MySuperContainer ()\n"); }
[+] 		{ printf("MySuperContainer::MySuperContainer ()\n"); }
[-] 	~MySuperContainer ()
[+] 	~MySuperContainer()
[-] 		{ printf ("MySuperContainer::~MySuperContainer ()\n"); }
[+] 		{ printf("MySuperContainer::~MySuperContainer ()\n"); }
[-] 	ref::Ptr <IMyInterface> getChild (int i)
[+] 	ref::Ptr<IMyInterface> getChild(int i)
[-] 		switch (i)
[+] 		switch(i)
[-] 	virtual void doSomething ()
[+] 	virtual void doSomething()
[-] 		{ printf ("MySuperContainer::doSomething ()\n"); }
[+] 		{ printf("MySuperContainer::doSomething ()\n"); }
[-] 	virtual void doSomethingElse ()
[+] 	virtual void doSomethingElse()
[-] 		{ printf ("MySuperContainer::doSomethingElse ()\n"); }
[+] 		{ printf("MySuperContainer::doSomethingElse ()\n"); }
[-] run_Container ()
[+] run_Container()
[-] 	ref::Ptr <IMyInterface> p;
[+] 	ref::Ptr<IMyInterface> p;
[-] 	ref::Ptr <IMyInterface> p2;
[+] 	ref::Ptr<IMyInterface> p2;
[-] 	ref::Ptr <IMyInterface> p3;
[+] 	ref::Ptr<IMyInterface> p3;
[-] 	p = AXL_REF_NEW (MySuperContainer);
[+] 	p = AXL_REF_NEW(MySuperContainer);
[-] 	p->doSomething ();
[+] 	p->doSomething();
[-] 	p->doSomethingElse ();
[+] 	p->doSomethingElse();
[-] 	p->getChild (1)->doSomething ();
[+] 	p->getChild(1)->doSomething();
[-] 	p->getChild (1)->doSomethingElse ();
[+] 	p->getChild(1)->doSomethingElse();
[-] 	p->getChild (2)->doSomething ();
[+] 	p->getChild(2)->doSomething();
[-] 	p->getChild (2)->doSomethingElse ();
[+] 	p->getChild(2)->doSomethingElse();
[-] 	p3 = AXL_REF_NEW (ref::Box <MyClass4>);
[+] 	p3 = AXL_REF_NEW(ref::Box<MyClass4>);
[-] 	ref::WeakPtr <IMyInterface> w = p3;
[+] 	ref::WeakPtr<IMyInterface> w = p3;
[-] 	p3->doSomethingElse ();
[+] 	p3->doSomethingElse();
[-] run ()
[+] run()
[-] 	run_Buf ();
[+] 	run_Buf();
[-] 	run_WeakRef ();
[+] 	run_WeakRef();
[-] 	run_Container ();
[+] 	run_Container();
[-] ADD_TEST_CASE ("test_Ref", run)
[+] ADD_TEST_CASE("test_Ref", run)
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\test_StringTemplate.cpp
----------------------
[-] run ()
[+] run()
[-] 	result = file.open (fileName, io::FileFlag_ReadOnly);
[+] 	result = file.open(fileName, io::FileFlag_ReadOnly);
[-] 		printf ("error: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("error: %s\n", err::getLastErrorDescription ().sz ());
[-] 	char* p = (char*) file.view ();
[+] 	char* p = (char*)file.view();
[-] 	size_t size = (size_t) file.getSize ();
[+] 	size_t size = (size_t)file.getSize();
[-] 	result = st.process (&resultString, fileName, sl::StringRef (p, size));
[+] 	result = st.process(&resultString, fileName, sl::StringRef(p, size));
[-] 		printf ("error processing string template: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("error processing string template: %s\n", err::getLastErrorDescription ().sz ());
[-] 	printf ("result string:\n%s\n", resultString.sz ());
[+] 	printf("result string:\n%s\n", resultString.sz ());
[-] ADD_TEST_CASE ("test_StringTemplate", run)
[+] ADD_TEST_CASE("test_StringTemplate", run)
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\test_Usb.cpp
----------------------
[-] run ()
[+] run()
[-] 	io::registerUsbErrorProvider ();
[+] 	io::registerUsbErrorProvider();
[-] 	bool result = io::getUsbDefaultContext ()->createDefault ();
[+] 	bool result = io::getUsbDefaultContext()->createDefault();
[-] 		printf ("Cannot initialize libusb: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("Cannot initialize libusb: %s\n", err::getLastErrorDescription ().sz ());
[-] 	size_t count = deviceList.enumerateDevices ();
[+] 	size_t count = deviceList.enumerateDevices();
[-] 		printf ("Cannot enumerate USB devices (%s)\n", err::getLastErrorDescription ().sz ());
[+] 		printf("Cannot enumerate USB devices (%s)\n", err::getLastErrorDescription ().sz ());
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] 	bufferString.createBuffer (4096);
[+] 	bufferString.createBuffer(4096);
[-] 		device.setDevice (*pp);
[+] 		device.setDevice(*pp);
[-] 		device.getDeviceDescriptor (&descriptor);
[+] 		device.getDeviceDescriptor(&descriptor);
[-] 		printf (
[+] 		printf(
[-] 			device.getBusNumber (),
[+] 			device.getBusNumber(),
[-] 			device.getDeviceAddress ()
[+] 			device.getDeviceAddress()
[-] 		result = device.open ();
[+] 		result = device.open();
[-] 		result = device.getStringDesrciptor (descriptor.iManufacturer, &bufferString);
[+] 		result = device.getStringDesrciptor(descriptor.iManufacturer, &bufferString);
[-] 			printf ("\tManufacturer:  %s\n", bufferString.sz ());
[+] 			printf("\tManufacturer:  %s\n", bufferString.sz ());
[-] 		result = device.getStringDesrciptor (descriptor.iProduct, &bufferString);
[+] 		result = device.getStringDesrciptor(descriptor.iProduct, &bufferString);
[-] 			printf ("\tProduct name:  %s\n", bufferString.sz ());
[+] 			printf("\tProduct name:  %s\n", bufferString.sz ());
[-] 		result = device.getStringDesrciptor (descriptor.iSerialNumber, &bufferString);
[+] 		result = device.getStringDesrciptor(descriptor.iSerialNumber, &bufferString);
[-] 			printf ("\tSerial number: %s\n", bufferString.sz ());
[+] 			printf("\tSerial number: %s\n", bufferString.sz ());
[-] ADD_TEST_CASE ("test_Usb", run)
[+] ADD_TEST_CASE("test_Usb", run)
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\pch.h
----------------------
[-] #	pragma comment (lib, "ws2_32.lib")
[+] #	pragma comment(lib, "ws2_32.lib")
[-] #	pragma comment (lib, "crypt32.lib")
[+] #	pragma comment(lib, "crypt32.lib")
[-] #	pragma comment (lib, "comctl32.lib")
[+] #	pragma comment(lib, "comctl32.lib")
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_auto\test.h
----------------------
[-] TestFunc ();
[+] TestFunc();
[-] sl::StringHashTable <TestFunc*> TestSet;
[+] sl::StringHashTable<TestFunc*> TestSet;
[-] getTestCaseSet ()
[+] getTestCaseSet()
[-] 	return sl::getSingleton <TestSet> (&flag);
[+] 	return sl::getSingleton<TestSet> (&flag);
[-] 	AddTestCase (
[+] 	AddTestCase(
[-] 		getTestCaseSet ()->add (name, func);
[+] 		getTestCaseSet()->add(name, func);
[-] 	static AddTestCase testCaseAdder_ ## func (name, func);
[+] 	static AddTestCase testCaseAdder_ ## func(name, func);
[-] 	(void) (throw "Assertion failure at: " __FILE__ "(" AXL_ITOA (__LINE__) "): " #e))
[+] 	(void)(throw "Assertion failure at: " __FILE__ "(" AXL_ITOA (__LINE__) "): " #e))
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_con\main.cpp
----------------------
[-] printAdapterAddress (const IP_ADDR_STRING* ipAddrString)
[+] printAdapterAddress(const IP_ADDR_STRING* ipAddrString)
[-] 		printf ("  #%-2d IP:   %s\n", i, ipAddrString->IpAddress.String);
[+] 		printf("  #%-2d IP:   %s\n", i, ipAddrString->IpAddress.String);
[-] 		printf ("  #%-2d MASK: %s\n", i, ipAddrString->IpMask.String);
[+] 		printf("  #%-2d MASK: %s\n", i, ipAddrString->IpMask.String);
[-] printAdapterInfo (IP_ADAPTER_INFO* ipAdapter)
[+] printAdapterInfo(IP_ADAPTER_INFO* ipAdapter)
[-] 	switch (ipAdapter->Type)
[+] 	switch(ipAdapter->Type)
[-] 		printf ("MIB_IF_TYPE_LOOPBACK\n");
[+] 		printf("MIB_IF_TYPE_LOOPBACK\n");
[-] 		printf ("MIB_IF_TYPE_ETHERNET\n");
[+] 		printf("MIB_IF_TYPE_ETHERNET\n");
[-] 		printf ("IF_TYPE_IEEE80211\n");
[+] 		printf("IF_TYPE_IEEE80211\n");
[-] 		printf ("MIB_IF_TYPE_PPP\n");
[+] 		printf("MIB_IF_TYPE_PPP\n");
[-] 		printf ("MIB_IF_TYPE_TOKENRING\n");
[+] 		printf("MIB_IF_TYPE_TOKENRING\n");
[-] 		printf ("MIB_IF_TYPE_SLIP\n");
[+] 		printf("MIB_IF_TYPE_SLIP\n");
[-] 		printf ("unknown adapter type #%d\n", ipAdapter->Type);
[+] 		printf("unknown adapter type #%d\n", ipAdapter->Type);
[-] 	printf ("AdapterName = %s\n", ipAdapter->AdapterName);
[+] 	printf("AdapterName = %s\n", ipAdapter->AdapterName);
[-] 	printf ("Description = %s\n", ipAdapter->Description);
[+] 	printf("Description = %s\n", ipAdapter->Description);
[-] 	printf ("MAC         = %02x:%02x:%02x:%02x:%02x:%02x\n",
[+] 	printf("MAC         = %02x:%02x:%02x:%02x:%02x:%02x\n",
[-] 		ipAdapter->Address [0],
[+] 		ipAdapter->Address[0],
[-] 		ipAdapter->Address [1],
[+] 		ipAdapter->Address[1],
[-] 		ipAdapter->Address [2],
[+] 		ipAdapter->Address[2],
[-] 		ipAdapter->Address [3],
[+] 		ipAdapter->Address[3],
[-] 		ipAdapter->Address [4],
[+] 		ipAdapter->Address[4],
[-] 		ipAdapter->Address [5]
[+] 		ipAdapter->Address[5]
[-] 	printf ("DHCP        = %d\n", ipAdapter->DhcpEnabled);
[+] 	printf("DHCP        = %d\n", ipAdapter->DhcpEnabled);
[-] 	printf ("ADDRESS:\n");
[+] 	printf("ADDRESS:\n");
[-] 	printAdapterAddress (&ipAdapter->IpAddressList);
[+] 	printAdapterAddress(&ipAdapter->IpAddressList);
[-] 	printf ("GATEWAY:\n");
[+] 	printf("GATEWAY:\n");
[-] 	printAdapterAddress (&ipAdapter->GatewayList);
[+] 	printAdapterAddress(&ipAdapter->GatewayList);
[-] 	printf ("DHCP:\n");
[+] 	printf("DHCP:\n");
[-] 	printAdapterAddress (&ipAdapter->DhcpServer);
[+] 	printAdapterAddress(&ipAdapter->DhcpServer);
[-] 	printf ("---\n\n");
[+] 	printf("---\n\n");
[-] testWinNetworkAdapterList ()
[+] testWinNetworkAdapterList()
[-] 	printf ("Using GetAdaptersInfo...\n\n");
[+] 	printf("Using GetAdaptersInfo...\n\n");
[-] 	dword_t error = ::GetAdaptersInfo (NULL, &size);
[+] 	dword_t error = ::GetAdaptersInfo(NULL, &size);
[-] 		printf ("GetAdaptersInfo failed (%d)\n", error);
[+] 		printf("GetAdaptersInfo failed (%d)\n", error);
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	sl::Array <char> bufferArray (ref::BufKind_Stack, buffer, sizeof (buffer));
[+] 	sl::Array<char> bufferArray(ref::BufKind_Stack, buffer, sizeof(buffer));
[-] 	bufferArray.setCount (size);
[+] 	bufferArray.setCount(size);
[-] 	IP_ADAPTER_INFO* ipAdapter = (IP_ADAPTER_INFO*) bufferArray.p ();
[+] 	IP_ADAPTER_INFO* ipAdapter = (IP_ADAPTER_INFO*)bufferArray.p();
[-] 	error = ::GetAdaptersInfo (ipAdapter, &size);
[+] 	error = ::GetAdaptersInfo(ipAdapter, &size);
[-] 		printf ("GetAdaptersInfo failed (%d)\n", error);
[+] 		printf("GetAdaptersInfo failed (%d)\n", error);
[-] 		printAdapterInfo (ipAdapter);
[+] 		printAdapterInfo(ipAdapter);
[-] 	printf ("%d adapters found\n---------------------------------\n\n", count);
[+] 	printf("%d adapters found\n---------------------------------\n\n", count);
[-] testWinNetworkAdapterList2 ()
[+] testWinNetworkAdapterList2()
[-] 	printf ("Using WinIoctl...\n\n");
[+] 	printf("Using WinIoctl...\n\n");
[-] 	printf (
[+] 	printf(
[-] 		sizeof (sockaddr),
[+] 		sizeof(sockaddr),
[-] 		sizeof (sockaddr_in),
[+] 		sizeof(sockaddr_in),
[-] 		sizeof (sockaddr_in6),
[+] 		sizeof(sockaddr_in6),
[-] 		sizeof (sockaddr_storage),
[+] 		sizeof(sockaddr_storage),
[-] 		sizeof (io::SockAddr)
[+] 		sizeof(io::SockAddr)
[-] 	bool result = socket.wsaOpen (AF_INET, SOCK_DGRAM, 0);
[+] 	bool result = socket.wsaOpen(AF_INET, SOCK_DGRAM, 0);
[-] 		printf ("socket.wsaOpen failed (%s)\n", err::getLastErrorDescription ().sz ());
[+] 		printf("socket.wsaOpen failed (%s)\n", err::getLastErrorDescription ().sz ());
[-] 	size_t size = 16 * sizeof (INTERFACE_INFO);
[+] 	size_t size = 16 * sizeof(INTERFACE_INFO);
[-] 	sl::Array <char> buffer;
[+] 	sl::Array<char> buffer;
[-] 	buffer.setCount (size);
[+] 	buffer.setCount(size);
[-] 		int result = ::WSAIoctl (
[+] 		int result = ::WSAIoctl(
[-] 			buffer.p (),
[+] 			buffer.p(),
[-] 		dword_t error = ::WSAGetLastError ();
[+] 		dword_t error = ::WSAGetLastError();
[-] 			printf ("WSAIoctl failed (%s)\n", err::Error (error).getDescription ().sz ());
[+] 			printf("WSAIoctl failed (%s)\n", err::Error (error).getDescription ().sz ());
[-] 		buffer.setCount (size);
[+] 		buffer.setCount(size);
[-] 	const INTERFACE_INFO* iface = (const INTERFACE_INFO*) buffer.cp ();
[+] 	const INTERFACE_INFO* iface = (const INTERFACE_INFO*) buffer.cp();
[-] 	size_t ifaceCount = actualSize / sizeof (INTERFACE_INFO);
[+] 	size_t ifaceCount = actualSize / sizeof(INTERFACE_INFO);
[-] 		printf ("Interface #%d\n", i);
[+] 		printf("Interface #%d\n", i);
[-] 		printf ("  Address   = %s\n", io::getSockAddrString ((const sockaddr*) &iface->iiAddress).sz ());
[+] 		printf("  Address   = %s\n", io::getSockAddrString ((const sockaddr*) &iface->iiAddress).sz ());
[-] 		printf ("  Broadcast = %s\n", io::getSockAddrString ((const sockaddr*) &iface->iiBroadcastAddress).sz ());
[+] 		printf("  Broadcast = %s\n", io::getSockAddrString ((const sockaddr*) &iface->iiBroadcastAddress).sz ());
[-] 		printf ("  Netmask   = %s\n", io::getSockAddrString ((const sockaddr*) &iface->iiNetmask).sz ());
[+] 		printf("  Netmask   = %s\n", io::getSockAddrString ((const sockaddr*) &iface->iiNetmask).sz ());
[-] 	printf ("%d adapters found\n---------------------------------\n\n", ifaceCount);
[+] 	printf("%d adapters found\n---------------------------------\n\n", ifaceCount);
[-] getFileTimes_nt (const char* fileName)
[+] getFileTimes_nt(const char* fileName)
[-] 	bool result = file.open (fileName);
[+] 	bool result = file.open(fileName);
[-] 		printf ("can't open %s: %s\n", fileName, err::getLastErrorDescription ().sz ());
[+] 		printf("can't open %s: %s\n", fileName, err::getLastErrorDescription ().sz ());
[-] 	NTSTATUS status = ntQueryInformationFile (
[+] 	NTSTATUS status = ntQueryInformationFile(
[-] 		(HANDLE) file.m_file,
[+] 		(HANDLE)file.m_file,
[-] 		sizeof (FILE_BASIC_INFORMATION),
[+] 		sizeof(FILE_BASIC_INFORMATION),
[-] 		printf ("can't query file information: %s: %s\n", fileName, sys::win::NtStatus (status).getDescription ().sz ());
[+] 		printf("can't query file information: %s: %s\n", fileName, sys::win::NtStatus (status).getDescription ().sz ());
[-] 	printf ("NT File times for: %s\n", fileName);
[+] 	printf("NT File times for: %s\n", fileName);
[-] 	printf ("  CreationTime:   %s\n", sys::Time (basicInfo.CreationTime.QuadPart).format ().sz ());
[+] 	printf("  CreationTime:   %s\n", sys::Time (basicInfo.CreationTime.QuadPart).format ().sz ());
[-] 	printf ("  LastWriteTime:  %s\n", sys::Time (basicInfo.LastWriteTime.QuadPart).format ().sz ());
[+] 	printf("  LastWriteTime:  %s\n", sys::Time (basicInfo.LastWriteTime.QuadPart).format ().sz ());
[-] 	printf ("  LastAccessTime: %s\n", sys::Time (basicInfo.LastAccessTime.QuadPart).format ().sz ());
[+] 	printf("  LastAccessTime: %s\n", sys::Time (basicInfo.LastAccessTime.QuadPart).format ().sz ());
[-] 	printf ("  ChangeTime:     %s\n", sys::Time (basicInfo.ChangeTime.QuadPart).format ().sz ());
[+] 	printf("  ChangeTime:     %s\n", sys::Time (basicInfo.ChangeTime.QuadPart).format ().sz ());
[-] getFileTimes_win (const char* fileName)
[+] getFileTimes_win(const char* fileName)
[-] 	bool result = file.open (fileName);
[+] 	bool result = file.open(fileName);
[-] 		printf ("can't open %s: %s\n", fileName, err::getLastErrorDescription ().sz ());
[+] 		printf("can't open %s: %s\n", fileName, err::getLastErrorDescription ().sz ());
[-] 	result = ::GetFileInformationByHandleEx (file.m_file, FileBasicInfo, &basicInfo2, sizeof (basicInfo2)) != 0;
[+] 	result = ::GetFileInformationByHandleEx(file.m_file, FileBasicInfo, &basicInfo2, sizeof(basicInfo2)) != 0;
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
[-] 		printf ("can't query file information: %s, %s\n", fileName, err::getLastErrorDescription ().sz ());
[+] 		printf("can't query file information: %s, %s\n", fileName, err::getLastErrorDescription ().sz ());
[-] 	printf ("WIN File times for: %s\n", fileName);
[+] 	printf("WIN File times for: %s\n", fileName);
[-] 	printf ("  CreationTime:   %s\n", sys::Time (basicInfo2.CreationTime.QuadPart).format ().sz ());
[+] 	printf("  CreationTime:   %s\n", sys::Time (basicInfo2.CreationTime.QuadPart).format ().sz ());
[-] 	printf ("  LastWriteTime:  %s\n", sys::Time (basicInfo2.LastWriteTime.QuadPart).format ().sz ());
[+] 	printf("  LastWriteTime:  %s\n", sys::Time (basicInfo2.LastWriteTime.QuadPart).format ().sz ());
[-] 	printf ("  LastAccessTime: %s\n", sys::Time (basicInfo2.LastAccessTime.QuadPart).format ().sz ());
[+] 	printf("  LastAccessTime: %s\n", sys::Time (basicInfo2.LastAccessTime.QuadPart).format ().sz ());
[-] 	printf ("  ChangeTime:     %s\n", sys::Time (basicInfo2.ChangeTime.QuadPart).format ().sz ());
[+] 	printf("  ChangeTime:     %s\n", sys::Time (basicInfo2.ChangeTime.QuadPart).format ().sz ());
[-] testFileTime ()
[+] testFileTime()
[-] 	getFileTimes_win ("c:/1/far/ioninja-3.7.4/bin/ioninja.exe");
[+] 	getFileTimes_win("c:/1/far/ioninja-3.7.4/bin/ioninja.exe");
[-] 	getFileTimes_nt ("c:/1/far/ioninja-3.7.4/bin/ioninja.exe");
[+] 	getFileTimes_nt("c:/1/far/ioninja-3.7.4/bin/ioninja.exe");
[-] 	getFileTimes_win ("c:/1/7z/ioninja-3.7.4/bin/ioninja.exe");
[+] 	getFileTimes_win("c:/1/7z/ioninja-3.7.4/bin/ioninja.exe");
[-] 	getFileTimes_nt ("c:/1/7z/ioninja-3.7.4/bin/ioninja.exe");
[+] 	getFileTimes_nt("c:/1/7z/ioninja-3.7.4/bin/ioninja.exe");
[-] testNetworkAdapterList ()
[+] testNetworkAdapterList()
[-] 	sl::List <io::NetworkAdapterDesc> adapterList;
[+] 	sl::List<io::NetworkAdapterDesc> adapterList;
[-] 	io::createNetworkAdapterDescList (&adapterList);
[+] 	io::createNetworkAdapterDescList(&adapterList);
[-] 	sl::Iterator <io::NetworkAdapterDesc> adapterIt = adapterList.getHead ();
[+] 	sl::Iterator<io::NetworkAdapterDesc> adapterIt = adapterList.getHead();
[-] 		printf ("Name        = %s\n", adapter->getName ().sz ());
[+] 		printf("Name        = %s\n", adapter->getName ().sz ());
[-] 		printf ("Description = %s\n", adapter->getDescription ().sz ());
[+] 		printf("Description = %s\n", adapter->getDescription ().sz ());
[-] 		printf ("Type        = %s\n", io::getNetworkAdapterTypeString (adapter->getType ()));
[+] 		printf("Type        = %s\n", io::getNetworkAdapterTypeString (adapter->getType ()));
[-] 		printf ("Flags       = %s\n", io::getNetworkAdapterFlagString (adapter->getFlags ()).sz ());
[+] 		printf("Flags       = %s\n", io::getNetworkAdapterFlagString (adapter->getFlags ()).sz ());
[-] 		sl::ConstList <io::NetworkAdapterAddress> addressList = adapter->getAddressList ();
[+] 		sl::ConstList<io::NetworkAdapterAddress> addressList = adapter->getAddressList();
[-] 		sl::ConstIterator <io::NetworkAdapterAddress> addressIt = addressList.getHead ();
[+] 		sl::ConstIterator<io::NetworkAdapterAddress> addressIt = addressList.getHead();
[-] 			printf ("%-11s = %s",
[+] 			printf("%-11s = %s",
[-] 				io::getSockAddrFamilyString (family),
[+] 				io::getSockAddrFamilyString(family),
[-] 				address->m_address.getString ().sz ()
[+] 				address->m_address.getString().sz()
[-] 				netMask.createNetMask_ip4 (address->m_netMaskBitCount);
[+] 				netMask.createNetMask_ip4(address->m_netMaskBitCount);
[-] 				printf (" (mask %s)\n", netMask.getString ().sz ());
[+] 				printf(" (mask %s)\n", netMask.getString ().sz ());
[-] 				printf ("/%d\n", address->m_netMaskBitCount);
[+] 				printf("/%d\n", address->m_netMaskBitCount);
[-] 		printf ("\n");
[+] 		printf("\n");
[-] 	printf ("%d adapters found\n", adapterList.getCount ());
[+] 	printf("%d adapters found\n", adapterList.getCount ());
[-] testParseFormatIp6 ()
[+] testParseFormatIp6()
[-] 	printf ("main ()\n");
[+] 	printf("main ()\n");
[-] 	result = sockAddr.parse ("6");
[+] 	result = sockAddr.parse("6");
[-] 	printf ("result = %d, addr = %s\n", result, sockAddr.getString ().sz ());
[+] 	printf("result = %d, addr = %s\n", result, sockAddr.getString ().sz ());
[-] 	result = sockAddr.parse ("[1::2:3:4:5]:6");
[+] 	result = sockAddr.parse("[1::2:3:4:5]:6");
[-] 	printf ("result = %d, addr = %s\n", result, sockAddr.getString ().sz ());
[+] 	printf("result = %d, addr = %s\n", result, sockAddr.getString ().sz ());
[-] 	result = sockAddr.parse ("[fe80::c990:d16e:a986:d56b%11]:10001");
[+] 	result = sockAddr.parse("[fe80::c990:d16e:a986:d56b%11]:10001");
[-] 	printf ("result = %d, addr = %s\n", result, sockAddr.getString ().sz ());
[+] 	printf("result = %d, addr = %s\n", result, sockAddr.getString ().sz ());
[-] 		ip [0] = rand () % 2 ? rand () : 0;
[+] 		ip[0] = rand() % 2 ? rand() : 0;
[-] 		ip [1] = rand () % 2 ? rand () : 0;
[+] 		ip[1] = rand() % 2 ? rand() : 0;
[-] 		ip [2] = rand () % 2 ? rand () : 0;
[+] 		ip[2] = rand() % 2 ? rand() : 0;
[-] 		ip [3] = rand () % 2 ? rand () : 0;
[+] 		ip[3] = rand() % 2 ? rand() : 0;
[-] 		ip [4] = rand () % 2 ? rand () : 0;
[+] 		ip[4] = rand() % 2 ? rand() : 0;
[-] 		ip [5] = rand () % 2 ? rand () : rand () % 2 ? 0xffff : 0;
[+] 		ip[5] = rand() % 2 ? rand() : rand() % 2 ? 0xffff : 0;
[-] 		ip [6] = rand () % 2 ? rand () : 0;
[+] 		ip[6] = rand() % 2 ? rand() : 0;
[-] 		ip [7] = rand () % 2 ? rand () : 0;
[+] 		ip[7] = rand() % 2 ? rand() : 0;
[-] 		addr.sin6_port = rand () % 2 ? rand () : 0;
[+] 		addr.sin6_port = rand() % 2 ? rand() : 0;
[-] 		addr.sin6_scope_id = rand () % 2 ? rand () : 0;
[+] 		addr.sin6_scope_id = rand() % 2 ? rand() : 0;
[-] 		sl::String addrString = io::getSockAddrString ((const sockaddr*) &addr).sz ();
[+] 		sl::String addrString = io::getSockAddrString((const sockaddr*) &addr).sz();
[-] 		printf ("addr1 = %s\n", addrString.sz ());
[+] 		printf("addr1 = %s\n", addrString.sz ());
[-] 		char addrString2 [1024] = { 0 };
[+] 		char addrString2[1024] = { 0 };
[-] 		dword_t size = sizeof (addrString2);
[+] 		dword_t size = sizeof(addrString2);
[-] 		WSAAddressToStringA ((sockaddr*) &addr, sizeof (addr), NULL, addrString2, &size);
[+] 		WSAAddressToStringA((sockaddr*) &addr, sizeof(addr), NULL, addrString2, &size);
[-] 		inet_ntop (AF_INET6, &addr.sin6_addr, addrString2, size);
[+] 		inet_ntop(AF_INET6, &addr.sin6_addr, addrString2, size);
[-] 		printf ("addr2 = %s\n\n", addrString2);
[+] 		printf("addr2 = %s\n\n", addrString2);
[-] 		ASSERT (addrString.cmp (addrString2) == 0);
[+] 		ASSERT(addrString.cmp(addrString2) == 0);
[-] 		result = io::parseSockAddr ((sockaddr*) &addr2, sizeof (addr2), addrString);
[+] 		result = io::parseSockAddr((sockaddr*) &addr2, sizeof(addr2), addrString);
[-] 		ASSERT (result && memcmp (&addr, &addr2, sizeof (addr)) == 0);
[+] 		ASSERT(result && memcmp(&addr, &addr2, sizeof(addr)) == 0);
[-] testKeepAlives (const sl::StringRef& addrString)
[+] testKeepAlives(const sl::StringRef& addrString)
[-] 	printf ("Opening a TCP socket (%d sec keep-alives)...\n", delay);
[+] 	printf("Opening a TCP socket (%d sec keep-alives)...\n", delay);
[-] 		socket.open (AF_INET, SOCK_STREAM, IPPROTO_TCP) &&
[+] 		socket.open(AF_INET, SOCK_STREAM, IPPROTO_TCP) &&
[-] 		socket.setOption (SOL_SOCKET, SO_KEEPALIVE, &value, sizeof (value)) &&
[+] 		socket.setOption(SOL_SOCKET, SO_KEEPALIVE, &value, sizeof(value)) &&
[-] 		socket.setOption (IPPROTO_TCP, TCP_KEEPIDLE, &delay, sizeof (delay)) &&
[+] 		socket.setOption(IPPROTO_TCP, TCP_KEEPIDLE, &delay, sizeof(delay)) &&
[-] 		socket.setOption (IPPROTO_TCP, TCP_KEEPINTVL, &delay, sizeof (delay));
[+] 		socket.setOption(IPPROTO_TCP, TCP_KEEPINTVL, &delay, sizeof(delay));
[-] 		printf ("socket.open failed (%s)\n", err::getLastErrorDescription ().sz ());
[+] 		printf("socket.open failed (%s)\n", err::getLastErrorDescription ().sz ());
[-] 	printf ("Parsing address '%s'...\n", addrString.sz ());
[+] 	printf("Parsing address '%s'...\n", addrString.sz ());
[-] 	result = addr.parse (addrString);
[+] 	result = addr.parse(addrString);
[-] 		printf ("addr.parse failed (%s)\n", err::getLastErrorDescription ().sz ());
[+] 		printf("addr.parse failed (%s)\n", err::getLastErrorDescription ().sz ());
[-] 	printf ("Connecting to %s...\n", addr.getString ().sz ());
[+] 	printf("Connecting to %s...\n", addr.getString ().sz ());
[-] 	result = socket.connect (addr);
[+] 	result = socket.connect(addr);
[-] 		printf ("socket.connect failed (%s)\n", err::getLastErrorDescription ().sz ());
[+] 		printf("socket.connect failed (%s)\n", err::getLastErrorDescription ().sz ());
[-] 	printf ("Press CTRL+C to exit...\n");
[+] 	printf("Press CTRL+C to exit...\n");
[-] 		sys::sleep (1000);
[+] 		sys::sleep(1000);
[-] testAddrInfoIp6 ()
[+] testAddrInfoIp6()
[-] 	sl::Array <io::SockAddr> addrArray;
[+] 	sl::Array<io::SockAddr> addrArray;
[-] 	bool result = io::resolveHostName (&addrArray, name, AF_INET6);
[+] 	bool result = io::resolveHostName(&addrArray, name, AF_INET6);
[-] 		printf ("io::resolveHostName failed (%s)\n", err::getLastErrorDescription ().sz ());
[+] 		printf("io::resolveHostName failed (%s)\n", err::getLastErrorDescription ().sz ());
[-] 	printf ("host name %s resolved to:\n", name);
[+] 	printf("host name %s resolved to:\n", name);
[-] 	size_t count = addrArray.getCount ();
[+] 	size_t count = addrArray.getCount();
[-] 		printf ("    %s\n", addrArray [i].getString ().sz ());
[+] 		printf("    %s\n", addrArray [i].getString ().sz ());
[-] testDynamicLibrary ()
[+] testDynamicLibrary()
[-] 	bool result = dl.open ("libc.so.6");
[+] 	bool result = dl.open("libc.so.6");
[-] 		printf ("dl.load failed: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("dl.load failed: %s\n", err::getLastErrorDescription ().sz ());
[-] 	typedef int Printf (const char*, ...);
[+] 	typedef int Printf(const char*, ...);
[-] 	Printf* prn = (Printf*) dl.getFunction ("printf");
[+] 	Printf* prn = (Printf*)dl.getFunction("printf");
[-] 		printf ("dl.load failed: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("dl.load failed: %s\n", err::getLastErrorDescription ().sz ());
[-] 	prn ("hui govno i muravei %d\n", 123);
[+] 	prn("hui govno i muravei %d\n", 123);
[-] bar ()
[+] bar()
[-] 	printf ("bar -- throwing...\n");
[+] 	printf("bar -- throwing...\n");
[-] 	AXL_SYS_SJLJ_THROW ();
[+] 	AXL_SYS_SJLJ_THROW();
[-] testLongJmpTry ()
[+] testLongJmpTry()
[-] 	AXL_SYS_BEGIN_SJLJ_TRY ()
[+] 	AXL_SYS_BEGIN_SJLJ_TRY()
[-] 		bar ();
[+] 		bar();
[-] 	AXL_SYS_SJLJ_CATCH ()
[+] 	AXL_SYS_SJLJ_CATCH()
[-] 		printf ("exception caught\n");
[+] 		printf("exception caught\n");
[-] 	AXL_SYS_SJLJ_FINALLY ()
[+] 	AXL_SYS_SJLJ_FINALLY()
[-] 		printf ("finally\n");
[+] 		printf("finally\n");
[-] 	AXL_SYS_END_SJLJ_TRY ()
[+] 	AXL_SYS_END_SJLJ_TRY()
[-] 	AXL_SYS_BEGIN_SJLJ_TRY ()
[+] 	AXL_SYS_BEGIN_SJLJ_TRY()
[-] 		bar ();
[+] 		bar();
[-] 	AXL_SYS_SJLJ_CATCH ()
[+] 	AXL_SYS_SJLJ_CATCH()
[-] 		printf ("exception caught\n");
[+] 		printf("exception caught\n");
[-] 	AXL_SYS_END_SJLJ_TRY ()
[+] 	AXL_SYS_END_SJLJ_TRY()
[-] 	AXL_SYS_BEGIN_SJLJ_TRY ()
[+] 	AXL_SYS_BEGIN_SJLJ_TRY()
[-] 		bar ();
[+] 		bar();
[-] 	AXL_SYS_SJLJ_FINALLY ()
[+] 	AXL_SYS_SJLJ_FINALLY()
[-] 		printf ("finally\n");
[+] 		printf("finally\n");
[-] 	AXL_SYS_END_SJLJ_TRY ()
[+] 	AXL_SYS_END_SJLJ_TRY()
[-] 	AXL_SYS_BEGIN_SJLJ_TRY ()
[+] 	AXL_SYS_BEGIN_SJLJ_TRY()
[-] 		bar ();
[+] 		bar();
[-] 	AXL_SYS_END_SJLJ_TRY ()
[+] 	AXL_SYS_END_SJLJ_TRY()
[-] 	printf ("done\n");
[+] 	printf("done\n");
[-] testRegex ()
[+] testRegex()
[-] 	nameMgr.addName ("ws",  "[ \\t\\r\\n]");
[+] 	nameMgr.addName("ws",  "[ \\t\\r\\n]");
[-] 	nameMgr.addName ("dec", "[0-9]");
[+] 	nameMgr.addName("dec", "[0-9]");
[-] 	fsm::RegexCompiler regexCompiler (flags, &regex, &nameMgr);
[+] 	fsm::RegexCompiler regexCompiler(flags, &regex, &nameMgr);
[-] /*	char const* src [] =
[+] /*	char const* src[] =
[-] 	for (size_t i = 0; i < countof (src); i++)
[+] 	for (size_t i = 0; i < countof(src); i++)
[-] 		bool result = regexCompiler.incrementalCompile (src [i]);
[+] 		bool result = regexCompiler.incrementalCompile(src[i]);
[-] 			printf ("error: %s\n", err::getLastErrorDescription ().sz ());
[+] 			printf("error: %s\n", err::getLastErrorDescription ().sz ());
[-] 	regexCompiler.finalize ();
[+] 	regexCompiler.finalize();
[-] 	regex.print ();
[+] 	regex.print();
[-] 	bool result = regexCompiler.compile ("ab|cd");
[+] 	bool result = regexCompiler.compile("ab|cd");
[-] 		regexCompiler.incrementalCompile ("(\\h{2})   ' '+ (\\d{2})") &&
[+] 		regexCompiler.incrementalCompile("(\\h{2})   ' '+ (\\d{2})") &&
[-] 		regexCompiler.incrementalCompile ("([a-z]{3}) ' '+ ([A-Z]{3})\\n");
[+] 		regexCompiler.incrementalCompile("([a-z]{3}) ' '+ ([A-Z]{3})\\n");
[-] 		printf ("error: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("error: %s\n", err::getLastErrorDescription ().sz ());
[-] 	regexCompiler.finalize ();
[+] 	regexCompiler.finalize();
[-] 	regex.print ();
[+] 	regex.print();
[-] testNamedPipes ()
[+] testNamedPipes()
[-] 	HMODULE ntdll = ::GetModuleHandleW (L"ntdll.dll");
[+] 	HMODULE ntdll = ::GetModuleHandleW(L"ntdll.dll");
[-] 	ASSERT (ntdll);
[+] 	ASSERT(ntdll);
[-] 	bool result = pipeDir.create (
[+] 	bool result = pipeDir.create(
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
[-] 		printf ("cannot open pipe dir: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("cannot open pipe dir: %s\n", err::getLastErrorDescription ().sz ());
[-] 	sl::Array <char> dirBuffer;
[+] 	sl::Array<char> dirBuffer;
[-] 	dirBuffer.setCount (BufferSize);
[+] 	dirBuffer.setCount(BufferSize);
[-] 		status = ntQueryDirectoryFile (
[+] 		status = ntQueryDirectoryFile(
[-] 			dirBuffer.getCount (),
[+] 			dirBuffer.getCount(),
[-] 			err::setError (sys::win::NtStatus (status));
[+] 			err::setError(sys::win::NtStatus(status));
[-] 			printf ("cannot open pipe dir: %s\n", err::getLastErrorDescription ().sz ());
[+] 			printf("cannot open pipe dir: %s\n", err::getLastErrorDescription ().sz ());
[-] 		FILE_DIRECTORY_INFORMATION* dirInfo = (FILE_DIRECTORY_INFORMATION*) dirBuffer.p ();
[+] 		FILE_DIRECTORY_INFORMATION* dirInfo = (FILE_DIRECTORY_INFORMATION*)dirBuffer.p();
[-] 			fileName.copy (dirInfo->FileName, dirInfo->FileNameLength / 2);
[+] 			fileName.copy(dirInfo->FileName, dirInfo->FileNameLength / 2);
[-] 			printf (
[+] 			printf(
[-] 				fileName.sz (),
[+] 				fileName.sz(),
[-] 			dirInfo = (FILE_DIRECTORY_INFORMATION*) ((char*) dirInfo + dirInfo->NextEntryOffset);
[+] 			dirInfo = (FILE_DIRECTORY_INFORMATION*)((char*)dirInfo + dirInfo->NextEntryOffset);
[-] querySymbolicLink (
[+] querySymbolicLink(
[-] 	string->clear ();
[+] 	string->clear();
[-] 	oa.Length = sizeof (oa);
[+] 	oa.Length = sizeof(oa);
[-] 	status = ntOpenSymbolicLinkObject (
[+] 	status = ntOpenSymbolicLinkObject(
[-] 		link.p (),
[+] 		link.p(),
[-] 		err::setError (sys::win::NtStatus (status));
[+] 		err::setError(sys::win::NtStatus(status));
[-] 		printf ("cannot open symbolic link: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("cannot open symbolic link: %s\n", err::getLastErrorDescription ().sz ());
[-] 	wchar_t* p = string->createBuffer (BufferSize);
[+] 	wchar_t* p = string->createBuffer(BufferSize);
[-] 	size_t length = string->getLength ();
[+] 	size_t length = string->getLength();
[-] 	uniTarget.MaximumLength = length + sizeof (wchar_t);
[+] 	uniTarget.MaximumLength = length + sizeof(wchar_t);
[-] 	status = ntQuerySymbolicLinkObject (link, &uniTarget, NULL);
[+] 	status = ntQuerySymbolicLinkObject(link, &uniTarget, NULL);
[-] 		err::setError (sys::win::NtStatus (status));
[+] 		err::setError(sys::win::NtStatus(status));
[-] 		printf ("cannot query symbolic link: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("cannot query symbolic link: %s\n", err::getLastErrorDescription ().sz ());
[-] 	string->setReducedLength (uniTarget.Length / sizeof (wchar_t));
[+] 	string->setReducedLength(uniTarget.Length / sizeof(wchar_t));
[-] enumerateDirectory (
[+] enumerateDirectory(
[-] 	uniName.Buffer = (wchar_t*) name;
[+] 	uniName.Buffer = (wchar_t*)name;
[-] 	uniName.Length = wcslen_s (name) * sizeof (wchar_t);
[+] 	uniName.Length = wcslen_s(name)* sizeof(wchar_t);
[-] 	uniName.MaximumLength = uniName.Length + sizeof (wchar_t);
[+] 	uniName.MaximumLength = uniName.Length + sizeof(wchar_t);
[-] 	oa.Length = sizeof (oa);
[+] 	oa.Length = sizeof(oa);
[-] 	status = ntOpenDirectoryObject (
[+] 	status = ntOpenDirectoryObject(
[-] 		dir.p (),
[+] 		dir.p(),
[-] 		err::setError (sys::win::NtStatus (status));
[+] 		err::setError(sys::win::NtStatus(status));
[-] 		printf ("cannot open directory: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("cannot open directory: %s\n", err::getLastErrorDescription ().sz ());
[-] 	sl::Array <char> buffer;
[+] 	sl::Array<char> buffer;
[-] 	buffer.setCount (BufferSize);
[+] 	buffer.setCount(BufferSize);
[-] 	sl::String indent ((utf32_t) ' ', level * 2);
[+] 	sl::String indent((utf32_t) ' ', level * 2);
[-] 		status = ntQueryDirectoryObject (
[+] 		status = ntQueryDirectoryObject(
[-] 			buffer.getCount (),
[+] 			buffer.getCount(),
[-] 			err::setError (sys::win::NtStatus (status));
[+] 			err::setError(sys::win::NtStatus(status));
[-] 			printf ("cannot query directory: %s\n", err::getLastErrorDescription ().sz ());
[+] 			printf("cannot query directory: %s\n", err::getLastErrorDescription ().sz ());
[-] 		OBJECT_DIRECTORY_INFORMATION* dirInfo = (OBJECT_DIRECTORY_INFORMATION*) buffer.p ();
[+] 		OBJECT_DIRECTORY_INFORMATION* dirInfo = (OBJECT_DIRECTORY_INFORMATION*)buffer.p();
[-] 			dirName.copy (dirInfo->Name.Buffer, dirInfo->Name.Length / sizeof (wchar_t));
[+] 			dirName.copy(dirInfo->Name.Buffer, dirInfo->Name.Length / sizeof(wchar_t));
[-] 			dirTypeName.copy (dirInfo->TypeName.Buffer, dirInfo->TypeName.Length / sizeof (wchar_t));
[+] 			dirTypeName.copy(dirInfo->TypeName.Buffer, dirInfo->TypeName.Length / sizeof(wchar_t));
[-] 			printf ("%s%S (%S)\n", indent.sz (), dirName.sz (), dirTypeName.sz ());
[+] 			printf("%s%S (%S)\n", indent.sz (), dirName.sz (), dirTypeName.sz ());
[-] 			if (dirTypeName.cmp (L"Directory") == 0)
[+] 			if (dirTypeName.cmp(L"Directory") == 0)
[-] 				enumerateDirectory (dir, dirName, level);
[+] 				enumerateDirectory(dir, dirName, level);
[-] 			else if (dirTypeName.cmp (L"SymbolicLink") == 0)
[+] 			else if (dirTypeName.cmp(L"SymbolicLink") == 0)
[-] 				bool result = querySymbolicLink (&symLinkTargetName, dir, &dirInfo->Name);
[+] 				bool result = querySymbolicLink(&symLinkTargetName, dir, &dirInfo->Name);
[-] 					printf ("%s  --> %S\n", indent.sz (), symLinkTargetName.sz ());
[+] 					printf("%s  --> %S\n", indent.sz (), symLinkTargetName.sz ());
[-] testDirectoryObjects ()
[+] testDirectoryObjects()
[-] 	bool result = f.create (L"COM3", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING);
[+] 	bool result = f.create(L"COM3", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING);
[-] 		char m_buffer [1024];
[+] 		char m_buffer[1024];
[-] 	NTSTATUS status = ntQueryObject (f, ObjectNameInformation, &objectNameInfo, sizeof (objectNameInfo), &actualSize);
[+] 	NTSTATUS status = ntQueryObject(f, ObjectNameInformation, &objectNameInfo, sizeof(objectNameInfo), &actualSize);
[-] 	result = io::getSymbolicLinkTarget (&ss, "COM3");
[+] 	result = io::getSymbolicLinkTarget(&ss, "COM3");
[-] 	size_t length = wcslen (linkName);
[+] 	size_t length = wcslen(linkName);
[-] 	uniLink.Length = length * sizeof (WCHAR);
[+] 	uniLink.Length = length * sizeof(WCHAR);
[-] 	uniLink.MaximumLength = (length + 1) * sizeof (wchar_t);
[+] 	uniLink.MaximumLength = (length + 1) * sizeof(wchar_t);
[-] 	querySymbolicLink (&s, NULL, &uniLink);
[+] 	querySymbolicLink(&s, NULL, &uniLink);
[-] 	printf ("target: %S\n", s.sz ());
[+] 	printf("target: %S\n", s.sz ());
[-] 	printf ("\\\n");
[+] 	printf("\\\n");
[-] 	enumerateDirectory (NULL, L"\\", 0);
[+] 	enumerateDirectory(NULL, L"\\", 0);
[-] testTcp ()
[+] testTcp()
[-] 	SOCKET s = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
[+] 	SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
[-] 	int s = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
[+] 	int s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
[-] 	ASSERT (s != -1);
[+] 	ASSERT(s != -1);
[-] 	setsockopt (s, SOL_SOCKET, SO_LINGER, (const char*) &l, sizeof (l));
[+] 	setsockopt(s, SOL_SOCKET, SO_LINGER, (const char*) &l, sizeof(l));
[-] 	a.sin_addr.s_addr = inet_addr ("127.0.0.1");
[+] 	a.sin_addr.s_addr = inet_addr("127.0.0.1");
[-] 	a.sin_port = htons (10001);
[+] 	a.sin_port = htons(10001);
[-] 	printf ("connecting...\n");
[+] 	printf("connecting...\n");
[-] 	int result = connect (s, (const sockaddr*) &a, sizeof (a));
[+] 	int result = connect(s, (const sockaddr*) &a, sizeof(a));
[-] 	printf ("result = %d\n", result);
[+] 	printf("result = %d\n", result);
[-] 	char buf [512];
[+] 	char buf[512];
[-] 	scanf ("%d", buf);
[+] 	scanf("%d", buf);
[-] 	socklen_t len = sizeof (error);
[+] 	socklen_t len = sizeof(error);
[-] 	result = getsockopt (s, SOL_SOCKET, SO_ERROR, (char*) &error, &len);
[+] 	result = getsockopt(s, SOL_SOCKET, SO_ERROR, (char*) &error, &len);
[-] 	printf ("receiving...\n");
[+] 	printf("receiving...\n");
[-] 	result = recv (s, buf, sizeof (buf), 0);
[+] 	result = recv(s, buf, sizeof(buf), 0);
[-] 	printf ("result = %d\n", result);
[+] 	printf("result = %d\n", result);
[-] 	printf ("receiving...\n");
[+] 	printf("receiving...\n");
[-] 	result = recv (s, buf, 0, 0);
[+] 	result = recv(s, buf, 0, 0);
[-] 	printf ("result = %d\n", result);
[+] 	printf("result = %d\n", result);
[-] 	printf ("closing...\n");
[+] 	printf("closing...\n");
[-] 	closesocket (s);
[+] 	closesocket(s);
[-] 	close (s);
[+] 	close(s);
[-] 	printf ("done.\n");
[+] 	printf("done.\n");
[-] printWinErrorDescription (
[+] printWinErrorDescription(
[-] 	::FormatMessageW (
[+] 	::FormatMessageW(
[-] 		MAKELANGID (langId, subLangId),
[+] 		MAKELANGID(langId, subLangId),
[-] 	::LocalFree (message);
[+] 	::LocalFree(message);
[-] 	printf ("%d/%d: %s\n", langId, subLangId, description.sz ());
[+] 	printf("%d/%d: %s\n", langId, subLangId, description.sz ());
[-] testWinError ()
[+] testWinError()
[-] 	printWinErrorDescription (error, LANG_NEUTRAL, SUBLANG_NEUTRAL);
[+] 	printWinErrorDescription(error, LANG_NEUTRAL, SUBLANG_NEUTRAL);
[-] 	printWinErrorDescription (error, LANG_NEUTRAL, SUBLANG_DEFAULT);
[+] 	printWinErrorDescription(error, LANG_NEUTRAL, SUBLANG_DEFAULT);
[-] 	printWinErrorDescription (error, LANG_NEUTRAL, SUBLANG_SYS_DEFAULT);
[+] 	printWinErrorDescription(error, LANG_NEUTRAL, SUBLANG_SYS_DEFAULT);
[-] 	printWinErrorDescription (error, LANG_SYSTEM_DEFAULT, SUBLANG_NEUTRAL);
[+] 	printWinErrorDescription(error, LANG_SYSTEM_DEFAULT, SUBLANG_NEUTRAL);
[-] 	printWinErrorDescription (error, LANG_SYSTEM_DEFAULT, SUBLANG_DEFAULT);
[+] 	printWinErrorDescription(error, LANG_SYSTEM_DEFAULT, SUBLANG_DEFAULT);
[-] 	printWinErrorDescription (error, LANG_SYSTEM_DEFAULT, SUBLANG_SYS_DEFAULT);
[+] 	printWinErrorDescription(error, LANG_SYSTEM_DEFAULT, SUBLANG_SYS_DEFAULT);
[-] 	printWinErrorDescription (error, LANG_ENGLISH, SUBLANG_NEUTRAL);
[+] 	printWinErrorDescription(error, LANG_ENGLISH, SUBLANG_NEUTRAL);
[-] 	printWinErrorDescription (error, LANG_ENGLISH, SUBLANG_DEFAULT);
[+] 	printWinErrorDescription(error, LANG_ENGLISH, SUBLANG_DEFAULT);
[-] 	printWinErrorDescription (error, LANG_ENGLISH, SUBLANG_SYS_DEFAULT);
[+] 	printWinErrorDescription(error, LANG_ENGLISH, SUBLANG_SYS_DEFAULT);
[-] 	printWinErrorDescription (error, LANG_ENGLISH, SUBLANG_ENGLISH_US);
[+] 	printWinErrorDescription(error, LANG_ENGLISH, SUBLANG_ENGLISH_US);
[-] 	printWinErrorDescription (error, LANG_ENGLISH, SUBLANG_ENGLISH_UK);
[+] 	printWinErrorDescription(error, LANG_ENGLISH, SUBLANG_ENGLISH_UK);
[-] testTimestamp ()
[+] testTimestamp()
[-] 		uint64_t t1 = sys::getTimestamp ();
[+] 		uint64_t t1 = sys::getTimestamp();
[-] 		printf ("%s: %llu\n", sys::Time (t1).format ("%h:%m:%s.%l.%c").sz (), t1);
[+] 		printf("%s: %llu\n", sys::Time (t1).format ("%h:%m:%s.%l.%c").sz (), t1);
[-] getUsbStringDescriptorText (
[+] getUsbStringDescriptorText(
[-] 	if (!device->isOpen ())
[+] 	if (!device->isOpen())
[-] 		bool result = device->getStringDesrciptor (index, &text);
[+] 		bool result = device->getStringDesrciptor(index, &text);
[-] 			text.format ("ERROR (%s)", err::getLastErrorDescription ().sz ());
[+] 			text.format("ERROR (%s)", err::getLastErrorDescription ().sz ());
[-] printUsbIfaceDesc (const libusb_interface_descriptor* ifaceDesc)
[+] printUsbIfaceDesc(const libusb_interface_descriptor* ifaceDesc)
[-] 	printf ("    Interface:   %d\n", ifaceDesc->bInterfaceNumber);
[+] 	printf("    Interface:   %d\n", ifaceDesc->bInterfaceNumber);
[-] 	printf ("    Alt setting: %d\n", ifaceDesc->bAlternateSetting);
[+] 	printf("    Alt setting: %d\n", ifaceDesc->bAlternateSetting);
[-] 	printf ("    Class:       %s\n", io::getUsbClassCodeString ((libusb_class_code) ifaceDesc->bInterfaceClass));
[+] 	printf("    Class:       %s\n", io::getUsbClassCodeString ((libusb_class_code) ifaceDesc->bInterfaceClass));
[-] 	printf ("    Subclass:    %d\n", ifaceDesc->bInterfaceSubClass);
[+] 	printf("    Subclass:    %d\n", ifaceDesc->bInterfaceSubClass);
[-] 	printf ("    Protocol:    %d\n", ifaceDesc->bInterfaceProtocol);
[+] 	printf("    Protocol:    %d\n", ifaceDesc->bInterfaceProtocol);
[-] 	printf ("    Endpoints:   %d\n", ifaceDesc->bNumEndpoints);
[+] 	printf("    Endpoints:   %d\n", ifaceDesc->bNumEndpoints);
[-] 		const libusb_endpoint_descriptor* endpointDesc = &ifaceDesc->endpoint [i];
[+] 		const libusb_endpoint_descriptor* endpointDesc = &ifaceDesc->endpoint[i];
[-] 		printf ("\n");
[+] 		printf("\n");
[-] 		printf ("      Endpoint:        0x%02x\n", endpointDesc->bEndpointAddress);
[+] 		printf("      Endpoint:        0x%02x\n", endpointDesc->bEndpointAddress);
[-] 		printf ("      Direction:       %s\n", (endpointDesc->bEndpointAddress & LIBUSB_ENDPOINT_IN) ? "In" : "Out");
[+] 		printf("      Direction:       %s\n", (endpointDesc->bEndpointAddress & LIBUSB_ENDPOINT_IN) ? "In" : "Out");
[-] 		printf ("      Type:            %s\n", io::getUsbTransferTypeString ((libusb_transfer_type) (endpointDesc->bmAttributes & LIBUSB_TRANSFER_TYPE_MASK)));
[+] 		printf("      Type:            %s\n", io::getUsbTransferTypeString ((libusb_transfer_type) (endpointDesc->bmAttributes & LIBUSB_TRANSFER_TYPE_MASK)));
[-] 		printf ("      Max packet size: %d\n", endpointDesc->wMaxPacketSize);
[+] 		printf("      Max packet size: %d\n", endpointDesc->wMaxPacketSize);
[-] printUsbConfigDesc (const libusb_config_descriptor* configDesc)
[+] printUsbConfigDesc(const libusb_config_descriptor* configDesc)
[-] 	printf ("  Configuration: %d\n", configDesc->bConfigurationValue);
[+] 	printf("  Configuration: %d\n", configDesc->bConfigurationValue);
[-] 	printf ("  Max power:     %d mA\n", configDesc->MaxPower * 2);
[+] 	printf("  Max power:     %d mA\n", configDesc->MaxPower * 2);
[-] 	printf ("  Interfaces:    %d\n", configDesc->bNumInterfaces);
[+] 	printf("  Interfaces:    %d\n", configDesc->bNumInterfaces);
[-] 		const libusb_interface* iface = &configDesc->interface [i];
[+] 		const libusb_interface* iface = &configDesc->interface[i];
[-] 			printf ("\n    Interface #%d is not configured\n", i);
[+] 			printf("\n    Interface #%d is not configured\n", i);
[-] 		else for (size_t j = 0; j < (size_t) iface->num_altsetting; j++)
[+] 		else for (size_t j = 0; j < (size_t)iface->num_altsetting; j++)
[-] 			printf ("\n");
[+] 			printf("\n");
[-] 			printUsbIfaceDesc (&iface->altsetting [j]);
[+] 			printUsbIfaceDesc(&iface->altsetting[j]);
[-] printUsbDevice (io::UsbDevice* device)
[+] printUsbDevice(io::UsbDevice* device)
[-] 	result = device->getDeviceDescriptor (&deviceDesc);
[+] 	result = device->getDeviceDescriptor(&deviceDesc);
[-] 		printf ("Cannot get device descriptor (%s)\n", err::getLastErrorDescription ().sz ());
[+] 		printf("Cannot get device descriptor (%s)\n", err::getLastErrorDescription ().sz ());
[-] 	printf ("HWID:           VID_%04x&PID_%04x\n", deviceDesc.idVendor, deviceDesc.idProduct);
[+] 	printf("HWID:           VID_%04x&PID_%04x\n", deviceDesc.idVendor, deviceDesc.idProduct);
[-] 	printf ("Class:          %s\n", io::getUsbClassCodeString ((libusb_class_code) deviceDesc.bDeviceClass));
[+] 	printf("Class:          %s\n", io::getUsbClassCodeString ((libusb_class_code) deviceDesc.bDeviceClass));
[-] 	printf ("Manufacturer:   %s\n", getUsbStringDescriptorText (device, deviceDesc.iManufacturer).sz ());
[+] 	printf("Manufacturer:   %s\n", getUsbStringDescriptorText (device, deviceDesc.iManufacturer).sz ());
[-] 	printf ("Product name:   %s\n", getUsbStringDescriptorText (device, deviceDesc.iProduct).sz ());
[+] 	printf("Product name:   %s\n", getUsbStringDescriptorText (device, deviceDesc.iProduct).sz ());
[-] 	printf ("Serial number:  %s\n", getUsbStringDescriptorText (device, deviceDesc.iSerialNumber).sz ());
[+] 	printf("Serial number:  %s\n", getUsbStringDescriptorText (device, deviceDesc.iSerialNumber).sz ());
[-] 	printf ("Address:        %d\n", device->getDeviceAddress ());
[+] 	printf("Address:        %d\n", device->getDeviceAddress ());
[-] 	printf ("Bus:            %d\n", device->getBusNumber ());
[+] 	printf("Bus:            %d\n", device->getBusNumber ());
[-] 	printf ("Port:           %d\n", device->getPortNumber ());
[+] 	printf("Port:           %d\n", device->getPortNumber ());
[-] 	printf ("Speed:          %s\n", io::getUsbSpeedString (device->getDeviceSpeed ()));
[+] 	printf("Speed:          %s\n", io::getUsbSpeedString (device->getDeviceSpeed ()));
[-] 	printf ("Port path:      ");
[+] 	printf("Port path:      ");
[-] 	uint8_t path [8];
[+] 	uint8_t path[8];
[-] 	size_t pathLength = device->getPortPath (path, countof (path));
[+] 	size_t pathLength = device->getPortPath(path, countof(path));
[-] 		printf ("ERROR (%s)\n", err::getLastErrorDescription ().sz ());
[+] 		printf("ERROR (%s)\n", err::getLastErrorDescription ().sz ());
[-] 			printf ("-> %d", path [i]);
[+] 			printf("-> %d", path [i]);
[-] 		printf ("\n");
[+] 		printf("\n");
[-] 	printf ("\n");
[+] 	printf("\n");
[-] 	printf ("Configurations: %d\n", deviceDesc.bNumConfigurations);
[+] 	printf("Configurations: %d\n", deviceDesc.bNumConfigurations);
[-] 		printf ("\n");
[+] 		printf("\n");
[-] 		bool result = device->getConfigDescriptor (i, &configDesc);
[+] 		bool result = device->getConfigDescriptor(i, &configDesc);
[-] 			printf ("  Cannot get config descriptor #%d (%s)\n", i, err::getLastErrorDescription ().sz ());
[+] 			printf("  Cannot get config descriptor #%d (%s)\n", i, err::getLastErrorDescription ().sz ());
[-] 			printUsbConfigDesc (configDesc);
[+] 			printUsbConfigDesc(configDesc);
[-] testUsbEnum ()
[+] testUsbEnum()
[-] 	io::registerUsbErrorProvider ();
[+] 	io::registerUsbErrorProvider();
[-] 	io::getUsbDefaultContext ()->createDefault ();
[+] 	io::getUsbDefaultContext()->createDefault();
[-] 	size_t count = deviceList.enumerateDevices ();
[+] 	size_t count = deviceList.enumerateDevices();
[-] 		printf ("Cannot enumerate USB devices (%s)\n", err::getLastErrorDescription ().sz ());
[+] 		printf("Cannot enumerate USB devices (%s)\n", err::getLastErrorDescription ().sz ());
[-] 		printf ("----------------------\nDevice #%d\n", i);
[+] 		printf("----------------------\nDevice #%d\n", i);
[-] 		device.setDevice (*pp);
[+] 		device.setDevice(*pp);
[-] 		result = device.open ();
[+] 		result = device.open();
[-] 			printf ("Cannot open device (%s)\n", err::getLastErrorDescription ().sz ());
[+] 			printf("Cannot open device (%s)\n", err::getLastErrorDescription ().sz ());
[-] 		printUsbDevice (&device); // even if not opened
[+] 		printUsbDevice(&device); // even if not opened
[-] 	UsbRead (
[+] 	UsbRead(
[-] 		m_device->getActiveConfigDescriptor (&configDesc);
[+] 		m_device->getActiveConfigDescriptor(&configDesc);
[-] 		const libusb_endpoint_descriptor* endpointDesc = io::findUsbEndpointDescriptor (configDesc, m_endpointId);
[+] 		const libusb_endpoint_descriptor* endpointDesc = io::findUsbEndpointDescriptor(configDesc, m_endpointId);
[-] 		ASSERT (endpointDesc);
[+] 		ASSERT(endpointDesc);
[-] 		m_endpointType = (libusb_transfer_type) (endpointDesc->bmAttributes & LIBUSB_TRANSFER_TYPE_MASK);
[+] 		m_endpointType = (libusb_transfer_type)(endpointDesc->bmAttributes & LIBUSB_TRANSFER_TYPE_MASK);
[-] 	public sys::ThreadImpl <UsbReadThread>,
[+] 	public sys::ThreadImpl<UsbReadThread>,
[-] 	UsbReadThread (
[+] 	UsbReadThread(
[-] 		): UsbRead (device, endpointId, timeout)
[+] 		): UsbRead(device, endpointId, timeout)
[-] 	threadFunc ()
[+] 	threadFunc()
[-] 		sl::Array <char> buffer;
[+] 		sl::Array<char> buffer;
[-] 		buffer.setCount (m_maxPacketSize);
[+] 		buffer.setCount(m_maxPacketSize);
[-] 			switch (m_endpointType)
[+] 			switch(m_endpointType)
[-] 				size = m_device->bulkTransfer (m_endpointId, buffer, m_maxPacketSize, m_timeout);
[+] 				size = m_device->bulkTransfer(m_endpointId, buffer, m_maxPacketSize, m_timeout);
[-] 				size = m_device->interruptTransfer (m_endpointId, buffer, m_maxPacketSize, m_timeout);
[+] 				size = m_device->interruptTransfer(m_endpointId, buffer, m_maxPacketSize, m_timeout);
[-] 				ASSERT (false);
[+] 				ASSERT(false);
[-] 				printf ("interrupt transfer error: %s\n", err::getLastErrorDescription ().sz ());
[+] 				printf("interrupt transfer error: %s\n", err::getLastErrorDescription ().sz ());
[-] 				printf ("received %d bytes\n", size);
[+] 				printf("received %d bytes\n", size);
[-] 	public sys::ThreadImpl <UsbReadThread>,
[+] 	public sys::ThreadImpl<UsbReadThread>,
[-] 	sl::Array <char> m_buffer;
[+] 	sl::Array<char> m_buffer;
[-] 	UsbAsyncTransfer (
[+] 	UsbAsyncTransfer(
[-] 		): UsbRead (device, endpointId, timeout)
[+] 		): UsbRead(device, endpointId, timeout)
[-] 		m_transfer.create ();
[+] 		m_transfer.create();
[-] 		m_buffer.setCount (m_maxPacketSize);
[+] 		m_buffer.setCount(m_maxPacketSize);
[-] 	next ()
[+] 	next()
[-] 		switch (m_endpointType)
[+] 		switch(m_endpointType)
[-] 			m_transfer.fillBulkTransfer (
[+] 			m_transfer.fillBulkTransfer(
[-] 			m_transfer.fillInterruptTransfer (
[+] 			m_transfer.fillInterruptTransfer(
[-] 			ASSERT (false);
[+] 			ASSERT(false);
[-] 		return m_transfer.submit ();
[+] 		return m_transfer.submit();
[-] 	wait (uint_t timeout = -1)
[+] 	wait(uint_t timeout = -1)
[-] 		return m_completionEvent.wait (timeout);
[+] 		return m_completionEvent.wait(timeout);
[-] 	onCompleted (libusb_transfer* transfer)
[+] 	onCompleted(libusb_transfer* transfer)
[-] 		UsbAsyncTransfer* self = (UsbAsyncTransfer*) transfer->user_data;
[+] 		UsbAsyncTransfer* self = (UsbAsyncTransfer*)transfer->user_data;
[-] 		printf (
[+] 		printf(
[-] 			io::getUsbTransferStatusString (transfer->status),
[+] 			io::getUsbTransferStatusString(transfer->status),
[-] 				self->m_completionEvent.signal ();
[+] 				self->m_completionEvent.signal();
[-] 		self->next ();
[+] 		self->next();
[-] testUsbMouse ()
[+] testUsbMouse()
[-] 	io::registerUsbErrorProvider ();
[+] 	io::registerUsbErrorProvider();
[-] 	io::getUsbDefaultContext ()->createDefault ();
[+] 	io::getUsbDefaultContext()->createDefault();
[-] 	io::getUsbDefaultContextEventThread ()->start ();
[+] 	io::getUsbDefaultContextEventThread()->start();
[-] 	printf ("Opening device...\n");
[+] 	printf("Opening device...\n");
[-] 	result = device.open (VendorId, ProductId);
[+] 	result = device.open(VendorId, ProductId);
[-] 		printf ("Error: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("Error: %s\n", err::getLastErrorDescription ().sz ());
[-] 	printf ("Reading device properties...\n");
[+] 	printf("Reading device properties...\n");
[-] 	printUsbDevice (&device);
[+] 	printUsbDevice(&device);
[-] 	if (io::hasUsbCapability (LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER))
[+] 	if (io::hasUsbCapability(LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER))
[-] 		printf ("Setting auto-detach for kernel driver...\n");
[+] 		printf("Setting auto-detach for kernel driver...\n");
[-] 		result = device.setAutoDetachKernelDriver (true);
[+] 		result = device.setAutoDetachKernelDriver(true);
[-] 			printf ("Error: %s\n", err::getLastErrorDescription ().sz ());
[+] 			printf("Error: %s\n", err::getLastErrorDescription ().sz ());
[-] 	printf ("Claiming interface #%d...\n", InterfaceId);
[+] 	printf("Claiming interface #%d...\n", InterfaceId);
[-] 	result = device.claimInterface (InterfaceId);
[+] 	result = device.claimInterface(InterfaceId);
[-] 		printf ("Error: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("Error: %s\n", err::getLastErrorDescription ().sz ());
[-] 	device.getActiveConfigDescriptor (&configDesc);
[+] 	device.getActiveConfigDescriptor(&configDesc);
[-] 	const libusb_endpoint_descriptor* endpointDesc = io::findUsbEndpointDescriptor (configDesc, EndpointId);
[+] 	const libusb_endpoint_descriptor* endpointDesc = io::findUsbEndpointDescriptor(configDesc, EndpointId);
[-] 	ASSERT (endpointDesc);
[+] 	ASSERT(endpointDesc);
[-] 	printf ("Sync read...\n");
[+] 	printf("Sync read...\n");
[-] 	sl::Array <char> buffer;
[+] 	sl::Array<char> buffer;
[-] 	buffer.setCount (endpointDesc->wMaxPacketSize);
[+] 	buffer.setCount(endpointDesc->wMaxPacketSize);
[-] 	size_t size = device.interruptTransfer (EndpointId, buffer, endpointDesc->wMaxPacketSize);
[+] 	size_t size = device.interruptTransfer(EndpointId, buffer, endpointDesc->wMaxPacketSize);
[-] 		printf ("Error: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("Error: %s\n", err::getLastErrorDescription ().sz ());
[-] 	printf ("%d bytes read...\n", size);
[+] 	printf("%d bytes read...\n", size);
[-] /*	UsbReadThread readThread (&device, EndpointId);
[+] /*	UsbReadThread readThread(&device, EndpointId);
[-] 	printf ("Starting read thread...\n");
[+] 	printf("Starting read thread...\n");
[-] 	readThread.start ();
[+] 	readThread.start();
[-] 	readThread.waitAndClose (); */
[+] 	readThread.waitAndClose(); */
[-] 	UsbAsyncTransfer asyncTransfer (&device, EndpointId);
[+] 	UsbAsyncTransfer asyncTransfer(&device, EndpointId);
[-] 	printf ("Starting async transfer...\n");
[+] 	printf("Starting async transfer...\n");
[-] 	asyncTransfer.next ();
[+] 	asyncTransfer.next();
[-] 	asyncTransfer.wait ();
[+] 	asyncTransfer.wait();
[-] 	device.releaseInterface (InterfaceId);
[+] 	device.releaseInterface(InterfaceId);
[-] class MyThread: public sys::ThreadImpl <MyThread>
[+] class MyThread: public sys::ThreadImpl<MyThread>
[-] 	MyThread ()
[+] 	MyThread()
[-] 	threadFunc ()
[+] 	threadFunc()
[-] 		uint64_t tid = getThreadId ();
[+] 		uint64_t tid = getThreadId();
[-] 			sys::sleep (1000);
[+] 			sys::sleep(1000);
[-] 			printf ("MyThread -- TID: %lld\n", tid);
[+] 			printf("MyThread -- TID: %lld\n", tid);
[-] 		printf ("MyThread -- TID: %lld -- TERMINATE\n", tid);
[+] 		printf("MyThread -- TID: %lld -- TERMINATE\n", tid);
[-] 	_exit (-1);
[+] 	_exit(-1);
[-] void* suspendThread (pthread_t thread)
[+] void* suspendThread(pthread_t thread)
[-] bool resumeThread (pthread_t thread)
[+] bool resumeThread(pthread_t thread)
[-] void testSuspendThread ()
[+] void testSuspendThread()
[-] 	thread1.start ();
[+] 	thread1.start();
[-] 	sys::sleep (500);
[+] 	sys::sleep(500);
[-] 	thread2.start ();
[+] 	thread2.start();
[-] 	sys::sleep (3000);
[+] 	sys::sleep(3000);
[-] 	suspendThread (thread2.m_thread);
[+] 	suspendThread(thread2.m_thread);
[-] 	printf ("thread2 is suspended...\n");
[+] 	printf("thread2 is suspended...\n");
[-] 	sys::sleep (3000);
[+] 	sys::sleep(3000);
[-] 	printf ("thread2 is resumed...\n");
[+] 	printf("thread2 is resumed...\n");
[-] 	resumeThread (thread2.m_thread);
[+] 	resumeThread(thread2.m_thread);
[-] 	sys::sleep (3000);
[+] 	sys::sleep(3000);
[-] 	printf ("terminating threads...\n");
[+] 	printf("terminating threads...\n");
[-] 	thread1.waitAndClose ();
[+] 	thread1.waitAndClose();
[-] 	thread2.waitAndClose ();
[+] 	thread2.waitAndClose();
[-] 	threadArray [i].suspend ();
[+] 	threadArray[i].suspend();
[-] 	sl::Array <uint64_t> m_threadArray;
[+] 	sl::Array<uint64_t> m_threadArray;
[-] 	sl::HashTable <uint64_t, bool, sl::HashId <uint64_t> > m_threadMap;
[+] 	sl::HashTable<uint64_t, bool, sl::HashId<uint64_t> > m_threadMap;
[-] 	Gc ()
[+] 	Gc()
[-] 		m_guardPage.map (
[+] 		m_guardPage.map(
[-] 		installSignalHandlers ();
[+] 		installSignalHandlers();
[-] 	gcSafePoint ()
[+] 	gcSafePoint()
[-] 		*(volatile int*) m_guardPage.p () = 0;
[+] 		*(volatile int*) m_guardPage.p() = 0;
[-] 	stopTheWorld ()
[+] 	stopTheWorld()
[-] 		m_handshakeCounter = m_threadMap.getCount ();
[+] 		m_handshakeCounter = m_threadMap.getCount();
[-] 		m_guardPage.protect (PROT_NONE);
[+] 		m_guardPage.protect(PROT_NONE);
[-] 		m_handshakeSem.wait ();
[+] 		m_handshakeSem.wait();
[-] 	resumeTheWorld ()
[+] 	resumeTheWorld()
[-] 		m_guardPage.protect (PROT_READ | PROT_WRITE);
[+] 		m_guardPage.protect(PROT_READ | PROT_WRITE);
[-] 		m_handshakeCounter = m_threadArray.getCount ();
[+] 		m_handshakeCounter = m_threadArray.getCount();
[-] 			pthread_kill ((pthread_t) m_threadArray [i], SIGUSR1); // resume
[+] 			pthread_kill((pthread_t)m_threadArray[i], SIGUSR1); // resume
[-] 		m_handshakeSem.wait ();
[+] 		m_handshakeSem.wait();
[-] 	registerThread (uint64_t threadId)
[+] 	registerThread(uint64_t threadId)
[-] 		sl::HashTableIterator <uint64_t, bool> it = m_threadMap.visit (threadId);
[+] 		sl::HashTableIterator<uint64_t, bool> it = m_threadMap.visit(threadId);
[-] 		m_threadArray.append (threadId);
[+] 		m_threadArray.append(threadId);
[-] 	installSignalHandlers ()
[+] 	installSignalHandlers()
[-] 		sigemptyset (&m_signalWaitMask); // don't block any signals when servicing SIGSEGV
[+] 		sigemptyset(&m_signalWaitMask); // don't block any signals when servicing SIGSEGV
[-] 		int result = sigaction (SIGSEGV, &sigAction, &prevSigAction);
[+] 		int result = sigaction(SIGSEGV, &sigAction, &prevSigAction);
[-] 		ASSERT (result == 0);
[+] 		ASSERT(result == 0);
[-] 		result = sigaction (SIGUSR1, &sigAction, &prevSigAction);
[+] 		result = sigaction(SIGUSR1, &sigAction, &prevSigAction);
[-] 		ASSERT (result == 0);
[+] 		ASSERT(result == 0);
[-] 	signalHandler_SIGSEGV (
[+] 	signalHandler_SIGSEGV(
[-] 		int32_t count = sys::atomicDec (&g_gc->m_handshakeCounter);
[+] 		int32_t count = sys::atomicDec(&g_gc->m_handshakeCounter);
[-] 			g_gc->m_handshakeSem.signal ();
[+] 			g_gc->m_handshakeSem.signal();
[-] 			sigsuspend (&g_gc->m_signalWaitMask);
[+] 			sigsuspend(&g_gc->m_signalWaitMask);
[-] 		count = sys::atomicDec (&g_gc->m_handshakeCounter);
[+] 		count = sys::atomicDec(&g_gc->m_handshakeCounter);
[-] 			g_gc->m_handshakeSem.signal ();
[+] 			g_gc->m_handshakeSem.signal();
[-] 	signalHandler_SIGUSR1 (int signal)
[+] 	signalHandler_SIGUSR1(int signal)
[-] 	sl::HashTable <uint64_t, bool, sl::HashId <uint64_t> > m_threadMap;
[+] 	sl::HashTable<uint64_t, bool, sl::HashId<uint64_t> > m_threadMap;
[-] 	Gc ()
[+] 	Gc()
[-] 		m_guardPage.alloc (4 * 1024);
[+] 		m_guardPage.alloc(4 * 1024);
[-] 	~Gc ()
[+] 	~Gc()
[-] 	gcSafePoint ()
[+] 	gcSafePoint()
[-] 		sys::atomicXchg ((volatile int*) m_guardPage.p (), 0);
[+] 		sys::atomicXchg((volatile int*) m_guardPage.p(), 0);
[-] 	stopTheWorld ()
[+] 	stopTheWorld()
[-] 		m_handshakeCounter = m_threadMap.getCount ();
[+] 		m_handshakeCounter = m_threadMap.getCount();
[-] 		m_resumeEvent.reset ();
[+] 		m_resumeEvent.reset();
[-] 		m_guardPage.protect (PAGE_NOACCESS);
[+] 		m_guardPage.protect(PAGE_NOACCESS);
[-] 		m_handshakeEvent.wait ();
[+] 		m_handshakeEvent.wait();
[-] 	resumeTheWorld ()
[+] 	resumeTheWorld()
[-] 		m_guardPage.protect (PAGE_READWRITE);
[+] 		m_guardPage.protect(PAGE_READWRITE);
[-] 		m_handshakeCounter = m_threadMap.getCount ();
[+] 		m_handshakeCounter = m_threadMap.getCount();
[-] 		m_resumeEvent.signal ();
[+] 		m_resumeEvent.signal();
[-] 		m_handshakeEvent.wait ();
[+] 		m_handshakeEvent.wait();
[-] 		m_resumeEvent.reset ();
[+] 		m_resumeEvent.reset();
[-] 	registerThread (uint64_t threadId)
[+] 	registerThread(uint64_t threadId)
[-] 		sl::HashTableIterator <uint64_t, bool> it = m_threadMap.visit (threadId);
[+] 		sl::HashTableIterator<uint64_t, bool> it = m_threadMap.visit(threadId);
[-] 	handleException (
[+] 	handleException(
[-] 		   exceptionPointers->ExceptionRecord->ExceptionInformation [1] != (uintptr_t) m_guardPage.p () ||
[+] 		   exceptionPointers->ExceptionRecord->ExceptionInformation[1] != (uintptr_t)m_guardPage.p() ||
[-] 		int32_t count = sys::atomicDec (&g_gc->m_handshakeCounter);
[+] 		int32_t count = sys::atomicDec(&g_gc->m_handshakeCounter);
[-] 			g_gc->m_handshakeEvent.signal ();
[+] 			g_gc->m_handshakeEvent.signal();
[-] 			g_gc->m_resumeEvent.wait ();
[+] 			g_gc->m_resumeEvent.wait();
[-] 		count = sys::atomicDec (&g_gc->m_handshakeCounter);
[+] 		count = sys::atomicDec(&g_gc->m_handshakeCounter);
[-] 			g_gc->m_handshakeEvent.signal ();
[+] 			g_gc->m_handshakeEvent.signal();
[-] #define GC_END() } __except (g_gc->handleException (GetExceptionCode (), GetExceptionInformation ())) { }
[+] #define GC_END() } __except(g_gc->handleException(GetExceptionCode(), GetExceptionInformation())) { }
[-] class MutatorThread: public sys::ThreadImpl <MutatorThread>
[+] class MutatorThread: public sys::ThreadImpl<MutatorThread>
[-] 	MutatorThread ()
[+] 	MutatorThread()
[-] 	stop ()
[+] 	stop()
[-] 		waitAndClose ();
[+] 		waitAndClose();
[-] 	threadFunc ()
[+] 	threadFunc()
[-] 		uint64_t threadId = sys::getCurrentThreadId ();
[+] 		uint64_t threadId = sys::getCurrentThreadId();
[-] 		GC_BEGIN ()
[+] 		GC_BEGIN()
[-] 			printf ("  mutator thread TID:%lld is working...\n", threadId);
[+] 			printf("  mutator thread TID:%lld is working...\n", threadId);
[-] 			sys::sleep (200);
[+] 			sys::sleep(200);
[-] 			g_gc->gcSafePoint ();
[+] 			g_gc->gcSafePoint();
[-] 		printf ("  mutator thread TID:%lld is finished.\n", threadId);
[+] 		printf("  mutator thread TID:%lld is finished.\n", threadId);
[-] 		GC_END ()
[+] 		GC_END()
[-] testGcSafePoints ()
[+] testGcSafePoints()
[-] 	printf ("starting mutator threads...\n");
[+] 	printf("starting mutator threads...\n");
[-] 	thread1.start ();
[+] 	thread1.start();
[-] 	thread2.start ();
[+] 	thread2.start();
[-] 	gc.registerThread (thread1.getThreadId ());
[+] 	gc.registerThread(thread1.getThreadId());
[-] 	gc.registerThread (thread2.getThreadId ());
[+] 	gc.registerThread(thread2.getThreadId());
[-] 	sys::sleep (1000);
[+] 	sys::sleep(1000);
[-] 	printf ("stopping the world...\n");
[+] 	printf("stopping the world...\n");
[-] 	gc.stopTheWorld ();
[+] 	gc.stopTheWorld();
[-] 	printf ("the world is stopped.\n");
[+] 	printf("the world is stopped.\n");
[-] 	sys::sleep (2000);
[+] 	sys::sleep(2000);
[-] 	printf ("resuming the world...\n");
[+] 	printf("resuming the world...\n");
[-] 	gc.resumeTheWorld ();
[+] 	gc.resumeTheWorld();
[-] 	sys::sleep (1000);
[+] 	sys::sleep(1000);
[-] 	printf ("stopping mutator threads...\n");
[+] 	printf("stopping mutator threads...\n");
[-] 	thread1.stop ();
[+] 	thread1.stop();
[-] 	thread2.stop ();
[+] 	thread2.stop();
[-] 	printf ("done.\n");
[+] 	printf("done.\n");
[-] 	Foo ()
[+] 	Foo()
[-] 		printf ("m_p1 = %s; m_p2 = %s; m_p3 = %s\n", m_p1, m_p2, m_p3);
[+] 		printf("m_p1 = %s; m_p2 = %s; m_p3 = %s\n", m_p1, m_p2, m_p3);
[-] testInheritance ()
[+] testInheritance()
[-] 	char buffer [sizeof (Foo)];
[+] 	char buffer[sizeof(Foo)];
[-] 	IfaceHdr* iface = (IfaceHdr*) buffer;
[+] 	IfaceHdr* iface = (IfaceHdr*)buffer;
[-] 	new (buffer) Foo ();
[+] 	new(buffer)Foo();
[-] testTimestamps ()
[+] testTimestamps()
[-] 	uint64_t ts1 = sys::getTimestamp ();
[+] 	uint64_t ts1 = sys::getTimestamp();
[-] 	uint64_t ts2 = sys::getPreciseTimestamp ();
[+] 	uint64_t ts2 = sys::getPreciseTimestamp();
[-] 	printf ("ts1 = %s\n", sys::Time (ts1).format ("%h:%m:%s.%l.%c").sz ());
[+] 	printf("ts1 = %s\n", sys::Time (ts1).format ("%h:%m:%s.%l.%c").sz ());
[-] 	printf ("ts2 = %s\n", sys::Time (ts2).format ("%h:%m:%s.%l.%c").sz ());
[+] 	printf("ts2 = %s\n", sys::Time (ts2).format ("%h:%m:%s.%l.%c").sz ());
[-] 	uint64_t t0 = sys::getPreciseTimestamp ();
[+] 	uint64_t t0 = sys::getPreciseTimestamp();
[-] 		sys::getTimestamp ();
[+] 		sys::getTimestamp();
[-] 	uint64_t t2 = sys::getPreciseTimestamp ();
[+] 	uint64_t t2 = sys::getPreciseTimestamp();
[-] 	printf ("time (ts1) = %s\n", sys::Time (d, 0).format ("%h:%m:%s.%l.%c").sz ());
[+] 	printf("time (ts1) = %s\n", sys::Time (d, 0).format ("%h:%m:%s.%l.%c").sz ());
[-] 	t0 = sys::getPreciseTimestamp ();
[+] 	t0 = sys::getPreciseTimestamp();
[-] 		sys::getPreciseTimestamp ();
[+] 		sys::getPreciseTimestamp();
[-] 	t2 = sys::getPreciseTimestamp ();
[+] 	t2 = sys::getPreciseTimestamp();
[-] 	printf ("time (ts2) = %s\n", sys::Time (d, 0).format ("%h:%m:%s.%l.%c").sz ());
[+] 	printf("time (ts2) = %s\n", sys::Time (d, 0).format ("%h:%m:%s.%l.%c").sz ());
[-] 	ts1 = sys::getTimestamp ();
[+] 	ts1 = sys::getTimestamp();
[-] 	ts2 = sys::getPreciseTimestamp ();
[+] 	ts2 = sys::getPreciseTimestamp();
[-] 	printf ("ts1 = %s\n", sys::Time (ts1).format ("%h:%m:%s.%l.%c").sz ());
[+] 	printf("ts1 = %s\n", sys::Time (ts1).format ("%h:%m:%s.%l.%c").sz ());
[-] 	printf ("ts2 = %s\n", sys::Time (ts2).format ("%h:%m:%s.%l.%c").sz ());
[+] 	printf("ts2 = %s\n", sys::Time (ts2).format ("%h:%m:%s.%l.%c").sz ());
[-] testProcess ()
[+] testProcess()
[-] 	sl::Array <char> output;
[+] 	sl::Array<char> output;
[-] 	bool result = sys::win::syncExec (cmdLine, &output, &exitCode);
[+] 	bool result = sys::win::syncExec(cmdLine, &output, &exitCode);
[-] 		printf ("sys::win::syncExec failed: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("sys::win::syncExec failed: %s\n", err::getLastErrorDescription ().sz ());
[-] 	output.append (0);
[+] 	output.append(0);
[-] 	printf ("process returned %d:\n%s\n", exitCode, output.cp ());
[+] 	printf("process returned %d:\n%s\n", exitCode, output.cp ());
[-] 	readMessage (sl::Array <char>* buffer) = 0;
[+] 	readMessage(sl::Array<char>* buffer) = 0;
[-] 	writeMessage (
[+] 	writeMessage(
[-] class ServerThread: public sys::ThreadImpl <ServerThread>
[+] class ServerThread: public sys::ThreadImpl<ServerThread>
[-] 	ServerThread (Transport* transport)
[+] 	ServerThread(Transport* transport)
[-] 	threadFunc ()
[+] 	threadFunc()
[-] 		ASSERT (m_transport);
[+] 		ASSERT(m_transport);
[-] 		sl::Array <char> buffer;
[+] 		sl::Array<char> buffer;
[-] 			size_t size = m_transport->readMessage (&buffer);
[+] 			size_t size = m_transport->readMessage(&buffer);
[-] 				printf ("server: read error: %s\n", err::getLastErrorDescription ().sz ());
[+] 				printf("server: read error: %s\n", err::getLastErrorDescription ().sz ());
[-] 			if (size < sizeof (ReqHdr))
[+] 			if (size < sizeof(ReqHdr))
[-] 				printf ("server: buffer too small\n");
[+] 				printf("server: buffer too small\n");
[-] 			ReqHdr* command = (ReqHdr*) buffer.cp ();
[+] 			ReqHdr* command = (ReqHdr*)buffer.cp();
[-] 			if (command->m_code != ReqCode_Command || sizeof (ReqHdr) + command->m_size != size)
[+] 			if (command->m_code != ReqCode_Command || sizeof(ReqHdr) + command->m_size != size)
[-] 				printf ("server: invalid command: %d (%d)\n", command->m_code, command->m_size);
[+] 				printf("server: invalid command: %d (%d)\n", command->m_code, command->m_size);
[-] 		static char data [MaxBlockSize] = { 0 };
[+] 		static char data[MaxBlockSize] = { 0 };
[-] 			size_t size = m_transport->readMessage (&buffer);
[+] 			size_t size = m_transport->readMessage(&buffer);
[-] 				printf ("server: read error: %s\n", err::getLastErrorDescription ().sz ());
[+] 				printf("server: read error: %s\n", err::getLastErrorDescription ().sz ());
[-] 			if (size < sizeof (ReqHdr))
[+] 			if (size < sizeof(ReqHdr))
[-] 				printf ("server: buffer too small\n");
[+] 				printf("server: buffer too small\n");
[-] 			ReqHdr* command = (ReqHdr*) buffer.cp ();
[+] 			ReqHdr* command = (ReqHdr*)buffer.cp();
[-] 			if (command->m_code != ReqCode_Command || sizeof (ReqHdr) + command->m_size != size)
[+] 			if (command->m_code != ReqCode_Command || sizeof(ReqHdr) + command->m_size != size)
[-] 				printf ("server: invalid command: %d (%d)\n", command->m_code, command->m_size);
[+] 				printf("server: invalid command: %d (%d)\n", command->m_code, command->m_size);
[-] 			reply.m_size = ::rand () % MaxBlockSize;
[+] 			reply.m_size = ::rand() % MaxBlockSize;
[-] 			m_transport->writeMessage (&reply, data, reply.m_size);
[+] 			m_transport->writeMessage(&reply, data, reply.m_size);
[-] class ClientThread: public sys::ThreadImpl <ClientThread>
[+] class ClientThread: public sys::ThreadImpl<ClientThread>
[-] 	ClientThread (Transport* transport)
[+] 	ClientThread(Transport* transport)
[-] 	threadFunc ()
[+] 	threadFunc()
[-] 		ASSERT (m_transport);
[+] 		ASSERT(m_transport);
[-] 		static char data [MaxBlockSize] = { 0 };
[+] 		static char data[MaxBlockSize] = { 0 };
[-] 			size_t blockSize = rand () % MaxBlockSize;
[+] 			size_t blockSize = rand() % MaxBlockSize;
[-] 			bool result = m_transport->writeMessage (&command, data, blockSize);
[+] 			bool result = m_transport->writeMessage(&command, data, blockSize);
[-] 				printf ("client: write error: %s\n", err::getLastErrorDescription ().sz ());
[+] 				printf("client: write error: %s\n", err::getLastErrorDescription ().sz ());
[-] 			int newPercentage = (uint64_t) totalSize * 100 / TotalSize;
[+] 			int newPercentage = (uint64_t)totalSize * 100 / TotalSize;
[-] 				printf ("\b\b\b\b%d%%", percentage);
[+] 				printf("\b\b\b\b%d%%", percentage);
[-] 		sl::Array <char> buffer;
[+] 		sl::Array<char> buffer;
[-] 			bool result = m_transport->writeMessage (&command, NULL, 0);
[+] 			bool result = m_transport->writeMessage(&command, NULL, 0);
[-] 				printf ("client: write error: %s\n", err::getLastErrorDescription ().sz ());
[+] 				printf("client: write error: %s\n", err::getLastErrorDescription ().sz ());
[-] 			size_t receivedSize = m_transport->readMessage (&buffer);
[+] 			size_t receivedSize = m_transport->readMessage(&buffer);
[-] 				printf ("client: read error: %s\n", err::getLastErrorDescription ().sz ());
[+] 				printf("client: read error: %s\n", err::getLastErrorDescription ().sz ());
[-] 			if (receivedSize < sizeof (ReqHdr))
[+] 			if (receivedSize < sizeof(ReqHdr))
[-] 				printf ("client: buffer too small\n");
[+] 				printf("client: buffer too small\n");
[-] 			ReqHdr* reply = (ReqHdr*) buffer.cp ();
[+] 			ReqHdr* reply = (ReqHdr*)buffer.cp();
[-] 			if (reply->m_code != ReqCode_Reply || sizeof (ReqHdr) + reply->m_size != receivedSize)
[+] 			if (reply->m_code != ReqCode_Reply || sizeof(ReqHdr) + reply->m_size != receivedSize)
[-] 				printf ("client: invalid reply: %d (%d)\n", reply->m_code, reply->m_size);
[+] 				printf("client: invalid reply: %d (%d)\n", reply->m_code, reply->m_size);
[-] 			int newPercentage = (uint64_t) totalSize * 100 / TotalSize;
[+] 			int newPercentage = (uint64_t)totalSize * 100 / TotalSize;
[-] 				printf ("\b\b\b\b%d%%", percentage);
[+] 				printf("\b\b\b\b%d%%", percentage);
[-] 		printf ("\b\b\b\b100%% (done)\n");
[+] 		printf("\b\b\b\b100%% (done)\n");
[-] 	readMessage (sl::Array <char>* buffer)
[+] 	readMessage(sl::Array<char>* buffer)
[-] 		return m_reader.read (buffer);
[+] 		return m_reader.read(buffer);
[-] 	writeMessage (
[+] 	writeMessage(
[-] 			return m_writer.write (hdr, sizeof (ReqHdr)) != -1;
[+] 			return m_writer.write(hdr, sizeof(ReqHdr)) != -1;
[-] 		const void* blockArray [] = { hdr, p };
[+] 		const void* blockArray[] = { hdr, p };
[-] 		size_t sizeArray [] = { sizeof (ReqHdr), size };
[+] 		size_t sizeArray[] = { sizeof(ReqHdr), size };
[-] 		return m_writer.write (blockArray, sizeArray, 2) != -1;
[+] 		return m_writer.write(blockArray, sizeArray, 2) != -1;
[-] 	sl::Array <char> m_leftover;
[+] 	sl::Array<char> m_leftover;
[-] 	readMessage (sl::Array <char>* buffer)
[+] 	readMessage(sl::Array<char>* buffer)
[-] 		size_t bufferSize = buffer->getCount ();
[+] 		size_t bufferSize = buffer->getCount();
[-] 		if (bufferSize < sizeof (ReqHdr))
[+] 		if (bufferSize < sizeof(ReqHdr))
[-] 			buffer->setCount (sizeof (ReqHdr));
[+] 			buffer->setCount(sizeof(ReqHdr));
[-] 		bufferSize = sizeof (ReqHdr);
[+] 		bufferSize = sizeof(ReqHdr);
[-] 			bool_t result = ::ReadFile (m_readPipe, buffer->p () + size, bufferSize - size, &actualSize, NULL);
[+] 			bool_t result = ::ReadFile(m_readPipe, buffer->p() + size, bufferSize - size, &actualSize, NULL);
[-] 			int actualSize = ::read (m_readPipe, buffer->p () + size, bufferSize - size);
[+] 			int actualSize = ::read(m_readPipe, buffer->p() + size, bufferSize - size);
[-] 				err::setLastSystemError ();
[+] 				err::setLastSystemError();
[-] 		ASSERT (size == bufferSize);
[+] 		ASSERT(size == bufferSize);
[-] 		ReqHdr* hdr = (ReqHdr*) buffer->p ();
[+] 		ReqHdr* hdr = (ReqHdr*)buffer->p();
[-] 			ASSERT (size == sizeof (ReqHdr));
[+] 			ASSERT(size == sizeof(ReqHdr));
[-] 			buffer->setCount (sizeof (ReqHdr));
[+] 			buffer->setCount(sizeof(ReqHdr));
[-] 			return sizeof (ReqHdr);
[+] 			return sizeof(ReqHdr);
[-] 		bufferSize = sizeof (ReqHdr) + hdr->m_size;
[+] 		bufferSize = sizeof(ReqHdr) + hdr->m_size;
[-] 		buffer->setCount (bufferSize);
[+] 		buffer->setCount(bufferSize);
[-] 			bool_t result = ::ReadFile (m_readPipe, buffer->p () + size, bufferSize - size, &actualSize, NULL);
[+] 			bool_t result = ::ReadFile(m_readPipe, buffer->p() + size, bufferSize - size, &actualSize, NULL);
[-] 			int actualSize = ::read (m_readPipe, buffer->p () + size, bufferSize - size);
[+] 			int actualSize = ::read(m_readPipe, buffer->p() + size, bufferSize - size);
[-] 				err::setLastSystemError ();
[+] 				err::setLastSystemError();
[-] 		ASSERT (size == bufferSize);
[+] 		ASSERT(size == bufferSize);
[-] 	writeMessage (
[+] 	writeMessage(
[-] 		bool result = ::WriteFile (m_writePipe, hdr, sizeof (ReqHdr), &actualSize, NULL) != 0;
[+] 		bool result = ::WriteFile(m_writePipe, hdr, sizeof(ReqHdr), &actualSize, NULL) != 0;
[-] 			result = ::WriteFile (m_writePipe, p, size, &actualSize, NULL) != 0;
[+] 			result = ::WriteFile(m_writePipe, p, size, &actualSize, NULL) != 0;
[-] 		bool result = ::write (m_writePipe, hdr, sizeof (ReqHdr)) != -1;
[+] 		bool result = ::write(m_writePipe, hdr, sizeof(ReqHdr)) != -1;
[-] 			result = ::write (m_writePipe, p, size) != -1;
[+] 			result = ::write(m_writePipe, p, size) != -1;
[-] testSharedMemoryTransport ()
[+] testSharedMemoryTransport()
[-] 	setvbuf (stdout, NULL, _IONBF, 0);
[+] 	setvbuf(stdout, NULL, _IONBF, 0);
[-] 	::sem_unlink ("shmt-test-cli-srv-r");
[+] 	::sem_unlink("shmt-test-cli-srv-r");
[-] 	::sem_unlink ("shmt-test-cli-srv-w");
[+] 	::sem_unlink("shmt-test-cli-srv-w");
[-] 	::sem_unlink ("shmt-test-srv-cli-r");
[+] 	::sem_unlink("shmt-test-srv-cli-r");
[-] 	::sem_unlink ("shmt-test-srv-cli-w");
[+] 	::sem_unlink("shmt-test-srv-cli-w");
[-] 		serverTransport.m_reader.open (
[+] 		serverTransport.m_reader.open(
[-] 		serverTransport.m_writer.open (
[+] 		serverTransport.m_writer.open(
[-] 		clientTransport.m_reader.open (
[+] 		clientTransport.m_reader.open(
[-] 		clientTransport.m_writer.open (
[+] 		clientTransport.m_writer.open(
[-] 		printf ("can't initialize: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("can't initialize: %s\n", err::getLastErrorDescription ().sz ());
[-] 	ServerThread serverThread (&serverTransport);
[+] 	ServerThread serverThread(&serverTransport);
[-] 	ClientThread clientThread (&clientTransport);
[+] 	ClientThread clientThread(&clientTransport);
[-] 	uint64_t time0 = sys::getTimestamp ();
[+] 	uint64_t time0 = sys::getTimestamp();
[-] 	serverThread.start ();
[+] 	serverThread.start();
[-] 	clientThread.start ();
[+] 	clientThread.start();
[-] 	clientThread.waitAndClose ();
[+] 	clientThread.waitAndClose();
[-] 	clientTransport.m_reader.disconnect ();
[+] 	clientTransport.m_reader.disconnect();
[-] 	clientTransport.m_writer.disconnect ();
[+] 	clientTransport.m_writer.disconnect();
[-] 	serverThread.waitAndClose ();
[+] 	serverThread.waitAndClose();
[-] 	uint64_t time2 = sys::getTimestamp ();
[+] 	uint64_t time2 = sys::getTimestamp();
[-] 	printf ("shm test completed: %s\n", sys::Time (time2 - time0, 0).format ("%m:%s.%l").sz ());
[+] 	printf("shm test completed: %s\n", sys::Time (time2 - time0, 0).format ("%m:%s.%l").sz ());
[-] testPipeTransport ()
[+] testPipeTransport()
[-] 	HANDLE pipeA [2] = { INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE };
[+] 	HANDLE pipeA[2] = { INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE };
[-] 	HANDLE pipeB [2] = { INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE };
[+] 	HANDLE pipeB[2] = { INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE };
[-] 		::CreatePipe (&pipeA [0], &pipeA [1], NULL, 0) &&
[+] 		::CreatePipe(&pipeA[0], &pipeA[1], NULL, 0) &&
[-] 		::CreatePipe (&pipeB [0], &pipeB [1], NULL, 0);
[+] 		::CreatePipe(&pipeB[0], &pipeB[1], NULL, 0);
[-] 	setvbuf (stdout, NULL, _IONBF, 0);
[+] 	setvbuf(stdout, NULL, _IONBF, 0);
[-] 	int pipeA [2] = { 0 };
[+] 	int pipeA[2] = { 0 };
[-] 	int pipeB [2] = { 0 };
[+] 	int pipeB[2] = { 0 };
[-] 		::pipe (pipeA) == 0 &&
[+] 		::pipe(pipeA) == 0 &&
[-] 		::pipe (pipeB) == 0;
[+] 		::pipe(pipeB) == 0;
[-] 		err::setLastSystemError ();
[+] 		err::setLastSystemError();
[-] 		printf ("can't initialize: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("can't initialize: %s\n", err::getLastErrorDescription ().sz ());
[-] 	serverTransport.m_readPipe = pipeA [0];
[+] 	serverTransport.m_readPipe = pipeA[0];
[-] 	serverTransport.m_writePipe = pipeB [1];
[+] 	serverTransport.m_writePipe = pipeB[1];
[-] 	clientTransport.m_readPipe = pipeB [0];
[+] 	clientTransport.m_readPipe = pipeB[0];
[-] 	clientTransport.m_writePipe = pipeA [1];
[+] 	clientTransport.m_writePipe = pipeA[1];
[-] 	ServerThread serverThread (&serverTransport);
[+] 	ServerThread serverThread(&serverTransport);
[-] 	ClientThread clientThread (&clientTransport);
[+] 	ClientThread clientThread(&clientTransport);
[-] 	uint64_t time0 = sys::getTimestamp ();
[+] 	uint64_t time0 = sys::getTimestamp();
[-] 	serverThread.start ();
[+] 	serverThread.start();
[-] 	clientThread.start ();
[+] 	clientThread.start();
[-] 	clientThread.waitAndClose ();
[+] 	clientThread.waitAndClose();
[-] 	::CloseHandle (pipeA [1]);
[+] 	::CloseHandle(pipeA[1]);
[-] 	::CloseHandle (pipeB [1]);
[+] 	::CloseHandle(pipeB[1]);
[-] 	::CloseHandle (pipeA [0]);
[+] 	::CloseHandle(pipeA[0]);
[-] 	::CloseHandle (pipeB [0]);
[+] 	::CloseHandle(pipeB[0]);
[-] 	::close (pipeA [1]);
[+] 	::close(pipeA[1]);
[-] 	::close (pipeB [1]);
[+] 	::close(pipeB[1]);
[-] 	::close (pipeA [0]);
[+] 	::close(pipeA[0]);
[-] 	::close (pipeB [0]);
[+] 	::close(pipeB[0]);
[-] 	serverThread.waitAndClose ();
[+] 	serverThread.waitAndClose();
[-] 	uint64_t time2 = sys::getTimestamp ();
[+] 	uint64_t time2 = sys::getTimestamp();
[-] 	printf ("pipe test completed: %s\n", sys::Time (time2 - time0, 0).format ("%m:%s.%l").sz ());
[+] 	printf("pipe test completed: %s\n", sys::Time (time2 - time0, 0).format ("%m:%s.%l").sz ());
[-] testZip ()
[+] testZip()
[-] 	result = reader.openFile ("C:/Program Files/Tibbo/Ninja 3/bin/io_base.jncx");
[+] 	result = reader.openFile("C:/Program Files/Tibbo/Ninja 3/bin/io_base.jncx");
[-] 		printf ("can't open file: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("can't open file: %s\n", err::getLastErrorDescription ().sz ());
[-] 	sl::Array <char> buffer;
[+] 	sl::Array<char> buffer;
[-] 	size_t count = reader.getFileCount ();
[+] 	size_t count = reader.getFileCount();
[-] 		sl::String fileName = reader.getFileName (i);
[+] 		sl::String fileName = reader.getFileName(i);
[-] 		reader.getFileInfo (i, &fileInfo);
[+] 		reader.getFileInfo(i, &fileInfo);
[-] 		bool isDir = reader.isDirectoryFile (i);
[+] 		bool isDir = reader.isDirectoryFile(i);
[-] 		printf (
[+] 		printf(
[-] 			fileName.sz (),
[+] 			fileName.sz(),
[-] 			(size_t) fileInfo.m_compressedSize,
[+] 			(size_t)fileInfo.m_compressedSize,
[-] 			(size_t) fileInfo.m_uncompressedSize,
[+] 			(size_t)fileInfo.m_uncompressedSize,
[-] 			sys::Time (fileInfo.m_timestamp).format ().sz (),
[+] 			sys::Time(fileInfo.m_timestamp).format().sz(),
[-] 			reader.extractFileToMem (i, &buffer);
[+] 			reader.extractFileToMem(i, &buffer);
[-] 			printf ("<<<\n%s\n>>>\n", buffer.cp ());
[+] 			printf("<<<\n%s\n>>>\n", buffer.cp ());
[-] 			result = reader.extractFileToFile (i, dstFileName);
[+] 			result = reader.extractFileToFile(i, dstFileName);
[-] 				printf ("can't extract file: %s\n", err::getLastErrorDescription ().sz ());
[+] 				printf("can't extract file: %s\n", err::getLastErrorDescription ().sz ());
[-] 		printf ("\n");
[+] 		printf("\n");
[-] testEnumSerial ()
[+] testEnumSerial()
[-] 	sl::List <io::SerialPortDesc> portList;
[+] 	sl::List<io::SerialPortDesc> portList;
[-] 	io::createSerialPortDescList (&portList);
[+] 	io::createSerialPortDescList(&portList);
[-] 	sl::Iterator <io::SerialPortDesc> it = portList.getHead ();
[+] 	sl::Iterator<io::SerialPortDesc> it = portList.getHead();
[-] 		printf ("device name: %s\ndescription: %s\n\n", it->getDeviceName ().sz (), it->getDescription ().sz ());
[+] 		printf("device name: %s\ndescription: %s\n\n", it->getDeviceName ().sz (), it->getDescription ().sz ());
[-] 	printf ("%d ports total\n", portList.getCount ());
[+] 	printf("%d ports total\n", portList.getCount ());
[-] testEncoding ()
[+] testEncoding()
[-] 	enc::EscapeEncoding::encode (&s, "\\\\.\\pipe\\mypipe");
[+] 	enc::EscapeEncoding::encode(&s, "\\\\.\\pipe\\mypipe");
[-] 	printf ("%s\n", s.sz ());
[+] 	printf("%s\n", s.sz ());
[-] testAddressSanitizer ()
[+] testAddressSanitizer()
[-] int foo (jmp_buf buf)
[+] int foo(jmp_buf buf)
[-] #pragma pack ()
[+] #pragma pack()
[-] #pragma pack (1)
[+] #pragma pack(1)
[-] #pragma pack (2)
[+] #pragma pack(2)
[-] #pragma pack (4)
[+] #pragma pack(4)
[-] #pragma pack (8)
[+] #pragma pack(8)
[-] testPacking ()
[+] testPacking()
[-] 	size_t s0 = sizeof (F0);
[+] 	size_t s0 = sizeof(F0);
[-] 	size_t s1 = sizeof (F1);
[+] 	size_t s1 = sizeof(F1);
[-] 	size_t s2 = sizeof (F2);
[+] 	size_t s2 = sizeof(F2);
[-] 	size_t s4 = sizeof (F4);
[+] 	size_t s4 = sizeof(F4);
[-] 	size_t s8 = sizeof (F8);
[+] 	size_t s8 = sizeof(F8);
[-] 	printf ("s0 = %d; s1 = %d; s2 = %d; s4 = %d; s8 = %d\n", s0, s1, s2, s4, s8);
[+] 	printf("s0 = %d; s1 = %d; s2 = %d; s4 = %d; s8 = %d\n", s0, s1, s2, s4, s8);
[-] uint16_t crc16_ansi (
[+] uint16_t crc16_ansi(
[-] 	static uint16_t const crcTable [256] =
[+] 	static uint16_t const crcTable[256] =
[-] 		crc = (crc >> 8) ^ crcTable [j];
[+] 		crc = (crc >> 8) ^ crcTable[j];
[-] uint16_t crc16_ccit (
[+] uint16_t crc16_ccit(
[-] 	static uint16_t const crcTable [256] =
[+] 	static uint16_t const crcTable[256] =
[-] 		crc = (crc << 8) ^ crcTable [j];
[+] 		crc = (crc << 8) ^ crcTable[j];
[-] 	return (uint16_t) crc;
[+] 	return (uint16_t)crc;
[-] testModBus ()
[+] testModBus()
[-] 	uint8_t packet [] =
[+] 	uint8_t packet[] =
[-] 	printf (
[+] 	printf(
[-] 		crc16_ansi (packet, sizeof (packet), 0),
[+] 		crc16_ansi(packet, sizeof(packet), 0),
[-] 		crc16_ansi (packet, sizeof (packet), 0xffff),
[+] 		crc16_ansi(packet, sizeof(packet), 0xffff),
[-] 		crc16_ccit (packet, sizeof (packet), 0),
[+] 		crc16_ccit(packet, sizeof(packet), 0),
[-] 		crc16_ccit (packet, sizeof (packet), 0xffff)
[+] 		crc16_ccit(packet, sizeof(packet), 0xffff)
[-] 	sl::String s_1_5 = sys::Time (timeout_1_5, false).format ("%s.%l.%c");
[+] 	sl::String s_1_5 = sys::Time(timeout_1_5, false).format("%s.%l.%c");
[-] 	sl::String s_3_5 = sys::Time (timeout_3_5, false).format ("%s.%l.%c");
[+] 	sl::String s_3_5 = sys::Time(timeout_3_5, false).format("%s.%l.%c");
[-] 	printf ("t_1_5 = %s\nt_3_5 = %s\n", s_1_5.sz (), s_3_5.sz ());
[+] 	printf("t_1_5 = %s\nt_3_5 = %s\n", s_1_5.sz (), s_3_5.sz ());
[-] uint_t calcChecksum16 (
[+] uint_t calcChecksum16(
[-] 		checksum += htons (*p);
[+] 		checksum += htons(*p);
[-] uint16_t adjustIpCheckSum (uint_t checksum)
[+] uint16_t adjustIpCheckSum(uint_t checksum)
[-] uint16_t calcIpHdrChecksum (const uint8_t* ipHdr, size_t size)
[+] uint16_t calcIpHdrChecksum(const uint8_t* ipHdr, size_t size)
[-] 	uint_t checksum = calcChecksum16 (ipHdr, size);
[+] 	uint_t checksum = calcChecksum16(ipHdr, size);
[-] 	return adjustIpCheckSum (checksum);
[+] 	return adjustIpCheckSum(checksum);
[-] testIpChecksum ()
[+] testIpChecksum()
[-] 	uint8_t data1_0 [] =
[+] 	uint8_t data1_0[] =
[-] 	uint8_t data1 [] =
[+] 	uint8_t data1[] =
[-] 	uint8_t data2_0 [] =
[+] 	uint8_t data2_0[] =
[-] 	uint8_t data2 [] =
[+] 	uint8_t data2[] =
[-] 	uint16_t x = calcIpHdrChecksum (data2, sizeof (data2));
[+] 	uint16_t x = calcIpHdrChecksum(data2, sizeof(data2));
[-] 	printf ("%x\n", x);
[+] 	printf("%x\n", x);
[-] encodeNetBiosName (
[+] encodeNetBiosName(
[-] 		uchar_t c = name [i];
[+] 		uchar_t c = name[i];
[-] 		c = toupper (c);
[+] 		c = toupper(c);
[-] 		buffer [j++] = 'A' + (c >> 4);
[+] 		buffer[j++] = 'A' + (c >> 4);
[-] 		buffer [j++] = 'A' + (c & 0x0f);
[+] 		buffer[j++] = 'A' + (c & 0x0f);
[-] 		buffer [j++] = paddingByteHi;
[+] 		buffer[j++] = paddingByteHi;
[-] 		buffer [j++] = paddingByteLo;
[+] 		buffer[j++] = paddingByteLo;
[-] decodeNetBiosName (
[+] decodeNetBiosName(
[-] 	ASSERT (!(length & 1)); // must be even
[+] 	ASSERT(!(length & 1)); // must be even
[-] 		uchar_t hi = name [i++] - 'A';
[+] 		uchar_t hi = name[i++] - 'A';
[-] 		uchar_t lo = name [i++] - 'A';
[+] 		uchar_t lo = name[i++] - 'A';
[-] 		buffer [j++] = lo + (hi << 4);
[+] 		buffer[j++] = lo + (hi << 4);
[-] testNetBios ()
[+] testNetBios()
[-] 	char buffer [1024] = "CKAAAAAAA" "AAAAAAAAAAAAAAAA" "AAAAAAA"; //{ 0 };
[+] 	char buffer[1024] = "CKAAAAAAA" "AAAAAAAAAAAAAAAA" "AAAAAAA"; //{ 0 };
[-] 	printf ("%s\n", buffer);
[+] 	printf("%s\n", buffer);
[-] 	char buffer2 [1024] = { 0 };
[+] 	char buffer2[1024] = { 0 };
[-] 	decodeNetBiosName (buffer2, buffer, length);
[+] 	decodeNetBiosName(buffer2, buffer, length);
[-] 	printf ("%s\n", buffer2);
[+] 	printf("%s\n", buffer2);
[-] 	 strlen (lpszMessage),
[+] 	 strlen(lpszMessage),
[-] 	 (LPOVERLAPPED) NULL);
[+] 	 (LPOVERLAPPED)NULL);
[-]    char buffer [256];
[+]    char buffer[256];
[-]    fResult = ReadFile (hSlot, buffer, sizeof (buffer) - 1, &cbRead, NULL);
[+]    fResult = ReadFile(hSlot, buffer, sizeof(buffer) - 1, &cbRead, NULL);
[-]    buffer [cbRead] = 0;
[+]    buffer[cbRead] = 0;
[-] testMailSlot ()
[+] testMailSlot()
[-] 	printf ("1 for server, 2 for client:\n");
[+] 	printf("1 for server, 2 for client:\n");
[-] 	char buffer [256];
[+] 	char buffer[256];
[-] 	fgets (buffer, countof (buffer), stdin);
[+] 	fgets(buffer, countof(buffer), stdin);
[-] 	if (buffer [0] == '1')
[+] 	if (buffer[0] == '1')
[-] 	char slotName [256];
[+] 	char slotName[256];
[-] 	printf ("slot name (e.g. \\\\.\\mailslot\\foo):\n");
[+] 	printf("slot name (e.g. \\\\.\\mailslot\\foo):\n");
[-] 	fgets (slotName, countof(slotName), stdin);
[+] 	fgets(slotName, countof(slotName), stdin);
[-] 		HANDLE hFile = CreateMailslotA (slotName, 0, -1, NULL);
[+] 		HANDLE hFile = CreateMailslotA(slotName, 0, -1, NULL);
[-] 	char slotName [256];
[+] 	char slotName[256];
[-] 	printf ("slot name (e.g. \\\\*\\mailslot\\foo):\n");
[+] 	printf("slot name (e.g. \\\\*\\mailslot\\foo):\n");
[-] 	fgets (slotName, countof(slotName), stdin);
[+] 	fgets(slotName, countof(slotName), stdin);
[-] 	   hFile = CreateFileA (
[+] 	   hFile = CreateFileA(
[-] 		 (LPSECURITY_ATTRIBUTES) NULL,
[+] 		 (LPSECURITY_ATTRIBUTES)NULL,
[-] 		 (HANDLE) NULL);
[+] 		 (HANDLE)NULL);
[-] class MyXmlParser: public xml::ExpatParser <MyXmlParser>
[+] class MyXmlParser: public xml::ExpatParser<MyXmlParser>
[-] 	MyXmlParser ()
[+] 	MyXmlParser()
[-] 	onStartElement (
[+] 	onStartElement(
[-] 		printIndent ();
[+] 		printIndent();
[-] 		printf ("<%s", name);
[+] 		printf("<%s", name);
[-] 			printf ("\n");
[+] 			printf("\n");
[-] 				printIndent ();
[+] 				printIndent();
[-] 				printf ("%s = %s\n", attributes [0], attributes [1]);
[+] 				printf("%s = %s\n", attributes [0], attributes [1]);
[-] 			printIndent ();
[+] 			printIndent();
[-] 		printf (">\n");
[+] 		printf(">\n");
[-] 	onEndElement (const char* name)
[+] 	onEndElement(const char* name)
[-] 		printIndent ();
[+] 		printIndent();
[-] 		printf ("</%s>\n", name);
[+] 		printf("</%s>\n", name);
[-] 	onCharacterData (
[+] 	onCharacterData(
[-] 		printIndent ();
[+] 		printIndent();
[-] 		printf ("%s\n", sl::String (string, length).sz ());
[+] 		printf("%s\n", sl::String (string, length).sz ());
[-] 	printIndent ()
[+] 	printIndent()
[-] 			printf ("  ");
[+] 			printf("  ");
[-] testXml ()
[+] testXml()
[-] 	result = parser.parseFile ("c:/projects/playground/doxygen/xml/index.xml", 100);
[+] 	result = parser.parseFile("c:/projects/playground/doxygen/xml/index.xml", 100);
[-] 		printf ("error: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("error: %s\n", err::getLastErrorDescription ().sz ());
[-] 	printf ("success\n");
[+] 	printf("success\n");
[-] testFileEnum ()
[+] testFileEnum()
[-] 	bool result = fileEnum.openDir (".");
[+] 	bool result = fileEnum.openDir(".");
[-] 		printf ("error: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("error: %s\n", err::getLastErrorDescription ().sz ());
[-] 	while (fileEnum.hasNextFile ())
[+] 	while (fileEnum.hasNextFile())
[-] 		sl::String fileName = fileEnum.getNextFileName ();
[+] 		sl::String fileName = fileEnum.getNextFileName();
[-] 		printf ("%s\n", fileName.sz ());
[+] 		printf("%s\n", fileName.sz ());
[-] testStringCase ()
[+] testStringCase()
[-] 	s.makeLowerCase ();
[+] 	s.makeLowerCase();
[-] 	printf ("s = %s\n", s.sz ());
[+] 	printf("s = %s\n", s.sz ());
[-] 	s.makeUpperCase ();
[+] 	s.makeUpperCase();
[-] 	printf ("s = %s\n", s.sz ());
[+] 	printf("s = %s\n", s.sz ());
[-] AXL_SL_BEGIN_CMD_LINE_SWITCH_TABLE (CmdLineSwitchTable, CmdLineSwitchKind)
[+] AXL_SL_BEGIN_CMD_LINE_SWITCH_TABLE(CmdLineSwitchTable, CmdLineSwitchKind)
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] AXL_SL_END_CMD_LINE_SWITCH_TABLE ()
[+] AXL_SL_END_CMD_LINE_SWITCH_TABLE()
[-] class CmdLineParser: public sl::CmdLineParser <CmdLineParser, CmdLineSwitchTable>
[+] class CmdLineParser: public sl::CmdLineParser<CmdLineParser, CmdLineSwitchTable>
[-] 	friend class sl::CmdLineParser <CmdLineParser, CmdLineSwitchTable>;
[+] 	friend class sl::CmdLineParser<CmdLineParser, CmdLineSwitchTable>;
[-] 	onValue (const sl::StringRef& value)
[+] 	onValue(const sl::StringRef& value)
[-] 		printf ("onValue (%s)\n", value.sz ());
[+] 		printf("onValue (%s)\n", value.sz ());
[-] 	onSwitch (
[+] 	onSwitch(
[-] 		switch (switchKind)
[+] 		switch(switchKind)
[-] 			printf ("CmdLineSwitchKind_Help\n");
[+] 			printf("CmdLineSwitchKind_Help\n");
[-] 			printf ("CmdLineSwitchKind_Version\n");
[+] 			printf("CmdLineSwitchKind_Version\n");
[-] 			printf ("CmdLineSwitchKind_Verbose\n");
[+] 			printf("CmdLineSwitchKind_Verbose\n");
[-] 			printf ("CmdLineSwitchKind_Add (%s)\n", value.sz ());
[+] 			printf("CmdLineSwitchKind_Add (%s)\n", value.sz ());
[-] 			printf ("CmdLineSwitchKind_Remove (%s)\n", value.sz ());
[+] 			printf("CmdLineSwitchKind_Remove (%s)\n", value.sz ());
[-] testCmdLine (
[+] testCmdLine(
[-] 	wchar_t* argv []
[+] 	wchar_t* argv[]
[-] testCmdLine (
[+] testCmdLine(
[-] 	char* argv []
[+] 	char* argv[]
[-] 	bool result = parser.parse (argc, argv);
[+] 	bool result = parser.parse(argc, argv);
[-] 		printf ("Error parsing command line: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("Error parsing command line: %s\n", err::getLastErrorDescription ().sz ());
[-] class ServerThread: public sys::ThreadImpl <ServerThread>
[+] class ServerThread: public sys::ThreadImpl<ServerThread>
[-] 	intptr_t threadFunc ()
[+] 	intptr_t threadFunc()
[-] 		addr.parse ("0.0.0.0:1002");
[+] 		addr.parse("0.0.0.0:1002");
[-] 		printf ("listening on TCP %s...\n", addr.getString ().sz ());
[+] 		printf("listening on TCP %s...\n", addr.getString ().sz ());
[-] 			serverSocket.open (AF_INET, SOCK_STREAM, IPPROTO_TCP) &&
[+] 			serverSocket.open(AF_INET, SOCK_STREAM, IPPROTO_TCP) &&
[-] 			serverSocket.bind (addr) &&
[+] 			serverSocket.bind(addr) &&
[-] 			serverSocket.listen (8);
[+] 			serverSocket.listen(8);
[-] 		m_startEvent.signal ();
[+] 		m_startEvent.signal();
[-] 		printf ("waiting for clients...\n");
[+] 		printf("waiting for clients...\n");
[-] 		result = serverSocket.accept (&clientSocket, &addr);
[+] 		result = serverSocket.accept(&clientSocket, &addr);
[-] 			printf ("failed: %s\n", err::getLastErrorDescription ().sz ());
[+] 			printf("failed: %s\n", err::getLastErrorDescription ().sz ());
[-] 		printf ("client connected from: %s\n", addr.getString ().sz ());
[+] 		printf("client connected from: %s\n", addr.getString ().sz ());
[-] 			char buffer [1024];
[+] 			char buffer[1024];
[-] 			int x = clientSocket.recv (buffer, sizeof (buffer) - 1);
[+] 			int x = clientSocket.recv(buffer, sizeof(buffer) - 1);
[-] 				buffer [x] = 0;
[+] 				buffer[x] = 0;
[-] 				printf ("client sent %d bytes: %s\n", x, buffer);
[+] 				printf("client sent %d bytes: %s\n", x, buffer);
[-] 				printf ("client reset.\n");
[+] 				printf("client reset.\n");
[-] 				printf ("client disconnected.\n");
[+] 				printf("client disconnected.\n");
[-] 		printf ("server thread done.\n");
[+] 		printf("server thread done.\n");
[-] testConn ()
[+] testConn()
[-] /*	printf ("startion server thread...\n");
[+] /*	printf("startion server thread...\n");
[-] 	thread.start ();
[+] 	thread.start();
[-] 	thread.m_startEvent.wait ();
[+] 	thread.m_startEvent.wait();
[-] 	addr.parse ("127.0.0.1:1002");
[+] 	addr.parse("127.0.0.1:1002");
[-] 	printf ("connecting to %s...\n", addr.getString ().sz ());
[+] 	printf("connecting to %s...\n", addr.getString ().sz ());
[-] 		socket.open (AF_INET, SOCK_STREAM, IPPROTO_TCP) &&
[+] 		socket.open(AF_INET, SOCK_STREAM, IPPROTO_TCP) &&
[-] 		socket.connect (addr);
[+] 		socket.connect(addr);
[-] 		printf ("failed: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("failed: %s\n", err::getLastErrorDescription ().sz ());
[-] 	static char data [] = "hui govno i muravei";
[+] 	static char data[] = "hui govno i muravei";
[-] 	printf ("sending %d bytes...\n", sizeof (data));
[+] 	printf("sending %d bytes...\n", sizeof (data));
[-] 	socket.send (data, sizeof (data));
[+] 	socket.send(data, sizeof(data));
[-] 	printf ("closing...\n");
[+] 	printf("closing...\n");
[-] 	socket.close ();
[+] 	socket.close();
[-] 	printf ("done.\n");
[+] 	printf("done.\n");
[-] testSerial ()
[+] testSerial()
[-] 	printf ("opening %s...\n", port);
[+] 	printf("opening %s...\n", port);
[-] 		serial.open (port) &&
[+] 		serial.open(port) &&
[-] 		serial.setSettings (&settings);
[+] 		serial.setSettings(&settings);
[-] 		printf ("failed: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("failed: %s\n", err::getLastErrorDescription ().sz ());
[-] 	serial.m_serial.setWaitMask (EV_ERR);
[+] 	serial.m_serial.setWaitMask(EV_ERR);
[-] 		char buf [1024] = { 0 };
[+] 		char buf[1024] = { 0 };
[-] 		size_t result = serial.read (buf, sizeof (buf));
[+] 		size_t result = serial.read(buf, sizeof(buf));
[-] 			printf ("failed: %s\n", err::getLastErrorDescription ().sz ());
[+] 			printf("failed: %s\n", err::getLastErrorDescription ().sz ());
[-] 		buf [result] = 0;
[+] 		buf[result] = 0;
[-] 		printf ("received: %s\n", buf);
[+] 		printf("received: %s\n", buf);
[-] 		bool result2 = serial.m_serial.wait (&events);
[+] 		bool result2 = serial.m_serial.wait(&events);
[-] 			printf ("failed: %s\n", err::getLastErrorDescription ().sz ());
[+] 			printf("failed: %s\n", err::getLastErrorDescription ().sz ());
[-] 		printf ("events: %x\n", events);
[+] 		printf("events: %x\n", events);
[-] 		result2 = serial.m_serial.clearError (&errors, &stat);
[+] 		result2 = serial.m_serial.clearError(&errors, &stat);
[-] 			printf ("failed: %s\n", err::getLastErrorDescription ().sz ());
[+] 			printf("failed: %s\n", err::getLastErrorDescription ().sz ());
[-] 		printf ("errors: %x\n", errors);
[+] 		printf("errors: %x\n", errors);
[-] 	printf ("\rwriting... %3d%%; bytes: %5d", totalSize * 100 / targetSize, totalSize);
[+] 	printf("\rwriting... %3d%%; bytes: %5d", totalSize * 100 / targetSize, totalSize);
[-] 		static char data [] = "123456789abcdef";
[+] 		static char data[] = "123456789abcdef";
[-] 		size_t size = serial.write (data, sizeof (data));
[+] 		size_t size = serial.write(data, sizeof(data));
[-] 			printf ("can't write: %s\n", err::getLastErrorDescription ().sz ());
[+] 			printf("can't write: %s\n", err::getLastErrorDescription ().sz ());
[-] 		printf ("\rwriting... %3d%%; bytes: %5d", totalSize * 100 / targetSize, totalSize);
[+] 		printf("\rwriting... %3d%%; bytes: %5d", totalSize * 100 / targetSize, totalSize);
[-] 	printf ("\ndone\n");
[+] 	printf("\ndone\n");
[-] testStringReplace ()
[+] testStringReplace()
[-] 	title.replace ("<", "&lt;");
[+] 	title.replace("<", "&lt;");
[-] 	title.replace (">", "&gt;");
[+] 	title.replace(">", "&gt;");
[-] 	title.replace ("&", "&amp;");
[+] 	title.replace("&", "&amp;");
[-] 	printf ("title = %s\n", title.sz ());
[+] 	printf("title = %s\n", title.sz ());
[-] testEvent ()
[+] testEvent()
[-] 		bool r = e.wait (500);
[+] 		bool r = e.wait(500);
[-] 			printf ("[%s] ---wait failed: %s\n", sys::Time (sys::getTimestamp ()).format ("%h:%m:%s.%l").sz (), err::getLastErrorDescription ().sz ());
[+] 			printf("[%s] ---wait failed: %s\n", sys::Time (sys::getTimestamp ()).format ("%h:%m:%s.%l").sz (), err::getLastErrorDescription ().sz ());
[-] 			printf ("[%s] ---wait SUCCEEDED! (WTF?!)\n", sys::Time (sys::getTimestamp ()).format ("%h:%m:%s.%l").sz ());
[+] 			printf("[%s] ---wait SUCCEEDED! (WTF?!)\n", sys::Time (sys::getTimestamp ()).format ("%h:%m:%s.%l").sz ());
[-] testBase32 ()
[+] testBase32()
[-] 	sl::Array <char> source;
[+] 	sl::Array<char> source;
[-] 		size_t size = rand () % 64 + 16;
[+] 		size_t size = rand() % 64 + 16;
[-] 		source.setCount (size);
[+] 		source.setCount(size);
[-] 			source [j] = rand () % 256;
[+] 			source[j] = rand() % 256;
[-] 		sl::String enc = enc::Base32Encoding::encode (source, size);
[+] 		sl::String enc = enc::Base32Encoding::encode(source, size);
[-] 		sl::Array <char> dec = enc::Base32Encoding::decode (enc);
[+] 		sl::Array<char> dec = enc::Base32Encoding::decode(enc);
[-] 		ASSERT (dec.getCount () == size && memcmp (dec, source, size) == 0);
[+] 		ASSERT(dec.getCount() == size && memcmp(dec, source, size) == 0);
[-] testTime ()
[+] testTime()
[-] 	uint64_t timestamp = sys::getTimestamp ();
[+] 	uint64_t timestamp = sys::getTimestamp();
[-] 	printf ("timestamp = 0x%llx; time = %s\n", timestamp, sys::Time (timestamp).format ().sz ());
[+] 	printf("timestamp = 0x%llx; time = %s\n", timestamp, sys::Time (timestamp).format ().sz ());
[-] testSerial2 ()
[+] testSerial2()
[-] 	result = serial.open ("/dev/ttyUSB0");
[+] 	result = serial.open("/dev/ttyUSB0");
[-] 	result = serial.setSettings (&settings);
[+] 	result = serial.setSettings(&settings);
[-] 	serial.write ("\r", 1);
[+] 	serial.write("\r", 1);
[-] 	char buffer [1024];
[+] 	char buffer[1024];
[-] 	size_t size = serial.read (buffer, sizeof (buffer));
[+] 	size_t size = serial.read(buffer, sizeof(buffer));
[-] 	sl::String s = enc::HexEncoding::encode (buffer, size);
[+] 	sl::String s = enc::HexEncoding::encode(buffer, size);
[-] 	printf ("incoming: %s\n", s.sz ());
[+] 	printf("incoming: %s\n", s.sz ());
[-] testSymbolicLinks ()
[+] testSymbolicLinks()
[-] 	bool result = io::getSymbolicLinkTarget (&target, "/home/vladimir/a");
[+] 	bool result = io::getSymbolicLinkTarget(&target, "/home/vladimir/a");
[-] 		printf ("error: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("error: %s\n", err::getLastErrorDescription ().sz ());
[-] 	printf ("target: %s\n", target.sz ());
[+] 	printf("target: %s\n", target.sz ());
[-] testBoyerMoore ()
[+] testBoyerMoore()
[-] 	static const char pattern [] = "muravei";
[+] 	static const char pattern[] = "muravei";
[-] 	find.setPattern (pattern, lengthof (pattern), sl::BoyerMooreFlag_Reverse);
[+] 	find.setPattern(pattern, lengthof(pattern), sl::BoyerMooreFlag_Reverse);
[-] 	static const char chunk1 [] = "vei! mura";
[+] 	static const char chunk1[] = "vei! mura";
[-] 	static const char chunk2 [] = "vei, go";
[+] 	static const char chunk2[] = "vei, go";
[-] 	offset = find.find (&incrementalContext, 0, chunk2, lengthof (chunk2));
[+] 	offset = find.find(&incrementalContext, 0, chunk2, lengthof(chunk2));
[-] 	offset = find.find (&incrementalContext, 0, chunk1, lengthof (chunk1));
[+] 	offset = find.find(&incrementalContext, 0, chunk1, lengthof(chunk1));
[-] 	printf ("offset = %d\n", offset);
[+] 	printf("offset = %d\n", offset);
[-] 	static const char pattern [] = "s";
[+] 	static const char pattern[] = "s";
[-] 	find.setPattern (
[+] 	find.setPattern(
[-] 		lengthof (pattern),
[+] 		lengthof(pattern),
[-] 	static const utf32_t chunk1 [] = { 'S', 'e' };
[+] 	static const utf32_t chunk1[] = { 'S', 'e' };
[-] 	offset = find.find (&incrementalContext, enc::CharCodecKind_Utf32, 0, chunk1, sizeof (chunk1));
[+] 	offset = find.find(&incrementalContext, enc::CharCodecKind_Utf32, 0, chunk1, sizeof(chunk1));
[-] testIoPerformance ()
[+] testIoPerformance()
[-] 	static char fileNameSrc [] = "G:/Temp/Test MTK TCP/Test MTK TCP.njlog";
[+] 	static char fileNameSrc[] = "G:/Temp/Test MTK TCP/Test MTK TCP.njlog";
[-] 	static char fileNameDst_s [] = "G:/Temp/Test MTK TCP/Test MTK TCP - 2.njlog";
[+] 	static char fileNameDst_s[] = "G:/Temp/Test MTK TCP/Test MTK TCP - 2.njlog";
[-] 	static char fileNameDst_m [] = "G:/Temp/Test MTK TCP/Test MTK TCP - 3.njlog";
[+] 	static char fileNameDst_m[] = "G:/Temp/Test MTK TCP/Test MTK TCP - 3.njlog";
[-] 	bool result = simpleFileSrc.open (fileNameSrc, io::FileFlag_ReadOnly);
[+] 	bool result = simpleFileSrc.open(fileNameSrc, io::FileFlag_ReadOnly);
[-] 		printf ("can't open %s: %s\n", fileNameSrc, err::getLastErrorDescription ().sz ());
[+] 		printf("can't open %s: %s\n", fileNameSrc, err::getLastErrorDescription ().sz ());
[-] 	sl::Array <char> buffer;
[+] 	sl::Array<char> buffer;
[-] 		char m_data [1024];
[+] 		char m_data[1024];
[-] 	memset (&staticRec, 0, sizeof (staticRec));
[+] 	memset(&staticRec, 0, sizeof(staticRec));
[-] 	staticRec.m_dataSize = sizeof (staticRec.m_data);
[+] 	staticRec.m_dataSize = sizeof(staticRec.m_data);
[-] 	result = mappedFileSrc.open (fileNameSrc, io::FileFlag_ReadOnly);
[+] 	result = mappedFileSrc.open(fileNameSrc, io::FileFlag_ReadOnly);
[-] 		mappedFileDst.open (fileNameDst_m) &&
[+] 		mappedFileDst.open(fileNameDst_m) &&
[-] 		mappedFileDst.setSize (0);
[+] 		mappedFileDst.setSize(0);
[-] 		printf ("error: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("error: %s\n", err::getLastErrorDescription ().sz ());
[-] 	printf ("testing mapped file...\n");
[+] 	printf("testing mapped file...\n");
[-] 	baseTimestamp = sys::getTimestamp ();
[+] 	baseTimestamp = sys::getTimestamp();
[-] 	RecordFileHdr* hdr2 = (RecordFileHdr*) mappedFileSrc.view (0, sizeof (RecordFileHdr), true);
[+] 	RecordFileHdr* hdr2 = (RecordFileHdr*)mappedFileSrc.view(0, sizeof(RecordFileHdr), true);
[-] 	RecordFileHdr* hdr3 = (RecordFileHdr*) mappedFileDst.view (0, sizeof (RecordFileHdr), true);
[+] 	RecordFileHdr* hdr3 = (RecordFileHdr*)mappedFileDst.view(0, sizeof(RecordFileHdr), true);
[-] 	offset = sizeof (RecordFileHdr);
[+] 	offset = sizeof(RecordFileHdr);
[-] 		size_t recSize = sizeof (rec);
[+] 		size_t recSize = sizeof(rec);
[-] 		Record* rec = (Record*) mappedFileSrc.view (offset, sizeof (Record));
[+] 		Record* rec = (Record*)mappedFileSrc.view(offset, sizeof(Record));
[-] 		size_t recSize = sizeof (Record) + rec->m_dataSize;
[+] 		size_t recSize = sizeof(Record) + rec->m_dataSize;
[-] 			rec = (Record*) mappedFileSrc.view (offset, recSize);
[+] 			rec = (Record*)mappedFileSrc.view(offset, recSize);
[-] 		void* p = mappedFileDst.view (offset, recSize);
[+] 		void* p = mappedFileDst.view(offset, recSize);
[-] 		memcpy (p, rec, recSize);
[+] 		memcpy(p, rec, recSize);
[-] 	time = sys::getTimestamp () - baseTimestamp;
[+] 	time = sys::getTimestamp() - baseTimestamp;
[-] 	printf ("Done: %s\n", sys::Time (time, 0).format ("%m.%s.%l").sz ());
[+] 	printf("Done: %s\n", sys::Time (time, 0).format ("%m.%s.%l").sz ());
[-] 		simpleFileDst.open (fileNameDst_s) &&
[+] 		simpleFileDst.open(fileNameDst_s) &&
[-] 		simpleFileDst.setSize (0);
[+] 		simpleFileDst.setSize(0);
[-] 		printf ("error: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("error: %s\n", err::getLastErrorDescription ().sz ());
[-] 	printf ("testing simple file...\n");
[+] 	printf("testing simple file...\n");
[-] 	baseTimestamp = sys::getTimestamp ();
[+] 	baseTimestamp = sys::getTimestamp();
[-] 	simpleFileSrc.read (&hdr, sizeof (hdr));
[+] 	simpleFileSrc.read(&hdr, sizeof(hdr));
[-] 	simpleFileDst.write (&hdr, sizeof (hdr));
[+] 	simpleFileDst.write(&hdr, sizeof(hdr));
[-] 		simpleFileSrc.read (&rec, sizeof (rec));
[+] 		simpleFileSrc.read(&rec, sizeof(rec));
[-] 			buffer.setCount (rec.m_dataSize);
[+] 			buffer.setCount(rec.m_dataSize);
[-] 			simpleFileSrc.read (buffer, rec.m_dataSize);
[+] 			simpleFileSrc.read(buffer, rec.m_dataSize);
[-] 		simpleFileDst.write (&rec, sizeof (rec));
[+] 		simpleFileDst.write(&rec, sizeof(rec));
[-] 		simpleFileDst.write (buffer, rec.m_dataSize);
[+] 		simpleFileDst.write(buffer, rec.m_dataSize);
[-] 		offset += sizeof (rec) + rec.m_dataSize;
[+] 		offset += sizeof(rec) + rec.m_dataSize;
[-] 		simpleFileDst.write (&staticRec, sizeof (staticRec));
[+] 		simpleFileDst.write(&staticRec, sizeof(staticRec));
[-] 		offset += sizeof (staticRec);
[+] 		offset += sizeof(staticRec);
[-] 	time = sys::getTimestamp () - baseTimestamp;
[+] 	time = sys::getTimestamp() - baseTimestamp;
[-] 	printf ("Done: %s\n", sys::Time (time, 0).format ("%m.%s.%l").sz ());
[+] 	printf("Done: %s\n", sys::Time (time, 0).format ("%m.%s.%l").sz ());
[-] 	public sys::ThreadImpl <RwLockThread>
[+] 	public sys::ThreadImpl<RwLockThread>
[-] 	RwLockThread (
[+] 	RwLockThread(
[-] 	threadFunc ()
[+] 	threadFunc()
[-] 		uint64_t tid = sys::getCurrentThreadId ();
[+] 		uint64_t tid = sys::getCurrentThreadId();
[-] 				m_lock->writeLock ();
[+] 				m_lock->writeLock();
[-] 				ASSERT (g_readerCount == 0);
[+] 				ASSERT(g_readerCount == 0);
[-] 				ASSERT (g_writerCount == 0);
[+] 				ASSERT(g_writerCount == 0);
[-] 				sys::atomicInc (&g_writerCount);
[+] 				sys::atomicInc(&g_writerCount);
[-] 				printf ("writer #%d (TID:%llx) is writing (%d/%d)...\n", m_index, tid, i, m_iterationCount);
[+] 				printf("writer #%d (TID:%llx) is writing (%d/%d)...\n", m_index, tid, i, m_iterationCount);
[-] 				sys::sleep (rand () % MaxSleepTime);
[+] 				sys::sleep(rand() % MaxSleepTime);
[-] 				sys::atomicDec (&g_writerCount);
[+] 				sys::atomicDec(&g_writerCount);
[-] 				m_lock->writeUnlock ();
[+] 				m_lock->writeUnlock();
[-] 				m_lock->readLock ();
[+] 				m_lock->readLock();
[-] 				ASSERT (g_writerCount == 0);
[+] 				ASSERT(g_writerCount == 0);
[-] 				sys::atomicInc (&g_readerCount);
[+] 				sys::atomicInc(&g_readerCount);
[-] 				printf ("reader #%d (TID:%llx) is reading (%d/%d; %d readers total)...\n", m_index, tid, i, m_iterationCount, g_readerCount);
[+] 				printf("reader #%d (TID:%llx) is reading (%d/%d; %d readers total)...\n", m_index, tid, i, m_iterationCount, g_readerCount);
[-] 				sys::sleep (rand () % MaxSleepTime);
[+] 				sys::sleep(rand() % MaxSleepTime);
[-] 				sys::atomicDec (&g_readerCount);
[+] 				sys::atomicDec(&g_readerCount);
[-] 				m_lock->readUnlock ();
[+] 				m_lock->readUnlock();
[-] testReadWriteLock ()
[+] testReadWriteLock()
[-] 	lock.create ();
[+] 	lock.create();
[-] 	sl::List <RwLockThread> threadList;
[+] 	sl::List<RwLockThread> threadList;
[-] 		RwLockThread* thread = AXL_MEM_NEW_ARGS (RwLockThread, (&lock, i, ReaderIterationCount, false));
[+] 		RwLockThread* thread = AXL_MEM_NEW_ARGS(RwLockThread, (&lock, i, ReaderIterationCount, false));
[-] 		thread->start ();
[+] 		thread->start();
[-] 		threadList.insertTail (thread);
[+] 		threadList.insertTail(thread);
[-] 		RwLockThread* thread = AXL_MEM_NEW_ARGS (RwLockThread, (&lock, i, WriterIterationCount, true));
[+] 		RwLockThread* thread = AXL_MEM_NEW_ARGS(RwLockThread, (&lock, i, WriterIterationCount, true));
[-] 		thread->start ();
[+] 		thread->start();
[-] 		threadList.insertTail (thread);
[+] 		threadList.insertTail(thread);
[-] 	sl::Iterator <RwLockThread> it = threadList.getHead ();
[+] 	sl::Iterator<RwLockThread> it = threadList.getHead();
[-] 		it->waitAndClose ();
[+] 		it->waitAndClose();
[-] foo (T* p)
[+] foo(T* p)
[-] 	printf ("foo - 1\n");
[+] 	printf("foo - 1\n");
[-] foo (const T* p)
[+] foo(const T* p)
[-] 	printf ("foo - 2\n");
[+] 	printf("foo - 2\n");
[-] testConstList ()
[+] testConstList()
[-] 	sl::List <Point> list;
[+] 	sl::List<Point> list;
[-] 	Point* point = AXL_MEM_NEW (Point);
[+] 	Point* point = AXL_MEM_NEW(Point);
[-] 	list.insertTail (point);
[+] 	list.insertTail(point);
[-] 	point = AXL_MEM_NEW (Point);
[+] 	point = AXL_MEM_NEW(Point);
[-] 	list.insertTail (point);
[+] 	list.insertTail(point);
[-] 	sl::Iterator <Point> it = list.getHead ();
[+] 	sl::Iterator<Point> it = list.getHead();
[-] 	sl::ConstIterator <Point> it2 = it;
[+] 	sl::ConstIterator<Point> it2 = it;
[-] testBitIdx ()
[+] testBitIdx()
[-] 	size_t size = sl::getAllocSize (0);
[+] 	size_t size = sl::getAllocSize(0);
[-] 	ASSERT (size == 0);
[+] 	ASSERT(size == 0);
[-] 	size_t x = sl::getPowerOf2Ge (0);
[+] 	size_t x = sl::getPowerOf2Ge(0);
[-] 	ASSERT (x == 0);
[+] 	ASSERT(x == 0);
[-] 	size_t y = sl::getHiBit (0);
[+] 	size_t y = sl::getHiBit(0);
[-] 	ASSERT (y == 0);
[+] 	ASSERT(y == 0);
[-] 	size_t z = sl::getLoBit (0);
[+] 	size_t z = sl::getLoBit(0);
[-] 	ASSERT (z == 0);
[+] 	ASSERT(z == 0);
[-] 		size_t size = sl::getAllocSize (i);
[+] 		size_t size = sl::getAllocSize(i);
[-] 		ASSERT (size >= i);
[+] 		ASSERT(size >= i);
[-] 		size_t x = sl::getPowerOf2Ge (i);
[+] 		size_t x = sl::getPowerOf2Ge(i);
[-] 		ASSERT (x >= i);
[+] 		ASSERT(x >= i);
[-] 		size_t y = sl::getHiBit (i);
[+] 		size_t y = sl::getHiBit(i);
[-] 		ASSERT ((i & y) && y <= i);
[+] 		ASSERT((i & y) && y <= i);
[-] 		size_t z = sl::getLoBit (i);
[+] 		size_t z = sl::getLoBit(i);
[-] 		ASSERT ((i & z) && z <= y);
[+] 		ASSERT((i & z) && z <= y);
[-] wmain (
[+] wmain(
[-] 	wchar_t* argv []
[+] 	wchar_t* argv[]
[-] main (
[+] main(
[-] 	char* argv []
[+] 	char* argv[]
[-] 	setvbuf (stdout, NULL, _IOLBF, 1024);
[+] 	setvbuf(stdout, NULL, _IOLBF, 1024);
[-] 	g::getModule ()->setTag ("axl_test_con");
[+] 	g::getModule()->setTag("axl_test_con");
[-] 	srand ((uint_t) sys::getTimestamp ());
[+] 	srand((uint_t)sys::getTimestamp());
[-] 	WSAStartup (0x0202, &wsaData);
[+] 	WSAStartup(0x0202, &wsaData);
[-] 	testSerial ();
[+] 	testSerial();
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_con\pch.h
----------------------
[-] #	pragma comment (lib, "ws2_32.lib")
[+] #	pragma comment(lib, "ws2_32.lib")
[-] #	pragma comment (lib, "iphlpapi.lib")
[+] #	pragma comment(lib, "iphlpapi.lib")
[-] #		pragma warning (disable: 4200) // warning C4200: nonstandard extension used : zero-sized array in struct/union
[+] #		pragma warning(disable: 4200) // warning C4200: nonstandard extension used : zero-sized array in struct/union
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_qt\main.cpp
----------------------
[-] trySudo ()
[+] trySudo()
[-] 	static char idPass [] = "55b828e362e44b9c8189e73d8eb01778";
[+] 	static char idPass[] = "55b828e362e44b9c8189e73d8eb01778";
[-] 	static char idEcho [] = "bb05199f9ad34eb0876dac63300e2b62";
[+] 	static char idEcho[] = "bb05199f9ad34eb0876dac63300e2b62";
[-] 	argList.append ("-S");
[+] 	argList.append("-S");
[-] 	argList.append ("-p");
[+] 	argList.append("-p");
[-] 	argList.append (idPass);
[+] 	argList.append(idPass);
[-] 	argList.append ("echo");
[+] 	argList.append("echo");
[-] 	argList.append (idEcho);
[+] 	argList.append(idEcho);
[-] 		process.setReadChannelMode (QProcess::MergedChannels);
[+] 		process.setReadChannelMode(QProcess::MergedChannels);
[-] 		process.start (
[+] 		process.start(
[-] 		process.waitForStarted ();
[+] 		process.waitForStarted();
[-] 			process.waitForReadyRead ();
[+] 			process.waitForReadyRead();
[-] 			output += process.readAll ();
[+] 			output += process.readAll();
[-] 		} while (output.size () < sizeof (idEcho) - 1);
[+] 		} while (output.size() < sizeof(idEcho) - 1);
[-] 		if (memcmp (output.cbegin (), idEcho, sizeof (idEcho) - 1) == 0)
[+] 		if (memcmp(output.cbegin(), idEcho, sizeof(idEcho) - 1) == 0)
[-] 			printf ("already a superuser\n");
[+] 			printf("already a superuser\n");
[-] 			process.waitForFinished ();
[+] 			process.waitForFinished();
[-] 		printf ("enter password: \n");
[+] 		printf("enter password: \n");
[-] 		char password [256];
[+] 		char password[256];
[-] 		scanf ("%s", password);
[+] 		scanf("%s", password);
[-] 		size_t length = strlen (password);
[+] 		size_t length = strlen(password);
[-] 			printf ("cancelled\n");
[+] 			printf("cancelled\n");
[-] 			process.waitForFinished ();
[+] 			process.waitForFinished();
[-] 		password [length++] = '\n';
[+] 		password[length++] = '\n';
[-] 		process.write (password, length);
[+] 		process.write(password, length);
[-] 		process.closeWriteChannel ();
[+] 		process.closeWriteChannel();
[-] 		process.waitForFinished ();
[+] 		process.waitForFinished();
[-] 		output = process.readAll ();
[+] 		output = process.readAll();
[-] 		length = output.size ();
[+] 		length = output.size();
[-] 		if (length >= sizeof (idEcho) - 1 &&
[+] 		if (length >= sizeof(idEcho) - 1 &&
[-] 			memcmp (output.cbegin (), idEcho, sizeof (idEcho) - 1) == 0)
[+] 			memcmp(output.cbegin(), idEcho, sizeof(idEcho) - 1) == 0)
[-] 			printf ("successfully authorized\n");
[+] 			printf("successfully authorized\n");
[-] int sendFd (
[+] int sendFd(
[-] 		ControlBufferLength = CMSG_LEN (sizeof (int))
[+] 		ControlBufferLength = CMSG_LEN(sizeof(int))
[-] 	char controlBuffer [ControlBufferLength];
[+] 	char controlBuffer[ControlBufferLength];
[-] 	dummyIov.iov_len = sizeof (dummyData);
[+] 	dummyIov.iov_len = sizeof(dummyData);
[-] 	cmsg = CMSG_FIRSTHDR (&msg);
[+] 	cmsg = CMSG_FIRSTHDR(&msg);
[-] 	cmsg->cmsg_len = CMSG_LEN (sizeof (int));
[+] 	cmsg->cmsg_len = CMSG_LEN(sizeof(int));
[-] 	*(int*) CMSG_DATA (cmsg) = fd;
[+] 	*(int*)CMSG_DATA(cmsg) = fd;
[-] 	return sendmsg (sock, &msg, 0);
[+] 	return sendmsg(sock, &msg, 0);
[-] int recvFd (int sock)
[+] int recvFd(int sock)
[-] 		ControlBufferLength = CMSG_LEN (sizeof (int))
[+] 		ControlBufferLength = CMSG_LEN(sizeof(int))
[-] 	char controlBuffer [ControlBufferLength];
[+] 	char controlBuffer[ControlBufferLength];
[-] 	dummyIov.iov_len = sizeof (dummyData);
[+] 	dummyIov.iov_len = sizeof(dummyData);
[-] 	cmsg = CMSG_FIRSTHDR (&msg);
[+] 	cmsg = CMSG_FIRSTHDR(&msg);
[-] 	cmsg->cmsg_len = CMSG_LEN (sizeof (int));
[+] 	cmsg->cmsg_len = CMSG_LEN(sizeof(int));
[-] 	int result = recvmsg (sock, &msg, 0);
[+] 	int result = recvmsg(sock, &msg, 0);
[-] 	return *(int*) CMSG_DATA (cmsg);
[+] 	return *(int*)CMSG_DATA(cmsg);
[-] static char g_transmitData [] = "abcdefghijklmnopqrstuvwxyz";
[+] static char g_transmitData[] = "abcdefghijklmnopqrstuvwxyz";
[-] class ReaderThread: public mt::ThreadImpl <ReaderThread>
[+] class ReaderThread: public mt::ThreadImpl<ReaderThread>
[-] 	void threadProc ()
[+] 	void threadProc()
[-] 		bool result = m_reader.open (
[+] 		bool result = m_reader.open(
[-] 			printf ("cannot open reader (%s)\n", err::getLastErrorDescription ().sz ());
[+] 			printf("cannot open reader (%s)\n", err::getLastErrorDescription ().sz ());
[-] 		sl::Array <char> buffer;
[+] 		sl::Array<char> buffer;
[-] 			size_t size = m_reader.read (&buffer);
[+] 			size_t size = m_reader.read(&buffer);
[-] 				printf ("cannot read (%s)\n", err::getLastErrorDescription ().sz ());
[+] 				printf("cannot read (%s)\n", err::getLastErrorDescription ().sz ());
[-] 			int cmpResult = memcmp (g_transmitData + offset, buffer, size);
[+] 			int cmpResult = memcmp(g_transmitData + offset, buffer, size);
[-] 				printf ("wrong data!\n");
[+] 				printf("wrong data!\n");
[-] 			if (offset >= sizeof (g_transmitData))
[+] 			if (offset >= sizeof(g_transmitData))
[-] class WriterThread: public mt::ThreadImpl <WriterThread>
[+] class WriterThread: public mt::ThreadImpl<WriterThread>
[-] 	void threadProc ()
[+] 	void threadProc()
[-] 		unlink ("/home/vladimir/test-transport");
[+] 		unlink("/home/vladimir/test-transport");
[-] 		bool result = m_writer.open (
[+] 		bool result = m_writer.open(
[-] 			printf ("cannot open writer (%s)\n", err::getLastErrorDescription ().sz ());
[+] 			printf("cannot open writer (%s)\n", err::getLastErrorDescription ().sz ());
[-] 			size_t size = 1 + rand () % (sizeof (g_transmitData) - 1);
[+] 			size_t size = 1 + rand() % (sizeof(g_transmitData) - 1);
[-] 			if (offset + size < sizeof (g_transmitData))
[+] 			if (offset + size < sizeof(g_transmitData))
[-] 				size = sizeof (g_transmitData) - offset;
[+] 				size = sizeof(g_transmitData) - offset;
[-] 			size_t result = m_writer.write (p, size);
[+] 			size_t result = m_writer.write(p, size);
[-] 				printf ("cannot write (%s)\n", err::getLastErrorDescription ().sz ());
[+] 				printf("cannot write (%s)\n", err::getLastErrorDescription ().sz ());
[-] testUtf ()
[+] testUtf()
[-] 	printf ("Testing UTF...\n");
[+] 	printf("Testing UTF...\n");
[-] 		if (axl::enc::utfIsDigit (c) != QChar::isDigit (c))
[+] 		if (axl::enc::utfIsDigit(c) != QChar::isDigit(c))
[-] 			printf ("%x\taxl::enc::utfIsDigit -> %d\tQChar::isDigit -> %d\n", c, axl::enc::utfIsDigit (c), QChar::isDigit (c));
[+] 			printf("%x\taxl::enc::utfIsDigit -> %d\tQChar::isDigit -> %d\n", c, axl::enc::utfIsDigit (c), QChar::isDigit (c));
[-] 		if (axl::enc::utfIsLetter (c) != QChar::isLetter (c))
[+] 		if (axl::enc::utfIsLetter(c) != QChar::isLetter(c))
[-] 			printf ("%x\taxl::enc::utfIsLetter -> %d\tQChar::isLetter -> %d\n", c, axl::enc::utfIsLetter (c), QChar::isLetter (c));
[+] 			printf("%x\taxl::enc::utfIsLetter -> %d\tQChar::isLetter -> %d\n", c, axl::enc::utfIsLetter (c), QChar::isLetter (c));
[-] 		if (axl::enc::utfIsNumber (c) != QChar::isNumber (c))
[+] 		if (axl::enc::utfIsNumber(c) != QChar::isNumber(c))
[-] 			printf ("%x\taxl::enc::utfIsNumber -> %d\tQChar::isNumber -> %d\n", c, axl::enc::utfIsNumber (c), QChar::isNumber (c));
[+] 			printf("%x\taxl::enc::utfIsNumber -> %d\tQChar::isNumber -> %d\n", c, axl::enc::utfIsNumber (c), QChar::isNumber (c));
[-] 		if (axl::enc::utfIsLetterOrDigit (c) != (QChar::isLetter (c) || QChar::isDigit (c)))
[+] 		if (axl::enc::utfIsLetterOrDigit(c) != (QChar::isLetter(c) || QChar::isDigit(c)))
[-] 			printf ("%x\taxl::enc::utfIsLetterOrDigit -> %d\tQChar::isLetter -> %d\tQChar::isDigit -> %d\n", c, axl::enc::utfIsLetterOrDigit (c), QChar::isLetter (c), QChar::isDigit (c));
[+] 			printf("%x\taxl::enc::utfIsLetterOrDigit -> %d\tQChar::isLetter -> %d\tQChar::isDigit -> %d\n", c, axl::enc::utfIsLetterOrDigit (c), QChar::isLetter (c), QChar::isDigit (c));
[-] 		if (axl::enc::utfIsLetterOrNumber (c) != QChar::isLetterOrNumber (c))
[+] 		if (axl::enc::utfIsLetterOrNumber(c) != QChar::isLetterOrNumber(c))
[-] 			printf ("%x\taxl::enc::utfIsLetterOrNumber -> %d\tQChar::isLetterOrNumber  -> %d\n", c, axl::enc::utfIsLetterOrNumber (c), QChar::isLetterOrNumber  (c));
[+] 			printf("%x\taxl::enc::utfIsLetterOrNumber -> %d\tQChar::isLetterOrNumber  -> %d\n", c, axl::enc::utfIsLetterOrNumber (c), QChar::isLetterOrNumber  (c));
[-] 		if (axl::enc::utfIsPunctuation (c) != QChar::isPunct (c))
[+] 		if (axl::enc::utfIsPunctuation(c) != QChar::isPunct(c))
[-] 			printf ("%x\taxl::enc::utfIsPunctuation -> %d\tQChar::isPunct -> %d\n", c, axl::enc::utfIsPunctuation (c), QChar::isPunct (c));
[+] 			printf("%x\taxl::enc::utfIsPunctuation -> %d\tQChar::isPunct -> %d\n", c, axl::enc::utfIsPunctuation (c), QChar::isPunct (c));
[-] 		if (axl::enc::utfIsSpace (c) != QChar::isSpace (c))
[+] 		if (axl::enc::utfIsSpace(c) != QChar::isSpace(c))
[-] 			printf ("%x\taxl::enc::utfIsSpace -> %d\tQChar::isDigit -> %d\n", c, axl::enc::utfIsSpace (c), QChar::isSpace (c));
[+] 			printf("%x\taxl::enc::utfIsSpace -> %d\tQChar::isDigit -> %d\n", c, axl::enc::utfIsSpace (c), QChar::isSpace (c));
[-] 		if (axl::enc::utfIsPrintable (c) != QChar::isPrint (c))
[+] 		if (axl::enc::utfIsPrintable(c) != QChar::isPrint(c))
[-] 			printf ("%x\taxl::enc::utfIsPrintable -> %d\tQChar::isPrint -> %d\n", c, axl::enc::utfIsPrintable (c), QChar::isPrint (c));
[+] 			printf("%x\taxl::enc::utfIsPrintable -> %d\tQChar::isPrint -> %d\n", c, axl::enc::utfIsPrintable (c), QChar::isPrint (c));
[-] 		if (axl::enc::utfIsPrintableNonMark (c) != (QChar::isPrint (c) && !QChar::isMark (c)))
[+] 		if (axl::enc::utfIsPrintableNonMark(c) != (QChar::isPrint(c) && !QChar::isMark(c)))
[-] 			printf ("%x\taxl::enc::utfIsPrintableNonMark -> %d\tQChar::isPrint -> %d\tQChar::isMark -> %d\n", c, axl::enc::utfIsPrintableNonMark (c), QChar::isPrint (c), QChar::isMark (c));
[+] 			printf("%x\taxl::enc::utfIsPrintableNonMark -> %d\tQChar::isPrint -> %d\tQChar::isMark -> %d\n", c, axl::enc::utfIsPrintableNonMark (c), QChar::isPrint (c), QChar::isMark (c));
[-] 		if (axl::enc::utfIsLowerCase (c) != QChar::isLower (c))
[+] 		if (axl::enc::utfIsLowerCase(c) != QChar::isLower(c))
[-] 			printf ("%x\taxl::enc::utfIsLowerCase -> %d\tQChar::isLower -> %d\n", c, axl::enc::utfIsLowerCase (c), QChar::isLower (c));
[+] 			printf("%x\taxl::enc::utfIsLowerCase -> %d\tQChar::isLower -> %d\n", c, axl::enc::utfIsLowerCase (c), QChar::isLower (c));
[-] 		if (axl::enc::utfIsUpperCase (c) != QChar::isUpper (c))
[+] 		if (axl::enc::utfIsUpperCase(c) != QChar::isUpper(c))
[-] 			printf ("%x\taxl::enc::utfIsUpperCase -> %d\tQChar::isUpper -> %d\n", c, axl::enc::utfIsUpperCase (c), QChar::isUpper (c));
[+] 			printf("%x\taxl::enc::utfIsUpperCase -> %d\tQChar::isUpper -> %d\n", c, axl::enc::utfIsUpperCase (c), QChar::isUpper (c));
[-] 		if (axl::enc::utfToLowerCase (c) != QChar::toLower (c))
[+] 		if (axl::enc::utfToLowerCase(c) != QChar::toLower(c))
[-] 			printf ("%x\taxl::enc::utfToLowerCase -> %x\tQChar::toLower -> %x\n", c, axl::enc::utfToLowerCase (c), QChar::toLower (c));
[+] 			printf("%x\taxl::enc::utfToLowerCase -> %x\tQChar::toLower -> %x\n", c, axl::enc::utfToLowerCase (c), QChar::toLower (c));
[-] 		if (axl::enc::utfToUpperCase (c) != QChar::toUpper (c))
[+] 		if (axl::enc::utfToUpperCase(c) != QChar::toUpper(c))
[-] 			printf ("%x\taxl::enc::utfToUpperCase -> %x\tQChar::toUpper -> %x\n", c, axl::enc::utfToUpperCase (c), QChar::toUpper (c));
[+] 			printf("%x\taxl::enc::utfToUpperCase -> %x\tQChar::toUpper -> %x\n", c, axl::enc::utfToUpperCase (c), QChar::toUpper (c));
[-] 		if (axl::enc::utfToCaseFolded (c) != QChar::toCaseFolded (c))
[+] 		if (axl::enc::utfToCaseFolded(c) != QChar::toCaseFolded(c))
[-] 			printf ("%x\taxl::enc::utfToCaseFolded -> %x\tQChar::toCaseFolded -> %x\n", c, axl::enc::utfToCaseFolded (c), QChar::toCaseFolded (c));
[+] 			printf("%x\taxl::enc::utfToCaseFolded -> %x\tQChar::toCaseFolded -> %x\n", c, axl::enc::utfToCaseFolded (c), QChar::toCaseFolded (c));
[-] 	printf ("Done\n");
[+] 	printf("Done\n");
[-] void ulltoa (quint64 l, char* buff, size_t size)
[+] void ulltoa(quint64 l, char* buff, size_t size)
[-] 	memset (buff, 'a', last);
[+] 	memset(buff, 'a', last);
[-] 	buff [last] = 0;
[+] 	buff[last] = 0;
[-] size_t formatIntegerWithThousandSep_stl (std::string* string, quint64 l)
[+] size_t formatIntegerWithThousandSep_stl(std::string* string, quint64 l)
[-] 	char buff [65];
[+] 	char buff[65];
[-] 	ulltoa (l, buff, sizeof (buff));
[+] 	ulltoa(l, buff, sizeof(buff));
[-] 	intptr_t i = string->length () - 3;
[+] 	intptr_t i = string->length() - 3;
[-] 		string->insert (i, 1, ',');
[+] 		string->insert(i, 1, ',');
[-] 	return string->length ();
[+] 	return string->length();
[-] formatIntegerWithThousandSep_stl (quint64 value)
[+] formatIntegerWithThousandSep_stl(quint64 value)
[-] 	formatIntegerWithThousandSep_stl (&string, value);
[+] 	formatIntegerWithThousandSep_stl(&string, value);
[-] size_t formatIntegerWithThousandSep_qt (QString* string, quint64 l)
[+] size_t formatIntegerWithThousandSep_qt(QString* string, quint64 l)
[-] 	char buff [65];
[+] 	char buff[65];
[-] 	ulltoa (l, buff, sizeof (buff));
[+] 	ulltoa(l, buff, sizeof(buff));
[-] 	*string = QString::fromUtf8 (buff, sizeof (buff) - 1);
[+] 	*string = QString::fromUtf8(buff, sizeof(buff) - 1);
[-] 	int i = string->length () - 3;
[+] 	int i = string->length() - 3;
[-] 		string->insert (i, ',');
[+] 		string->insert(i, ',');
[-] 	return string->length ();
[+] 	return string->length();
[-] formatIntegerWithThousandSep_qt (quint64 value)
[+] formatIntegerWithThousandSep_qt(quint64 value)
[-] 	formatIntegerWithThousandSep_qt (&string, value);
[+] 	formatIntegerWithThousandSep_qt(&string, value);
[-] size_t formatIntegerWithThousandSep_axl (sl::String* string, quint64 l)
[+] size_t formatIntegerWithThousandSep_axl(sl::String* string, quint64 l)
[-] 	char buff [65];
[+] 	char buff[65];
[-] 	ulltoa (l, buff, sizeof (buff));
[+] 	ulltoa(l, buff, sizeof(buff));
[-] 	string->copy (buff, sizeof (buff) - 1);
[+] 	string->copy(buff, sizeof(buff) - 1);
[-] 	intptr_t i = string->getLength () - 3;
[+] 	intptr_t i = string->getLength() - 3;
[-] 		string->insert (i, ',');
[+] 		string->insert(i, ',');
[-] 	return string->getLength ();
[+] 	return string->getLength();
[-] formatIntegerWithThousandSep_axl (quint64 value)
[+] formatIntegerWithThousandSep_axl(quint64 value)
[-] 	formatIntegerWithThousandSep_axl (&string, value);
[+] 	formatIntegerWithThousandSep_axl(&string, value);
[-] getMinPower2Gt (size_t size)
[+] getMinPower2Gt(size_t size)
[-] 	ASSERT ((intptr_t) size >= 0); // hi-bit is already set
[+] 	ASSERT((intptr_t)size >= 0); // hi-bit is already set
[-] 	return size ? 2 << sl::getHiBitIdx (size) : 1;
[+] 	return size ? 2 << sl::getHiBitIdx(size) : 1;
[-] getMinPower2Ge (size_t size)
[+] getMinPower2Ge(size_t size)
[-] 	return !(size & (size - 1)) ? size : getMinPower2Gt (size);
[+] 	return !(size & (size - 1)) ? size : getMinPower2Gt(size);
[-] void benchFormat ()
[+] void benchFormat()
[-] 	printf ("__cplusplus = %d\n", __cplusplus);
[+] 	printf("__cplusplus = %d\n", __cplusplus);
[-] 	printf ("AXL_CPP_MSC_VERSION = %x\n", AXL_CPP_MSC_VERSION);
[+] 	printf("AXL_CPP_MSC_VERSION = %x\n", AXL_CPP_MSC_VERSION);
[-] 	printf ("sizeof (std::string) = %d\n", sizeof (std::string));
[+] 	printf("sizeof (std::string) = %d\n", sizeof (std::string));
[-] 	printf ("sizeof (axl::sl::String) = %d\n", sizeof (axl::sl::String));
[+] 	printf("sizeof (axl::sl::String) = %d\n", sizeof (axl::sl::String));
[-] 	printf ("Testing Hacker's delight...\n");
[+] 	printf("Testing Hacker's delight...\n");
[-] 	baseTimestamp = sys::getTimestamp ();
[+] 	baseTimestamp = sys::getTimestamp();
[-] 		counter += sl::getPowerOf2Ge (j);
[+] 		counter += sl::getPowerOf2Ge(j);
[-] 	time = sys::getTimestamp () - baseTimestamp;
[+] 	time = sys::getTimestamp() - baseTimestamp;
[-] 	printf ("Done: %d %s\n", counter, sys::Time (time, 0).format ("%m:%s.%l").sz ());
[+] 	printf("Done: %d %s\n", counter, sys::Time (time, 0).format ("%m:%s.%l").sz ());
[-] 	printf ("Testing old index-based search...\n");
[+] 	printf("Testing old index-based search...\n");
[-] 	baseTimestamp = sys::getTimestamp ();
[+] 	baseTimestamp = sys::getTimestamp();
[-] 		counter += getMinPower2Ge (j);
[+] 		counter += getMinPower2Ge(j);
[-] 	time = sys::getTimestamp () - baseTimestamp;
[+] 	time = sys::getTimestamp() - baseTimestamp;
[-] 	printf ("Done: %d %s\n", counter, sys::Time (time, 0).format ("%m:%s.%l").sz ());
[+] 	printf("Done: %d %s\n", counter, sys::Time (time, 0).format ("%m:%s.%l").sz ());
[-] 	printf ("Testing Interlocked (intrinsic, i32)...\n");
[+] 	printf("Testing Interlocked (intrinsic, i32)...\n");
[-] 	baseTimestamp = sys::getTimestamp ();
[+] 	baseTimestamp = sys::getTimestamp();
[-] 		_InterlockedIncrement (&i32);
[+] 		_InterlockedIncrement(&i32);
[-] 	time = sys::getTimestamp () - baseTimestamp;
[+] 	time = sys::getTimestamp() - baseTimestamp;
[-] 	printf ("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[+] 	printf("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[-] 	printf ("Testing Interlocked (winapi, i32)...\n");
[+] 	printf("Testing Interlocked (winapi, i32)...\n");
[-] 	baseTimestamp = sys::getTimestamp ();
[+] 	baseTimestamp = sys::getTimestamp();
[-] 		::InterlockedIncrement (&i32);
[+] 		::InterlockedIncrement(&i32);
[-] 	time = sys::getTimestamp () - baseTimestamp;
[+] 	time = sys::getTimestamp() - baseTimestamp;
[-] 	printf ("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[+] 	printf("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[-] 	printf ("Testing Interlocked (intrinsic, i64)...\n");
[+] 	printf("Testing Interlocked (intrinsic, i64)...\n");
[-] 	baseTimestamp = sys::getTimestamp ();
[+] 	baseTimestamp = sys::getTimestamp();
[-] 		_InterlockedIncrement64 (&i64);
[+] 		_InterlockedIncrement64(&i64);
[-] 	time = sys::getTimestamp () - baseTimestamp;
[+] 	time = sys::getTimestamp() - baseTimestamp;
[-] 	printf ("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[+] 	printf("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[-] 	printf ("Testing Interlocked (winapi, i64)...\n");
[+] 	printf("Testing Interlocked (winapi, i64)...\n");
[-] 	baseTimestamp = sys::getTimestamp ();
[+] 	baseTimestamp = sys::getTimestamp();
[-] 		::InterlockedIncrement64 (&i64);
[+] 		::InterlockedIncrement64(&i64);
[-] 	time = sys::getTimestamp () - baseTimestamp;
[+] 	time = sys::getTimestamp() - baseTimestamp;
[-] 	printf ("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[+] 	printf("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[-] 	printf ("Testing STL...\n");
[+] 	printf("Testing STL...\n");
[-] 	baseTimestamp = sys::getTimestamp ();
[+] 	baseTimestamp = sys::getTimestamp();
[-] 		stlString = formatIntegerWithThousandSep_stl (i);
[+] 		stlString = formatIntegerWithThousandSep_stl(i);
[-] 		formatIntegerWithThousandSep_stl (i);
[+] 		formatIntegerWithThousandSep_stl(i);
[-] 	time = sys::getTimestamp () - baseTimestamp;
[+] 	time = sys::getTimestamp() - baseTimestamp;
[-] 	printf ("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[+] 	printf("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[-] 	printf ("Testing STL (no alloc)...\n");
[+] 	printf("Testing STL (no alloc)...\n");
[-] 	baseTimestamp = sys::getTimestamp ();
[+] 	baseTimestamp = sys::getTimestamp();
[-] 		formatIntegerWithThousandSep_stl (&stlString, i);
[+] 		formatIntegerWithThousandSep_stl(&stlString, i);
[-] 	time = sys::getTimestamp () - baseTimestamp;
[+] 	time = sys::getTimestamp() - baseTimestamp;
[-] 	printf ("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[+] 	printf("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[-] 	printf ("Testing QT...\n");
[+] 	printf("Testing QT...\n");
[-] 	baseTimestamp = sys::getTimestamp ();
[+] 	baseTimestamp = sys::getTimestamp();
[-] 		qtString = formatIntegerWithThousandSep_qt (i);
[+] 		qtString = formatIntegerWithThousandSep_qt(i);
[-] 		formatIntegerWithThousandSep_qt (i);
[+] 		formatIntegerWithThousandSep_qt(i);
[-] 	time = sys::getTimestamp () - baseTimestamp;
[+] 	time = sys::getTimestamp() - baseTimestamp;
[-] 	printf ("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[+] 	printf("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[-] 	printf ("Testing QT (no alloc)...\n");
[+] 	printf("Testing QT (no alloc)...\n");
[-] 	baseTimestamp = sys::getTimestamp ();
[+] 	baseTimestamp = sys::getTimestamp();
[-] 		formatIntegerWithThousandSep_qt (&qtString, i);
[+] 		formatIntegerWithThousandSep_qt(&qtString, i);
[-] 	time = sys::getTimestamp () - baseTimestamp;
[+] 	time = sys::getTimestamp() - baseTimestamp;
[-] 	printf ("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[+] 	printf("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[-] 	printf ("Testing AXL...\n");
[+] 	printf("Testing AXL...\n");
[-] 	baseTimestamp = sys::getTimestamp ();
[+] 	baseTimestamp = sys::getTimestamp();
[-] 		axlString = formatIntegerWithThousandSep_axl (i);
[+] 		axlString = formatIntegerWithThousandSep_axl(i);
[-] 		formatIntegerWithThousandSep_axl (i);
[+] 		formatIntegerWithThousandSep_axl(i);
[-] 	time = sys::getTimestamp () - baseTimestamp;
[+] 	time = sys::getTimestamp() - baseTimestamp;
[-] 	printf ("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[+] 	printf("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[-] 	printf ("Testing AXL (no alloc)...\n");
[+] 	printf("Testing AXL (no alloc)...\n");
[-] 	baseTimestamp = sys::getTimestamp ();
[+] 	baseTimestamp = sys::getTimestamp();
[-] 		formatIntegerWithThousandSep_axl (&axlString, i);
[+] 		formatIntegerWithThousandSep_axl(&axlString, i);
[-] 	time = sys::getTimestamp () - baseTimestamp;
[+] 	time = sys::getTimestamp() - baseTimestamp;
[-] 	printf ("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[+] 	printf("Done: %s\n", sys::Time (time, 0).format ("%m:%s.%l").sz ());
[-] main (
[+] main(
[-] 	setvbuf (stdout, NULL, _IOLBF, 1024);
[+] 	setvbuf(stdout, NULL, _IOLBF, 1024);
[-] 	g::getModule ()->setTag ("axl_test_qt");
[+] 	g::getModule()->setTag("axl_test_qt");
[-] 	benchFormat ();
[+] 	benchFormat();
[-] 	testUtf ();
[+] 	testUtf();
[-] 	bool result = regex.compile (src);
[+] 	bool result = regex.compile(src);
[-] 		printf ("error: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("error: %s\n", err::getLastErrorDescription ().sz ());
[-] 	regex.print ();
[+] 	regex.print();
[-] 	writerThread.start ();
[+] 	writerThread.start();
[-] 	readerThread.start ();
[+] 	readerThread.start();
[-] 	char s [256];
[+] 	char s[256];
[-] 	scanf ("%s", s);
[+] 	scanf("%s", s);
[-] 	int fd = open ("/home/vladimir/suka-bla", O_RDWR | O_CREAT, 0666);
[+] 	int fd = open("/home/vladimir/suka-bla", O_RDWR | O_CREAT, 0666);
[-] 		printf ("error (%d): %s\n", errno, strerror (errno));
[+] 		printf("error (%d): %s\n", errno, strerror (errno));
[-] 	char s [] = "hui govno i muravei";
[+] 	char s[] = "hui govno i muravei";
[-] 	write (fd, s, sizeof (s));
[+] 	write(fd, s, sizeof(s));
[-] 	lseek (fd, 0, SEEK_SET);
[+] 	lseek(fd, 0, SEEK_SET);
[-] 	char sockName [] = "/home/vladimir/hui-govno-i-muravei-2";
[+] 	char sockName[] = "/home/vladimir/hui-govno-i-muravei-2";
[-] 	char fifoName [] = "/home/vladimir/hui-govno-i-muravei-3";
[+] 	char fifoName[] = "/home/vladimir/hui-govno-i-muravei-3";
[-] 	result = mkfifo (fifoName, 0666);
[+] 	result = mkfifo(fifoName, 0666);
[-] 		printf ("mkfifo error (%d): %s\n", errno, strerror (errno));
[+] 		printf("mkfifo error (%d): %s\n", errno, strerror (errno));
[-] 	int sockClient = socket (AF_UNIX, SOCK_STREAM, 0);
[+] 	int sockClient = socket(AF_UNIX, SOCK_STREAM, 0);
[-] 	int sockServer = socket (AF_UNIX, SOCK_STREAM, 0);
[+] 	int sockServer = socket(AF_UNIX, SOCK_STREAM, 0);
[-] 	ASSERT (sockClient != -1 && sockServer != -1);
[+] 	ASSERT(sockClient != -1 && sockServer != -1);
[-] 	memcpy (addr.sun_path, sockName, sizeof (sockName));
[+] 	memcpy(addr.sun_path, sockName, sizeof(sockName));
[-] 	result = bind (sockServer, (const sockaddr*) &addr, sizeof (addr));
[+] 	result = bind(sockServer, (const sockaddr*) &addr, sizeof(addr));
[-] 		printf ("bind error (%d): %s\n", errno, strerror (errno));
[+] 		printf("bind error (%d): %s\n", errno, strerror (errno));
[-] 	result = listen (sockServer, 8);
[+] 	result = listen(sockServer, 8);
[-] 		printf ("listen error (%d): %s\n", errno, strerror (errno));
[+] 		printf("listen error (%d): %s\n", errno, strerror (errno));
[-] 	result = connect (sockClient, (const sockaddr*) &addr, sizeof (addr));
[+] 	result = connect(sockClient, (const sockaddr*) &addr, sizeof(addr));
[-] 		printf ("connect error (%d): %s\n", errno, strerror (errno));
[+] 		printf("connect error (%d): %s\n", errno, strerror (errno));
[-] 	socklen_t len = sizeof (addr);
[+] 	socklen_t len = sizeof(addr);
[-] 	int sockAccept = accept (sockServer, (sockaddr*) &addr, &len);
[+] 	int sockAccept = accept(sockServer, (sockaddr*) &addr, &len);
[-] 		printf ("accept error (%d): %s\n", errno, strerror (errno));
[+] 		printf("accept error (%d): %s\n", errno, strerror (errno));
[-] 	result = sendFd (sockClient, fd);
[+] 	result = sendFd(sockClient, fd);
[-] 		printf ("sendmsg error (%d): %s\n", errno, strerror (errno));
[+] 		printf("sendmsg error (%d): %s\n", errno, strerror (errno));
[-] 	int fd2 = recvFd (sockAccept);
[+] 	int fd2 = recvFd(sockAccept);
[-] 		printf ("recvmsg error (%d): %s\n", errno, strerror (errno));
[+] 		printf("recvmsg error (%d): %s\n", errno, strerror (errno));
[-] 	char buffer [256] = { 0 };
[+] 	char buffer[256] = { 0 };
[-] 	result = read (fd2, buffer, sizeof (buffer));
[+] 	result = read(fd2, buffer, sizeof(buffer));
[-] 		printf ("read error (%d): %s\n", errno, strerror (errno));
[+] 		printf("read error (%d): %s\n", errno, strerror (errno));
[-] 	printf ("read: %s\n", buffer);
[+] 	printf("read: %s\n", buffer);
[-] 	trySudo ();
[+] 	trySudo();
[-] 	trySudo ();
[+] 	trySudo();
[-] 	QApplication app (argc, argv);
[+] 	QApplication app(argc, argv);
[-] 	mainWindow.show ();
[+] 	mainWindow.show();
[-] 	return app.exec ();
[+] 	return app.exec();
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_qt\mainwindow.cpp
----------------------
[-] MyWidget::MyWidget (QWidget* parent):
[+] MyWidget::MyWidget(QWidget* parent):
[-] 	QWidget (parent)
[+] 	QWidget(parent)
[-] MyWidget::paintEvent (QPaintEvent* e)
[+] MyWidget::paintEvent(QPaintEvent* e)
[-] 	char str [] = "abcdefghijklmnopqrstuvwxyz";
[+] 	char str[] = "abcdefghijklmnopqrstuvwxyz";
[-] 	hyperText.setHyperText ("\xd0\x91\xd0\xbe " "abc \x1b^pizda\x1b[4mdef\x1b[m suka");
[+] 	hyperText.setHyperText("\xd0\x91\xd0\xbe " "abc \x1b^pizda\x1b[4mdef\x1b[m suka");
[-] 	const gui::TextAttrAnchorArray* attrArray = hyperText.getAttrArray ();
[+] 	const gui::TextAttrAnchorArray* attrArray = hyperText.getAttrArray();
[-] 	sl::String_utf32 text = hyperText.getText ();
[+] 	sl::String_utf32 text = hyperText.getText();
[-] 	const gui::HyperlinkAnchor* anchor = hyperText.findHyperlinkByOffset (1);
[+] 	const gui::HyperlinkAnchor* anchor = hyperText.findHyperlinkByOffset(1);
[-] 	for (size_t i = 0; i < text.getLength (); i++)
[+] 	for (size_t i = 0; i < text.getLength(); i++)
[-] 		anchor = hyperText.findHyperlinkByOffset (i);
[+] 		anchor = hyperText.findHyperlinkByOffset(i);
[-] 			printf ("%d -- %s\n", i, anchor->m_hyperlink.sz ());
[+] 			printf("%d -- %s\n", i, anchor->m_hyperlink.sz ());
[-] 	canvas.m_qtPainter.begin (this);
[+] 	canvas.m_qtPainter.begin(this);
[-] 	canvas.m_font = gui::getQtEngine ()->getStdFont (gui::StdFontKind_Monospace);
[+] 	canvas.m_font = gui::getQtEngine()->getStdFont(gui::StdFontKind_Monospace);
[-] 	canvas.m_palette = gui::getQtEngine ()->getStdPalette ();
[+] 	canvas.m_palette = gui::getQtEngine()->getStdPalette();
[-] 	gui::TextPainter painter (&canvas);
[+] 	gui::TextPainter painter(&canvas);
[-] 	QSize s = size ();
[+] 	QSize s = size();
[-] 	painter.m_bottom = s.height ();
[+] 	painter.m_bottom = s.height();
[-] 	painter.drawHyperText_utf32 (attrArray, text);
[+] 	painter.drawHyperText_utf32(attrArray, text);
[-] 	canvas.m_qtPainter.end ();
[+] 	canvas.m_qtPainter.end();
[-] 	SizeHintCombo (QWidget* parent):
[+] 	SizeHintCombo(QWidget* parent):
[-] 		QComboBox (parent)
[+] 		QComboBox(parent)
[-] 	void setSizeHint (const QSize& size)
[+] 	void setSizeHint(const QSize& size)
[-] 	void setSizeHint (int width, int height)
[+] 	void setSizeHint(int width, int height)
[-] 		setSizeHint (QSize (width, height));
[+] 		setSizeHint(QSize(width, height));
[-] 		return m_sizeHint.isValid () ? m_sizeHint : QComboBox::sizeHint ();
[+] 		return m_sizeHint.isValid() ? m_sizeHint : QComboBox::sizeHint();
[-] 	void setMinimumSizeHint (const QSize& size)
[+] 	void setMinimumSizeHint(const QSize& size)
[-] 	void setMinimumSizeHint (int width, int height)
[+] 	void setMinimumSizeHint(int width, int height)
[-] 		setMinimumSizeHint (QSize (width, height));
[+] 		setMinimumSizeHint(QSize(width, height));
[-] 		return m_minimumSizeHint.isValid () ? m_minimumSizeHint : QComboBox::minimumSizeHint ();
[+] 		return m_minimumSizeHint.isValid() ? m_minimumSizeHint : QComboBox::minimumSizeHint();
[-] cloneStandardItemModel (
[+] cloneStandardItemModel(
[-] 		QStandardItem* item = src->item (i);
[+] 		QStandardItem* item = src->item(i);
[-] 		dst->appendRow (item->clone ());
[+] 		dst->appendRow(item->clone());
[-] 	MyItemModel (QObject* parent = NULL):
[+] 	MyItemModel(QObject* parent = NULL):
[-] 		QStandardItemModel (parent)
[+] 		QStandardItemModel(parent)
[-] 	MyItemModel (
[+] 	MyItemModel(
[-] 		QStandardItemModel (parent)
[+] 		QStandardItemModel(parent)
[-] 		cloneStandardItemModel (this, model);
[+] 		cloneStandardItemModel(this, model);
[-] 			QVariant userData = QStandardItemModel::data (index, Qt::UserRole);
[+] 			QVariant userData = QStandardItemModel::data(index, Qt::UserRole);
[-] 			if (!userData.isNull ())
[+] 			if (!userData.isNull())
[-] 		return QStandardItemModel::data (index, role);
[+] 		return QStandardItemModel::data(index, role);
[-] MainWindow::MainWindow (QWidget* parent) :
[+] MainWindow::MainWindow(QWidget* parent) :
[-] 	QMainWindow (parent),
[+] 	QMainWindow(parent),
[-] 	m_myWidget (this)
[+] 	m_myWidget(this)
[-] 	m_editWidget (this)
[+] 	m_editWidget(this)
[-] 	QFont f ("Monospace", 10);
[+] 	QFont f("Monospace", 10);
[-] 	f.setFixedPitch (true);
[+] 	f.setFixedPitch(true);
[-] 	f.setStyleHint (
[+] 	f.setStyleHint(
[-] 		(QFont::StyleStrategy) (QFont::NoFontMerging | QFont::ForceIntegerMetrics)
[+] 		(QFont::StyleStrategy)(QFont::NoFontMerging | QFont::ForceIntegerMetrics)
[-] 	QWidget* client = new QWidget (this);
[+] 	QWidget* client = new QWidget(this);
[-] 	setCentralWidget (client);
[+] 	setCentralWidget(client);
[-] 	client->setLayout (vlayout);
[+] 	client->setLayout(vlayout);
[-] 	m_myWidget.setFont (f);
[+] 	m_myWidget.setFont(f);
[-] 	m_myWidget.setGeometry (0, 0, 400, 40);
[+] 	m_myWidget.setGeometry(0, 0, 400, 40);
[-] 	vlayout->addWidget (&m_myWidget);
[+] 	vlayout->addWidget(&m_myWidget);
[-] 	m_editWidget.setFont (f);
[+] 	m_editWidget.setFont(f);
[-] 	m_editWidget.setFrameStyle (0);
[+] 	m_editWidget.setFrameStyle(0);
[-] 	m_editWidget.setGeometry (0, 40, 400, 100);
[+] 	m_editWidget.setGeometry(0, 40, 400, 100);
[-] 	m_editWidget.setContentsMargins (0, 0, 0, 0);
[+] 	m_editWidget.setContentsMargins(0, 0, 0, 0);
[-] 	m_editWidget.setText ("abcdefghijklmnopqrstuvwxyz");
[+] 	m_editWidget.setText("abcdefghijklmnopqrstuvwxyz");
[-] 	vlayout->addWidget (&m_editWidget);
[+] 	vlayout->addWidget(&m_editWidget);
[-] 	vlayout->addLayout (hlayout);
[+] 	vlayout->addLayout(hlayout);
[-] 	QLabel* label1 = new QLabel (this);
[+] 	QLabel* label1 = new QLabel(this);
[-] 	label1->setText ("Adapter:");
[+] 	label1->setText("Adapter:");
[-] 	hlayout->addWidget (label1);
[+] 	hlayout->addWidget(label1);
[-] 	SizeHintCombo* combo1 = new SizeHintCombo (this);
[+] 	SizeHintCombo* combo1 = new SizeHintCombo(this);
[-] 	combo1->setSizePolicy (QSizePolicy::Expanding, QSizePolicy::Fixed);
[+] 	combo1->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);
[-] 	combo1->setEditable (true);
[+] 	combo1->setEditable(true);
[-] 	combo1->setSizeAdjustPolicy (QComboBox::AdjustToContents);
[+] 	combo1->setSizeAdjustPolicy(QComboBox::AdjustToContents);
[-] 	combo1->setSizeHint (combo1->sizeHint ());
[+] 	combo1->setSizeHint(combo1->sizeHint());
[-] 	combo1->setMinimumSizeHint (combo1->minimumSizeHint ());
[+] 	combo1->setMinimumSizeHint(combo1->minimumSizeHint());
[-] 	combo1->view ()->setTextElideMode (Qt::ElideRight);
[+] 	combo1->view()->setTextElideMode(Qt::ElideRight);
[-] 	combo1->addItem ("hui", "HUI");
[+] 	combo1->addItem("hui", "HUI");
[-] 	combo1->addItem ("hui govno", "HUI GOVNO");
[+] 	combo1->addItem("hui govno", "HUI GOVNO");
[-] 	combo1->addItem ("hui govno i", "HUI GOVNO I");
[+] 	combo1->addItem("hui govno i", "HUI GOVNO I");
[-] 	combo1->addItem ("hui govno i muravei", "HUI GOVNO I MURAVEI");
[+] 	combo1->addItem("hui govno i muravei", "HUI GOVNO I MURAVEI");
[-] 	combo1->addItem ("hui govno i muravei (c) laertsky", "LAERTSKY");
[+] 	combo1->addItem("hui govno i muravei (c) laertsky", "LAERTSKY");
[-] 	combo1->setModel (new MyItemModel (qobject_cast <QStandardItemModel*> (combo1->model ())));
[+] 	combo1->setModel(new MyItemModel(qobject_cast<QStandardItemModel*> (combo1->model())));
[-] 	combo1->view ()->setMinimumWidth (combo1->QComboBox::sizeHint ().width ());
[+] 	combo1->view()->setMinimumWidth(combo1->QComboBox::sizeHint().width());
[-] 	hlayout->addWidget (combo1);
[+] 	hlayout->addWidget(combo1);
[-] 	QLabel* label2 = new QLabel (this);
[+] 	QLabel* label2 = new QLabel(this);
[-] 	label2->setText ("Port:");
[+] 	label2->setText("Port:");
[-] 	hlayout->addWidget (label2);
[+] 	hlayout->addWidget(label2);
[-] 	SizeHintCombo* combo2 = new SizeHintCombo (this);
[+] 	SizeHintCombo* combo2 = new SizeHintCombo(this);
[-] 	combo2->setEditable (true);
[+] 	combo2->setEditable(true);
[-] 	combo2->lineEdit ()->setText ("127.0.0.1:1001");
[+] 	combo2->lineEdit()->setText("127.0.0.1:1001");
[-] 	combo2->setSizePolicy (QSizePolicy::Expanding, QSizePolicy::Fixed);
[+] 	combo2->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);
[-] 	hlayout->addWidget (combo2);
[+] 	hlayout->addWidget(combo2);
----------------------
27/02/2019 18:01:52 - C:\Projects\repos\ioninja\axl\test\axl_test_qt\mainwindow.h
----------------------
[-] 	MyWidget (QWidget* parent = NULL);
[+] 	MyWidget(QWidget* parent = NULL);
[-] 	paintEvent (QPaintEvent* e);
[+] 	paintEvent(QPaintEvent* e);
[-] 	MainWindow (QWidget* parent = NULL);
[+] 	MainWindow(QWidget* parent = NULL);
[-] 	virtual QSize sizeHint () const
[+] 	virtual QSize sizeHint() const
[-] 		return QSize (640, 480);
[+] 		return QSize(640, 480);
