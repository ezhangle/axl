//............................................................................. 

class
{
	rtl::CBoxListT <CToken> m_TokenList;
}
function_body_pass1
	:	compound_stmt_pass1 <&$.m_TokenList>
	;

noast 
compound_stmt_pass1 <rtl::CBoxListT <CToken>* $pTokenList>
	:	'{'
			{
				$pTokenList->InsertTail ($1);
			}
		statement_pass1 <$pTokenList>* 
		'}'
			{
				$pTokenList->InsertTail ($3);
			}
	;

noast
statement_pass1 <rtl::CBoxListT <CToken>* $pTokenList>
	:	compound_stmt_pass1 <$pTokenList>
	|	any
			{
				$pTokenList->InsertTail ($1);
			}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

start
compound_stmt
	:	'{' $l
			{
				m_pModule->m_NamespaceMgr.OpenScope ($l.m_Pos);
			}
		local_declaration* 
		'}' $r
			{
				m_pModule->m_NamespaceMgr.CloseScope ($r.m_Pos);
			}
	;

start
constructor_compound_stmt
	:	'{' $l
			{
				m_pModule->m_NamespaceMgr.OpenScope ($l.m_Pos);
			} 
		btm_construct_stmt*
			{
				return FinalizeBaseTypeMemberConstructBlock ();
			}
		local_declaration* 
		'}' $r
			{
				m_pModule->m_NamespaceMgr.CloseScope ($r.m_Pos);
			}
	;

// conflict at qualified_name : '.' is a continue-vs-fold conflict, in which fold loses immediatly
// this problem could be solved with double resolvers, but it looks really ugly
// actually, LADFA should be modified to allow LL(k) lookup also in case of continue-vs-fold conflict 

btm_construct_stmt
	:	resolver (btm_construct_stmt_rslv)
		btm_construct_name $n '(' expression_or_empty_list $a ')'
			{
				return CallBaseTypeMemberConstructor ($n.m_Name, &$a.m_ValueList);
			}
	|	';'
	;

btm_construct_stmt_rslv
	: EToken_Identifier '.' (EToken_Identifier '.')* EToken_Construct
	;

class 
{
	CQualifiedName m_Name;
}
btm_construct_name
	:	EToken_Identifier '.' 
			{  
				$.m_Name.AddName ($1.m_Data.m_String); 
			}
		(EToken_Identifier $n2 '.'
			{ 
				$.m_Name.AddName ($n2.m_Data.m_String);
			}
		)*
		EToken_Construct
	;

statement
	enter
	{
		m_pModule->m_ControlFlowMgr.ResetJumpFlag (); // 'stack new' is currently illegal in conditional expression
		m_pModule->m_LlvmIrBuilder.SetSourcePos (m_CurrentToken.m_Pos);
	}
	:	compound_stmt
	|	expression_stmt
	|	if_stmt
	|	switch_stmt
	|	while_stmt
	|	do_stmt
	|	for_stmt
	|	break_stmt
	|	continue_stmt
	|	return_stmt
	|	once_stmt
	|	';'
	;

expression_stmt
	:	expression ';'
	;

if_stmt
	local
	{
		TIfStmt $Stmt;
	}
	enter
	{
		m_pModule->m_ControlFlowMgr.IfStmt_Create (&$Stmt);
	}
	:	EToken_If '(' expression $e ')' $a
			{
				return m_pModule->m_ControlFlowMgr.IfStmt_Condition (&$Stmt, $e.m_Value, $a.m_Pos);
			}
		statement $t 
		(
			EToken_Else $a2
				{
					m_pModule->m_ControlFlowMgr.IfStmt_Else (&$Stmt, $a2.m_Pos);
				}
			statement $f
		)?
			{	
				m_pModule->m_ControlFlowMgr.IfStmt_Follow (&$Stmt, IsValidLocator ($f) ? $f.m_LastToken.m_Pos : $t.m_LastToken.m_Pos);
			}
	;

switch_stmt
	local
	{
		TSwitchStmt $Stmt;
	}
	enter
	{
		m_pModule->m_ControlFlowMgr.SwitchStmt_Create (&$Stmt);
	}
	:	EToken_Switch '(' expression $e ')' '{' $l
			{
				return m_pModule->m_ControlFlowMgr.SwitchStmt_Condition (&$Stmt, $e.m_Value, $l.m_Pos);
			}
		switch_block_stmt <&$Stmt>* '}' $r
			{
				m_pModule->m_ControlFlowMgr.SwitchStmt_Follow (&$Stmt, $r.m_Pos);
			}
	;

switch_block_stmt <TSwitchStmt* $pStmt>
	:	EToken_Case constant_integer_expr $e ':' $a
			{
				return m_pModule->m_ControlFlowMgr.SwitchStmt_Case ($pStmt, $e.m_Value, $1.m_Pos, $a.m_Pos);
			}
	|	EToken_Default ':' $a
			{
				return m_pModule->m_ControlFlowMgr.SwitchStmt_Default ($pStmt, $1.m_Pos, $a.m_Pos);
			}
	|	statement
	;

while_stmt
	local
	{
		TWhileStmt $Stmt;
	}
	enter
	{
		m_pModule->m_ControlFlowMgr.WhileStmt_Create (&$Stmt);
	}
	:	EToken_While '(' expression $e ')' $a
			{
				m_pModule->m_ControlFlowMgr.WhileStmt_Condition (&$Stmt, $e.m_Value, $a.m_Pos);
			}		
		statement $s
			{
				m_pModule->m_ControlFlowMgr.WhileStmt_Follow (&$Stmt, $s.m_LastToken.m_Pos);
			}		
	;

do_stmt
	local
	{
		TDoStmt $Stmt;
	}
	enter
	{
		m_pModule->m_ControlFlowMgr.DoStmt_Create (&$Stmt);
	}
	:	EToken_Do
			{
				m_pModule->m_ControlFlowMgr.DoStmt_PreBody (&$Stmt, $1.m_Pos);
			}
		statement $s
			{
				m_pModule->m_ControlFlowMgr.DoStmt_PostBody (&$Stmt, $s.m_LastToken.m_Pos);
			}
		EToken_While '(' expression $e ')' ';'
			{
				return m_pModule->m_ControlFlowMgr.DoStmt_Condition (&$Stmt, $e.m_Value);
			}	  
	;

for_stmt
	local
	{
		TForStmt $Stmt;
	}
	enter
	{
		m_pModule->m_ControlFlowMgr.ForStmt_Create (&$Stmt);
	}
	:	EToken_For '(' 
			{
				m_pModule->m_ControlFlowMgr.ForStmt_PreInit (&$Stmt, $1.m_Pos);
			}	  
		(item_declaration_w_specifier | expression_or_empty_list ';') 
		(
				{
					m_pModule->m_ControlFlowMgr.ForStmt_PreCondition (&$Stmt);
				}
			expression $e
				{
					return m_pModule->m_ControlFlowMgr.ForStmt_PostCondition (&$Stmt, $e.m_Value);
				}
		)? ';' 
		(
				{
					m_pModule->m_ControlFlowMgr.ForStmt_PreLoop (&$Stmt);
				}
			expression_list
				{
					m_pModule->m_ControlFlowMgr.ForStmt_PostLoop (&$Stmt);
				}
		)? ')'
			{
				m_pModule->m_ControlFlowMgr.ForStmt_PreBody (&$Stmt);
			}
		statement $s
			{
				m_pModule->m_ControlFlowMgr.ForStmt_PostBody (&$Stmt, $s.m_LastToken.m_Pos);
			}
	;

break_stmt
	:	EToken_Break constant_integer_expr $e? ';'
			{
				return m_pModule->m_ControlFlowMgr.Break (IsValidLocator ($e) ? $e.m_Value : 1);
			}
	;

continue_stmt 
	:	EToken_Continue constant_integer_expr $e? ';'
			{
				return m_pModule->m_ControlFlowMgr.Continue (IsValidLocator ($e) ? $e.m_Value : 1);
			}
	;

return_stmt
	:	EToken_Silent? EToken_Return expression $e? ';'
			{
				return m_pModule->m_ControlFlowMgr.Return (IsValidLocator ($e) ? $e.m_Value : CValue (), IsValidLocator ($1));
			}
	;

once_stmt
	local
	{
		TOnceStmt $Stmt;
	}
	:	storage_specifier? EToken_Once
			{
				EStorage StorageKind = IsValidLocator ($1) ? $1.m_StorageKind : EStorage_Static;
				return 
					m_pModule->m_ControlFlowMgr.OnceStmt_Create (&$Stmt, StorageKind) &&				
					m_pModule->m_ControlFlowMgr.OnceStmt_PreBody (&$Stmt, $2.m_Pos);
			}
		statement $s
			{
				m_pModule->m_ControlFlowMgr.OnceStmt_PostBody (&$Stmt, $s.m_LastToken.m_Pos);
			}
	;

//.............................................................................

start
autoev_body
	: '{' autoev_stmt+ '}'
		{
			return FinalizeAutoEv ();
		}
	;
	
autoev_stmt
	:	resolver ({ return true; }) // within autoev_body prefer autoev_onchange_stmt 
		autoev_onchange_stmt 
	|	autoev_expression_stmt
	|	';'
	;

autoev_onchange_stmt
	:	EToken_OnChange '(' expression_list ')'
			{
				return FinalizeAutoEvOnChangeClause ();
			}
		statement 
			{
				return FinalizeAutoEvOnChangeStmt ();
			}
	;

autoev_expression_stmt
	:	expression_pass1 ';'
			{
				return AutoEvExpressionStmt (&$1.m_TokenList);
			}
	;

//.............................................................................
