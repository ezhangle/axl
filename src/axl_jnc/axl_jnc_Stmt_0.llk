//.............................................................................

statement_0
	:	compound_stmt_0
	|	expression_stmt_0
	|	if_stmt_0
	|	switch_stmt_0
	|	while_stmt_0
	|	do_stmt_0
	|	for_stmt_0
	|	break_stmt_0
	|	continue_stmt_0
	|	return_stmt_0
	|	once_stmt_0
	|	';'
	;

compound_stmt_0
	:	'{' (compound_stmt_0 | any)* '}'
	;

expression_stmt_0
	:	expression_0 ';'
	;

expression_0
	:	primary_expr_0+
	;

primary_expr_0
	:	'[' primary_expr_0+ ']'
	|	'(' primary_expr_0* ')'
	|	any
	;

if_stmt_0
	:	EToken_If '(' expression_0 ')' statement_0 (EToken_Else statement_0)?
	;

switch_stmt_0
	:	EToken_Switch '(' expression_0 ')' compound_stmt_0
	;

while_stmt_0
	:	EToken_While '(' expression_0 ')' statement_0
	;

do_stmt_0
	:	EToken_Do statement_0 EToken_While '(' expression_0 ')' ';'
	;

for_stmt_0
	:	EToken_For '(' expression_0? ';' expression_0? ';' expression_0? ')' statement_0
	;

break_stmt_0
	:	EToken_Break expression_0? ';'
	;

continue_stmt_0 
	:	EToken_Continue expression_0? ';'
	;

return_stmt_0
	:	EToken_Silent? EToken_Return expression_0? ';'
	;

once_stmt_0
	:	EToken_Once statement_0
	;

//.............................................................................

start
reactor_body_0
	:	'{' reactor_stmt_0+ '}'
	;
	
reactor_stmt_0
	enter
	{
		m_ReactorBindSiteCount = 0;
	}
	:	resolver ({ return true; }) // within reactor_body prefer reactor_onchange_stmt 
		reactor_onchange_stmt_0
	|	reactor_expression_stmt_0
	|	';'
	;

reactor_onchange_stmt_0
	:	EToken_OnChange '(' expression_list_s ')' 
			{
				return CountReactorBindSites ();
			}
		statement_0
	;

reactor_expression_stmt_0
	:	expression_s ';'
			{
				return CountReactorBindSites ();
			}
	;

//.............................................................................
