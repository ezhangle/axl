//.............................................................................

declarator_list <CTypeSpecifier* $pTypeSpecifier>
	:	full_declarator <$pTypeSpecifier> (',' full_declarator <$pTypeSpecifier>)*
	;

full_declarator <CTypeSpecifier* $pTypeSpecifier>
	enter
	{
		return PreDeclare ();
	}
	:	declarator $d <$pTypeSpecifier>
		(EToken_Construct arg_list_pass1 $c
			{
				$d.m_Declarator.m_Constructor.TakeOver (&$c.m_TokenList);
			}
		)?
		('=' expression_pass1 $i
			{
				$d.m_Declarator.m_Initializer.TakeOver (&$i.m_TokenList);
			}
		)?
			{
				return Declare (&$d.m_Declarator);
			}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	CDeclarator m_Declarator;
}
declarator <CTypeSpecifier* $pTypeSpecifier>
	enter
	{
		$.m_Declarator.SetTypeSpecifier ($pTypeSpecifier);
	}
	:	declarator_prefix <&$.m_Declarator>*
		declarator_name <&$.m_Declarator>
		declarator_suffix <&$.m_Declarator>*
		post_declarator_modifier <&$.m_Declarator>*
	;

//.............................................................................

declarator_name <CDeclarator* $pDeclarator>
	:	declarator_qualifier <$pDeclarator>
			{
				$pDeclarator->m_Pos = $1.m_FirstToken.m_Pos;
			}
		('.' declarator_qualifier <$pDeclarator>)*
	;

declarator_qualifier <CDeclarator* $pDeclarator>
	:	EToken_Identifier
			{
				return $pDeclarator->AddName ($1.m_Data.m_String);
			}
	|	EToken_Get
			{
				return $pDeclarator->AddUnnamedMethod (EFunction_Getter);
			}
	|	EToken_Set
			{
				return $pDeclarator->AddUnnamedMethod (EFunction_Setter);
			}
	|	EToken_PreConstruct
			{
				return $pDeclarator->AddUnnamedMethod (EFunction_PreConstructor);
			}
	|	EToken_Construct
			{
				return $pDeclarator->AddUnnamedMethod (EFunction_Constructor);
			}
	|	EToken_Destruct
			{
				return $pDeclarator->AddUnnamedMethod (EFunction_Destructor);
			}
	|	EToken_Static EToken_Construct
			{
				return $pDeclarator->AddUnnamedMethod (EFunction_StaticConstructor);
			}
	|	EToken_Static EToken_Destruct
			{
				return $pDeclarator->AddUnnamedMethod (EFunction_StaticDestructor);
			}
	|	EToken_Operator '(' ')'
			{
				return $pDeclarator->AddUnnamedMethod (EFunction_CallOperator);
			}
	|	EToken_Operator type_name
			{
				return $pDeclarator->AddCastOperator ($2.m_pType);
			}
	|	EToken_Operator operator_name
			{
				return $pDeclarator->AddUnaryBinaryOperator ($2.m_UnOpKind, $2.m_BinOpKind);
			}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

class
{
	EUnOp m_UnOpKind;
	EBinOp m_BinOpKind;
}
operator_name
	enter
	{
		$.m_UnOpKind = EUnOp_Undefined;
		$.m_BinOpKind = EBinOp_Undefined;
	}
	:	'~'
			{
				$.m_UnOpKind = EUnOp_BwNot;
			}
	|	'!'
			{
				$.m_UnOpKind = EUnOp_LogNot;
			}
	|	EToken_Inc
			{
				$.m_UnOpKind = EUnOp_PreInc;
			}
	|	EToken_Dec
			{
				$.m_UnOpKind = EUnOp_PreDec;
			}
	|	EToken_Postfix EToken_Inc
			{
				$.m_UnOpKind = EUnOp_PostInc;
			}
	|	EToken_Postfix EToken_Dec
			{
				$.m_UnOpKind = EUnOp_PostDec;
			}
	|	EToken_Postfix? EToken_Ptr
			{
				$.m_UnOpKind = EUnOp_Ptr;
			}
	|	'+'
			{
				$.m_UnOpKind = EUnOp_Plus;
				$.m_BinOpKind = EBinOp_Add;
			}
	|	'-'
			{
				$.m_UnOpKind = EUnOp_Minus;
				$.m_BinOpKind = EBinOp_Sub;
			}
	|	'*'
			{
				$.m_UnOpKind = EUnOp_Indir;
				$.m_BinOpKind = EBinOp_Mul;
			}
	|	'/'
			{
				$.m_BinOpKind = EBinOp_Div;
			}
	|	'%'
			{
				$.m_BinOpKind = EBinOp_Mod;
			}
	|	EToken_Shl
			{
				$.m_BinOpKind = EBinOp_Shl;
			}
	|	EToken_Shr
			{
				$.m_BinOpKind = EBinOp_Shr;
			}
	|	'&'
			{
				$.m_UnOpKind = EUnOp_Addr;
				$.m_BinOpKind = EBinOp_BwAnd;
			}
	|	'^'
			{
				$.m_BinOpKind = EBinOp_BwXor;
			}
	|	'|'
			{
				$.m_BinOpKind = EBinOp_BwOr;
			}
	|	EToken_Eq
			{
				$.m_BinOpKind = EBinOp_Eq;
			}
	|	EToken_Ne
			{
				$.m_BinOpKind = EBinOp_Ne;
			}
	|	'<'
			{
				$.m_BinOpKind = EBinOp_Lt;
			}
	|	EToken_Le
			{
				$.m_BinOpKind = EBinOp_Le;
			}
	|	'>'
			{
				$.m_BinOpKind = EBinOp_Gt;
			}
	|	EToken_Ge
			{
				$.m_BinOpKind = EBinOp_Ge;
			}
	|	'='
			{
				$.m_BinOpKind = EBinOp_Assign;
			}
	|	EToken_RefAssign
			{
				$.m_BinOpKind = EBinOp_RefAssign;
			}
	|	EToken_AddAssign
			{
				$.m_BinOpKind = EBinOp_AddAssign;
			}
	|	EToken_SubAssign
			{
				$.m_BinOpKind = EBinOp_SubAssign;
			}
	|	EToken_MulAssign
			{
				$.m_BinOpKind = EBinOp_MulAssign;
			}
	|	EToken_DivAssign
			{
				$.m_BinOpKind = EBinOp_DivAssign;
			}
	|	EToken_ModAssign
			{
				$.m_BinOpKind = EBinOp_ModAssign;
			}
	|	EToken_ShlAssign
			{
				$.m_BinOpKind = EBinOp_ShlAssign;
			}
	|	EToken_ShrAssign
			{
				$.m_BinOpKind = EBinOp_ShrAssign;
			}
	|	EToken_AndAssign
			{
				$.m_BinOpKind = EBinOp_AndAssign;
			}
	|	EToken_XorAssign
			{
				$.m_BinOpKind = EBinOp_XorAssign;
			}
	|	EToken_OrAssign
			{
				$.m_BinOpKind = EBinOp_OrAssign;
			}
	|	EToken_AtAssign
			{
				$.m_BinOpKind = EBinOp_AtAssign;
			}
	|	EToken_LogAnd
			{
				$.m_BinOpKind = EBinOp_LogAnd;
			}
	|	EToken_LogOr
			{
				$.m_BinOpKind = EBinOp_LogOr;
			}
	|	'[' ']'
			{
				$.m_BinOpKind = EBinOp_Idx;
			}
	|	'@'
			{
				$.m_BinOpKind = EBinOp_At;
			}
	;

//.............................................................................

// prefix & suffix

noast
declarator_prefix <CDeclarator* $pDeclarator>
	:	'*'
			{
				$pDeclarator->AddPointerPrefix ();
			}
		(type_modifier $m
			{
				return $pDeclarator->SetTypeModifier ($m.m_TypeModifier);
			}
		)*
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

noast
declarator_suffix <CDeclarator* $pDeclarator>
	:	array_suffix <$pDeclarator>
	|	function_suffix <$pDeclarator>
	|	throw_suffix <$pDeclarator>
	|	resolver ({ return false; }) // prefer conditional-expr over type-name
		bitfield_suffix <$pDeclarator>
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

array_suffix <CDeclarator* $pDeclarator>
	:	'[' expression_pass1 ']'
			{
				$pDeclarator->AddArraySuffix (&$2.m_TokenList);
			}
	|	'[' EToken_Integer ']' // avoid reparsing where possible
			{
				$pDeclarator->AddArraySuffix ($2.m_Data.m_Integer);
			}
	|	'[' ']'
			{
				$pDeclarator->AddArraySuffix (-1);
			}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

function_suffix <CDeclarator* $pDeclarator>
	local
	{
		CDeclFunctionSuffix* $pFunctionSuffix;
		EStorage $PrevStorageKind;
	}
	enter
	{
		$pFunctionSuffix = $pDeclarator->AddFunctionSuffix ();
		$PrevStorageKind = m_StorageKind;
	}
	leave
	{
		m_StorageKind = $PrevStorageKind;
	}
	:	'(' function_formal_argument_list <$pFunctionSuffix>? ')'
	;

function_formal_argument_list <CDeclFunctionSuffix* $pFunctionSuffix>
	:	function_formal_argument <$pFunctionSuffix>
		(',' function_formal_argument <$pFunctionSuffix>)*
	;

function_formal_argument <CDeclFunctionSuffix* $pFunctionSuffix>
	:	function_formal_argument_w_specifier <$pFunctionSuffix>
	|	function_formal_argument_no_specifier <$pFunctionSuffix>
	|	EToken_Ellipsis
			{
				$pFunctionSuffix->m_FunctionTypeFlags |= EFunctionTypeFlag_VarArg;
			}
	;

function_formal_argument_w_specifier <CDeclFunctionSuffix* $pFunctionSuffix>
	local
	{
		CDeclarator $Declarator;
	}
	enter
	{
		m_StorageKind = EStorage_Undefined;
	}
	:	declaration_specifier_list $s
			{
				$Declarator.SetTypeSpecifier (&$s.m_TypeSpecifier);
			}
		declarator_prefix <&$Declarator>*
		declarator_name <&$Declarator>?
		declarator_suffix <&$Declarator>*
		('=' expression_pass1 $i
			{
				$Declarator.m_Initializer.TakeOver (&$i.m_TokenList);
			}
		)?
			{
				return CreateFormalArg ($pFunctionSuffix, &$Declarator) != NULL;
			}
	;

function_formal_argument_no_specifier <CDeclFunctionSuffix* $pFunctionSuffix>
	local
	{
		CDeclarator $Declarator;
	}
	enter
	{
		m_StorageKind = EStorage_Undefined;
		$Declarator.SetTypeSpecifier (NULL);
	}
	:	declarator_prefix <&$Declarator>+
		declarator_name <&$Declarator>?
		declarator_suffix <&$Declarator>*
		('=' expression_pass1 $i
			{
				$Declarator.m_Initializer.TakeOver (&$i.m_TokenList);
			}
		)?
			{
				return CreateFormalArg ($pFunctionSuffix, &$Declarator) != NULL;
			}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

throw_suffix <CDeclarator* $pDeclarator>
	:	EToken_Throws
			{
				$pDeclarator->AddThrowSuffix ();
			}

	|	EToken_Throws EToken_If '(' expression_pass1 $e ')'
			{
				$pDeclarator->AddThrowSuffix (&$e.m_TokenList);
			}
	;
	
//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

bitfield_suffix <CDeclarator* $pDeclarator>
	:	':' EToken_Integer
			{
				return $pDeclarator->AddBitFieldSuffix ($2.m_Data.m_Integer);
			}
	;

//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

post_declarator_modifier <CDeclarator* $pDeclarator>
	:	EToken_Const
			{
				return $pDeclarator->SetPostDeclaratorModifier (EPostDeclaratorModifier_Const);
			}
	;

//.............................................................................
